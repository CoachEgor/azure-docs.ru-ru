---
title: 'Конструктор: пример прогнозируемого кредитного риска'
titleSuffix: Azure Machine Learning
description: Создание классификатора и использование пользовательских скриптов Python для прогнозирования кредитных рисков с помощью Машинное обучение Azure конструктора.
services: machine-learning
ms.service: machine-learning
ms.subservice: core
ms.topic: conceptual
author: likebupt
ms.author: keli19
ms.reviewer: peterlu
ms.date: 12/25/2019
ms.openlocfilehash: 54ca0df005dccceacc88044a51f31ad784b7071b
ms.sourcegitcommit: aee08b05a4e72b192a6e62a8fb581a7b08b9c02a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/09/2020
ms.locfileid: "75763408"
---
# <a name="build-a-classifier--use-python-scripts-to-predict-credit-risk-using-azure-machine-learning-designer"></a>Создание классификатора & использование скриптов Python для прогнозирования кредитных рисков с помощью конструктора Машинное обучение Azure

**Конструктор (Предварительная версия) — пример 4**

[!INCLUDE [applies-to-skus](../../includes/aml-applies-to-enterprise-sku.md)]

В этой статье показано, как создать сложный конвейер машинного обучения с помощью конструктора (Предварительная версия). Вы узнаете, как реализовать пользовательскую логику с помощью скриптов Python и сравнить несколько моделей, чтобы выбрать наилучший вариант.

В этом примере демонстрируется обучение классификатора для прогнозирования кредитного риска с помощью таких сведений о кредитных приложениях, как история кредита, возраст и количество кредитных карт. Однако вы можете применить основные понятия, описанные в этой статье, чтобы решить свои проблемы машинного обучения.

Вот завершенный граф для этого конвейера:

[![граф конвейера](./media/how-to-designer-sample-classification-credit-risk-cost-sensitive/graph.png)](./media/how-to-designer-sample-classification-credit-risk-cost-sensitive/graph.png#lightbox)

## <a name="prerequisites"></a>Технические условия

[!INCLUDE [aml-ui-prereq](../../includes/aml-ui-prereq.md)]

4. Щелкните пример 4, чтобы открыть его.

## <a name="data"></a>Данные

В этом примере используется набор данных с кредитными картами для Германии из репозитория Ирвин UC. Он содержит 1 000 примеров с 20 функциями и одной меткой. Каждый пример представляет человека. 20 функций включают в себя числовые и функции категорий. Дополнительные сведения о наборе данных см. на [веб-сайте UCI](https://archive.ics.uci.edu/ml/datasets/Statlog+%28German+Credit+Data%29). Последний столбец — это метка, которая обозначает кредитный риск и имеет только два возможных значения: высокий кредитный риск = 2 и низкий кредитный риск = 1.

## <a name="pipeline-summary"></a>Сводка по конвейеру

В этом конвейере вы сравниваете два разных подхода к созданию моделей для решения этой проблемы:

- Обучение с помощью исходного набора данных.
- Обучение с помощью реплицируемого набора данных.

С обоими подходами вы оцениваете модели с помощью тестового набора данных с репликацией, чтобы обеспечить согласованность результатов с функцией cost. Протестируйте два классификатора с обоими способами: с **двумя классами** и с **повышенным деревом принятия решений в двух классах**.

Стоимость неверной классификации в примере с низким риском — 1, а стоимость неверной классификации примера с высоким риском — 5. Для учета этой неправильной классификации мы используем модуль **выполнить сценарий Python** .

Вот граф конвейера:

[![граф конвейера](./media/how-to-designer-sample-classification-credit-risk-cost-sensitive/graph.png)](./media/how-to-designer-sample-classification-credit-risk-cost-sensitive/graph.png#lightbox)

## <a name="data-processing"></a>Обработка данных

Начните с использования модуля **редактора метаданных** , чтобы добавить имена столбцов, чтобы заменить имена столбцов по умолчанию более понятными именами, полученными из описания набора данных на сайте UCI. Укажите новые имена столбцов в качестве значений, разделенных запятыми, в поле имя **нового столбца** в **редакторе метаданных**.

Затем создайте обучающие и проверочные наборы, используемые для разработки модели прогнозирования рисков. Разделите исходный набор данных на обучающие и проверочные наборы с тем же размером с помощью модуля **Split Data (разделение данных** ). Чтобы создать наборы одинакового размера, задайте в качестве **доли строк в первом параметре выходного набора данных** значение 0,7.

### <a name="generate-the-new-dataset"></a>Создать новый набор данных

Так как затраты на недооценку имеют высокий уровень, установите стоимость неправильной классификации следующим образом:

- Для случаев с высоким риском, неклассифицированных с низким риском: 5
- Для случаев с низким риском, не классифицированных как высокий риск: 1

Чтобы отразить эту функцию затрат, создайте новый набор данных. В новом наборе данных каждый пример с высоким риском реплицируется пять раз, но количество примеров с низким риском не меняется. Разбейте данные на обучающие и проверочные наборы данных перед репликацией, чтобы предотвратить появление одной и той же строки в обоих наборах.

Чтобы реплицировать данные с высоким риском, поставьте этот код Python в модуль **выполнения сценария Python** :

```Python
import pandas as pd

def azureml_main(dataframe1 = None, dataframe2 = None):

    df_label_1 = dataframe1[dataframe1.iloc[:, 20] == 1]
    df_label_2 = dataframe1[dataframe1.iloc[:, 20] == 2]

    result = df_label_1.append([df_label_2] * 5, ignore_index=True)
    return result,
```

Модуль **выполнение скрипта Python** реплицирует и обучающие, и проверочные наборы данных.

### <a name="feature-engineering"></a>Проектирование признаков

Для алгоритма **векторного компьютера поддержки двух классов** требуются Нормализованные данные. Поэтому используйте модуль **нормализация данных** для нормализации диапазонов всех числовых функций с помощью преобразования `tanh`. Преобразование «`tanh`» преобразует все числовые функции в значения в диапазоне от 0 до 1 с сохранением общего распределения значений.

Модуль **векторной поддержки с двумя классами** обрабатывает строковые функции, преобразуя их в функции категорий, а затем в двоичные функции со значением 0 или 1. Поэтому вам не нужно нормализовать эти функции.

## <a name="models"></a>Модели

Поскольку вы применили два классификатора, **два класса** (SVM) и **высококлассное дерево принятия решений**, а также два набора данных, вы создадите всего четыре модели:

- SVM, обученные исходными данными.
- SVM, обученные с помощью реплицированных данных.
- Увеличивающееся дерево решений обучено исходными данными.
- Повышенное дерево принятия решений, обученное с помощью реплицированных данных.

В этом примере используется стандартный рабочий процесс обработки и анализа данных для создания, обучения и тестирования моделей.

1. Инициализируйте алгоритмы обучения, используя **два класса Векторный компьютер поддержки** и **высококлассное дерево принятия решений**.
1. Используйте **обучение модели** , чтобы применить алгоритм к данным и создать фактическую модель.
1. Используйте **модель оценки** для формирования оценок с помощью примеров тестов.

На следующей диаграмме показана часть конвейера, в которой исходные и реплицированные обучающие наборы используются для обучения двух различных моделей SVM. **Обучение модели** подключено к обучающему набору, а **модель оценки** подключена к тестовому набору.

![Граф конвейера](./media/how-to-designer-sample-classification-credit-risk-cost-sensitive/score-part.png)

На этапе оценки конвейера вы Вычислите точность каждой из четырех моделей. Для этого конвейера используйте функцию " **вычислить модель** ", чтобы сравнить примеры с одинаковыми затратами на классификацию.

Модуль « **Оценка модели** » может вычислять метрики производительности столько же, сколько в двух оцененных моделях. Поэтому можно использовать один экземпляр **Evaluate Model** для вычисления двух моделей SVM и другой экземпляр **Evaluate Model** для вычисления двух моделей увеличивающегося дерева принятия решений.

Обратите внимание на то, что в качестве входных данных для **модели оценки**используется реплицированный набор тестов. Иными словами, окончательные оценки точности включают стоимость неправильного получения меток.

## <a name="combine-multiple-results"></a>Объединение нескольких результатов

Модуль « **Анализ модели** » создает таблицу с одной строкой, содержащей различные метрики. Чтобы создать единый набор результатов точности, мы сначала используем **Добавление строк** , чтобы объединить результаты в одну таблицу. Затем мы используем следующий скрипт Python в модуле **выполнение скрипта Python** , чтобы добавить имя модели и подход к обучению для каждой строки в таблице результатов:

```Python
import pandas as pd

def azureml_main(dataframe1 = None, dataframe2 = None):

    new_cols = pd.DataFrame(
            columns=["Algorithm","Training"],
            data=[
                ["SVM", "weighted"],
                ["SVM", "unweighted"],
                ["Boosted Decision Tree","weighted"],
                ["Boosted Decision Tree","unweighted"]
            ])

    result = pd.concat([new_cols, dataframe1], axis=1)
    return result,
```

## <a name="results"></a>Результаты

Для просмотра результатов конвейера можно щелкнуть правой кнопкой мыши визуализацию выходных данных последнего **столбца выбор столбцов в наборе данных** .

![Визуализация выходных данных](media/how-to-designer-sample-classification-credit-risk-cost-sensitive/sample4-lastselect-1225.png)

В первом столбце перечисляются алгоритмы машинного обучения, используемые для создания модели.

Во втором столбце указывается тип обучающего набора.

Третий столбец содержит значение точности с учетом стоимости.

Из этих результатов можно увидеть, что наилучшая точность обеспечивается моделью, созданной с помощью **векторной машины поддержки двух классов** , и обучена по реплицированному набору данных для обучения.

## <a name="clean-up-resources"></a>Очистка ресурсов

[!INCLUDE [aml-ui-cleanup](../../includes/aml-ui-cleanup.md)]

## <a name="next-steps"></a>Дальнейшие действия

Изучите другие примеры, доступные для конструктора:

- [Пример 1. регрессия: прогнозирование цены автомобиля](how-to-designer-sample-regression-automobile-price-basic.md)
- [Пример 2. регрессия. алгоритмы сравнения для прогнозирования цен автомобилей](how-to-designer-sample-regression-automobile-price-compare-algorithms.md)
- [Пример 3. Классификация с выбором компонентов: прогноз дохода](how-to-designer-sample-classification-predict-income.md)
- [Пример 5. Классификация: обработка прогнозов](how-to-designer-sample-classification-churn.md)
- [Пример 6. Классификация: прогнозы задержек полета](how-to-designer-sample-classification-flight-delay.md)
- [Пример 7. Классификация текста: набор данных Википедии SP 500](how-to-designer-sample-text-classification.md)
