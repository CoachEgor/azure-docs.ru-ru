---
title: Использование R с МАШИНным развертыванием (классическая модель) — Azure
description: Используйте это руководство по программированию на R для начала работы с Машинное обучение Azure Studio (классической) в R для создания решения для прогнозирования.
services: machine-learning
ms.service: machine-learning
ms.subservice: studio
ms.topic: how-to
author: likebupt
ms.author: keli19
ms.custom: previous-author=heatherbshapiro, previous-ms.author=hshapiro
ms.date: 03/01/2019
ms.openlocfilehash: b4f3733806eb810cff7722e6432bb274b6d46a37
ms.sourcegitcommit: b33c9ad17598d7e4d66fe11d511daa78b4b8b330
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88854824"
---
# <a name="get-started-with-azure-machine-learning-studio-classic-in-r"></a>Приступая к работе с Машинное обучение Azure Studio (классическая модель) в R

**ПРИМЕНИМО К:** ![да](../../../includes/media/aml-applies-to-skus/yes.png)Студия машинного обучения (классическая) ![нет](../../../includes/media/aml-applies-to-skus/no.png)[Машинное обучение Azure](../compare-azure-ml-to-studio-classic.md)


<!-- Stephen F Elston, Ph.D. -->
В этом руководстве вы узнаете, как использовать студию машинного обучения (классический) для создания, тестирования и выполнения кода R. В итоге у вас будет полноценное решение для прогнозирования.  

> [!div class="checklist"]
> * Создание кода для очистки и преобразования данных.
> * Анализируйте корреляции между несколькими переменными в нашем наборе данных.
> * Создание модели прогнозирования временных рядов для молоко производства.


Машинное обучение Azure Studio (классическая модель) содержит множество мощных модулей машинного обучения и управления данными. А с помощью языка программирования R это сочетание обеспечивает масштабируемость и простоту развертывания Studio (классической) с гибким и глубоким анализом R.

Прогнозирование — широко распространенный и чрезвычайно полезный метод аналитики. Сфера его применения охватывает широкий диапазон: от прогноза объема продаж сезонных товаров, определяющего уровень заполнения склада, до расчета макроэкономических переменных. Преимущественно при прогнозировании используются модели временных рядов. Данные временных рядов — данные, значения которых имеют индекс времени. Значение индекса времени может быть регулярным (например, помесячным или поминутным), или нерегулярным. Модель временных рядов основана на данных временных рядов. Язык программирования R располагает гибкой структурой и широкими аналитическими возможностями для временных данных.

## <a name="get-the-data"></a>Получение данных

В этом руководстве вы используете данные о производстве и ценах на продукты в Калифорнии, которые включают в себя ежемесячные сведения о производстве нескольких молочных продуктов и цены на молоко FAT, набор тестов производительности.

Данные, используемые в этой статье вместе с скриптами R, можно скачать из [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples). Данные в файле `cadairydata.csv` первоначально были синтезированы из информации, доступной в Университете Висконсина по адресу [https://dairymarkets.com](https://dairymarkets.com) .



## <a name="interact-with-r-language-in-machine-learning-studio-classic"></a><a id="mlstudio"></a>Взаимодействие с языком R в Машинное обучение Studio (классическая модель)

В этом разделе рассматриваются некоторые основные принципы взаимодействия с языком программирования R в среде Машинное обучение Studio (классическая модель). Язык R предоставляет мощный инструмент для создания пользовательских модулей аналитики и манипулирования данными в среде Машинное обучение Azure Studio (классической).

Для разработки, тестирования и отладки небольших фрагментов кода на языке R мы будем использовать RStudio. Затем этот код вырезается и вставляется в модуль [выполнить сценарий R][execute-r-script] , готовый к запуску в машинное обучение Azure Studio (классическая модель).  

### <a name="the-execute-r-script-module"></a>Модуль «Выполнение сценария R»

В среде Машинное обучение Studio (классическая модель) скрипты R выполняются в модуле [выполнить сценарий r][execute-r-script] . Пример модуля [выполнить сценарий R][execute-r-script] в машинное обучение Studio (классическая модель) показан на рис. 1.

 ![Язык программирования R: модуль "выполнение скрипта R", выбранный в Машинное обучение Studio (классическая модель)](./media/r-quickstart/fig1.png)

*Рис. 1. Среда Машинное обучение Studio (классическая), показывающая выбранный модуль выполнить сценарий R.*

На рис. 1 мы рассмотрим некоторые ключевые части среды Машинное обучение Studio (классической) для работы с модулем « [выполнение сценария R][execute-r-script] ».

* Модули эксперимента отображаются на центральной панели.
* В верхней части правой панели находится окно просмотра и изменения скриптов R.  
* В нижней части правой панели отображаются свойства модуля [Выполнить сценарий R][execute-r-script]. Чтобы просмотреть журналы ошибок и выходных данных, выберите соответствующие участки этой панели.

Конечно, в оставшейся части этой статьи мы будем обсуждать [сценарий выполнения R][execute-r-script] более подробно.

При работе с более сложными функциями R для изменения, тестирования и отладки кода я рекомендую использовать RStudio. Как и в случае разработки любого программного обеспечения, создавайте код пошагово, отдельными фрагментами, и тестируйте его на небольших, простых проверочных примерах. Затем вырезайте и вставляйте готовые функции в окно сценария модуля [Выполнить сценарий R][execute-r-script]. Такой подход позволяет использовать как интегрированную среду разработки (IDE) RStudio, так и возможности Машинное обучение Azure Studio (классическая модель).  

#### <a name="execute-r-code"></a>Выполнение кода R

Любой код R в модуле [выполнить сценарий r][execute-r-script] будет выполняться при запуске эксперимента, нажав кнопку **выполнить** . Когда код выполнен, на значке модуля [Выполнить сценарий R][execute-r-script] появляется флажок.

#### <a name="defensive-r-coding-for-azure-machine-learning"></a>Защищенное программирование на R для Машинного обучения Azure

При разработке кода R для, скажем, веб-службы с помощью Машинное обучение Azure Studio (классическая модель), следует определенно спланировать, как код будет работать с непредвиденными входными данными и исключениями. Чтобы не усложнять, я не стал добавлять проверку или обработку исключений во все примеры кода. Однако далее я приведу несколько примеров функций, использующих возможности языка R для обработки исключений.  

Если вам требуется более полная обработка исключений R, я рекомендую ознакомиться с соответствующими разделами книги, Wickham приведенные [ниже.](#appendixb)

#### <a name="debug-and-test-r-in-machine-learning-studio-classic"></a>Отладка и тестирование R в Машинное обучение Studio (классическая модель)

Повторюсь: я рекомендую использовать RStudio для отладки и тестирования небольших фрагментов кода на R. Но бывают случаи, когда необходимо отслеживать проблемы кода непосредственно в модуле [Выполнить сценарий R][execute-r-script]. Кроме того, рекомендуется проверять результаты в Машинное обучение Studio (классическая модель).

Выходные данные выполнения кода R и на платформе Машинное обучение Azure Studio (классическая модель) находятся в основном в выходных данных. log. Дополнительная информация отображается в файле error.log.  

При возникновении ошибки в Машинное обучение Studio (классической версии) во время выполнения кода на языке R первым разумеется, следует обратить внимание на Error. log. В этом файле могут быть полезные сообщения об ошибках, которые помогут вам понять и исправить свою ошибку. Чтобы просмотреть журнал ошибок., выберите **Просмотреть журнал ошибок** на **панели свойств** для [скрипта выполнения R][execute-r-script] , содержащего ошибку.

Например, запустим этот код на R с неопределенной переменной y в модуле [Выполнить сценарий R][execute-r-script]:

```r
x <- 1.0
z <- x + y
```

Выполнить этот код не удается, возникает условие ошибки. При выборе параметра **Просмотреть журнал ошибок** на **панели свойств** отображается изображение, показанное на рис. 2.

  ![Всплывающее окно сообщения об ошибке](./media/r-quickstart/fig2.png)

*Рис. 2. Всплывающее окно сообщения об ошибке*

Похоже, нужно просмотреть файл output.log, чтобы прочитать сообщение об ошибке в коде на R. Выберите [выполнить сценарий R][execute-r-script] , а затем щелкните элемент **Просмотреть выходной файл журнала** на **панели свойств** справа. Откроется новое окно браузера, где мы увидим следующее:

```output
[Critical]     Error: Error 0063: The following error occurred during evaluation of R script:
---------- Start of error message from R ----------
object 'y' not found


object 'y' not found
----------- End of error message from R -----------
```

В сообщении об ошибке нет ничего неожиданного: проблема четко определена.

Чтобы проверить значение любого объекта в коде на R, можно обеспечить вывод этих значений в файл output.log. Правила проверки значений объектов в принципе те же, что и при интерактивном сеансе работы с R. Например, если ввести в строке имя переменной, значение объекта выводится в файл output.log.  

#### <a name="packages-in-machine-learning-studio-classic"></a>Пакеты в Машинное обучение Studio (классическая модель)

Студия машинного обучения содержит более 350 предустановленных пакетов на языке R. Чтобы увидеть список предустановленных пакетов, используйте приведенный ниже код в модуле [Выполнить сценарий R][execute-r-script].

```r
data.set <- data.frame(installed.packages())
maml.mapOutputPort("data.set")
```

Если вам пока не понятна последняя строка кода, не останавливайтесь. В оставшейся части этой статьи мы подробно рассмотрим использование R в среде Studio (классическая среда).

### <a name="introduction-to-rstudio"></a>Основные сведения об RStudio

RStudio — широко используемая интегрированная среда разработки для R. Я буду использовать RStudio для редактирования, тестирования и отладки некоторых кодов R, используемых в этом руководством. После тестирования и подготовки кода R можно просто вырезать и вставить его из редактора RStudio в модуль [выполнения сценариев r][execute-r-script] машинное обучение Studio (классический).  

Если на вашем компьютере еще не установлен язык R, советую сделать это сейчас. Бесплатные загружаемые файлы языка R с открытым кодом доступны в полной архивной сети R (CRAN) по адресу [https://www.r-project.org/](https://www.r-project.org/) . Доступны файлы для скачивания для Windows, Mac OS и Linux или UNIX. Выберите любое зеркало и следуйте инструкциям по загрузке. CRAN также содержит множество полезных пакетов для аналитики и обработки данных.

Если вы еще не знакомы с RStudio, вам лучше загрузить и установить версию для настольного компьютера. RStudio для Windows, Mac OS и Linux (UNIX): http://www.rstudio.com/products/RStudio/. Следуйте инструкциям по установке RStudio на компьютер.  

Введение в учебник по RStudio можно найти в статье [Использование интегрированной среды разработки RStudio](https://support.rstudio.com/hc/sections/200107586-Using-RStudio).

Я предоставил дополнительную информацию об использовании RStudio в [руководстве по RStudio документации](#appendixa) ниже.  

## <a name="get-data-in-and-out-of-the-execute-r-script-module"></a><a id="scriptmodule"></a>Добавление данных в модуль «Выполнение сценария R» и их извлечение оттуда

В этом разделе мы рассмотрим ввод и вывод данных модуля [Выполнить сценарий R][execute-r-script]. Мы ознакомимся с обработкой различных типов данных, передаваемых в модуль [Выполнить сценарий R][execute-r-script] и получаемых из него.

Полный код для этого раздела приведен в разделе [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="load-and-check-data"></a>Загрузка и проверка данных 

#### <a name="load-the-dataset"></a><a id="loading"></a>Загрузка набора данных

Начнем с загрузки файла **csdairydata.csv** в машинное обучение Azure Studio (классическая модель).

1. Запустите среду Машинное обучение Azure Studio (классическая среда).
1. Выберите **+ создать** в левом нижнем углу экрана и выберите **набор данных**.
1. Выберите **From Local File** (Из локального файла) и нажмите кнопку **Browse** (Обзор), чтобы выбрать файл.
1. Убедитесь, что в качестве типа набора данных выбран вариант **Универсальный CSV-файл с заголовком** .
1. Установите флажок.
1. После отправки набора данных вы увидите новый набор данных, выбрав вкладку **DataSets** .  

#### <a name="create-an-experiment"></a>Создание эксперимента

Теперь, когда у нас есть данные в Машинное обучение Studio (классическая модель), необходимо создать эксперимент для анализа.  

1. Выберите **+ создать** в левом нижнем углу и выберите **эксперимент**, а затем **оставьте пустой эксперимент**.
1. Чтобы задать для него название, выделите и отредактируйте заголовок **Эксперимент создан...** вверху страницы. Например, можно изменить его на **Анализ молочных продуктов**.
1. В левой части страницы эксперимента разверните узел **Saved Datasets** (Сохраненные наборы данных), а затем – **My Datasets** (Мои наборы данных). Вы должны увидеть загруженный ранее файл **cadairydata.csv** .
1. Перетащите **набор данных csdairydata.csv** на рабочую область эксперимента.
1. В поле **Search experiment items** (Поиск элементов эксперимента) в верхней части левой панели введите текст [Выполнить сценарий R][execute-r-script]. Этот модуль появится в списке результатов поиска.
1. Перетащите модуль [Выполнить сценарий R][execute-r-script] на палитру.  
1. Соедините порт вывода **набора данных csdairydata.csv** с крайним левым портом ввода (**Набор данных 1**) модуля [Выполнить сценарий R][execute-r-script].
1. **Не забудьте выбрать "Сохранить"!**  

На этом этапе ваш эксперимент должен выглядеть, как показано на рисунке 3.

![Эксперимент «Анализ молочных продуктов»: набор данных и модуль «Выполнение сценария R»](./media/r-quickstart/fig3.png)

*Рис. 3. Эксперимент «Анализ молочных продуктов»: набор данных и модуль «Выполнение сценария R»*

#### <a name="check-on-the-data"></a>Проверка данных

Рассмотрим данные, загруженные в наш эксперимент. В эксперименте выберите выходные данные **cadairydata.csv набора данных** и щелкните **визуализировать**. Вы увидите нечто вроде этого (рис. 4):  

![Сводка набора данных cadairydata.csv](./media/r-quickstart/fig4.png)

*Рис. 4. Сводка набора данных cadairydata.csv*

Здесь представлено много полезной информации. Также видны первые несколько строк этого набора данных. Если выбрать какой-либо столбец, в разделе «Статистика» появится более подробная информация об этом столбце. Например, строка тип функции показывает, какие типы данных Машинное обучение Azure Studio (классическая модель) назначено столбцу. Такой беглый просмотр данных — хорошая проверка перед началом серьезной работы.

### <a name="first-r-script"></a>Первый сценарий R

Давайте создадим простой первый скрипт R для экспериментов в Машинное обучение Azure Studio (классическая модель). Я создал и протестировал такой сценарий в RStudio:  

```r
## Only one of the following two lines should be used
## If running in Machine Learning Studio (classic), use the first line with maml.mapInputPort()
## If in RStudio, use the second line with read.csv()
cadairydata <- maml.mapInputPort(1)
# cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
str(cadairydata)
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
## The following line should be executed only when running in
## Azure Machine Learning Studio (classic)
maml.mapOutputPort('cadairydata')
```

Теперь мне нужно передавать этот скрипт в Машинное обучение Azure Studio (классическая модель). Можно было бы его просто вырезать и вставить. Но в данном случае я перенесу свой скрипт R при помощи ZIP-файла.

### <a name="data-input-to-the-execute-r-script-module"></a>Ввод данных в модуль "Выполнение скрипта R"

Рассмотрим порты ввода модуля [Выполнить сценарий R][execute-r-script]. В этом примере мы считаем данные по молочной продукции Калифорнии в модуль [Выполнить сценарий R][execute-r-script].  

У модуля [Выполнить сценарий R][execute-r-script] может быть три порта ввода. В зависимости от приложения можно использовать любой из них или все. Кроме того, иногда целесообразно использовать сценарий R вообще без портов ввода.  

Рассмотрим все порты ввода по порядку слева направо. Наведя курсор на порт, можно увидеть всплывающую подсказку с его именем.  

#### <a name="script-bundle"></a>Пакет скриптов

Порт ввода "Пакет сценариев" позволяет передать содержимое ZIP-файла в модуль [Выполнить сценарий R][execute-r-script]. Для считывания содержимого ZIP-файла в код на R можно использовать одну из этих команд.

```r
source("src/yourfile.R") # Reads a zipped R script
load("src/yourData.rdata") # Reads a zipped R data file
```

> [!NOTE]
> Машинное обучение Azure Studio (классическая модель) обрабатывает файлы в ZIP-файле так, как если бы они направляются в каталог src/, поэтому необходимо добавить в имя этого каталога имена файлов. Например, если ZIP-файл содержит файлы `yourfile.R` и `yourData.rdata` в корне, вы будете рассматривать их как `src/yourfile.R` и `src/yourData.rdata` при использовании `source` и `load`.

Мы уже обсуждали загрузку наборов [данных в Load](#loading). После создания и тестирования сценария R, описанного в предыдущем разделе, сделайте следующее:

1. Сохраните скрипт R в файл с расширением .R. Я назвал свой файл скрипта "simpleplot.R". Вот именно в файле:

   ```r
   ## Only one of the following two lines should be used
   ## If running in Machine Learning Studio (classic), use the first line with maml.mapInputPort()
   ## If in RStudio, use the second line with read.csv()
   cadairydata <- maml.mapInputPort(1)
   # cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
   str(cadairydata)
   pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
   ## The following line should be executed only when running in
   ## Azure Machine Learning Studio (classic)
   maml.mapOutputPort('cadairydata')
   ```

1. Создайте ZIP-файл и скопируйте в него свой скрипт. В Windows можно щелкнуть правой кнопкой мыши файл и выбрать **Отправить**, а затем **Сжатая папка**. Будет создан ZIP-файл, содержащий файл "simpleplot.R".

1. Добавьте файл в **наборы данных** в машинное обучение Azure Studio (классическая модель), указав тип **ZIP**. Теперь вы увидите ZIP-файл среди своих наборов данных.

1. Перетащите ZIP-файл из **наборов данных** на **холст студии машинного обучения (классический)**.

1. Соедините порт вывода значка **ZIP-данных** с портом ввода **Пакет сценариев** модуля [Выполнить сценарий R][execute-r-script].

1. В окне кода модуля [Выполнить сценарий R][execute-r-script] введите функцию `source()` с именем вашего ZIP-файла. В данном случае введено `source("src/simpleplot.R")`.  

1. Убедитесь, что выбран параметр **Сохранить**.

После выполнения этих шагов модуль [Выполнить сценарий R][execute-r-script] выполнит сценарий R в ZIP-файле при запуске эксперимента. На этом этапе ваш эксперимент должен выглядеть, как изображено на рисунке 5.

![Эксперимент с использованием сценария R, сжатого в ZIP-файл](./media/r-quickstart/fig6.png)

*Рис. 5. Эксперимент с использованием сценария R, сжатого в ZIP-файл*

#### <a name="dataset1"></a>Набор данных 1

С помощью порта ввода «Набор данных 1» можно передать прямоугольную таблицу данных в код на R. В нашем простом сценарии функция `maml.mapInputPort(1)` считывает данные из порта 1. Затем эти данные присваиваются имени переменной в вашем коде, тип которой — таблица данных. В нашем примере скрипта присвоение выполняет первая строка кода.

```r
cadairydata <- maml.mapInputPort(1)
```

Запустите эксперимент, нажав кнопку **выполнить** . По завершении выполнения выберите модуль [выполнить сценарий R][execute-r-script] , а затем на панели свойств выберите **Просмотреть журнал вывода** . В браузере откроется новая страница с содержимым файла output.log. Прокрутив ее вниз, вы увидите следующее:

```output
[ModuleOutput] InputDataStructure
[ModuleOutput]
[ModuleOutput] {
[ModuleOutput]  "InputName":Dataset1
[ModuleOutput]  "Rows":228
[ModuleOutput]  "Cols":9
[ModuleOutput]  "ColumnTypes":System.Int32,3,System.Double,5,System.String,1
[ModuleOutput] }
```

Далее в нижней части страницы содержатся более подробные сведения в столбцах, которые будут выглядеть примерно следующим образом.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput]
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput]
[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput]
[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
[ModuleOutput]
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput]
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput]
[ModuleOutput]  $ Month            : chr  "Jan" "Feb" "Mar" "Apr" ...
[ModuleOutput]
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput]
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput]
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput]
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
```

Результаты преимущественно ожидаемые. В таблице данных 228 наблюдений и 9 столбцов. Отображаются имена столбцов, тип данных R и пример каждого столбца.

> [!NOTE]
> Эти же результаты можно получить с помощью порта вывода "Устройство R" модуля [Выполнить сценарий R][execute-r-script]. Порты вывода модуля [Выполнить сценарий R][execute-r-script] мы рассмотрим подробнее в следующем разделе.  

#### <a name="dataset2"></a>Набор данных 2

Поведение портов ввода "Набор данных 2" такое же, как у портов "Набор данных 1". С помощью этого порта можно передать еще одну прямоугольную таблицу данных в код на R. Для передачи этих данных используется функция `maml.mapInputPort(2)`с аргументом 2.  

### <a name="execute-r-script-outputs"></a>Порты вывода модуля "Выполнение скрипта R"

#### <a name="output-a-dataframe"></a>Вывод таблицы данных

Через порт «Итоговый набор данных 1» можно вывести содержимое таблицы данных на R в виде прямоугольной таблицы с помощью функции `maml.mapOutputPort()` . В нашем примере простого сценария R это выполняется с помощью такой строки:

```r
maml.mapOutputPort('cadairydata')
```

После выполнения эксперимента выберите выходной порт DataSet1 и нажмите кнопку **визуализировать**. Вы увидите нечто вроде этого (рис. 6):

![Визуализация вывода данных по молочной продукции Калифорнии](./media/r-quickstart/fig7.png)

*Рис. 6. Визуализация вывода данных по молочной продукции Калифорнии*

Выходные данные выглядят в точности так, как и входные — как и предполагалось.  

### <a name="r-device-output"></a>Порт вывода "Устройство R"

Порт вывода "Устройство R" модуля [Выполнить сценарий R][execute-r-script] предназначен для вывода сообщений и графики. Как стандартный вывод данных, так и сообщения об ошибках на R направляются в порт вывода "Устройство R".  

Чтобы просмотреть выходные данные устройства R, выберите порт, а затем на панели **визуализация**. На рисунке 7 показаны стандартный вывод данных и стандартный вывод ошибок.

![Стандартный вывод данных и стандартный вывод ошибок из порта «Устройство R»](./media/r-quickstart/fig8.png)

*Рис. 7. Стандартный вывод данных и стандартный вывод ошибок из порта «Устройство R»*

Прокрутив вниз, увидим графический вывод данных скрипта R (рис. 8).  

![Графический вывод данных из порта «Устройство R»](./media/r-quickstart/fig9.png)

*Рис. 8. Графический вывод данных из порта «Устройство R»*  

## <a name="data-filtering-and-transformation"></a><a id="filtering"></a>Фильтрация и преобразование данных

В этом разделе мы выполним простые операции фильтрации и преобразования данных по молочной продукции Калифорнии. В конце мы получим данные в формате, удобном для построения аналитической модели.  

В частности, в этом разделе мы выполним несколько распространенных задач по очистке и преобразованию данных: преобразование типа данных, фильтрацию кадров данных, добавление новых вычисляемых столбцов и преобразование значений. Эти базовые навыки помогут вам справиться с любыми видами задач при решении практических проблем.

Полный код R для этого раздела доступен в [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="type-transformations"></a>Преобразование типов данных

Мы уже можем считать данные по молочной продукции Калифорнии в код на R модуля [Выполнить сценарий R][execute-r-script], но нужно убедиться, что данные в столбцах имеют нужный тип и формат.  

R — динамически типизированный язык. Другими словами, при необходимости типы данных преобразуются из одного в другой. Атомарные типы данных в языке R включают числовые, логические и символьные. Факторы используются для компактного хранения категориальных данных. Дополнительные сведения о типах данных в ссылках см [. ниже.](#appendixb)

При считывании в R табличных данных из внешних источников рекомендуется всегда проверять в столбцах результирующие типы. Зачастую может оказаться, что данные в столбце не символьного типа, как предполагалось, а относятся к типу фактор (или наоборот). В других случаях столбец, который должен содержать числовые данные, содержит символьные данные, например «1,23» вместо 1,23 — числа с плавающей запятой.  

К счастью, можно легко преобразовывать один тип данных в другой, при условии что их сопоставление возможно. Например, нельзя преобразовать слово "Самара" в числовое значение, но его можно преобразовать в фактор (категориальную переменную). Еще один пример. Числовое значение 1 можно преобразовать в символ '1' или в фактор.  

Синтаксис любого из этих преобразований прост: `as.datatype()`. Вот функции преобразования типов данных:

* `as.numeric()`
* `as.character()`
* `as.logical()`
* `as.factor()`

Рассмотрим типы данных столбцов, которые мы ввели в предыдущем разделе. Тип всех столбцов числовой, кроме столбца Month, тип которого символьный. Преобразуем его в фактор и проверим результат.  

Я удалил строку, создававшую матрицу точечной диаграммы, и добавил строку, преобразующую тип столбца Month в фактор. В моем эксперименте я просто вырежу код на R и вставлю его в окно кода модуля [Выполнить сценарий R][execute-r-script]. Вы также можете обновить ZIP-файл и передать его в Машинное обучение Azure Studio (классический), но это займет несколько шагов.  

```r
## Only one of the following two lines should be used
## If running in Machine Learning Studio (classic), use the first line with maml.mapInputPort()
## If in RStudio, use the second line with read.csv()
cadairydata <- maml.mapInputPort(1)
# cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
## Ensure the coding is consistent and convert column to a factor
cadairydata$Month <- as.factor(cadairydata$Month)
str(cadairydata) # Check the result
## The following line should be executed only when running in
## Azure Machine Learning Studio (classic)
maml.mapOutputPort('cadairydata')
```

Выполните этот код и найдите в журнале сценарий R. Соответствующие данные журнала показаны на рис. 9.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 14 levels "Apr","April",..: 6 5 9 1 11 8 7 3 14 13 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

*Рис. 9. Сводка таблицы данных с фактором в качестве переменной*

Тип столбца Month изменился на**Factor w/ 14 levels**. Такой вариант нас не устраивает, поскольку в году всего 12 месяцев. Также можно убедиться, что тип выходных данных — **Categorical** (Категориальный), выбрав **Visualize** (Визуализировать) в меню порта Result Dataset (Итоговый набор данных).

Проблема в том, что кодирование столбца "Месяц" было бессистемным. В некоторых случаях месяц называется «Апрель», а в других — сокращено до апреля. Мы можем решить эту проблему, выполнив усечение строки до 3 символов. Теперь строка кода выглядит так:

```r
## Ensure the coding is consistent and convert column to a factor
cadairydata$Month <- as.factor(substr(cadairydata$Month, 1, 3))
```

Запустите эксперимент еще раз и проверьте журнал. Ожидаемые результаты показаны на рис. 10.  

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

*Рис. 10. Сводка таблицы данных с правильным количеством уровней фактора*

Теперь у нашей переменной — фактора — 12 уровней, как и положено.

### <a name="basic-data-frame-filtering"></a>Базовая фильтрация таблицы данных

Таблицы данных R поддерживают массу возможностей фильтрации. Наборы данных можно разбивать на подмножества, используя логическую фильтрацию по строкам или столбцам. Во многих случаях вам потребуются сложные критерии фильтрации. Ссылки, приведенные [ниже, содержат подробные примеры](#appendixb) фильтрации кадров данных.  

Выполним операцию фильтрации в нашем наборе данных. Если рассмотреть столбцы таблицы данных cadariydata, можно заметить два ненужных столбца. Первый содержит только номер строки — который не так уж и важен. Второй, Year.Month, содержит избыточную информацию. С помощью кода на R мы можем легко исключить эти столбцы.

> [!NOTE]
> С этого момента я буду показывать только дополнительный код, который добавляется в модуль [Выполнить сценарий R][execute-r-script]. Новые строки будут добавляться **перед** функцией `str()`. Я использую эту функцию для проверки результатов в Машинное обучение Azure Studio (классическая модель).

Добавим следующую строку в код на R в модуле [Выполнить сценарий R][execute-r-script].

```r
# Remove two columns we do not need
cadairydata <- cadairydata[, c(-1, -2)]
```

Выполните этот код в своем эксперименте и проверьте результат по журналу. Результат приведен на рис. 11.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  7 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

*Рис. 11. Сводка таблицы данных после удаления двух столбцов*

Отличная новость! Результат оправдал ожидания.

### <a name="add-a-new-column"></a>Добавление нового столбца

При создании модели временных рядов удобно иметь столбец, отсчитывающий месяцы с начала временного ряда. Мы создадим столбец Month.Count (Количество месяцев).

Для упрощения кодирования создадим первую простую функцию `num.month()`. Затем применим эту функцию для создания столбца в таблице данных. Вот новый код:

```r
## Create a new column with the month count
## Function to find the number of months from the first
## month of the time series
num.month <- function(Year, Month) {
  ## Find the starting year
  min.year  <- min(Year)

  ## Compute the number of months from the start of the time series
  12 * (Year - min.year) + Month - 1
}

## Compute the new column for the dataframe
cadairydata$Month.Count <- num.month(cadairydata$Year, cadairydata$Month.Number)
```

Теперь выполните обновленный эксперимент и посмотрите результаты в журнале. Этот результат приведен на рисунке 12.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  8 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

*Рис. 12. Сводка таблицы данных с добавленным столбцом*

Похоже, все работает. У нас появился новый столбец с заданными значениями.

### <a name="value-transformations"></a>Преобразование значений

В этом разделе мы выполним несколько простых преобразований значений в некоторых столбцах таблицы данных. Язык R поддерживает практически любые преобразования значений. Ссылки, приведенные [ниже, содержат подробные примеры](#appendixb) .

Если взглянуть на значения в сводных таблицах данных, вы должны увидеть нечто, нечетное. Неужели мороженого в Калифорнии производят больше, чем молока? Разумеется, нет. Это просто не имеет смысла — как это ни печально для всех любителей мороженого. Просто использованы разные единицы измерения. Цена привязана к фунтам веса. Количество молока измеряется в миллионах фунтов, мороженого — в тысячах галлонов, а творога — в тысячах фунтов. Предполагая, что число морожений составляет около 6,5 фунта на галлон, можно легко выполнить умножение, чтобы преобразовать эти значения, чтобы они были в равной мере 1 000 фунта.

В нашей модели прогнозирования мы используем мультипликативную модель для корректировки этих данных. Логарифмическое преобразование позволяет использовать линейную модель, что упрощает этот процесс. Логарифмическое преобразование можно применить в той же функции, в которой применяется множитель.

В следующем примере кода я определил новую функцию `log.transform()`и применил ее к строкам, содержащим числовые значения. Функция R `Map()` используется для того, чтобы применить функцию `log.transform()` к выбранным столбцам таблицы данных. Функция `Map()` сходна с функцией `apply()`, но позволяет добавлять в функцию несколько списков аргументов. Обратите внимание, что список множителей предоставляет второй аргумент функции `log.transform()` . Функция `na.omit()` используется для очистки, чтобы убедиться, что в таблице данных нет недостающих или неопределенных значений.

```r
log.transform <- function(invec, multiplier = 1) {
  ## Function for the transformation, which is the log
  ## of the input value times a multiplier

  warningmessages <- c("ERROR: Non-numeric argument encountered in function log.transform",
                       "ERROR: Arguments to function log.transform must be greate than zero",
                       "ERROR: Aggurment multiplier to funcition log.transform must be a scaler",
                       "ERROR: Invalid time seies value encountered in function log.transform"
                       )

  ## Check the input arguments
  if(!is.numeric(invec) | !is.numeric(multiplier)) {warning(warningmessages[1]); return(NA)}  
  if(any(invec < 0.0) | any(multiplier < 0.0)) {warning(warningmessages[2]); return(NA)}
  if(length(multiplier) != 1) {{warning(warningmessages[3]); return(NA)}}

  ## Wrap the multiplication in tryCatch
  ## If there is an exception, print the warningmessage to
  ## standard error and return NA
  tryCatch(log(multiplier * invec),
           error = function(e){warning(warningmessages[4]); NA})
}


## Apply the transformation function to the 4 columns
## of the dataframe with production data
multipliers  <- list(1.0, 6.5, 1000.0, 1000.0)
cadairydata[, 4:7] <- Map(log.transform, cadairydata[, 4:7], multipliers)

## Get rid of any rows with NA values
cadairydata <- na.omit(cadairydata)  
```

Функция `log.transform()` выполняет большую работу. Большая часть кода выполняет поиск потенциальных проблем с использованием аргументов или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Цель такого защищенного программирования — не допустить, чтобы сбой одной функции привел к нарушению всей работы. Внезапный сбой продолжительного анализа — вещь довольно неприятная. Чтобы избежать этого, необходимо выбрать значения, возвращаемые по умолчанию, что уменьшит возможные негативные последствия. Также выдается сообщение, предупреждающее пользователя о проблеме.

Если вы не знакомы с защищенным программированием на R, понять этот код может быть трудно. Поясню основные шаги:

1. Определяется вектор четырех сообщений. Они используются для передачи информации о некоторых потенциальных ошибках и исключениях, которые могут возникнуть при выполнении кода.
2. Во всех этих случаях возвращается значение NA (нет данных). Есть и другие возможности, у которых может быть меньше побочных эффектов. Например, можно было бы возвращать вектор нулей или вектор исходного входного объекта.
3. Выполняются проверки аргументов функций. В каждом случае при обнаружении ошибки возвращается значение по умолчанию и создается сообщение с помощью функции `warning()`. Я использую `warning()`, а не `stop()`, так как последняя функция прерывает выполнение, а именно этого я и хочу избежать. Обратите внимание, что при написании этого кода я использовал процедуры, поскольку использование функций сделало бы его сложнее и непонятнее.
4. Вычисления журнала выполняются внутри вызова `tryCatch()` , чтобы исключения не привели к внезапному прерыванию обработки. Без функции `tryCatch()` большинство ошибок, вызванных функциями R, вызывает сигнал остановки, что приводит именно к прерыванию.

Выполните этот код на R в своем эксперименте и просмотрите вывод данных в файле output.log. Преобразованные значения четырех столбцов появятся в журнале (см. рис. 13).

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  8 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

*Рис. 13. Сводка преобразованных значений в таблице данных*

Как мы видим, значения изменились. Теперь производство молока значительно превышает по объемам производство остальных молочных продуктов (не забывайте, что мы используем логарифмическую шкалу).

Теперь все наши данные в порядке и мы можем приступать к моделированию. Просмотрев визуализацию вывода данных через порт "Итоговый набор данных" модуля [Выполнить сценарий R][execute-r-script], вы увидите, что тип столбца Month теперь "Категориальный" с 12 уникальными значениями, как мы и хотели.

## <a name="time-series-objects-and-correlation-analysis"></a><a id="timeseries"></a>Объекты временного ряда и корреляционный анализ

В этом разделе мы исследуем несколько базовых объектов временных рядов R и проанализируем взаимосвязи некоторых переменных. Наша задача — вывод таблицы данных, содержащей сведения о попарной корреляции с несколькими задержками.

Полный код R для этого раздела приведен в [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="time-series-objects-in-r"></a>Объекты временных рядов в языке R

Как уже упоминалось, временные ряды представляют собой ряды значений данных, индексированные по времени. Объекты временных рядов на R используются для создания индексов времени и управления ними. Использование объектов временных рядов имеет несколько преимуществ. Оно избавляет от необходимости вникать в подробности управления значениями индексов временных рядов, которые уже включены в объект. Кроме того, использование объектов временных рядов позволяет применять многочисленные методы временных рядов для построения графиков, моделирования и много другого.

Класс временных рядов POSIXct довольно распространен и относительно прост. Этот класс временных рядов измеряет количество времени, прошедшее с начала эры UNIX — 1 января 1970 г. В этом примере мы будем использовать объекты временных рядов POSIXct. Другие распространенные классы объектов временных рядов включают zoo и xts (расширяемые временные ряды).

### <a name="time-series-object-example"></a>Пример объекта временных рядов

Приступим к разбору примера. Перетащим **новый модуль ** [Выполнить сценарий R][execute-r-script] в свой эксперимент. Соединим порт вывода "Итоговый набор данных 1" существующего модуля [Выполнить сценарий R][execute-r-script] с портом ввода "Набор данных 1" нового модуля [Выполнить сценарий R][execute-r-script].

Как и в предыдущих случаях, с определенного момента работы над примером я буду показывать только отдельные фрагменты кода на R, которые добавляются на каждом этапе.  

#### <a name="reading-the-dataframe"></a>Чтение таблицы данных

Для начала давайте считаем таблицу данных и убедимся, что мы получили тот результат, на который рассчитывали. Эту работу может выполнить следующий код:

```r
# Comment the following if using RStudio
cadairydata <- maml.mapInputPort(1)
str(cadairydata) # Check the results
```

Теперь выполним эксперимент. Журнал новой формы «Выполнение скрипта R» должен выглядеть как на рис. 14.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  8 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
```

*Рис. 14. Сводка таблицы данных в модуле «Выполнение сценария R»*

У этих данных ожидаемый тип и формат. Тип данных столбца "Месяц" — фактор с верным количеством уровней.

#### <a name="creating-a-time-series-object"></a>Создание объекта временных рядов

В нашу таблицу данных нужно добавить объект временного ряда. Замените текущий код следующим, добавляющим новый столбец класса POSIXct:

```r
# Comment the following if using RStudio
cadairydata <- maml.mapInputPort(1)

## Create a new column as a POSIXct object
Sys.setenv(TZ = "PST8PDT")
cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

str(cadairydata) # Check the results
```

Теперь проверьте журнал. Результат приведен на рисунке 15.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput]  $ Time             : POSIXct, format: "1995-01-01" "1995-02-01" ...
```

*Рис. 15. Сводка таблицы данных с объектом временных рядов*

Как мы видим, действительно появился новый столбец класса POSIXct.

### <a name="exploring-and-transforming-the-data"></a>Исследование и преобразование данных

Рассмотрим некоторые из переменных в этом наборе данных. Для этого прекрасно подойдет точечная диаграмма. Заменим функцию `str()` в предыдущем фрагменте кода на R следующей строкой:

```r
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata, main = "Pairwise Scatterplots of dairy time series")
```

Выполним этот код и посмотрим на результат. Диаграмма, полученная через порт "Устройство R", приведена на рисунке 16.

![Точечная диаграмма выбранных переменных](./media/r-quickstart/fig17.png)

*Рис. 16. Матрица точечной диаграммы выбранных переменных*

Во взаимосвязях этих переменных можно заметить необычную структуру. Возможно, это результат наличия тренда в данных или вызвано тем, что переменные не стандартизованы.

### <a name="correlation-analysis"></a>Корреляционный анализ

Для осуществления корреляционного анализа необходимо произвести как вычитание тренда, так и стандартизацию переменных. Можно просто использовать функцию R `scale()` , которая масштабирует переменные и размещает их по центру. Возможно, это было бы быстрее. Однако я хочу продемонстрировать пример защитного программирования на языке R.

Функция `ts.detrend()` , показанная ниже, выполняет обе эти операции. Следующие две строки кода вычитают тренд из данных и приводят значения к одному стандарту.

```r
ts.detrend <- function(ts, Time, min.length = 3){
  ## Function to de-trend and standardize a time series

  ## Define some messages if they are NULL  
  messages <- c('ERROR: ts.detrend requires arguments ts and Time to have the same length',
                'ERROR: ts.detrend requires argument ts to be of type numeric',
                paste('WARNING: ts.detrend has encountered a time series with length less than', as.character(min.length)),
                'ERROR: ts.detrend has encountered a Time argument not of class POSIXct',
                'ERROR: Detrend regression has failed in ts.detrend',
                'ERROR: Exception occurred in ts.detrend while standardizing time series in function ts.detrend'
  )
  # Create a vector of zeros to return as a default in some cases
  zerovec  <- rep(length(ts), 0.0)

  # The input arguments are not of the same length, return ts and quit
  if(length(Time) != length(ts)) {warning(messages[1]); return(ts)}

  # If the ts is not numeric, just return a zero vector and quit
  if(!is.numeric(ts)) {warning(messages[2]); return(zerovec)}

  # If the ts is too short, just return it and quit
  if((ts.length <- length(ts)) < min.length) {warning(messages[3]); return(ts)}

  ## Check that the Time variable is of class POSIXct
  if(class(cadairydata$Time)[[1]] != "POSIXct") {warning(messages[4]); return(ts)}

  ## De-trend the time series by using a linear model
  ts.frame  <- data.frame(ts = ts, Time = Time)
  tryCatch({ts <- ts - fitted(lm(ts ~ Time, data = ts.frame))},
           error = function(e){warning(messages[5]); zerovec})

  tryCatch( {stdev <- sqrt(sum((ts - mean(ts))^2))/(ts.length - 1)
             ts <- ts/stdev},
            error = function(e){warning(messages[6]); zerovec})

  ts
}  
## Apply the detrend.ts function to the variables of interest
df.detrend <- data.frame(lapply(cadairydata[, 4:7], ts.detrend, cadairydata$Time))

## Plot the results to look at the relationships
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = df.detrend, main = "Pairwise Scatterplots of detrended standardized time series")
```

Функция `ts.detrend()` выполняет большую работу. Большая часть кода выполняет поиск потенциальных проблем с использованием аргументов или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Мы уже обсуждали пример защищенного программирования в преобразовании значений. Оба блока вычислений выполняются внутри функции `tryCatch()`. Для некоторых ошибок имеет смысл возвращать вектор исходного входного объекта, а в других случаях я возвращаю вектор нулей.  

Обратите внимание, что линейная регрессия, использующаяся для вычитания тренда, является регрессией временного ряда. Прогнозирующая переменная — это объект временного ряда.  

После `ts.detrend()` определения мы применяем его к переменным, представляющим интерес в нашем кадре данных. Нужно привести список, созданный функцией `lapply()`, в соответствие с данными таблицы данных с помощью функции `as.data.frame()`. Благодаря защищенности `ts.detrend()`сбой обработки одной переменной не помешает обработке остальных.  

Последняя строка кода создает попарную точечную диаграмму. Точечная диаграмма, полученная в результате выполнения этого кода на R, приведена на рис. 17.

![Попарная точечная диаграмма после вычитания тренда и стандартизации временных рядов](./media/r-quickstart/fig18.png)

*Рис. 17. Попарная точечная диаграмма после вычитания тренда и стандартизации временных рядов*

Вы можете сравнить эти результаты с приведенными на рис. 16. После удаления тренда и стандартизации переменных мы видим, что взаимосвязи переменных гораздо менее структурированы.

Код для вычисления корреляций как объектов взаимнокорреляционной функции (CCF-объектов) R следующий:

```r
## A function to compute pairwise correlations from a
## list of time series value vectors
pair.cor <- function(pair.ind, ts.list, lag.max = 1, plot = FALSE){
  ccf(ts.list[[pair.ind[1]]], ts.list[[pair.ind[2]]], lag.max = lag.max, plot = plot)
}

## A list of the pairwise indices
corpairs <- list(c(1,2), c(1,3), c(1,4), c(2,3), c(2,4), c(3,4))

## Compute the list of ccf objects
cadairycorrelations <- lapply(corpairs, pair.cor, df.detrend)  

cadairycorrelations
```

При выполнении этого кода создается журнал, показанный на рис. 18.

```output
[ModuleOutput] Loading objects:
[ModuleOutput]   port1
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] [[1]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]    -1     0     1 
[ModuleOutput] 0.148 0.358 0.317 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[2]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]     -1      0      1 
[ModuleOutput] -0.395 -0.186 -0.238 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[3]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]     -1      0      1 
[ModuleOutput] -0.059 -0.089 -0.127 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[4]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]    -1     0     1 
[ModuleOutput] 0.140 0.294 0.293 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[5]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]     -1      0      1 
[ModuleOutput] -0.002 -0.074 -0.124 
```

*Рис. 18. Список CCF-объектов после попарного корреляционного анализа*

Каждой задержке соответствует значение корреляции. Все эти значения корреляции слишком малы, чтобы быть значимыми. Таким образом, можно заключить, что каждую переменную можно моделировать независимо от других.

### <a name="output-a-dataframe"></a>Вывод таблицы данных
Мы рассчитали попарные корреляции в виде списка CCF-объектов. Это представляет определенные сложности, поскольку порту вывода "Итоговый набор данных" требуется таблица данных на R. Более того, CCF-объект сам по себе является списком, а нас интересуют только значения первого элемента этого списка, корреляции с различными задержками.

Следующий код извлекает значения задержек из списка CCF-объектов, которые и сами являются списками.

```r
df.correlations <- data.frame(do.call(rbind, lapply(cadairycorrelations, '[[', 1)))

c.names <- c("correlation pair", "-1 lag", "0 lag", "+1 lag")
r.names  <- c("Corr Cot Cheese - Ice Cream",
              "Corr Cot Cheese - Milk Prod",
              "Corr Cot Cheese - Fat Price",
              "Corr Ice Cream - Mik Prod",
              "Corr Ice Cream - Fat Price",
              "Corr Milk Prod - Fat Price")

## Build a dataframe with the row names column and the
## correlation data frame and assign the column names
outframe <- cbind(r.names, df.correlations)
colnames(outframe) <- c.names
outframe


## WARNING!
## The following line works only in Azure Machine Learning Studio (classic)
## When running in RStudio, this code will result in an error
#maml.mapOutputPort('outframe')
```

Первая строка кода довольно сложная. Возможно, объяснения помогут понять ее. Проанализируем по порядку, от вложенных операторов к внешним:

1. Оператор **[[** с аргументом **1** выбирает вектор корреляций с задержками из первого элемента списка CCF-объектов.
2. Функция `do.call()` применяет функцию `rbind()` к элементам списка возвращаемых значений с помощью `lapply()`.
3. Функция `data.frame()` относит результаты, полученные от `do.call()`, к таблице данных.

Обратите внимание, что имена строк находятся в столбце таблицы данных. Благодаря этому имена строк сохраняются при выводе из модуля [Выполнить сценарий R][execute-r-script].

Результат выполнения кода после применения **визуализации** вывода из порта Result Dataset (Итоговый набор данных) показан на рис. 19. Имена строк находятся в первом столбце, как и предполагалось.

![Вывод результатов корреляционного анализа](./media/r-quickstart/fig20.png)

*Рис. 19. Вывод результатов корреляционного анализа*

## <a name="time-series-example-seasonal-forecasting"></a><a id="seasonalforecasting"></a>Пример временных рядов: сезонное прогнозирование

Сейчас наши данные приведены к виду, удобному для анализа, и мы установили, что между переменными нет значимых корреляций. Пойдем дальше и создадим прогностическую модель временных рядов. С помощью этой модели мы спрогнозируем производство молока в Калифорнии на 12 месяцев 2013 г.

У нашей прогностической модели будет два компонента: тренд и сезонный компонент. Окончательный прогноз будет произведением этих двух компонентов. Модели такого типа называются мультипликативными. Альтернативой является аддитивная модель. Мы уже применили логарифмическое преобразование к интересующим нас переменным, благодаря чему будет легко обработать результаты анализа.

Полный код R для этого раздела приведен в [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="creating-the-dataframe-for-analysis"></a>Создание таблицы данных для анализа

В первую очередь добавьте в эксперимент **новый модуль ** [Выполнить сценарий R][execute-r-script]. Соедините порт вывода **Итоговый набор данных** существующего модуля [Выполнить сценарий R][execute-r-script] с портом ввода **Набор данных 1** нового модуля. Результат изображен на рисунке 20.

![Эксперимент после добавления нового модуля «Выполнение сценария R»](./media/r-quickstart/fig21.png)

*Рис. 20. Эксперимент после добавления нового модуля «Выполнение сценария R»*

Как и в случае недавно выполненного корреляционного анализа, нужно добавить столбец с объектом временных рядов POSIXct. Это может выполнить следующий код.

```r
# If running in Machine Learning Studio (classic), uncomment the first line with maml.mapInputPort()
cadairydata <- maml.mapInputPort(1)

## Create a new column as a POSIXct object
Sys.setenv(TZ = "PST8PDT")
cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

str(cadairydata)
```

Выполните этот код и проверьте журнал. Результат приведен на рисунке 21.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput]  $ Time             : POSIXct, format: "1995-01-01" "1995-02-01" ...
```

*Рис. 21. Сводка таблицы данных*

Получив такой результат, мы можем приступить к анализу.

### <a name="create-a-training-dataset"></a>Создание набора данных для обучения

Имея готовую таблицу данных, нужно создать учебный набор данных. Эти данные будут включать все наблюдения за исключением последних 12 (за 2013 год), которые станут тестовым набором данных. Приведенный ниже код разбивает таблицу данных на подмножества и создает графики переменных: цены и производства молочных продуктов. Затем создаем графики четырех переменных: цены и производства молочных продуктов. Анонимная функция используется для определения приращений графика и последующей итерации для списка оставшихся двух аргументов с помощью `Map()`. Если вам кажется, что здесь пригодилась бы структура for ... loop, вы совершенно правы. Но поскольку язык R оперирует функциями, я продемонстрирую решение с использованием функций.

```r
cadairytrain <- cadairydata[1:216, ]

Ylabs  <- list("Log CA Cotage Cheese Production, 1000s lb",
               "Log CA Ice Cream Production, 1000s lb",
               "Log CA Milk Production 1000s lb",
               "Log North CA Milk Milk Fat Price per 1000 lb")

Map(function(y, Ylabs){plot(cadairytrain$Time, y, xlab = "Time", ylab = Ylabs, type = "l")}, cadairytrain[, 4:7], Ylabs)
```

После выполнения кода получаем серию графиков временных рядов через порт вывода "Устройство R" (см. рис. 22). Заметьте, что по оси времени расположены даты. Это приятный бонус при использовании метода построения графиков временных рядов.

![Первый график временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-161.png)

![Второй график временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-162.png)

![Третий график временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-163.png)

![Четвертый график временных рядов данных по ценам и производству молочных продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-164.png)

*Рис. 22. Графики временных рядов данных по ценам и производству молочных продуктов в Калифорнии*

### <a name="a-trend-model"></a>Модель тренда

Создав объект временных рядов и просмотрев данные, приступим к созданию модели тренда для данных по производству молочных продуктов в Калифорнии. Для этого можно использовать регрессию временного ряда. Но по графику видно, что для точного моделирования наблюдаемого в данных для обучения тренда недостаточно знать только наклон и смещение.

Учитывая небольшой масштаб данных, я создаю модель для трендов в RStudio, а затем вырезания и вставки результирующей модели в Машинное обучение Azure Studio (классическая модель). RStudio предоставляет интерактивную среду для такого рода интерактивного анализа.

Для начала попробуем применить полиномиальную регрессию со степенями до 3. При создании таких моделей существует высокая вероятность образования лжевзаимосвязей. Поэтому лучше не использовать члены со степенями высокого порядка. Функция `I()` запрещает интерпретацию содержимого (интерпретирует содержимое «как есть») и позволяет записать интерпретируемую буквально функцию в уравнение регрессии.

```r
milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3), data = cadairytrain)
summary(milk.lm)
```

Это дает следующий результат:

```output
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3),
##     data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.12667 -0.02730  0.00236  0.02943  0.10586
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## (Intercept)       6.33e+00   1.45e-01   43.60   <2e-16 ***
## Time              1.63e-09   1.72e-10    9.47   <2e-16 ***
## I(Month.Count^2) -1.71e-06   4.89e-06   -0.35    0.726
## I(Month.Count^3) -3.24e-08   1.49e-08   -2.17    0.031 *  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0418 on 212 degrees of freedom
## Multiple R-squared:  0.941,    Adjusted R-squared:  0.94
## F-statistic: 1.12e+03 on 3 and 212 DF,  p-value: <2e-16
```

Из значений P ( `Pr(>|t|)` ) в этих выходных данных видно, что термин "квадратный Терм" может быть незначительным. С помощью функции `update()` изменим эту модель, опустив член со степенью 2.

```r
milk.lm <- update(milk.lm, . ~ . - I(Month.Count^2))
summary(milk.lm)
```

Это дает следующий результат:

```output
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.12597 -0.02659  0.00185  0.02963  0.10696
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## (Intercept)       6.38e+00   4.07e-02   156.6   <2e-16 ***
## Time              1.57e-09   4.32e-11    36.3   <2e-16 ***
## I(Month.Count^3) -3.76e-08   2.50e-09   -15.1   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0417 on 213 degrees of freedom
## Multiple R-squared:  0.941,  Adjusted R-squared:  0.94
## F-statistic: 1.69e+03 on 2 and 213 DF,  p-value: <2e-16
```

Теперь значительно лучше. Остались только значимые члены. Однако значение 2e-16 — значение по умолчанию, и ему не стоит придавать большого значения.  

Для проверки корректности создадим график временных рядов данных молочного производства Калифорнии с использованием полученной линии тренда. Я добавил следующий код в Машинное обучение Azure Studio (классическая модель) для [выполнения скрипта R][execute-r-script] (не RStudio), чтобы создать модель и создать график. Результат показан на рис. 23.

```r
milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)

plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
lines(cadairytrain$Time, predict(milk.lm, cadairytrain), lty = 2, col = 2)
```

![Данные молочного производства Калифорнии с моделью тренда](./media/r-quickstart/unnamed-chunk-18.png)

*Рис. 23. Данные молочного производства Калифорнии с моделью тренда*

Как видим, модель тренда идеально соответствует данным. Более того, нет никаких признаков чрезмерной детализации вроде случайных колебаний линии модели.  

### <a name="seasonal-model"></a>Сезонная модель

Получив модель тренда, можно двигаться дальше и добавить сезонные составляющие. Мы используем месяц года в качестве фиктивной переменной линейной модели, чтобы отследить изменения по месяцам. Обратите внимание, что при внесении в модель переменных факторов расчет смещения не выполняют. Если это сделать, формула будет слишком детализирована, и R проигнорирует один из требуемых факторов, но сохранит определяющий смещение член.

Так как у нас есть удовлетворительная модель тренда, мы можем использовать `update()` функцию для добавления новых терминов в существующую модель. -1 в формуле обновления удаляет определяющий смещение член. Теперь продолжим в RStudio:

```r
milk.lm2 <- update(milk.lm, . ~ . + Month - 1)
summary(milk.lm2)
```

Это дает следующий результат:

```output
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^3) + Month - 1,
##     data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.06879 -0.01693  0.00346  0.01543  0.08726
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## Time              1.57e-09   2.72e-11    57.7   <2e-16 ***
## I(Month.Count^3) -3.74e-08   1.57e-09   -23.8   <2e-16 ***
## MonthApr          6.40e+00   2.63e-02   243.3   <2e-16 ***
## MonthAug          6.38e+00   2.63e-02   242.2   <2e-16 ***
## MonthDec          6.38e+00   2.64e-02   241.9   <2e-16 ***
## MonthFeb          6.31e+00   2.63e-02   240.1   <2e-16 ***
## MonthJan          6.39e+00   2.63e-02   243.1   <2e-16 ***
## MonthJul          6.39e+00   2.63e-02   242.6   <2e-16 ***
## MonthJun          6.38e+00   2.63e-02   242.4   <2e-16 ***
## MonthMar          6.42e+00   2.63e-02   244.2   <2e-16 ***
## MonthMay          6.43e+00   2.63e-02   244.3   <2e-16 ***
## MonthNov          6.34e+00   2.63e-02   240.6   <2e-16 ***
## MonthOct          6.37e+00   2.63e-02   241.8   <2e-16 ***
## MonthSep          6.34e+00   2.63e-02   240.6   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0263 on 202 degrees of freedom
## Multiple R-squared:     1,    Adjusted R-squared:     1
## F-statistic: 1.42e+06 on 14 and 202 DF,  p-value: <2e-16
```

Мы видим, что в модели отсутствует определяющий смещение член, но есть 12 значимых факторов месяца. Именно к этому мы и стремились.

Построим еще один график временного ряда данных по молочному производству Калифорнии, чтобы проверить работу модели. Чтобы создать модель и построить график, я добавил следующий код в Машинное обучение Azure Studio (классический) для [выполнения сценария R][execute-r-script] .

```r
milk.lm2 <- lm(Milk.Prod ~ Time + I(Month.Count^3) + Month - 1, data = cadairytrain)

plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
lines(cadairytrain$Time, predict(milk.lm2, cadairytrain), lty = 2, col = 2)
```

Выполнение этого кода в Машинное обучение Azure Studio (классическая модель) создает график, показанный на рис. 24.

![Данные молочного производства Калифорнии с моделью, включающей сезонные составляющие](./media/r-quickstart/unnamed-chunk-20.png)

*Рис. 24. Данные молочного производства Калифорнии с моделью, включающей сезонные составляющие*

Соответствие данных на рисунке 24 довольно обнадеживающее. И тренд, и сезонная составляющая (в помесячном варианте) выглядят вполне разумно.

В качестве еще одной проверки нашей модели рассмотрим остатки. Приведенный ниже код вычисляет прогнозируемые значения наших двух моделей, вычисляет остатки для сезонной модели и отображает эти остатки для данных для обучения.

```r
## Compute predictions from our models
predict1  <- predict(milk.lm, cadairydata)
predict2  <- predict(milk.lm2, cadairydata)

## Compute and plot the residuals
residuals <- cadairydata$Milk.Prod - predict2
plot(cadairytrain$Time, residuals[1:216], xlab = "Time", ylab ="Residuals of Seasonal Model")
```

Диаграмма остатков приведена на рисунке 25.

![Остатки сезонной модели для данных для обучения](./media/r-quickstart/unnamed-chunk-21.png)

*Рис. 25. Остатки сезонной модели для данных для обучения*

Выглядит вполне логично. Определенная структура отсутствует, за исключением влияния экономического спада 2008–2009 годов, который не слишком хорошо отражен в нашей модели.

Диаграмма на рис. 25 помогает определить любые связанные со временем закономерности в остатках. Благодаря использованию эксплицитного подхода к вычислению и визуальному представлению остатков они располагаются на диаграмме во временной последовательности. Если бы для построения диаграммы использовалось `milk.lm$residuals`, диаграмма не отражала бы зависимость от времени.

Для построения ряда диагностических диаграмм можно также использовать функцию `plot.lm()`.

```r
## Show the diagnostic plots for the model
plot(milk.lm2, ask = FALSE)
```

Пример ряда диагностических диаграмм, созданных с помощью этого кода, приведен на рис. 26.

![Первая диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-221.png)

![Вторая диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-222.png)

![Третья диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-223.png)

![Четвертая диагностическая диаграмма для сезонной модели](./media/r-quickstart/unnamed-chunk-224.png)

*Рис. 26. Диагностические диаграммы для сезонной модели*

На этих диаграммах можно увидеть несколько точек влияния, но они не дают поводов для серьезного беспокойства. Более того, на графике Q-Q видно, что распределение остатков близко к нормальному, что важно для линейных моделей.

### <a name="forecasting-and-model-evaluation"></a>Прогнозирование и оценка моделей

Остался последний шаг до завершения работы. Необходимо рассчитать прогнозы и измерить их отклонения от фактических данных. Составим прогноз на 12 месяцев 2013 года. Можно рассчитать величину отклонений для этого прогноза по отношению к фактическим данным, не входящим в наш набор данных для обучения. Кроме того, можно сравнить эффективность, используя учебные данные за 18 лет и тестовые данные за 12 месяцев.  

Для измерения эффективности моделей временных рядов используется несколько показателей. В нашем случае мы используем среднеквадратическое отклонение. Следующая функция вычисляет среднеквадратическое отклонение между двумя рядами.  

```r
RMS.error <- function(series1, series2, is.log = TRUE, min.length = 2){
  ## Function to compute the RMS error or difference between two
  ## series or vectors

  messages <- c("ERROR: Input arguments to function RMS.error of wrong type encountered",
                "ERROR: Input vector to function RMS.error is too short",
                "ERROR: Input vectors to function RMS.error must be of same length",
                "WARNING: Funtion rms.error has received invald input time series.")

  ## Check the arguments
  if(!is.numeric(series1) | !is.numeric(series2) | !is.logical(is.log) | !is.numeric(min.length)) {
    warning(messages[1])
    return(NA)}

  if(length(series1) < min.length) {
    warning(messages[2])
    return(NA)}

  if((length(series1) != length(series2))) {
       warning(messages[3])
    return(NA)}

  ## If is.log is TRUE exponentiate the values, else just copy
  if(is.log) {
    tryCatch( {
      temp1 <- exp(series1)
      temp2 <- exp(series2) },
      error = function(e){warning(messages[4]); NA}
    )
  } else {
    temp1 <- series1
    temp2 <- series2
  }

 ## Compute predictions from our models
predict1  <- predict(milk.lm, cadairydata)
predict2  <- predict(milk.lm2, cadairydata)

## Compute the RMS error in a dataframe
  tryCatch( {
    sqrt(sum((temp1 - temp2)^2) / length(temp1))},
    error = function(e){warning(messages[4]); NA})
}
```

Как и в случае с функцией `log.transform()` , которую мы рассматривали в разделе «Преобразование значений», значительная часть кода данной функции занимается проверкой и обработкой исключений. Задействованы те же принципы. Работа выполняется двумя фрагментами кода внутри функций `tryCatch()`. В первом фрагменте временные ряды возводятся в степень, поскольку до этого мы работали с логарифмами значений. Во втором фрагменте вычисляется фактическое среднеквадратическое отклонение.  

Вооружившись функцией для измерения среднеквадратического отклонения, построим и выведем таблицу данных с отклонениями. Введем только члены для модели тренда и полную модель с сезонными факторами. Приведенный ниже код выполнит эту задачу с помощью двух линейных моделей, созданных ранее.

```r
## Compute the RMS error in a dataframe
## Include the row names in the first column so they will
## appear in the output of the Execute R Script
RMS.df  <-  data.frame(
rowNames = c("Trend Model", "Seasonal Model"),
  Traing = c(
  RMS.error(predict1[1:216], cadairydata$Milk.Prod[1:216]),
  RMS.error(predict2[1:216], cadairydata$Milk.Prod[1:216])),
  Forecast = c(
    RMS.error(predict1[217:228], cadairydata$Milk.Prod[217:228]),
    RMS.error(predict2[217:228], cadairydata$Milk.Prod[217:228]))
)
RMS.df

## The following line should be executed only when running in
## Azure Machine Learning Studio (classic)
maml.mapOutputPort('RMS.df')
```

Результат выполнения этого кода, выведенный через порт "Итоговый набор данных", приведен на рисунке 27

![Сравнение среднеквадратического отклонения для моделей](./media/r-quickstart/fig26.png)

*Рис. 27. Сравнение среднеквадратического отклонения для моделей*

Как видно по этим результатам, после добавления к модели сезонных факторов среднеквадратическое отклонение значительно уменьшилось. Вполне ожидаемо, что отклонение для учебных данных чуть меньше, чем для прогноза.

## <a name="guide-to-rstudio-documentation"></a><a id="appendixa"></a>Руководство по RStudio документации

RStudio довольно хорошо документирован. Ниже приведены ссылки на основные разделы документации по RStudio, чтобы приступить к работе.

* **Создание проектов** . Вы можете организовать код R и управлять ими в проектах с помощью RStudio. Дополнительные сведения см. [в разделе Использование проектов](https://support.rstudio.com/hc/articles/200526207-Using-Projects) . Я рекомендую следовать этим инструкциям и создать проект для примеров кода R в этой статье.  
* **Редактирование и исполнение кода r** — RStudio предоставляет интегрированную среду для редактирования и исполнения кода r. Дополнительные сведения см. в разделе [Редактирование и исполнение кода](https://support.rstudio.com/hc/articles/200484448-Editing-and-Executing-Code) .
* **Отладка** — RStudio включает мощные возможности отладки. Дополнительные сведения об этих функциях см. [в разделе Отладка с помощью RStudio](https://support.rstudio.com/hc/articles/200713843-Debugging-with-RStudio) . Дополнительные сведения о возможностях устранения неполадок в [точке останова см.](https://support.rstudio.com/hc/articles/200534337-Breakpoint-Troubleshooting)

## <a name="further-reading"></a><a id="appendixb"></a>Дополнительные материалы

В этом руководстве по программированию на языке R рассматриваются основы использования языка R с Машинное обучение Azure Studio (классическая модель). Если вы еще не знакомы с языком R, на ресурсе CRAN можно найти два вводных курса:

* Для начала лучше всего начать с [R для начинающих](https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf) с Paradis Emmanuel.  
* [Введение в R](https://cran.r-project.org/doc/manuals/R-intro.html) by W. N. Венаблес et al. переходит к более подробной версии.

По языку R написано много книг, которые могут помочь в его освоении. Вот некоторые из них, которые показались мне наиболее полезными:

* **Искусство программирования на языке r: Обзор статистической разработки программного обеспечения** с помощью Норман матлофф — это отличное введение в программирование на r.  
* **R Cookbook** по пол титор предоставляет проблему и подход к использованию языка r.  
* **R в действии** Роберт кабакофф — еще одна полезная вводная книга. Вспомогательный [веб-сайт Quick R](https://www.statmethods.net/) — это полезный ресурс.
* **R Inferno адский** by Патрик — это удивительно юмористическом книга, которая работает с несколькими сложными и сложными темами, которые могут возникнуть при программировании на R. Книга доступна бесплатно на сайте [R Inferno адский](https://www.burns-stat.com/documents/books/the-r-inferno/).
* Если вы хотите подробно ознакомиться с дополнительными разделами в R, ознакомьтесь с книгой **Advanced R** Hadley Wickham. Интерактивная версия этой книги доступна бесплатно по адресу [http://adv-r.had.co.nz/](http://adv-r.had.co.nz/) .

Каталог пакетов временных рядов R можно найти в [представлении задач Cran: анализ временных рядов](https://cran.r-project.org/web/views/TimeSeries.html). Информацию по определенным пакетам объектов временных рядов см. в документации к этим пакетам.

В книге с **вводом временных рядов** с r по пол Ковпертваит и Эндрю меткалфе содержатся общие сведения об использовании R для анализа временных рядов. Множество других теоретических работ содержат примеры на языке R.

Ниже приведены некоторые полезные Интернет – ресурсы.

* На сайте DataCamp обучение R происходит в вашем браузере с помощью видеоуроков и упражнений по программированию. Здесь представлены интерактивные учебники по последним методам кодирования на R и пакетам R. Примите участие в бесплатном [интерактивном учебнике по R](https://www.datacamp.com/courses/introduction-to-r).
* [Знакомство с программированием R — полное пошаговое руководством](https://www.datamentor.io/r-programming/) по работе с инструктором.
* [программиста R](https://r-coder.com/). Подробные руководства R и бесплатный курс R для начинающих.
* Быстрый [учебник по R](https://www.cyclismo.org/tutorial/R/) , Келли черный от Кларксон университета.
* [Для улучшения навыков работы с данными у вас](https://www.computerworld.com/article/2497464/business-intelligence-60-r-resources-to-improve-your-data-skills.html)есть более 60 ресурсов r, перечисленных в верхней части ресурсов на языке r.

<!-- Module References -->
[execute-r-script]: /azure/machine-learning/studio-module-reference/execute-r-script
