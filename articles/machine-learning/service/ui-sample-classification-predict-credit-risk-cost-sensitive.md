---
title: Обновлений Прогнозируемый кредитный риск (с учетом стоимости)
titleSuffix: Azure Machine Learning service
description: В этой статье показано, как создать сложный эксперимент машинного обучения с помощью визуального интерфейса. Вы узнаете, как реализовать пользовательские скрипты Python и сравнить несколько моделей, чтобы выбрать наилучший вариант.
services: machine-learning
ms.service: machine-learning
ms.subservice: core
ms.topic: conceptual
author: xiaoharper
ms.author: zhanxia
ms.reviewer: sgilley
ms.date: 05/10/2019
ms.openlocfilehash: 942d6fa6db7ee2fc07fd11d3448ac7ec96c3bd43
ms.sourcegitcommit: 670c38d85ef97bf236b45850fd4750e3b98c8899
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/08/2019
ms.locfileid: "68845976"
---
# <a name="sample-4---classification-predict-credit-risk-cost-sensitive"></a>Пример 4. Классификация: Прогнозируемый кредитный риск (с учетом стоимости)

В этой статье показано, как создать сложный эксперимент машинного обучения с помощью визуального интерфейса. Вы узнаете, как реализовать пользовательскую логику с помощью скриптов Python и сравнить несколько моделей, чтобы выбрать наилучший вариант.

В этом примере демонстрируется обучение классификатора для прогнозирования кредитного риска с помощью таких сведений о кредитных приложениях, как история кредита, возраст и количество кредитных карт. Однако вы можете применить основные понятия, описанные в этой статье, чтобы решить свои проблемы машинного обучения.

Если вы только начинаете работу с машинным обучением, сначала ознакомьтесь с [примером базового классификатора](ui-sample-classification-predict-credit-risk-basic.md) .

Вот готовый граф для этого эксперимента:

[![График эксперимента](media/ui-sample-classification-predict-credit-risk-cost-sensitive/graph.png)](media/ui-sample-classification-predict-credit-risk-cost-sensitive/graph.png#lightbox)

## <a name="prerequisites"></a>предварительные требования

[!INCLUDE [aml-ui-prereq](../../../includes/aml-ui-prereq.md)]

4. Нажмите кнопку **Открыть** для примера 4 эксперимента:

    ![Открытие эксперимента](media/ui-sample-classification-predict-credit-risk-cost-sensitive/open-sample4.png)

## <a name="data"></a>Data

Мы используем набор данных для кредитных карт на немецком языке из репозитория UC Ирвин. Этот набор данных содержит 1 000 выборок с 20 компонентами и одной меткой. Каждый пример представляет человека. 20 функций включают в себя числовые и функции категорий. Дополнительные сведения о наборе данных см. на [веб-сайте UCI](https://archive.ics.uci.edu/ml/datasets/Statlog+%28German+Credit+Data%29) . Последний столбец — это метка, которая обозначает кредитный риск и имеет только два возможных значения: высокий кредитный риск = 2 и низкий кредитный риск = 1.

## <a name="experiment-summary"></a>Сводка по экспериментам

В этом эксперименте мы сравниваем два разных подхода к созданию моделей для решения этой проблемы:

- Обучение с помощью исходного набора данных.
- Обучение с помощью реплицируемого набора данных.

С обоими подходами мы оцениваем модели с помощью тестового набора данных с репликацией, чтобы обеспечить согласованность результатов с функцией cost. Мы тестируем два классификатора с обоими способами: **2-классовый компьютер с поддержкой вектора** и высококлассное **Дерево принятия решений**.

Стоимость неверной классификации в примере с низким риском — 1, а стоимость неверной классификации примера с высоким риском — 5. Для учета этой неправильной классификации мы используем модуль **выполнить сценарий Python** .

Вот график эксперимента:

[![График эксперимента](media/ui-sample-classification-predict-credit-risk-cost-sensitive/graph.png)](media/ui-sample-classification-predict-credit-risk-cost-sensitive/graph.png#lightbox)

## <a name="data-processing"></a>Обработка данных

Начнем с использования модуля **редактора метаданных** , чтобы добавить имена столбцов, чтобы заменить имена столбцов по умолчанию более понятными именами, полученными из описания набора данных на сайте UCI. Мы предоставляем новые имена столбцов в качестве значений, разделенных запятыми, в поле имя **нового столбца** в **редакторе метаданных**.

Далее мы создадим обучающие и проверочные наборы, используемые для разработки модели прогнозирования рисков. Мы разбиваем исходный набор данных на обучающие и проверочные наборы с тем же размером с помощью модуля **Split Data (разделение данных** ). Для создания наборов одинакового размера мы устанавливаем **доли строк в первом параметре выходного набора данных** в 0,5.

### <a name="generate-the-new-dataset"></a>Создать новый набор данных

Так как затраты на недооценку очень высоки, мы устанавливаем стоимость неправильной классификации следующим образом:

- Для случаев с высоким риском, неклассифицированных с низким риском: 5
- Для случаев с низким риском, не классифицированных как высокий риск: 1

Чтобы отразить эту функцию затрат, мы создаем новый набор данных. В новом наборе данных каждый пример с высоким риском реплицируется пять раз, но количество примеров с низким риском не меняется. Мы разбиваем данные на обучающие и проверочные наборы данных перед репликацией, чтобы предотвратить появление одной и той же строки в обоих наборах.

Чтобы реплицировать данные с высоким риском, мы поместим этот код Python в модуль **EXECUTE Python Script (выполнение скрипта** ):

```Python
import pandas as pd

def azureml_main(dataframe1 = None, dataframe2 = None):

    df_label_1 = dataframe1[dataframe1.iloc[:, 20] == 1]
    df_label_2 = dataframe1[dataframe1.iloc[:, 20] == 2]

    result = df_label_1.append([df_label_2] * 5, ignore_index=True)
    return result,
```

Модуль **выполнение скрипта Python** реплицирует и обучающие, и проверочные наборы данных.

### <a name="feature-engineering"></a>Проектирование признаков

Для алгоритма **векторного компьютера поддержки двух классов** требуются Нормализованные данные. Поэтому мы используем модуль **нормализация данных** для нормализации диапазонов всех числовых функций с помощью `tanh` преобразования. `tanh` Преобразование преобразует все числовые функции в значения в диапазоне от 0 до 1 с сохранением общего распределения значений.

Модуль **векторной поддержки с двумя классами** обрабатывает строковые функции, преобразуя их в функции категорий, а затем в двоичные функции со значением 0 или 1. Поэтому не нужно нормализовать эти функции.

## <a name="models"></a>Модели

Поскольку мы применяем два классификатора, **Высококлассовый компьютер с поддержкой векторной поддержки** (SVM) и высококлассное **Дерево принятия решений**, а также два набора данных, мы создаем всего четыре модели:

- SVM, обученные исходными данными.
- SVM, обученные с помощью реплицированных данных.
- Увеличивающееся дерево решений обучено исходными данными.
- Повышенное дерево принятия решений, обученное с помощью реплицированных данных.

Мы используем стандартный экспериментальный рабочий процесс для создания, обучения и тестирования моделей:

1. Инициализируйте алгоритмы обучения, используя **два класса Векторный компьютер поддержки** и высококлассное **Дерево принятия решений**.
1. Используйте **обучение модели** , чтобы применить алгоритм к данным и создать фактическую модель.
1. Используйте **модель оценки** для формирования оценок с помощью примеров тестов.

На следующей диаграмме показана часть этого эксперимента, в которой исходные и реплицированные обучающие наборы используются для обучения двух различных моделей SVM. **Обучение модели** подключено к обучающему набору, а **модель оценки** подключена к тестовому набору.

![Граф эксперимента](media/ui-sample-classification-predict-credit-risk-cost-sensitive/score-part.png)

На этапе оценки эксперимента мы вычисляем точность каждой из четырех моделей. Для этого эксперимента мы используем функцию « **Оценка модели** » для сравнения примеров с одинаковыми затратами на классификацию.

Модуль « **Оценка модели** » может вычислять метрики производительности столько же, сколько в двух оцененных моделях. Поэтому мы используем один экземпляр **Evaluate Model** для вычисления двух моделей SVM и другой экземпляр **Evaluate Model** для вычисления двух моделей увеличивающегося дерева принятия решений.

Обратите внимание на то, что в качестве входных данных для **модели оценки**используется реплицированный набор тестов. Иными словами, окончательные оценки точности включают стоимость неправильного получения меток.

## <a name="combine-multiple-results"></a>Объединение нескольких результатов

Модуль « **Анализ модели** » создает таблицу с одной строкой, содержащей различные метрики. Чтобы создать единый набор результатов точности, мы сначала используем **Добавление строк** , чтобы объединить результаты в одну таблицу. Затем мы используем следующий скрипт Python в модуле **выполнение скрипта Python** , чтобы добавить имя модели и подход к обучению для каждой строки в таблице результатов:

```Python
import pandas as pd

def azureml_main(dataframe1 = None, dataframe2 = None):

    new_cols = pd.DataFrame(
            columns=["Algorithm","Training"],
            data=[
                ["SVM", "weighted"],
                ["SVM", "unweighted"],
                ["Boosted Decision Tree","weighted"],
                ["Boosted Decision Tree","unweighted"]
            ])

    result = pd.concat([new_cols, dataframe1], axis=1)
    return result,
```

## <a name="results"></a>Результаты

Чтобы просмотреть результаты эксперимента, можно щелкнуть правой кнопкой мыши визуализацию выходных данных для последнего модуля **Выбор столбцов в наборе данных** .

![Визуализация выходных данных](media/ui-sample-classification-predict-credit-risk-cost-sensitive/result.png)

В первом столбце перечисляются алгоритмы машинного обучения, используемые для создания модели.
Во втором столбце указывается тип обучающего набора.
Третий столбец содержит значение точности с учетом стоимости.

Из этих результатов можно увидеть, что наилучшая точность обеспечивается моделью, созданной с помощью векторной **машины поддержки двух классов** , и обучена по реплицированному набору данных для обучения.

## <a name="clean-up-resources"></a>Очистка ресурсов

[!INCLUDE [aml-ui-cleanup](../../../includes/aml-ui-cleanup.md)]

## <a name="next-steps"></a>Следующие шаги

Изучите другие примеры, доступные для визуального интерфейса:

- [Пример 1. регрессия: Прогнозирование цены автомобиля](ui-sample-regression-predict-automobile-price-basic.md)
- [Пример 2. регрессия: Сравнение алгоритмов для прогнозирования цен автомобилей](ui-sample-regression-predict-automobile-price-compare-algorithms.md)
- [Пример 3. Классификация: Прогнозируемый кредитный риск](ui-sample-classification-predict-credit-risk-basic.md)
- [Пример 5. Классификация: Прогнозирование обновлений](ui-sample-classification-predict-churn.md)
- [Пример 6. Классификация: Прогнозирование задержек рейсов](ui-sample-classification-predict-flight-delay.md)