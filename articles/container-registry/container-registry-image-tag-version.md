---
title: Рекомендации по тегов для изображений
description: Рекомендации по пометки и версии изображений контейнера Docker при нажатии изображений и вытягивании изображений из реестра контейнеров Azure
author: stevelasker
ms.topic: article
ms.date: 07/10/2019
ms.author: stevelas
ms.openlocfilehash: b483317960409fe1fbea181706f12375606fe659
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "75445738"
---
# <a name="recommendations-for-tagging-and-versioning-container-images"></a>Рекомендации по пометки и версии изображений контейнеров

При нажатии развертывания изображений контейнера в реестр контейнеров, а затем их развертывание, вам нужна стратегия для пометки изображений и версии. В этой статье рассматриваются два подхода и то, где каждый из них подходит в течение жизненного цикла контейнера:

* **Стабильные теги** - Теги, которые вы повторно использовать, например, для указания основных или незначительных версий, таких как *mycontainerimage:1.0*.
* **Уникальные теги** - различные теги для каждого изображения вы нажимаете на реестр, такие как *mycontainerimage:abc123*.

## <a name="stable-tags"></a>Стабильные теги

**Рекомендация**: Используйте стабильные теги для поддержания **базовых изображений** для сборки контейнеров. Избегайте развертывания со стабильными тегами, поскольку эти теги продолжают получать обновления и могут вводить несоответствия в производственных средах.

*Стабильные теги* означают, что разработчик или система сборки могут продолжать тянуть определенный тег, который продолжает получать обновления. Стабильный не означает, что содержимое заморожено. Скорее, стабильный подразумевает, что изображение должно быть стабильным для намерения этой версии. Чтобы оставаться «стабильным», можно обслуживать исправлять исправления безопасности или обновления фреймворка.

### <a name="example"></a>Пример

Рамочная команда отправляет версию 1.0. Они знают, что будут поставлять обновления, в том числе незначительные обновления. Для поддержки стабильных тегов для данной основной и незначительной версии, они имеют два набора стабильных тегов.

* `:1`- стабильный тег для основной версии. `1`представляет собой «новейшую» или «последнюю» версию 1.
* `:1.0`- стабильный тег для версии 1.0, позволяющий разработчику привязатьки к обновлениям 1.0, а не быть перенесенным вперед до 1.1, когда он выпущен.

Команда также использует `:latest` тег, который указывает на последний стабильный тег, независимо от текущей основной версии.

При доступном базовом изображении или любом типе обслуживания системы изображения со стабильными тегами обновляются до новейшего дайджеста, который представляет собой наиболее актуальный стабильный выпуск этой версии.

В этом случае постоянно обслуживаются как основные, так и второстепенные теги. В базовом сценарии изображения это позволяет владельцу изображения предоставлять обслуживаемые изображения.

### <a name="delete-untagged-manifests"></a>Удаление немаркированных манифестов

Если изображение со стабильным тегом обновляется, предварительно помеченное изображение не маркируется, в результате чего изображение осиротевших. Данные предыдущего изображения остаются в реестре. Для поддержания размера реестра можно периодически удалять немаркированные манифесты в результате стабильных обновлений изображений. Например, немаркированные манифесты [автоматической чистки](container-registry-auto-purge.md) старше указанной продолжительности или настройка [политики удержания](container-registry-retention-policy.md) для немаркированных манифестов.

## <a name="unique-tags"></a>Уникальные теги

**Рекомендация**: Используйте уникальные теги для **развертывания,** особенно в среде, которая может масштабироваться на нескольких узлах. Вероятно, требуется преднамеренное развертывание согласованной версии компонентов. Если ваш контейнер перезапускается или оркестрант масштабирует больше экземпляров, узлы не случайно вытащат новую версию, несовместимую с другими узлами.

Уникальный пометок просто означает, что каждое изображение, отодвинутое в реестр, имеет уникальный тег. Теги не используются повторно. Есть несколько шаблонов, которые вы можете следовать для создания уникальных тегов, в том числе:

* **Дата времени штамп** - Этот подход является довольно распространенным, так как вы можете четко сказать, когда изображение было построено. Но, как соотнести его обратно к вашей системе сборки? Вы должны найти сборку, которая была завершена в то же время? В каком часовом поясе вы находитесь? Все ли системы сборки откалиброваны в UTC?
* **Git commit** - Этот подход работает до тех пор, пока вы не начнете поддерживать базовые обновления изображений. Если происходит обновление базового изображения, система сборки начинается с того же Git-коммита, что и предыдущая сборка. Тем не менее, базовое изображение имеет новое содержание. Как правило, коммит Git обеспечивает *полустабильный*тег.
* **Манифест дайджест** - Каждое изображение контейнера, отодвинутое в реестр контейнеров, связано с манифестом, выявленным уникальным хэшом SHA-256 или дайджетом. Хотя уникальный, дайджест длинный, трудно читать, и не коррелирует с вашей среды сборки.
* **Сборка ID** - Этот вариант может быть лучшим, так как это, вероятно, инкрементные, и это позволяет соотнести обратно в конкретную сборку, чтобы найти все артефакты и журналы. Однако, как манифест дайджест, это может быть трудно для человека, чтобы читать.

  Если в вашей организации есть несколько систем сборки, префикс `<build-system>-<build-id>`тегс с именем системы сборки является вариацией на эту опцию: . Например, можно отличить сборки от системы сборки Команды API ВИЕН Ис созданию системы сборки Azure Pipelines.

### <a name="lock-deployed-image-tags"></a>Блокировка развернутых тегов изображений

В качестве наилучшей практики мы рекомендуем [заблокировать](container-registry-image-lock.md) любой `write-enabled` развернутый тег изображения, установив его атрибут. `false` Эта практика предотвращает непреднамеренное удаление изображения из реестра и возможное нарушение развертывания. Можно включить шаг блокировки в конвейер выпуска.

Блокировка развернутого изображения по-прежнему позволяет удалять другие неразвернутые изображения из реестра с помощью функций реестра контейнеров Azure для ведения реестра. Например, [автоматическая чистка](container-registry-auto-purge.md) немаркированных манифестов или разблокированных изображений старше указанной продолжительности или установка [политики удержания](container-registry-retention-policy.md) для немаркированных манифестов.

## <a name="next-steps"></a>Дальнейшие действия

Для более подробного обсуждения концепций в этой статье, см. блог [Докер Теги: Лучшие практики для пометки и версии докер изображения](https://stevelasker.blog/2018/03/01/docker-tagging-best-practices-for-tagging-and-versioning-docker-images/).

Чтобы обеспечить максимальную производительность и эффективное использование контейнерного реестра Azure, смотрите [рекомендации для реестра контейнеров Azure.](container-registry-best-practices.md)

<!-- IMAGES -->


<!-- LINKS - Internal -->

