---
title: Политики индексирования в Azure Cosmos DB
description: Узнайте, как настроить и изменить политику индексирования по умолчанию для автоматической индексации и повышения производительности в Azure Cosmos DB.
author: timsander1
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 03/26/2020
ms.author: tisande
ms.openlocfilehash: 930f156ebec76be860e7af02d41540ce67982f92
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "80292061"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Indexing policy in Azure Cosmos DB (Политики индексации в Azure Cosmos DB)

В Azure Cosmos DB каждый контейнер имеет политику индексирования, которая диктует, как элементы контейнера должны быть проиндексированы. Политика индексирования по умолчанию для вновь созданных контейнеров индексирует каждое свойство каждого элемента, применяя индексы диапазона для любой строки или числа, а также пространственные индексы для любого объекта GeoJSON типа Point. Это позволяет получить высокую производительность запроса без необходимости думать об индексации и управлении индексами заранее.

В некоторых ситуациях полезно переопределить автоматическое поведение в соответствии с конкретными требованиями. Можно настроить политику индексирования контейнера, установив *режим индексирования,* а также включить или исключить *пути свойств.*

> [!NOTE]
> Метод обновления политик и индексирования, описанный в этой статье, применяется только к API-изб Юнит (Core) Azure Cosmos DB.

## <a name="indexing-mode"></a>Режим индексирования

Azure Cosmos DB поддерживает два режима индексации:

- **Последовательно**: Индекс обновляется синхронно при создании, обновлении или удалении элементов. Это означает, что согласованность прочитанных запросов будет [согласованием, настроенным для учетной записи.](consistency-levels.md)
- **Нет**: Индексирование отключено на контейнере. Это обычно используется, когда контейнер используется в качестве чистого хранилища значения ключа без необходимости вторичных индексов. Он также может быть использован для повышения производительности оптовых операций. После завершения оптовых операций режим индекса может быть установлен на последовательный, а затем контролироваться с помощью [IndexTransformationProgress](how-to-manage-indexing-policy.md#use-the-net-sdk-v2) до завершения.

> [!NOTE]
> Azure Cosmos DB также поддерживает режим ленивого индексирования. Ленивая индексация выполняет обновления индекса на гораздо более низком уровне приоритета, когда двигатель не выполняет никакой другой работы. Это может привести к **несогласованным или неполным** результатам запроса. Если вы планируете запрос контейнера Cosmos, не следует выбирать ленивый индекс.

По умолчанию политика индексирования `automatic`установлена на . Это достигается путем `automatic` установки свойства в `true`политике индексирования. Установка этого `true` свойства позволяет Azure CosmosDB автоматически индексировать документы по мере их записи.

## <a name="including-and-excluding-property-paths"></a><a id="include-exclude-paths"></a>Включение и исключение имущественных путей

Пользовательская политика индексирования может указывать пути свойств, которые явно включены или исключены из индексации. Оптимизируя количество проиндексированных путей, можно снизить объем хранилища, используемого контейнером, и улучшить задержку операций записи. Эти пути определяются [по методу, описанного в разделе обзора индексирования](index-overview.md#from-trees-to-property-paths) со следующими дополнениями:

- путь, ведущий к масштабируемому значению (строка или число), заканчивается`/?`
- элементы из массива решаются вместе через `/0` `/1` `/[]` обозначение (вместо, и т.д.)
- подстановочный `/*` знак может быть использован для соответствия любых элементов ниже узла

Принимая тот же пример еще раз:

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- `headquarters`'S `employees` путь`/headquarters/employees/?`

- `locations`' `country` путь`/locations/[]/country/?`

- путь к чему-либо под `headquarters` является`/headquarters/*`

Например, мы можем `/headquarters/employees/?` включить путь. Этот путь гарантирует, что мы индексируем свойство сотрудников, но не будем индексировать дополнительные вложенные JSON в пределах этого свойства.

## <a name="includeexclude-strategy"></a>Включить/исключить стратегию

Любая политика индексирования должна `/*` включать корневой путь в качестве включенного или исключенного пути.

- Включите корневой путь, чтобы выборочно исключить пути, которые не должны быть проиндексированы. Это рекомендуемый подход, поскольку он позволяет Azure Cosmos DB активно индексировать любое новое свойство, которое может быть добавлено в модель.
- Исключите корневой путь для выборочного включения путей, которые необходимо проиндексировать.

- Для путей с регулярными символами, которые включают в себя: алфавитные символы и q (подчеркиваю), вам не придется бежать строку пути вокруг двойных котировок (например, "/путь/?"). Для путей с другими специальными символами, вам нужно избежать строки\"пути вокруг\"двойных котировок (например, "/ путь-abc /?"). Если вы ожидаете специальных персонажей на вашем пути, вы можете избежать каждый путь для безопасности. Функционально это не имеет никакого значения, если вы избежать каждого пути Vs только те, которые имеют специальные символы.

- Свойство `_etag` системы исключается из индексации по умолчанию, если etag не добавляется к включенному пути для индексации.

- Если режим индексации настроен на **согласование,** свойства `id` системы и `_ts` автоматически индексируются.

При включении и исключении путей вы можете столкнуться со следующими атрибутами:

- `kind`может быть `range` `hash`либо или . Функциональность индекса диапазона обеспечивает всю функциональность хэш-индекса, поэтому мы рекомендуем использовать индекс диапазона.

- `precision`— это число, определяемое на уровне индекса для включенных путей. Значение `-1` указывает на максимальную точность. Мы рекомендуем всегда устанавливать `-1`это значение на .

- `dataType`может быть `String` `Number`либо или . Это указывает на типы свойств JSON, которые будут проиндексированы.

Если эти свойства не указаны, они будут иметь следующие значения по умолчанию:

| **Имя свойства**     | **Значение по умолчанию** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` и `Number` |

Приведенные в [этом разделе](how-to-manage-indexing-policy.md#indexing-policy-examples) примеры политики индексирования для включения и исключения путей.

## <a name="spatial-indexes"></a>Пространственные индексы

При определении пространственного пути в политике индексирования следует ```type``` определить, какой индекс должен быть применен к этому пути. Возможные типы пространственных индексов включают:

* Точка

* Многоугольник

* MultiPolygon

* LineString

Azure Cosmos DB по умолчанию не создает пространственных индексов. Если вы хотите использовать пространственные встроенные функции S'L, следует создать пространственный индекс по требуемым свойствам. Смотрите [в этом разделе](geospatial.md) примеры политики индексирования для добавления пространственных индексов.

## <a name="composite-indexes"></a>Композитные индексы

Запросы, которые `ORDER BY` имеют положение с двумя или более свойствами, требуют составного индекса. Можно также определить составной индекс для повышения производительности многих запросов равенства и диапазона. По умолчанию составные индексы не определяются, поэтому следует [добавлять композитные индексы](how-to-manage-indexing-policy.md#composite-indexing-policy-examples) по мере необходимости.

При определении составного индекса указывается:

- Два или более путей свойства. Последовательность, в которой определяются пути свойств, имеет значение.

- Порядок (восходящий или нисходящий).

> [!NOTE]
> При добавлении композитного индекса запрос будет использовать существующие индексы диапазона до тех пор, пока не будет завершено новое дополнение композитного индекса. Поэтому при добавлении композитного индекса можно не сразу наблюдать за улучшением производительности. Отследить ход трансформации индекса можно [с помощью одного из SDK.](how-to-manage-indexing-policy.md)

### <a name="order-by-queries-on-multiple-properties"></a>ORDER BY запросы по нескольким свойствам:

При использовании составных индексов для запросов `ORDER BY` с оговоркой с двумя или более свойствами используются следующие соображения:

- Если составные пути индекса не совпадают с `ORDER BY` последовательностью свойств в предложении, то составной индекс не может поддерживать запрос.

- Порядок композитных траекторий индекса (восходящий или `order` нисходящий) также должен соответствовать пункту. `ORDER BY`

- Составной индекс также `ORDER BY` поддерживает положение с противоположным порядком на всех путях.

Рассмотрим следующий пример, когда составной индекс определяется по имени, возрасту и _ts свойствам:

| **Композитный индекс**     | **Пример `ORDER BY` запроса**      | **Поддерживается композитный индекс?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

Вы должны настроить политику индексирования, чтобы `ORDER BY` вы могли обслуживать все необходимые запросы.

### <a name="queries-with-filters-on-multiple-properties"></a>запросы с фильтрами по нескольким свойствам.

Если в запросе есть фильтры на двух или более свойствах, может быть полезно создать составной индекс для этих свойств.

Например, рассмотрим следующий запрос, в котором фильтр равенства имеется на двух свойствах:

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age = 18
```

Этот запрос будет более эффективным, занимав меньше времени и занимав меньше RU, если он сможет использовать составной индекс (имя ASC, возраст ASC).

Запросы с диапазонными фильтрами также могут быть оптимизированы с составным индексом. Однако в запросе может быть только один фильтр диапазона. Диапазон фильтры `>` `<`включают, `>=`, `!=` `<=`, и . Фильтр диапазона должен быть определен последним в составном индексе.

Рассмотрим следующий запрос с фильтрами равенства и диапазона:

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age > 18
```

Этот запрос будет более эффективным с составным индексом на (имя ASC, возраст ASC). Однако в запросе не будет использоваться составной индекс (возраст ASC, название ASC), поскольку фильтры равенства должны быть определены сначала в составном индексе.

При создании композитных индексов для запросов с фильтрами на нескольких свойствах используются следующие соображения

- Свойства в фильтре запроса должны соответствовать свойствам в составном индексе. Если свойство находится в составном индексе, но не включено в запрос в качестве фильтра, запрос не будет использовать составной индекс.
- Если запрос имеет дополнительные свойства в фильтре, которые не были определены в составном индексе, то для оценки запроса будет использоваться комбинация композитных и диапазонных индексов. Для этого потребуется меньше RU, чем исключительно с использованием индексов диапазона.
- Если свойство имеет фильтр`>` `<`диапазона `<=` `>=`(, `!=`, , или), то это свойство должно быть определено последним в составном индексе. Если запрос имеет более одного фильтра диапазона, он не будет использовать составной индекс.
- При создании композитного индекса для оптимизации `ORDER` запросов с несколькими фильтрами составной индекс не будет влиять на результаты. Это необязательное свойство.
- Если вы не определите составной индекс для запроса с фильтрами на нескольких свойствах, запрос все равно будет успешным. Тем не менее, стоимость запроса RU может быть уменьшена с помощью композитного индекса.

Рассмотрим следующие примеры, когда составной индекс определяется по имени, возрасту и метке времени:

| **Композитный индекс**     | **Пример запроса**      | **Поддерживается композитный индекс?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |

### <a name="queries-with-a-filter-as-well-as-an-order-by-clause"></a>запросы с фильтром, а также с предложением ORDER BY;

Если запрос фильтрует одно или несколько свойств и имеет различные свойства в пункте ORDER BY, `ORDER BY` может быть полезно добавить свойства в фильтре к оговорке.

Например, путем добавления свойств в фильтре в положение ORDER BY можно переписать следующий запрос, чтобы использовать составной индекс:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp
```

Запрос с использованием композитного индекса:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.name, c.timestamp
```

Один и тот же шаблон и оптимизация запросов могут быть обобщены для запросов с несколькими фильтрами равенства:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.timestamp
```

Запрос с использованием композитного индекса:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.name, c.age, c.timestamp
```

При создании составных индексов используются следующие соображения для `ORDER BY` оптимизации запроса с помощью фильтра и положения:

* Если запрос фильтрует свойства, они должны быть `ORDER BY` включены сначала в положение.
* Если вы не определите составной индекс в запросе с `ORDER BY` фильтром на одном свойстве и отдельным положением с использованием другого свойства, запрос все равно будет успешным. Тем не менее, стоимость запроса RU может быть уменьшена с `ORDER BY` помощью композитного индекса, особенно если свойство в оговорке имеет высокую кардинальность.
* Все соображения для создания `ORDER BY` композитных индексов для запросов с несколькими свойствами, а также запросы с фильтрами на нескольких свойствах по-прежнему применяются.


| **Композитный индекс**                      | **Пример `ORDER BY` запроса**                                  | **Поддерживается композитный индекс?** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="modifying-the-indexing-policy"></a>Изменение политики индексирования

Политика индексирования контейнера может быть обновлена в любое время [с помощью портала Azure или одного из поддерживаемых SDK.](how-to-manage-indexing-policy.md) Обновление политики индексирования приводит к преобразованию старого индекса в новый, который выполняется в режиме онлайн и на месте (так что во время операции не будет использовано дополнительное пространство для хранения). Индекс старой политики эффективно преобразуется в новую политику, не влияя на доступность записи или пропускную емкость, установленную на контейнере. Преобразование индекса является асинхронной операцией, и время, необходимое для завершения, зависит от подготовленной пропускной выхачислений, количества элементов и их размера.

> [!NOTE]
> При добавлении диапазона или пространственного индекса запросы могут не возвращать все соответствующие результаты и делать это без возврата ошибок. Это означает, что результаты запроса могут быть непоследовательными до завершения преобразования индекса. Отследить ход трансформации индекса можно [с помощью одного из SDK.](how-to-manage-indexing-policy.md)

Если режим новой политики индексирования настроен на соответствие, никакие другие изменения политики индексирования не могут быть применены во время преобразования индекса. Преобразование запущенного индекса может быть отменено, установив режим политики индексирования на None (который немедленно упадет индекс).

## <a name="indexing-policies-and-ttl"></a>Политика индексирования и TTL

[Функция Time-to-Live (TTL)](time-to-live.md) требует активной индексации на включенном контейнере. Это означает следующее:

- невозможно активировать TTL в контейнере, где режим индексации установлен на None,
- невозможно установить режим индексации на None в контейнере, в котором активируется TTL.

Для сценариев, где не требуется индексировать путь свойств, но требуется TTL, можно использовать политику индексирования с:

- режим индексации, установленный на последовательный, и
- не включен путь, и
- `/*`как единственный исключенный путь.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании см. по следующим ссылкам:

- [Общие сведения об индексировании](index-overview.md)
- [Как управлять политикой индексации](how-to-manage-indexing-policy.md)
