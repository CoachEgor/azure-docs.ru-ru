---
title: Политики индексирования в Azure Cosmos DB
description: Узнайте, как настроить и изменить политику индексирования по умолчанию для автоматического индексирования и повышения производительности в Azure Cosmos DB.
author: ThomasWeiss
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 09/10/2019
ms.author: thweiss
ms.openlocfilehash: 60b323c12e5c548c974a7d660d08861637ac2381
ms.sourcegitcommit: 1752581945226a748b3c7141bffeb1c0616ad720
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2019
ms.locfileid: "70996670"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Политики индексирования в Azure Cosmos DB

В Azure Cosmos DB каждый контейнер имеет политику индексирования, определяющую, как должны индексироваться элементы контейнера. Политика индексирования по умолчанию для вновь создаваемых контейнеров индексирует все свойства каждого элемента, принудительно заменяя индексы диапазона для любой строки или числа, а также пространственные индексы для любого объекта геообъектного формата JSON типа Point. Это позволяет получить высокую производительность запросов без необходимости думать об индексировании и управлении индексами.

В некоторых ситуациях может потребоваться переопределить это автоматическое поведение, чтобы лучше соответствовать вашим требованиям. Политику индексирования контейнера можно настроить, задав ее *режим индексирования*, а также включить или исключить *пути к свойствам*.

> [!NOTE]
> Метод обновления политик индексации, описанный в этой статье, применим только к API-интерфейсу SQL (Core) Azure Cosmos DB.

## <a name="indexing-mode"></a>Режим индексирования

Azure Cosmos DB поддерживает два режима индексирования:

- **Consistent** (Согласованный). Если политика индексирования контейнера имеет значение consistent, индекс обновляется синхронно по мере создания, обновления или удаления элементов. Это означает, что согласованность запросов чтения будет согласована, [настроенной для учетной записи](consistency-levels.md).
- **Нет** — Если для политики индексирования контейнера задано значение нет, индексирование в этом контейнере эффективно отключается. Это часто используется, когда контейнер используется в качестве чистого хранилища значений ключа без необходимости в вторичных индексах. Это также может помочь ускорить операции с массовыми вставками.

По умолчанию для `automatic`политики индексирования задано значение. Это достигается путем задания `automatic` свойству в `true`политике индексирования значения. Задание этого свойства `true` позволяет Azure CosmosDB автоматически индексировать документы по мере их написания.

## <a name="including-and-excluding-property-paths"></a>Включение и исключение путей к свойствам

Пользовательская политика индексации может указывать пути к свойствам, которые явно включены или исключены из индексирования. Оптимизируя Количество индексируемых путей, можно уменьшить объем хранилища, используемого контейнером, и увеличить задержку операций записи. Эти пути определяются [методом, описанным в разделе Обзор индексирования](index-overview.md#from-trees-to-property-paths) со следующими дополнениями.

- путь, ведущий к скалярному значению (строке или номеру), заканчивается на`/?`
- элементы из массива обрабатываются вместе с помощью `/[]` нотации ( `/0`а не `/1` и т. д.).
- `/*` подстановочный знак можно использовать для сопоставления с любыми элементами, расположенными под узлом

Снова выполнив тот же пример:

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- `headquarters`путь :`employees``/headquarters/employees/?`

- `locations`путь `country``/locations/[]/country/?`

- путь к любому элементу `headquarters` в разделе`/headquarters/*`

Например, можно включить `/headquarters/employees/?` путь. Этот путь обеспечит индексирование свойства Employees, но не будет индексировать дополнительный вложенный код JSON в этом свойстве.

## <a name="includeexclude-strategy"></a>Стратегия включения и исключения

Любая политика индексации должна включать корневой путь `/*` как либо включенный, либо Исключенный путь.

- Включите корневой путь для выборочного исключения путей, которые не нужно индексировать. Это рекомендуемый подход, так как он позволяет Azure Cosmos DB заранее индексировать любое новое свойство, которое может быть добавлено в модель.
- Исключите корневой путь для выборочного включения путей, которые необходимо проиндексировать.

- Для путей с обычными символами, включающими буквенно-цифровые символы и символ _ (подчеркивание), не нужно заключать строку пути вокруг двойных кавычек (например, "/Пас/?"). Для путей с другими специальными символами необходимо экранировать строку пути, заключенную в двойные кавычки (например\", "/\"Path-ABC/?"). Если в пути предполагается наличие специальных символов, можно избежать последовательного переключения всех путей в целях безопасности. Функционально, это не имеет никакой разницы при экранировании всех путей и только тех, которые имеют специальные символы.

- Системное свойство "ETag" исключается из индексирования по умолчанию, если только ETag не добавлен в включаемый путь для индексирования.

При включении и исключении путей можно столкнуться со следующими атрибутами:

- `kind`может иметь значение `range` или `hash`. Функция индекса диапазона предоставляет все функции хэш-индекса, поэтому мы рекомендуем использовать индекс диапазона.

- `precision`число, определенное на уровне индекса для включенных путей. Значение `-1` указывает на максимальную точность. Рекомендуется всегда задавать для `-1`этого параметра значение.

- `dataType`может иметь значение `String` или `Number`. Указывает типы свойств JSON, которые будут индексироваться.

Если этот параметр не указан, эти свойства будут иметь следующие значения по умолчанию:

| **Имя свойства**     | **Значение по умолчанию** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` и `Number` |

В [этом разделе](how-to-manage-indexing-policy.md#indexing-policy-examples) приведены примеры политик индексации для включения и исключения путей.

## <a name="spatial-indexes"></a>Пространственные индексы

При определении пространственного пути в политике индексации необходимо определить, какой индекс ```type``` следует применить к этому пути. К пространственным индексам могут относиться следующие типы:

* Точка

* Polygon.

* MultiPolygon;

* LineString;

По умолчанию Azure Cosmos DB не создает пространственные индексы. Если вы хотите использовать встроенные функции пространственного SQL, необходимо создать пространственный индекс для обязательных свойств. В [этом разделе](geospatial.md) приведены примеры политик индексации для добавления пространственных индексов.

## <a name="composite-indexes"></a>Составные индексы

Для запросов, имеющих `ORDER BY` предложение с двумя или более свойствами, требуется составной индекс. Кроме того, можно определить составной индекс, чтобы повысить производительность многих запросов на равенство и диапазонов. По умолчанию составные индексы не определяются, поэтому при необходимости следует [добавлять составные индексы](how-to-manage-indexing-policy.md#composite-indexing-policy-examples) .

При определении составного индекса необходимо указать:

- Два или более пути свойств. Последовательность, в которой определяются пути к свойствам, имеет значение.

- Порядок (по возрастанию или по убыванию).

> [!NOTE]
> При добавлении составного индекса, как и с другими типами индексов, запросы могут возвращать непоследовательные результаты при обновлении индекса.

### <a name="order-by-queries-on-multiple-properties"></a>УПОРЯДОЧИТЬ по запросам для нескольких свойств:

Следующие рекомендации используются при использовании составных индексов для запросов с `ORDER BY` предложением с двумя или более свойствами:

- Если пути составного индекса не соответствуют последовательности свойств в `ORDER BY` предложении, составной индекс не поддерживает запрос.

- Порядок составных путей индексов (по возрастанию или `order` `ORDER BY` по убыванию) должен также совпадать с параметром в предложении.

- Составной индекс также поддерживает `ORDER BY` предложение с противоположным порядком для всех путей.

Рассмотрим следующий пример, где составной индекс определяется для свойств Name, Age и _TS:

| **Составной индекс**     | **Образец `ORDER BY` запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

Необходимо настроить политику индексирования, чтобы можно было обслуживать все `ORDER BY` необходимые запросы.

### <a name="queries-with-filters-on-multiple-properties"></a>Запросы с фильтрами по нескольким свойствам

Если запрос имеет фильтры по двум или более свойствам, может оказаться полезным создать составной индекс для этих свойств.

Например, рассмотрим следующий запрос, имеющий фильтр проверки на равенство двух свойств:

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age = 18
```

Этот запрос будет более эффективным, что займет меньше времени и потребляет меньше единиц запросов, если он способен использовать составной индекс в (Name ASC, Age ASC).

Запросы с фильтрами диапазонов также можно оптимизировать с помощью составного индекса. Однако запрос может иметь только один фильтр диапазона. Фильтры диапазонов `>`включают `<`, `<=`, `>=`, и `!=`. Фильтр диапазона должен быть определен последним в составном индексе.

Рассмотрим следующий запрос с фильтрами равенства и диапазона.

```sql
SELECT * FROM c WHERE c.name = "John" AND c.age > 18
```

Этот запрос будет более эффективным с составным индексом в (Name ASC, Age ASC). Однако запрос не будет использовать составной индекс в (Age ASC, Name ASC), так как фильтры равенства должны быть определены первыми в составном индексе.

При создании составных индексов для запросов с фильтрами для нескольких свойств используются следующие рекомендации.

- Свойства в фильтре запроса должны соответствовать значениям в составном индексе. Если свойство находится в составном индексе, но не включено в запрос в качестве фильтра, то запрос не будет использовать составной индекс.
- Если запрос содержит дополнительные свойства в фильтре, которые не были определены в составном индексе, то для оценки запроса будет использоваться сочетание составного индекса и индекса диапазона. Для этого потребуется меньше единиц запросов, чем при использовании индексов диапазона.
- Если свойство имеет фильтр диапазона (`>` `<=`, `<`,, `>=`или `!=`), то это свойство должно быть определено последним в составном индексе. Если запрос содержит более одного фильтра диапазона, он не будет использовать составной индекс.
- При создании составного индекса для оптимизации запросов с несколькими фильтрами `ORDER` составной индекс не будет оказывать влияния на результаты. Это необязательное свойство.
- Если не определить составной индекс для запроса с фильтрами по нескольким свойствам, запрос будет выполняться с ошибкой. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса.

Рассмотрим следующие примеры, где составной индекс определяется по имени, возрасту и метке свойства.

| **Составной индекс**     | **Образец запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |

### <a name="queries-with-a-filter-as-well-as-an-order-by-clause"></a>Запросы с фильтром, а также с предложением ORDER BY

Если запрос фильтрует одно или несколько свойств и имеет различные свойства в предложении ORDER BY, может быть полезно добавить свойства в фильтр `ORDER BY` в предложение.

Например, добавив свойства в фильтре в предложение ORDER BY, можно переписывать следующий запрос, чтобы использовать составной индекс:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * FROM c WHERE c.name = "John" ORDER BY c.name, c.timestamp
```

Те же оптимизации шаблонов и запросов можно обобщить для запросов с несколькими фильтрами равенства:

Запрос с использованием индекса диапазона:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * FROM c WHERE c.name = "John", c.age = 18 ORDER BY c.name, c.age, c.timestamp
```

Следующие рекомендации используются при создании составных индексов для оптимизации запроса с помощью фильтра и `ORDER BY` предложения.

* Если запрос фильтрует свойства, они должны быть включены в `ORDER BY` предложение первыми.
* Если не определить составной индекс для запроса с фильтром по одному свойству и отдельным `ORDER BY` предложением с другим свойством, запрос будет выполняться. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса, особенно если свойство в `ORDER BY` предложении имеет большую кратность.
* Все вопросы, касающиеся создания составных `ORDER BY` индексов для запросов с несколькими свойствами, а также запросы с фильтрами по нескольким свойствам, по-прежнему применяются.


| **Составной индекс**                      | **Образец `ORDER BY` запроса**                                  | **Поддерживается составным индексом?** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="modifying-the-indexing-policy"></a>Изменение политики индексирования

Политику индексирования контейнера можно обновить в любое время с [помощью портал Azure или одного из поддерживаемых пакетов SDK](how-to-manage-indexing-policy.md). Обновление политики индексирования активирует преобразование старого индекса в новый, который выполняется в сети и на месте (поэтому дополнительное пространство для хранения данных во время операции не потребляется). Индекс старой политики эффективно преобразуется в новую политику, не влияя на доступность записи или пропускную способность, подготовленную в контейнере. Преобразование индекса — это асинхронная операция, а время, необходимое для выполнения, зависит от подготовленной пропускной способности, количества элементов и их размера.

> [!NOTE]
> Во время повторного индексирования запросы могут не возвращать все совпадающие результаты и выполнять их без возврата ошибок. Это означает, что результаты запроса могут быть непостоянными до завершения преобразования индекса. Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

Если для новой политики индексирования задан режим "целостный", другие изменения политики индексирования не могут быть применены во время преобразования индекса. Чтобы отменить выполнение преобразования индекса, можно задать для параметра режим политики индексирования значение нет (что приведет к немедленному удалению индекса).

## <a name="indexing-policies-and-ttl"></a>Политики индексирования и TTL

Для [функции срока жизни (TTL)](time-to-live.md) необходимо, чтобы индексация была активной в контейнере, в котором он включен. Это означает следующее.

- невозможно активировать TTL для контейнера, в котором для режима индексирования задано значение None,
- невозможно задать для режима индексирования значение None в контейнере, где активирован TTL.

В сценариях, где не требуется индексировать свойство, но требуется TTL, можно использовать политику индексации с:

- режим индексирования установлен в значение consistent, а
- Нет добавленных путей и
- `/*`только как исключающий путь.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения об индексировании см. по следующим ссылкам:

- [Общие сведения об индексировании](index-overview.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
