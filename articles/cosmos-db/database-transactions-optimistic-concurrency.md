---
title: Транзакции базы данных и оптимистическая блокировка в Azure Cosmos DB
description: Эта статья содержит сведения о транзакциях базы данных и оптимистической блокировке в Azure Cosmos DB
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 12/04/2019
ms.reviewer: sngun
ms.openlocfilehash: d453bb4071c4a6972e01b8f7e90375181caf6d01
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "74806530"
---
# <a name="transactions-and-optimistic-concurrency-control"></a>Управление транзакциями и оптимистической блокировкой

Транзакции базы данных обеспечивают безопасную и предсказуемую модель программирования для работы с одновременными изменениями данных. Традиционные реляционные базы данных, например SQL Server, позволяют писать бизнес-логику с помощью хранимых процедур и/или триггеров, отправляйте их на сервер для выполнения непосредственно в ядре СУБД. В традиционных реляционных базах данных необходимо иметь дело с двумя различными языками программирования (без транзакций), такими как JavaScript, Python, C#, Java и т. д., а также с языком программирования транзакций (например, T-SQL), который изначально исполняется базой данных.

Ядро СУБД Azure Cosmos DB поддерживает транзакции с полной совместимостью с ACID (атомарность, согласованность, изоляция, устойчивость) и изоляцией моментального снимка. Все операции базы данных в области действия [логической секции](partition-data.md) контейнера являются транзакционно выполняемыми в ядре СУБД, размещенном в реплике секции. К ним относятся операции записи (обновление одного или нескольких элементов в логическом разделе) и операции чтения. В следующей таблице показаны различные операции и типы транзакций.

| **Операция**  | **Тип операции** | **Транзакция для одного или нескольких элементов** |
|---------|---------|---------|
| INSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| INSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| REPLACE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| REPLACE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| UPSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| UPSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| DELETE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| DELETE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение хранимой процедуры | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение процедуры слияния, инициируемое системой | запись | Транзакции для нескольких элементов |
| Удаление элементов, у которых истек срок жизни (TTL), инициируемое системой | запись | Транзакции для нескольких элементов |
| Чтение | Чтение | Транзакция для одного элемента |
| Канал изменений | Чтение | Транзакции для нескольких элементов |
| Чтение с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Запрос с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Выполнение определяемой пользователем функции в составе запроса с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |

## <a name="multi-item-transactions"></a>Транзакции для нескольких элементов

Azure Cosmos DB позволяет создавать [хранимые процедуры, триггеры pre и POST, пользовательские функции (UDF)](stored-procedures-triggers-udfs.md) и процедуры MERGE в JavaScript. Ядро СУБД Azure Cosmos DB имеет встроенную поддержку выполнения JavaScript. Вы можете зарегистрировать в контейнере хранимые процедуры, предшествующие и последующие триггеры, определяемые пользователем функции и процедуры слияния, чтобы позднее выполнять их транзакционно в ядре СУБД Azure Cosmos. Создание логики приложения на JavaScript допускает естественное выражение потока управления, области видимости переменных, присвоения, а также интеграцию примитивов обработки исключений с транзакциями базы данных непосредственно на JavaScript.

Хранимые процедуры, триггеры, определяемые пользователем функции и процедуры слияния на JavaScript помещаются в контекстные транзакции ACID с изоляцией моментального снимка для всех элементов в логическом разделе. Если при выполнении такой транзакции код JavaScript создает исключение, то вся транзакция прерывается и откатывается к прежнему состоянию. Полученная модель программирования является простой, но эффективной. Разработчики JavaScript получают надежную модель программирования, сохраняя привычные языковые конструкции и библиотечные примитивы.

Возможность выполнить код JavaScript непосредственно в ядре СУБД повышает производительность операций над элементами контейнера в базе данных и обеспечивает поддержку транзакций. Кроме того, встроенная поддержка JSON и JavaScript в ядре СУБД Azure Cosmos устраняет несоответствия между системами типов в приложении и базе данных.

## <a name="optimistic-concurrency-control"></a>Управление оптимистическим параллелизмом

Оптимистическая блокировка позволяет предотвратить потери операций обновления и удаления. Для конфликтующих одновременных операций применяется обычная пессимистическая блокировка ядра СУБД, размещенного в том же логическом разделе, что и обрабатываемый элемент. Когда две параллельные операции пытаются обновить элемент в логическом разделе до последней версии, одна из них будет успешной, а вторая завершится ошибкой. Но если одна или обе из таких операций ранее считали старое значение обновляемого элемента, база данных не может проверить актуальность считанных значений для любой из конфликтующих операций. К счастью, эту ситуацию можно обнаружить с помощью **управления оптимистичным параллелизмом (OCC)** , прежде чем позволить двум операциям ввести границу транзакции в ядре СУБД. Оптимистическая блокировка защищает от случайной перезаписи данные, внесенные другими пользователями. Она также не позволит другим процессам случайно перезаписать ваши изменения.

Для одновременных обновлений элемента Azure Cosmos DB применяет оптимистическую блокировку на уровне протокола связи. База данных Azure Cosmos следит за тем, чтобы версия обновляемого (или удаляемого) элемента на стороне клиента точно совпадала с версией этого же элемента в контейнере Azure Cosmos. Это гарантирует защиту операций записи от случайного изменения чужими записями, и наоборот. В среде с несколькими пользователями оптимистическая блокировка не позволит вам случайно удалить или изменить элемент с неправильной версией. Это обеспечивает защиту от печально известных проблем "потерянного обновления" и "потерянного удаления".

Для каждого элемента в контейнере Azure Cosmos определено системное свойство `_etag`. Значение `_etag` создается и обновляется на сервере автоматически при каждом обновлении элемента. `_etag`можно использовать с заголовком запроса `if-match` , предоставляемым клиентом, чтобы позволить серверу решить, можно ли условно обновить элемент. Значение `if-match` заголовка совпадает со значением объекта `_etag` на сервере. Затем элемент обновляется. Если значение заголовка `if-match` запроса больше не является актуальным, сервер отклоняет операцию с ответом на сообщение "HTTP 412 предусловие". Затем клиент может повторно получить элемент для получения текущей версии элемента на сервере или переопределить версию элемента на сервере со своим собственным `_etag` значением элемента. Кроме того, `_etag` можно использовать с `if-none-match` заголовком для определения необходимости повторной выборки ресурса.

`_etag` Значение элемента изменяется каждый раз при обновлении элемента. Для операций Replace Item `if-match` должен быть явно выражен как часть параметров запроса. Пример такого кода можно найти на [GitHub](https://github.com/Azure/azure-cosmos-dotnet-v3/blob/master/Microsoft.Azure.Cosmos.Samples/Usage/ItemManagement/Program.cs#L578-L674). `_etag`значения неявно проверяются для всех записанных элементов, затронутых хранимой процедурой. При обнаружении любого конфликта хранимая процедура выполняет откат транзакции и создает исключение. Такой метод гарантирует, что операции записи хранимой процедуры применяются атомарным образом, то есть "все или ничего". Приложение получает сигнал о необходимости повторно применить обновления и повторить исходный запрос клиента.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о транзакциях базы данных и оптимистической блокировке вы можете получить в следующих статьях.

- [Работа с базами данных, контейнерами и элементами Azure Cosmos](databases-containers-items.md)
- [Уровни согласованности](consistency-levels.md)
- [Типы конфликтов и политики их разрешения](conflict-resolution-policies.md)
- [Хранимые процедуры, триггеры и определяемые пользователем функции](stored-procedures-triggers-udfs.md)
