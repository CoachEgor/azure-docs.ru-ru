---
title: Транзакции базы данных и оптимистическая блокировка в Azure Cosmos DB
description: Эта статья содержит сведения о транзакциях базы данных и оптимистической блокировке в Azure Cosmos DB
author: rimman
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 04/08/2019
ms.author: rimman
ms.reviewer: sngun
ms.openlocfilehash: 568f47aacf39793d4c2da46798682abc002ca33b
ms.sourcegitcommit: 3102f886aa962842303c8753fe8fa5324a52834a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "60889361"
---
# <a name="transactions-and-optimistic-concurrency-control"></a>Управление транзакциями и оптимистической блокировкой

Транзакции базы данных обеспечивают безопасную и предсказуемую модель программирования для работы с одновременными изменениями данных. Традиционных реляционных баз данных, например SQL Server, позволяют создавать бизнес-логику, с помощью хранимых процедур или триггеров, отправить его на сервер для выполнения непосредственно в ядре СУБД. С помощью традиционных реляционных баз данных, вы должны иметь дело с двумя различными языками программирования (нетранзакционный) языка, такие как JavaScript, Python, программный C#, Java, т. д. и транзакций программирования (язык Например, T-SQL), скомпилированных в собственном коде выполняется в базе данных.

Ядро СУБД Azure Cosmos DB поддерживает транзакции с полной совместимостью с ACID (атомарность, согласованность, изоляция, устойчивость) и изоляцией моментального снимка. Все операции базы данных в области действия контейнера [логической секции](partition-data.md) транзакционно в ядре СУБД, которое размещено объектом реплики раздела. К ним относятся операции записи (обновление одного или нескольких элементов в логическом разделе) и операции чтения. В следующей таблице перечислены различные операции и типы транзакции:

| **Операция**  | **Тип операции** | **Транзакция для одного или нескольких элементов** |
|---------|---------|---------|
| INSERT (без предшествующего и последующего триггера) | Запись | Транзакция для одного элемента |
| INSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| REPLACE (без предшествующего и последующего триггера) | Запись | Транзакция для одного элемента |
| REPLACE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| UPSERT (без предшествующего и последующего триггера) | Запись | Транзакция для одного элемента |
| UPSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| DELETE (без предшествующего и последующего триггера) | Запись | Транзакция для одного элемента |
| DELETE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| Выполнить хранимую процедуру | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение процедуры слияния, инициируемое системой | Запись | Транзакции для нескольких элементов |
| Удаление элементов, у которых истек срок жизни (TTL), инициируемое системой | Запись | Транзакции для нескольких элементов |
| Чтение | Чтение | Транзакция для одного элемента |
| Канал изменений | Чтение | Транзакции для нескольких элементов |
| Чтение с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Запрос с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Выполнение определяемой пользователем функции в составе запроса с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |

## <a name="multi-item-transactions"></a>Транзакции для нескольких элементов

Azure Cosmos DB позволяет записать [хранимые процедуры, триггеры pre, post, пользователь--функции (UDF)](stored-procedures-triggers-udfs.md) и слияния процедуры на языке JavaScript. Ядро СУБД Azure Cosmos DB имеет встроенную поддержку выполнения JavaScript. Вы можете зарегистрировать в контейнере хранимые процедуры, предшествующие и последующие триггеры, определяемые пользователем функции и процедуры слияния, чтобы позднее выполнять их транзакционно в ядре СУБД Azure Cosmos. Создание логики приложения на JavaScript допускает естественное выражение потока управления, области видимости переменных, присвоения, а также интеграцию примитивов обработки исключений с транзакциями базы данных непосредственно на JavaScript.

Хранимые процедуры, триггеры, определяемые пользователем функции и процедуры слияния на JavaScript помещаются в контекстные транзакции ACID с изоляцией моментального снимка для всех элементов в логическом разделе. Если при выполнении такой транзакции код JavaScript создает исключение, то вся транзакция прерывается и откатывается к прежнему состоянию. Полученная модель программирования является простой, но эффективной. Разработчики JavaScript получают надежную модель программирования, сохраняя привычные языковые конструкции и библиотечные примитивы.

Возможность выполнить код JavaScript непосредственно в ядре СУБД повышает производительность операций над элементами контейнера в базе данных и обеспечивает поддержку транзакций. Кроме того, встроенная поддержка JSON и JavaScript в ядре СУБД Azure Cosmos устраняет несоответствия между системами типов в приложении и базе данных.

## <a name="optimistic-concurrency-control"></a>Оптимистичное управление параллелизмом 

Оптимистическая блокировка позволяет предотвратить потери операций обновления и удаления. Для конфликтующих одновременных операций применяется обычная пессимистическая блокировка ядра СУБД, размещенного в том же логическом разделе, что и обрабатываемый элемент. Когда две параллельные операции пытаются обновить элемент в логическом разделе до последней версии, одна из них будет успешной, а вторая завершится ошибкой. Но если одна или обе из таких операций ранее считали старое значение обновляемого элемента, база данных не может проверить актуальность считанных значений для любой из конфликтующих операций. К счастью, это могут быть обнаружены с помощью **оптимистического управления параллелизмом (OCC)** перед позволяя две операции введите границы транзакции в ядре СУБД. Оптимистическая блокировка защищает от случайной перезаписи данные, внесенные другими пользователями. Она также не позволит другим процессам случайно перезаписать ваши изменения.

Для одновременных обновлений элемента Azure Cosmos DB применяет оптимистическую блокировку на уровне протокола связи. База данных Azure Cosmos следит за тем, чтобы версия обновляемого (или удаляемого) элемента на стороне клиента точно совпадала с версией этого же элемента в контейнере Azure Cosmos. Это гарантирует защиту операций записи от случайного изменения чужими записями, и наоборот. В среде с несколькими пользователями оптимистическая блокировка не позволит вам случайно удалить или изменить элемент с неправильной версией. Это обеспечивает защиту от печально известных проблем "потерянного обновления" и "потерянного удаления".

Для каждого элемента в контейнере Azure Cosmos определено системное свойство `_etag`. Значение `_etag` создается и обновляется на сервере автоматически при каждом обновлении элемента. `_etag` можно использовать с поставляемые клиентом `if-match` заголовка запроса, чтобы сервер мог определить, могут ли элемент быть обновлены по условию. Значение `if-match` заголовок совпадает со значением `_etag` на сервере, затем обновляется элемент. Если значение `if-match` заголовок запроса больше не актуален, сервер отклоняет операцию с «HTTP 412 ошибка в предусловии» ответное сообщение. Клиент затем снова можно получить элемент, чтобы получить текущую версию элемента, на сервере или переопределить версию элемента на сервере с собственным `_etag` значение для элемента. Кроме того `_etag` может использоваться с `if-none-match` заголовка, чтобы определить, требуется ли повторно извлечь ресурс. 

Элемента `_etag` изменяется каждый раз при обновлении элемента. Элемент операциях замены `if-match` должен быть выражен явно как часть параметров запроса. Пример такого кода можно найти на [GitHub](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/DocumentManagement/Program.cs#L398-L446). `_etag` значения неявно проверяются все письменные элементов, затронутых хранимой процедурой. При обнаружении любого конфликта хранимая процедура откат транзакции и создания исключения. Такой метод гарантирует, что операции записи хранимой процедуры применяются атомарным образом, то есть "все или ничего". Приложение получает сигнал о необходимости повторно применить обновления и повторить исходный запрос клиента.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о транзакциях базы данных и оптимистической блокировке вы можете получить в следующих статьях.

- [Работа с базами данных, контейнерами и элементами Azure Cosmos](databases-containers-items.md)
- [Уровни согласованности](consistency-levels.md)
- [Типы конфликтов и политики их устранения](conflict-resolution-policies.md)
- [Хранимые процедуры, триггеры и определяемые пользователем функции](stored-procedures-triggers-udfs.md)
