---
title: Транзакции базы данных и оптимистическая блокировка в Azure Cosmos DB
description: Эта статья содержит сведения о транзакциях базы данных и оптимистической блокировке в Azure Cosmos DB
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 12/04/2019
ms.reviewer: sngun
ms.openlocfilehash: d453bb4071c4a6972e01b8f7e90375181caf6d01
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74806530"
---
# <a name="transactions-and-optimistic-concurrency-control"></a>Управление транзакциями и оптимистической блокировкой

Транзакции базы данных обеспечивают безопасную и предсказуемую модель программирования для работы с одновременными изменениями данных. Традиционные реляционные базы данных, такие как S'L Server, позволяют записывать бизнес-логику с помощью сохраненных процедур и/или триггеров, отправлять ее на сервер для выполнения непосредственно внутри движка базы данных. С традиционными реляционными базами данных необходимо иметь дело с двумя различными языками программирования , такими (нетранзакционными) языками программирования приложений, как JavaScript, Python, C, Java и т.д., а также с транзакционным языком программирования (например, T-S'L), который осуществляется базой данных.

Ядро СУБД Azure Cosmos DB поддерживает транзакции с полной совместимостью с ACID (атомарность, согласованность, изоляция, устойчивость) и изоляцией моментального снимка. Все операции базы данных в рамках [логического раздела](partition-data.md) контейнера транзакционно выполняются в движке базы данных, которая размещается копией раздела. К ним относятся операции записи (обновление одного или нескольких элементов в логическом разделе) и операции чтения. В следующей таблице иллюстрируются различные типы операций и транзакций:

| **Операции**  | **Тип операции** | **Транзакция для одного или нескольких элементов** |
|---------|---------|---------|
| INSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| INSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| REPLACE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| REPLACE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| UPSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| UPSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| DELETE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| DELETE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение хранимой процедуры | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение процедуры слияния, инициируемое системой | запись | Транзакции для нескольких элементов |
| Удаление элементов, у которых истек срок жизни (TTL), инициируемое системой | запись | Транзакции для нескольких элементов |
| Чтение | Чтение | Транзакция для одного элемента |
| Канал изменений | Чтение | Транзакции для нескольких элементов |
| Чтение с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Запрос с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Выполнение определяемой пользователем функции в составе запроса с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |

## <a name="multi-item-transactions"></a>Транзакции для нескольких элементов

Azure Cosmos DB позволяет записывать [сохраненные процедуры, триггеры pre/post, пользовательские функции (UDF)](stored-procedures-triggers-udfs.md) и процедуры слияния в JavaScript. Ядро СУБД Azure Cosmos DB имеет встроенную поддержку выполнения JavaScript. Вы можете зарегистрировать в контейнере хранимые процедуры, предшествующие и последующие триггеры, определяемые пользователем функции и процедуры слияния, чтобы позднее выполнять их транзакционно в ядре СУБД Azure Cosmos. Создание логики приложения на JavaScript допускает естественное выражение потока управления, области видимости переменных, присвоения, а также интеграцию примитивов обработки исключений с транзакциями базы данных непосредственно на JavaScript.

Хранимые процедуры, триггеры, определяемые пользователем функции и процедуры слияния на JavaScript помещаются в контекстные транзакции ACID с изоляцией моментального снимка для всех элементов в логическом разделе. Если при выполнении такой транзакции код JavaScript создает исключение, то вся транзакция прерывается и откатывается к прежнему состоянию. Полученная модель программирования является простой, но эффективной. Разработчики JavaScript получают надежную модель программирования, сохраняя привычные языковые конструкции и библиотечные примитивы.

Возможность выполнить код JavaScript непосредственно в ядре СУБД повышает производительность операций над элементами контейнера в базе данных и обеспечивает поддержку транзакций. Кроме того, встроенная поддержка JSON и JavaScript в ядре СУБД Azure Cosmos устраняет несоответствия между системами типов в приложении и базе данных.

## <a name="optimistic-concurrency-control"></a>Управление оптимистическим параллелизмом

Оптимистическая блокировка позволяет предотвратить потери операций обновления и удаления. Для конфликтующих одновременных операций применяется обычная пессимистическая блокировка ядра СУБД, размещенного в том же логическом разделе, что и обрабатываемый элемент. Когда две параллельные операции пытаются обновить элемент в логическом разделе до последней версии, одна из них будет успешной, а вторая завершится ошибкой. Но если одна или обе из таких операций ранее считали старое значение обновляемого элемента, база данных не может проверить актуальность считанных значений для любой из конфликтующих операций. К счастью, эта ситуация может быть обнаружена с **помощью Optimistic Concurrency Control (OCC),** прежде чем позволить двум операциям войти в границу транзакций внутри движка базы данных. Оптимистическая блокировка защищает от случайной перезаписи данные, внесенные другими пользователями. Она также не позволит другим процессам случайно перезаписать ваши изменения.

Для одновременных обновлений элемента Azure Cosmos DB применяет оптимистическую блокировку на уровне протокола связи. База данных Azure Cosmos следит за тем, чтобы версия обновляемого (или удаляемого) элемента на стороне клиента точно совпадала с версией этого же элемента в контейнере Azure Cosmos. Это гарантирует защиту операций записи от случайного изменения чужими записями, и наоборот. В среде с несколькими пользователями оптимистическая блокировка не позволит вам случайно удалить или изменить элемент с неправильной версией. Это обеспечивает защиту от печально известных проблем "потерянного обновления" и "потерянного удаления".

Для каждого элемента в контейнере Azure Cosmos определено системное свойство `_etag`. Значение `_etag` создается и обновляется на сервере автоматически при каждом обновлении элемента. `_etag`может быть использован с `if-match` клиентом поставляется заголовок запроса, чтобы позволить серверу решить, может ли элемент может быть условно обновлен. Значение заголовка `if-match` соответствует значению `_etag` на сервере, затем элемент обновляется. Если значение заголовка `if-match` запроса больше не происходит, сервер отклоняет операцию с сообщением ответа "HTTP 412 Precondition". Затем клиент может повторно получить товар, чтобы приобрести текущую версию товара на сервере или `_etag` переопределить версию товара на сервере с собственным значением для элемента. Кроме того, `_etag` можно использовать `if-none-match` с заголовком, чтобы определить, является ли refetch ресурса не требуется.

Значение элемента `_etag` изменяется каждый раз, когда элемент обновляется. Для замены `if-match` операций элемента, должны быть четко выражены как часть вариантов запроса. Пример такого кода можно найти на [GitHub](https://github.com/Azure/azure-cosmos-dotnet-v3/blob/master/Microsoft.Azure.Cosmos.Samples/Usage/ItemManagement/Program.cs#L578-L674). `_etag`значения неявно проверяются для всех письменных элементов, затронутых сохраненной процедурой. При обнаружении какого-либо конфликта сохраненная процедура откатит транзакцию и выкинет исключение. Такой метод гарантирует, что операции записи хранимой процедуры применяются атомарным образом, то есть "все или ничего". Приложение получает сигнал о необходимости повторно применить обновления и повторить исходный запрос клиента.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о транзакциях базы данных и оптимистической блокировке вы можете получить в следующих статьях.

- [Работа с базами данных, контейнерами и элементами Azure Cosmos](databases-containers-items.md)
- [Уровни согласованности](consistency-levels.md)
- [Типы конфликтов и политики их устранения](conflict-resolution-policies.md)
- [Хранимые процедуры, триггеры и определяемые пользователем функции](stored-procedures-triggers-udfs.md)
