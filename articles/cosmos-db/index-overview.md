---
title: Индексирование в Azure Cosmos DB
description: Сведения об осуществлении индексации в Azure Cosmos DB.
author: ThomasWeiss
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 05/06/2019
ms.author: thweiss
ms.openlocfilehash: 44706e5ebe2442dcb45dfc45e2c322938cf7dca9
ms.sourcegitcommit: 0ae3139c7e2f9d27e8200ae02e6eed6f52aca476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65068656"
---
# <a name="indexing-in-azure-cosmos-db---overview"></a>Индексирование в Azure Cosmos DB — Обзор

Azure Cosmos DB — это база данных не используются схемы, которой можно перебирайте приложения без необходимости управлять схемами или индексами. По умолчанию Azure Cosmos DB автоматически индексирует каждое свойство для всех элементов в вашей [контейнера](databases-containers-items.md#azure-cosmos-containers) без необходимости определять любой схемы или настроить вторичные индексы.

Цель этой статьи — объяснить, как Azure Cosmos DB индексирует данные и использует индексы для повышения производительности запросов. Рекомендуется пройти через группу в этом разделе, прежде чем просмотреть способы настройки [политики индексирования](index-policy.md).

## <a name="from-items-to-trees"></a>Из элементов в деревья

Каждый раз, когда элемент хранится в контейнере, его содержимое является защищен как документ JSON, а затем преобразуется в дерево. Это означает, что каждое свойство этого элемента представляется как узел в дереве. Корневой узел псевдо создается в качестве родительской для всех свойств первого уровня элемента. Конечные узлы содержат фактические скалярные значения, переданные в элемент.

Например рассмотрим этот элемент:

    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 },
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }

Он может быть представлена следующее дерево:

![Предыдущий элемент, представить в виде дерева](./media/index-overview/item-as-tree.png)

Обратите внимание на то, как массивы кодируются в дереве: Каждая запись в массиве возвращает промежуточный узел, которому была присвоена индекс этого элемента в массиве (0, 1 и т.д.).

## <a name="from-trees-to-property-paths"></a>Из деревьев для пути к свойствам

Причина, почему Azure Cosmos DB в деревья для преобразования элементов является, поскольку она позволяет свойства, на которые ссылается их пути в пределах этих структур. Для получения пути для свойства, мы проходить по дереву от корневого узла к этому свойству и СЦЕПИТЬ метки каждого просматриваемый узла.

Ниже приведены расположения для каждого свойства из элемента примере описанные выше:

    /locations/0/country: "Germany"
    /locations/0/city: "Berlin"
    /locations/1/country: "France"
    /locations/1/city: "Paris"
    /headquarters/country: "Belgium"
    /headquarters/employees: 250
    /exports/0/city: "Moscow"
    /exports/1/city: "Athens"

При записи элемента, Azure Cosmos DB эффективно индексирует каждое свойство пути и его соответствующее значение.

## <a name="index-kinds"></a>Типы индекса

В настоящее время Azure Cosmos DB поддерживает два вида индексов:

**Диапазон** вид индекса используется для:

- запросов равенства: 

   ```sql SELECT * FROM container c WHERE c.property = 'value'```

- Запросы в диапазоне: 

   ```sql SELECT * FROM container c WHERE c.property > 'value'``` (работает для `>`, `<`, `>=`, `<=`, `!=`)

- `ORDER BY` запросы:

   ```sql SELECT * FROM container c ORDER BY c.property```

- `JOIN` запросы: 

   ```sql SELECT child FROM container c JOIN child IN c.properties WHERE child = 'value'```

Диапазонные индексы можно использовать в скалярных значений (строка или число).

**Пространственных** вид индекса используется для:

- геопространственные запросы для определения расстояния: 

   ```sql SELECT * FROM container c WHERE ST_DISTANCE(c.property, { "type": "Point", "coordinates": [0.0, 10.0] }) < 40```

- геопространственные в запросах: 

   ```sql SELECT * FROM container c WHERE ST_WITHIN(c.property, {"type": "Point", "coordinates": [0.0, 10.0] } })```

Пространственные индексы можно использовать на правильный формат [GeoJSON](geospatial.md) объектов. В настоящее время поддерживаются точки, объекты linestring и многоугольники.

**Составного** вид индекса используется для:

- `ORDER BY` запросы по нескольким свойствам: 

   ```sql SELECT * FROM container c ORDER BY c.firstName, c.lastName```

## <a name="querying-with-indexes"></a>Выполнение запросов с использованием индексов

Пути, извлеченные при индексировании данных, позволяют легко выполнять поиск индекса при обработке запроса. Сопоставляя `WHERE` предложение запроса с список индексированных путей, можно определить элементы, которые соответствуют предикату запроса очень быстро.

Например, рассмотрим следующий запрос: `SELECT location FROM location IN company.locations WHERE location.country = 'France'`. Предикат запроса (Фильтрация элементов, где любое расположение имеет «Франция», что его страны) будет соответствовать пути, они выделены красным цветом:

![Сопоставление в указанное расположение в дереве](./media/index-overview/matching-path.png)

> [!NOTE]
> `ORDER BY` Предложение, которое упорядочивает по одному свойству *всегда* должен диапазона индекса и завершится ошибкой, если путь, он ссылается на еще не настроен. Аналогичным образом, с несколькими `ORDER BY` запроса *всегда* должен составной индекс.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании вы найдете в следующих статьях.

- [Политика индексирования](index-policy.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
