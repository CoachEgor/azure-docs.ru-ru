---
title: Индексирование в Azure Cosmos DB
description: Поймите, как работает индексирование в Azure Cosmos DB, поддерживаются различные типы индексов, такие как диапазон, пространственный, составной индексы.
author: ThomasWeiss
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 10/11/2019
ms.author: thweiss
ms.openlocfilehash: 65186262095560d7ae54d32b218d1c01f1fb921d
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74873630"
---
# <a name="indexing-in-azure-cosmos-db---overview"></a>Индексирование в Azure Cosmos DB — обзор

Azure Cosmos DB — это схема-агностическая база данных, которая позволяет итерировать приложение без необходимости иметь дело со схемой или управлением индексами. По умолчанию Azure Cosmos DB автоматически индексирует каждое свойство для всех элементов в [контейнере](databases-containers-items.md#azure-cosmos-containers) без необходимости определять какие-либо схемы или настраивать вторичные индексы.

В статье описан способы индексирования данных в Azure Cosmos DB и использования индексов для повышения производительности запросов. Рекомендуется пройти через этот раздел, прежде чем изучать, как настроить [политику индексирования.](index-policy.md)

## <a name="from-items-to-trees"></a>От предметов до деревьев

Каждый раз, когда элемент хранится в контейнере, его содержимое проецируется как документ JSON, а затем преобразуется в представление дерева. Это означает, что каждое свойство этого элемента представлено как узл на дереве. Псевдокорневый узла создается как родитель для всех свойств элемента первого уровня. Узлы листа содержат фактические значения масштабирования, переносимые элементом.

В качестве примера рассмотрим этот пункт:

```json
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 },
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

Он будет представлен следующим деревом:

![Предыдущий элемент, представленный как дерево](./media/index-overview/item-as-tree.png)

Обратите внимание, как массивы кодируются в дереве: каждая запись в массиве получает промежуточный узл, помеченный индексом этой записи в массиве (0, 1 и т.д.).

## <a name="from-trees-to-property-paths"></a>От деревьев к имущественным дорожкам

Причина, по которой Azure Cosmos DB преобразует элементы в деревья, заключается в том, что он позволяет ссылаться на их пути в этих деревьях. Чтобы получить путь для свойства, мы можем пройти дерево от корневого узла к этому свойству, и concatenate этикетки каждого пройденного узла.

Вот пути для каждого свойства из приведенного выше элемента примера:

    /locations/0/country: "Germany"
    /locations/0/city: "Berlin"
    /locations/1/country: "France"
    /locations/1/city: "Paris"
    /headquarters/country: "Belgium"
    /headquarters/employees: 250
    /exports/0/city: "Moscow"
    /exports/1/city: "Athens"

Когда элемент написан, Azure Cosmos DB эффективно индексирует траекторию каждого свойства и его соответствующую ценность.

## <a name="index-kinds"></a>Типы индексов

Azure Cosmos DB в настоящее время поддерживает три вида индексов.

### <a name="range-index"></a>Индекс диапазона

**Диапазон** индекса основан на упорядоченной древесно-подобной структуре. Тип индекса диапазона используется для:

- Запросы о равенстве:

    ```sql
   SELECT * FROM container c WHERE c.property = 'value'
   ```

   ```sql
   SELECT * FROM c WHERE c.property IN ("value1", "value2", "value3")
   ```

   Равенство на элементе массива
   ```sql
    SELECT * FROM c WHERE ARRAY_CONTAINS(c.tags, "tag1”)
    ```

- Запросы диапазона:

   ```sql
   SELECT * FROM container c WHERE c.property > 'value'
   ```
  (работает `>`для `<` `>=`, `<=` `!=`, , )

- Проверка наличия объекта:

   ```sql
   SELECT * FROM c WHERE IS_DEFINED(c.property)
   ```

- Строка префикс совпадает (КЛЮЧЕВОе слово CONTAINS не будет использовать диапазон индекса):

   ```sql
   SELECT * FROM c WHERE STARTSWITH(c.property, "value")
   ```

- `ORDER BY`Запросов:

   ```sql
   SELECT * FROM container c ORDER BY c.property
   ```

- `JOIN`Запросов:

   ```sql
   SELECT child FROM container c JOIN child IN c.properties WHERE child = 'value'
   ```

Диапазон индексов может быть использован на значениях масштабирования (строка или число).

### <a name="spatial-index"></a>Пространственный индекс

**Пространственные** индексы позволяют эффективно запрашивать геопространственные объекты, такие как точки, линии, полигоны и мультиполигон. В этих запросах используются ST_DISTANCE, ST_WITHIN, ST_INTERSECTS ключевые слова. Ниже приведены некоторые примеры, которые используют пространственный индекс рода:

- Запросы геопространственного расстояния:

   ```sql
   SELECT * FROM container c WHERE ST_DISTANCE(c.property, { "type": "Point", "coordinates": [0.0, 10.0] }) < 40
   ```

- Геопространственный в запросах:

   ```sql
   SELECT * FROM container c WHERE ST_WITHIN(c.property, {"type": "Point", "coordinates": [0.0, 10.0] } })
   ```

- Геопространственные пересекающиеся запросы:

   ```sql
   SELECT * FROM c WHERE ST_INTERSECTS(c.property, { 'type':'Polygon', 'coordinates': [[ [31.8, -5], [32, -5], [31.8, -5] ]]  })  
   ```

Пространственные индексы могут быть использованы на правильно отформатированных объектах [GeoJSON.](geospatial.md) Очки, LineStrings, Полигоны и MultiPolygons в настоящее время поддерживаются.

### <a name="composite-indexes"></a>Композитные индексы

**Композитные** индексы повышают эффективность при выполнении операций на нескольких полях. Композитный тип индекса используется для:

- `ORDER BY`запросы по нескольким свойствам:

```sql
 SELECT * FROM container c ORDER BY c.property1, c.property2
```

- Запросы с фильтром и `ORDER BY`. Эти запросы могут использовать составной индекс, если `ORDER BY` свойство фильтра добавлено в положение.

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' ORDER BY c.property1, c.property2
```

- Запросы с фильтром на двух или более свойствах, где по крайней мере одно свойство является фильтром равенства

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' AND c.property2 > 'value'
```

До тех пор, пока один предикат фильтра использует на виде индекса, движок запроса будет оценивать его, прежде чем сканировать остальные. Например, если у вас есть запрос на`SELECT * FROM c WHERE c.firstName = "Andrew" and CONTAINS(c.lastName, "Liu")`

* Вышеупомянутый запрос будет сначала фильтровать для записей, где firstName и "Эндрю" с помощью индекса. Затем он проходит все первыеИмена - "Эндрю" записи через последующий конвейер для оценки предиката фильтра CONTAINS.

* Вы можете ускорить запросы и избежать полного сканирования контейнера при использовании функций, которые не используют индекс (например, CONTAINS) путем добавления дополнительных предикатов фильтра, которые используют индекс. Порядок положений фильтра не имеет значения. Движок запроса выяснит, какие предикаты являются более избирательными, и запустит запрос соответствующим образом.


## <a name="querying-with-indexes"></a>Выполнение запросов с использованием индексов

Пути, извлеченные при индексации данных, упрощают поиск индекса при обработке запроса. Сопоставляя `WHERE` положение запроса со списком индексированных путей, можно очень быстро определить элементы, соответствующие предикату запроса.

Например, рассмотрим следующий `SELECT location FROM location IN company.locations WHERE location.country = 'France'`запрос: . Предикат запроса (фильтрация на элементы, где любое место имеет "Франция", как его страна) будет соответствовать пути выделены красным цветом ниже:

![Соответствие определенного пути внутри дерева](./media/index-overview/matching-path.png)

> [!NOTE]
> Положение `ORDER BY` о том, что заказы по одному свойству *всегда* нуждается в индексе диапазона и не сбудутся, если на путь, на который он ссылается, не будет. Аналогичным образом, запрос, `ORDER BY` который заказывает по нескольким свойствам, *всегда* требует составного индекса.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании вы найдете в следующих статьях.

- [Политика индексирования](index-policy.md)
- [Как управлять политикой индексации](how-to-manage-indexing-policy.md)
