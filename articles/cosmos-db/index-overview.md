---
title: Индексирование в Azure Cosmos DB
description: Узнайте, как работает индексирование в Azure Cosmos DB и поддерживаются различные типы индексов, такие как диапазоны, пространственные и составные индексы.
author: timsander1
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 05/21/2020
ms.author: tisande
ms.openlocfilehash: 44a51972e459f64f44a791ef1cf40825dddedf91
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2020
ms.locfileid: "85798159"
---
# <a name="indexing-in-azure-cosmos-db---overview"></a>Индексирование в Azure Cosmos DB — обзор

Azure Cosmos DB — это база данных без использования схем, которая позволяет выполнять итерацию приложения, не отвлекаясь на управление схемами или индексами. По умолчанию Azure Cosmos DB автоматически индексирует каждое свойство всех элементов в [контейнере](databases-containers-items.md#azure-cosmos-containers). Разработчикам не нужно определять схемы или настраивать вторичные индексы.

В статье описан способы индексирования данных в Azure Cosmos DB и использования индексов для повышения производительности запросов. Мы рекомендуем ознакомиться с ней перед изучением процедуры настройки [политик индексирования](index-policy.md).

## <a name="from-items-to-trees"></a>От элементов к деревьям

Каждый раз, когда элемент сохраняется в контейнере, его содержимое проецируется как документ JSON, а затем преобразуется в представление в виде дерева. Это означает, что каждое свойство этого элемента представлено в виде узла дерева. Псевдоузел корня создается как родительский элемент для всех свойств элемента первого уровня. Листовые узлы содержат фактические скалярные значения, перенесенные элементом.

Рассмотрим этот элемент в качестве примера:

```json
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 },
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

Он будет представлен в виде следующего дерева:

:::image type="content" source="./media/index-overview/item-as-tree.png" alt-text="Предыдущий элемент, представленный в виде дерева" border="false":::

Обратите внимание, как массивы кодируются в дереве: каждая запись в массиве получает промежуточный узел с меткой индекса этой записи в массиве (0, 1 и т. д.).

## <a name="from-trees-to-property-paths"></a>От деревьев к путям к свойствам

Причина, по которой Azure Cosmos DB преобразует элементы в деревья, заключается в том, что это позволяет ссылаться на свойства по путям в этих деревьях. Чтобы получить путь к свойству, мы можем перемещаться по дереву с корневого узла к этому свойстве и объединять метки каждого пройденного узла.

Ниже приведены пути для каждого свойства из примера элемента, описанного выше.

- /Locations/0/Country: "Германия"
- /Locations/0/City: "Берлин"
- /Locations/1/Country: "Франция"
- /Locations/1/City: "Париж"
- /хеадкуартерс/Каунтри: "Бельгия"
- /хеадкуартерс/емплойис: 250
- /EXPORTS/0/City: Москва
- /EXPORTS/1/City: «Афины»

При записи элемента Azure Cosmos DB эффективно индексирует путь каждого свойства и соответствующее ему значение.

## <a name="index-kinds"></a>Типы индексов

В настоящее время Azure Cosmos DB поддерживает три типа индексов.

### <a name="range-index"></a>Индекс диапазона

Индекс **диапазона** основан на упорядоченной древовидной структуре. Индекс диапазона используется в следующих случаях.

- Запросы на равенство:

    ```sql
   SELECT * FROM container c WHERE c.property = 'value'
   ```

   ```sql
   SELECT * FROM c WHERE c.property IN ("value1", "value2", "value3")
   ```

   совпадение для элемента массива
   ```sql
    SELECT * FROM c WHERE ARRAY_CONTAINS(c.tags, "tag1")
    ```

- Запросы к диапазону:

   ```sql
   SELECT * FROM container c WHERE c.property > 'value'
   ```
  (для `>`, `<`, `>=`, `<=`, `!=`)

- Проверка наличия свойства:

   ```sql
   SELECT * FROM c WHERE IS_DEFINED(c.property)
   ```

- Строковые системные функции:

   ```sql
   SELECT * FROM c WHERE CONTAINS(c.property, "value")
   ```

   ```sql
   SELECT * FROM c WHERE STRINGEQUALS(c.property, "value")
   ```

- Запросы `ORDER BY`:

   ```sql
   SELECT * FROM container c ORDER BY c.property
   ```

- Запросы `JOIN`:

   ```sql
   SELECT child FROM container c JOIN child IN c.properties WHERE child = 'value'
   ```

Индексы диапазона можно использовать для скалярных значений (строка или число).

### <a name="spatial-index"></a>Пространственный индекс

**Пространственные** индексы позволяют выполнять эффективные запросы к геопространственным объектам, таким как точки, линии и многоугольники. В этих запросах используются ключевые слова ST_DISTANCE, ST_WITHIN и ST_INTERSECTS. Ниже приведены примеры, где используется пространственный индекс.

- Геопространственные запросы расстояний:

   ```sql
   SELECT * FROM container c WHERE ST_DISTANCE(c.property, { "type": "Point", "coordinates": [0.0, 10.0] }) < 40
   ```

- Геопространственные запросы включения:

   ```sql
   SELECT * FROM container c WHERE ST_WITHIN(c.property, {"type": "Point", "coordinates": [0.0, 10.0] } })
   ```

- Геопространственные запросы пересечения:

   ```sql
   SELECT * FROM c WHERE ST_INTERSECTS(c.property, { 'type':'Polygon', 'coordinates': [[ [31.8, -5], [32, -5], [31.8, -5] ]]  })  
   ```

Пространственные индексы можно использовать для правильно отформатированных объектов [GeoJSON](geospatial.md). В настоящее время поддерживаются Points, LineStrings, Polygons и MultiPolygons.

### <a name="composite-indexes"></a>Составные индексы

**Составные индексы** увеличивают эффективность выполнения операций над несколькими полями. Составной индекс используется в следующих случаях.

- Запросы `ORDER BY` к нескольким свойствам:

```sql
 SELECT * FROM container c ORDER BY c.property1, c.property2
```

- Запросы с фильтром и `ORDER BY`. Эти запросы могут использовать составной индекс, если свойство фильтра добавлено в предложение `ORDER BY`.

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' ORDER BY c.property1, c.property2
```

- Запросы с фильтром для двух или более свойств, в которых по крайней мере одно свойство является фильтром проверки на равенство

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' AND c.property2 > 'value'
```

Если один предикат фильтра использует один из типов индексов, обработчик запросов будет оценивать его перед проверкой остальных. Например, вас есть SQL-запрос `SELECT * FROM c WHERE c.firstName = "Andrew" and CONTAINS(c.lastName, "Liu")`

* Приведенный выше запрос сначала фильтрует записи со значением firstName = "Andrew", используя индекс. Затем он передает все записи firstName = "Andrew" через последующий конвейер для вычисления предиката CONTAINS.

* Вы можете ускорить запросы и избежать полной проверки при использовании функций, которые не используют индекс (например, CONTAINS), добавив дополнительные предикаты фильтра, которые используют этот индекс. Порядок предложений фильтра не важен. Обработчик запросов позволяет определить, какие предикаты являются более избирательными, и выполнить запрос соответствующим образом.


## <a name="querying-with-indexes"></a>Выполнение запросов с использованием индексов

Пути, извлеченные при индексировании данных, упрощают поиск индекса при обработке запроса. Сопоставляя предложение `WHERE` запроса со списком индексированных путей, можно очень быстро выявить элементы, которые соответствуют предикату запроса.

Например, рассмотрим следующий запрос: `SELECT location FROM location IN company.locations WHERE location.country = 'France'`. Предикат запроса (фильтрация по элементам, где любое расположение имеет значение "France" в качестве страны или региона) соответствует пути, выделенному красным цветом:

:::image type="content" source="./media/index-overview/matching-path.png" alt-text="Сопоставление определенного пути в дереве" border="false":::

> [!NOTE]
> Предложение `ORDER BY`, которое упорядочивается по одному свойству, *всегда* требует индекс диапазона, и если у пути, на который оно ссылается, его нет, оно завершится ошибкой. Аналогичным образом запросу `ORDER BY`, который упорядочивается по нескольким свойствам, *всегда* требуется составной индекс.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании вы найдете в следующих статьях.

- [Политика индексирования](index-policy.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
