---
title: Индексирование в Azure Cosmos DB
description: Сведения об осуществлении индексации в Azure Cosmos DB.
author: ThomasWeiss
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 10/11/2019
ms.author: thweiss
ms.openlocfilehash: d679208914eb7d1f74bfaec77fbcff196909a2f4
ms.sourcegitcommit: 8b44498b922f7d7d34e4de7189b3ad5a9ba1488b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2019
ms.locfileid: "72299780"
---
# <a name="indexing-in-azure-cosmos-db---overview"></a>Индексирование в Azure Cosmos DB — обзор

Azure Cosmos DB — это независимая от схемы база данных, позволяющая выполнять итерацию по приложению без необходимости управлять схемой или индексами. По умолчанию Azure Cosmos DB автоматически индексирует все свойства для всех элементов в [контейнере](databases-containers-items.md#azure-cosmos-containers) без необходимости определения какой-либо схемы или настройки вторичных индексов.

Цель этой статьи — объяснить, как Azure Cosmos DB индексирует данные и как они используют индексы для повышения производительности запросов. Перед изучением процедуры настройки [политик индексирования](index-policy.md)рекомендуется пройти по этому разделу.

## <a name="from-items-to-trees"></a>От элементов к деревьям

Каждый раз, когда элемент хранится в контейнере, его содержимое проецируется как документ JSON, а затем преобразуется в представление в виде дерева. Это означает, что каждое свойство этого элемента представлено в виде узла дерева. Узел псевдокласса создается как родительский для всех свойств элемента первого уровня. Конечные узлы содержат фактические скалярные значения, перенесенные элементом.

В качестве примера рассмотрим этот элемент:

```json
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 },
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

Оно будет представлено в следующем дереве:

![Предыдущий элемент представлен в виде дерева](./media/index-overview/item-as-tree.png)

Обратите внимание, как массивы кодируются в дереве: Каждая запись в массиве получает промежуточный узел с меткой индекса этой записи в массиве (0, 1 и т. д.).

## <a name="from-trees-to-property-paths"></a>Из деревьев в пути к свойствам

Причина, по которой Azure Cosmos DB преобразует элементы в деревья, заключается в том, что она позволяет ссылаться на свойства по путям в этих деревьях. Чтобы получить путь к свойству, мы можем перемещаться по дереву с корневого узла на это свойство и объединять метки каждого обходного узла.

Ниже приведены пути для каждого свойства из примера элемента, описанного выше.

    /locations/0/country: "Germany"
    /locations/0/city: "Berlin"
    /locations/1/country: "France"
    /locations/1/city: "Paris"
    /headquarters/country: "Belgium"
    /headquarters/employees: 250
    /exports/0/city: "Moscow"
    /exports/1/city: "Athens"

При записи элемента Azure Cosmos DB эффективно индексирует путь каждого свойства и соответствующее ему значение.

## <a name="index-kinds"></a>Типы индексов

В настоящее время Azure Cosmos DB поддерживает три типа индексов.

### <a name="range-index"></a>Индекс диапазона

Индекс **диапазона** основан на упорядоченной древовидно-подобной структуре. Тип индекса Range используется для:

- Запросы на равенство:

    ```sql
   SELECT * FROM container c WHERE c.property = 'value'
   ```

   ```sql
   SELECT * FROM c WHERE c.property IN ("value1", "value2", "value3")
   ```

   Совпадение равенства для элемента массива
   ```sql
    SELECT * FROM c WHERE ARRAY_CONTAINS(c.tags, "tag1”)
    ```

- Запросы к диапазону:

   ```sql
   SELECT * FROM container c WHERE c.property > 'value'
   ```
  (работает для `>`, `<`, `>=`, `<=`, `!=`)

- Проверка наличия свойства:

   ```sql
   SELECT * FROM c WHERE IS_DEFINED(c.property)
   ```

- Префикс строки совпадает (содержит ключевое слово, не использующее индекс диапазона):

   ```sql
   SELECT * FROM c WHERE STARTSWITH(c.property, "value")
   ```

- запросы `ORDER BY`:

   ```sql
   SELECT * FROM container c ORDER BY c.property
   ```

- запросы `JOIN`:

   ```sql
   SELECT child FROM container c JOIN child IN c.properties WHERE child = 'value'
   ```

Индексы диапазона можно использовать в скалярных значениях (строка или число).

### <a name="spatial-index"></a>Пространственный индекс

**Пространственные** индексы позволяют выполнять эффективные запросы к геопространственных объектам, таким как точки, линии, многоугольники и многоугольные. В этих запросах используются ключевые слова ST_DISTANCE, ST_WITHIN и ST_INTERSECTS. Ниже приведены некоторые примеры, в которых используется тип пространственного индекса.

- Запросы геопространственных расстояний:

   ```sql
   SELECT * FROM container c WHERE ST_DISTANCE(c.property, { "type": "Point", "coordinates": [0.0, 10.0] }) < 40
   ```

- Геопространственные в запросах:

   ```sql
   SELECT * FROM container c WHERE ST_WITHIN(c.property, {"type": "Point", "coordinates": [0.0, 10.0] } })
   ```

- Запросы геопространственных пересечением:

   ```sql
   SELECT * FROM c WHERE ST_INTERSECTS(c.property, { 'type':'Polygon', 'coordinates': [[ [31.8, -5], [32, -5], [31.8, -5] ]]  })  
   ```

Пространственные индексы можно использовать в правильно отформатированных геообъектах [JSON](geospatial.md) . В настоящее время поддерживаются точки, LineString, многоугольники и многомногоугольники.

### <a name="composite-indexes"></a>Составные индексы

**Составные** индексы увеличивают эффективность при выполнении операций над несколькими полями. Тип составного индекса используется для:

- `ORDER BY` запросов к нескольким свойствам:

```sql
 SELECT * FROM container c ORDER BY c.property1, c.property2
```

- Запросы с фильтром и `ORDER BY`. Эти запросы могут использовать составной индекс, если свойство Filter Добавлено в предложение `ORDER BY`.

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' ORDER BY c.property1, c.property2
```

- Запросы с фильтром для двух или более свойств, в которых по крайней мере одно свойство является фильтром проверки на равенство

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' AND c.property2 > 'value'
```

До тех пор, пока один предикат фильтра использует для типа индекса, обработчик запросов оценивает это перед продолжением поиска. Например, если у вас есть запрос SQL, например `SELECT * FROM c WHERE c.firstName = "Andrew" and CONTAINS(c.lastName, "Liu")`

* Приведенный выше запрос сначала фильтрует записи, где firstName = "Эндрю", с помощью индекса. Затем он передает все записи firstName = "Эндрю" через последующий конвейер для вычисления предиката CONTAINS.

* Вы можете ускорить запросы и избежать полных просмотров контейнеров при использовании функций, которые не используют индекс (например, CONTAINS), добавив дополнительные предикаты фильтра, которые используют этот индекс. Порядок предложений фильтра не важен. Обработчик запросов позволяет определить, какие Предикаты являются более селективными, и выполнить запрос соответствующим образом.


## <a name="querying-with-indexes"></a>Выполнение запросов с использованием индексов

Пути, извлеченные при индексировании данных, упрощают поиск индекса при обработке запроса. Сопоставляя предложение `WHERE` запроса со списком индексированных путей, можно очень быстро выявить элементы, которые соответствуют предикату запроса.

Например, рассмотрим следующий запрос: `SELECT location FROM location IN company.locations WHERE location.country = 'France'`. Предикат запроса (фильтрация по элементам, где любое расположение имеет значение "Франция" в качестве страны), соответствует пути, выделенному красным цветом:

![Сопоставление определенного пути в дереве](./media/index-overview/matching-path.png)

> [!NOTE]
> Предложение `ORDER BY`, которое упорядочивается по отдельному свойству, *всегда* нуждается в индексе диапазона и завершится ошибкой, если путь, на который он ссылается, не имеет такого значения. Аналогично, запрос `ORDER BY`, который упорядочивается по нескольким свойствам, *всегда* должен иметь составной индекс.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения об индексировании вы найдете в следующих статьях.

- [Политика индексирования](index-policy.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
