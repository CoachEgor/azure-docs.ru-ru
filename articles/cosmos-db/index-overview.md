---
title: Индексирование в Azure Cosmos DB
description: Сведения об осуществлении индексации в Azure Cosmos DB.
author: ThomasWeiss
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 09/10/2019
ms.author: thweiss
ms.openlocfilehash: 4d961f8635a52a09011543b793ce8a87eaa4ea9e
ms.sourcegitcommit: 083aa7cc8fc958fc75365462aed542f1b5409623
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/11/2019
ms.locfileid: "70914193"
---
# <a name="indexing-in-azure-cosmos-db---overview"></a>Индексирование в Azure Cosmos DB — обзор

Azure Cosmos DB — это независимая от схемы база данных, позволяющая выполнять итерацию по приложению без необходимости управлять схемой или индексами. По умолчанию Azure Cosmos DB автоматически индексирует все свойства для всех элементов в [контейнере](databases-containers-items.md#azure-cosmos-containers) без необходимости определения какой-либо схемы или настройки вторичных индексов.

Цель этой статьи — объяснить, как Azure Cosmos DB индексирует данные и как они используют индексы для повышения производительности запросов. Перед изучением процедуры настройки [политик индексирования](index-policy.md)рекомендуется пройти по этому разделу.

## <a name="from-items-to-trees"></a>От элементов к деревьям

Каждый раз, когда элемент хранится в контейнере, его содержимое проецируется как документ JSON, а затем преобразуется в представление в виде дерева. Это означает, что каждое свойство этого элемента представлено в виде узла дерева. Узел псевдокласса создается как родительский для всех свойств элемента первого уровня. Конечные узлы содержат фактические скалярные значения, перенесенные элементом.

В качестве примера рассмотрим этот элемент:

```json
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 },
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

Оно будет представлено в следующем дереве:

![Предыдущий элемент представлен в виде дерева](./media/index-overview/item-as-tree.png)

Обратите внимание, как массивы кодируются в дереве: Каждая запись в массиве получает промежуточный узел с меткой индекса этой записи в массиве (0, 1 и т. д.).

## <a name="from-trees-to-property-paths"></a>Из деревьев в пути к свойствам

Причина, по которой Azure Cosmos DB преобразует элементы в деревья, заключается в том, что она позволяет ссылаться на свойства по путям в этих деревьях. Чтобы получить путь к свойству, мы можем перемещаться по дереву с корневого узла на это свойство и объединять метки каждого обходного узла.

Ниже приведены пути для каждого свойства из примера элемента, описанного выше.

    /locations/0/country: "Germany"
    /locations/0/city: "Berlin"
    /locations/1/country: "France"
    /locations/1/city: "Paris"
    /headquarters/country: "Belgium"
    /headquarters/employees: 250
    /exports/0/city: "Moscow"
    /exports/1/city: "Athens"

При записи элемента Azure Cosmos DB эффективно индексирует путь каждого свойства и соответствующее ему значение.

## <a name="index-kinds"></a>Типы индексов

В настоящее время Azure Cosmos DB поддерживает три типа индексов:

Тип индекса **Range** используется для:

- Запросы на равенство:

    ```sql
   SELECT * FROM container c WHERE c.property = 'value'
   ```

- Запросы к диапазону:

   ```sql
   SELECT * FROM container c WHERE c.property > 'value'
   ```
  (работает для `>`, `<`, `>=` ,`<=`, )`!=`

- `ORDER BY`запроса

   ```sql 
   SELECT * FROM container c ORDER BY c.property
   ```

- `JOIN`запроса

   ```sql
   SELECT child FROM container c JOIN child IN c.properties WHERE child = 'value'
   ```

Индексы диапазона можно использовать в скалярных значениях (строка или число).

Тип **пространственного** индекса используется для:

- Запросы геопространственных расстояний: 

   ```sql
   SELECT * FROM container c WHERE ST_DISTANCE(c.property, { "type": "Point", "coordinates": [0.0, 10.0] }) < 40
   ```

- Геопространственные в запросах: 

   ```sql
   SELECT * FROM container c WHERE ST_WITHIN(c.property, {"type": "Point", "coordinates": [0.0, 10.0] } })
   ```

Пространственные индексы можно использовать в правильно отформатированных геообъектах [JSON](geospatial.md) . В настоящее время поддерживаются точки, LineString, многоугольники и многомногоугольники.

Тип **составного** индекса используется для:

- `ORDER BY`запросы к нескольким свойствам:

```sql
 SELECT * FROM container c ORDER BY c.property1, c.property2
```

- Запросы с фильтром и `ORDER BY`. Эти запросы могут использовать составной индекс, если свойство Filter Добавлено в `ORDER BY` предложение.

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' ORDER BY c.property1, c.property2
```

- Запросы с фильтром для двух или более свойств, в которых по крайней мере одно свойство является фильтром проверки на равенство

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' AND c.property2 > 'value'
```

## <a name="querying-with-indexes"></a>Выполнение запросов с использованием индексов

Пути, извлеченные при индексировании данных, упрощают поиск индекса при обработке запроса. Сопоставляя `WHERE` предложение запроса со списком индексированных путей, можно очень быстро выявить элементы, которые соответствуют предикату запроса.

Например, рассмотрим следующий запрос: `SELECT location FROM location IN company.locations WHERE location.country = 'France'`. Предикат запроса (фильтрация по элементам, где любое расположение имеет значение "Франция" в качестве страны), соответствует пути, выделенному красным цветом:

![Сопоставление определенного пути в дереве](./media/index-overview/matching-path.png)

> [!NOTE]
> Предложение, которое упорядочивается по отдельному свойству, всегда нуждается в индексе диапазона и завершается ошибкой, если путь, на который он ссылается, не имеет такого значения. `ORDER BY` Аналогичным образом `ORDER BY` , запрос, который упорядочивается по нескольким свойствам, *всегда* должен иметь составной индекс.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения об индексировании вы найдете в следующих статьях.

- [Политика индексирования](index-policy.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
