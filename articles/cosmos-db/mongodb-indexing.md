---
title: Индексирование в API Azure Cosmos DB для MongoDB
description: Обзор возможностей индексирования в API Azure Cosmos DB для MongoDB.
ms.service: cosmos-db
ms.subservice: cosmosdb-mongo
ms.devlang: nodejs
ms.topic: conceptual
ms.date: 12/26/2018
author: sivethe
ms.author: sivethe
ms.openlocfilehash: e51e96c0c553bcf37284878cab11f3ec592ddd05
ms.sourcegitcommit: 8074f482fcd1f61442b3b8101f153adb52cf35c9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2019
ms.locfileid: "72753378"
---
# <a name="indexing-using-azure-cosmos-dbs-api-for-mongodb"></a>Индексирование с помощью API Azure Cosmos DB для MongoDB

API Azure Cosmos DB для MongoDB использует возможности автоматического управления индексами Cosmos DB. В результате у пользователей появляется доступ к стандартным политикам индексации Cosmos DB. Таким образом, если индексы не были определены пользователем и ни один индекс не был удален, тогда все поля будут автоматически проиндексированы по умолчанию в момент вставки в коллекцию. В большинстве случаев рекомендуется использовать набор политик индексирования по умолчанию, установленный в учетной записи.

## <a name="indexing-for-version-36"></a>Индексирование для версии 3,6

Учетные записи, обслуживающие протокол проводной версии 3,6, предоставляют политику индексирования по умолчанию, отличную от политики более ранних версий. По умолчанию индексируется только поле _id. Чтобы индексировать дополнительные поля, пользователь должен применить команды управления индексами MongoDB. Чтобы применить сортировку к запросу, в настоящее время необходимо создать индекс для полей, используемых в операции сортировки.

### <a name="dropping-the-default-indexes-36"></a>Удаление индексов по умолчанию (3,6)

Для учетных записей, обслуживающих протокол связи версии 3,6, единственным индексом по умолчанию является _id, который не может быть удален.

### <a name="creating-a-compound-index-36"></a>Создание составного индекса (3,6)

Истинные составные индексы поддерживаются для учетных записей, использующих протокол Wire 3,6. Следующая команда создаст составной индекс для полей "a" и "b": `db.coll.createIndex({a:1,b:1})`

Составные индексы можно использовать для эффективной сортировки нескольких полей одновременно, например: `db.coll.find().sort({a:1,b:1})`

## <a name="indexing-for-version-32"></a>Индексирование для версии 3,2

### <a name="dropping-the-default-indexes-32"></a>Удаление индексов по умолчанию (3,2)

Можно использовать следующую команду для удаления стандартных индексов коллекции ```coll```:

```JavaScript
> db.coll.dropIndexes()
{ "_t" : "DropIndexesResponse", "ok" : 1, "nIndexesWas" : 3 }
```

### <a name="creating-a-compound-index-32"></a>Создание составного индекса (3,2)

Составные индексы содержат ссылки на множество полей документа. Логически это эквивалентно созданию нескольких отдельных индексов для каждого поля. Чтобы воспользоваться преимуществами оптимизации, предоставляемыми технологиями индексирования Cosmos DB, рекомендуется создать несколько отдельных индексов вместо одного (неуникального) составного индекса.

## <a name="common-indexing-operations"></a>Общие операции индексирования

Следующие операции являются общими для обоих учетных записей, обслуживающих протоколы сети 3,6 и учетных записей, обслуживающих более ранние версии протокола проводной сети. 

## <a name="creating-unique-indexes"></a>Создание уникальных индексов

[Уникальные индексы](unique-keys.md) позволяют гарантировать, что никакие два или больше документов не будут содержать одинаковые значения для индексированных полей.

>[!Important]
> В настоящее время уникальные индексы можно создавать только в том случае, если коллекция пуста (не содержит документов).

Следующая команда создает уникальный индекс для поля "student_id":

```shell
globaldb:PRIMARY> db.coll.createIndex( { "student_id" : 1 }, {unique:true} )
{
        "_t" : "CreateIndexesResponse",
        "ok" : 1,
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 4
}
```

Для сегментированных коллекций при работе с MongoDB создание уникального индекса требует наличия ключа секции (раздела). Иными словами, все уникальные индексы для сегментированной коллекции — это составные индексы, где одно из полей является ключом раздела.

Следующие команды создают сегментированную коллекцию ```coll``` (ключ сегмента — ```university```) с уникальным индексом для полей "student_id" и "university":

```shell
globaldb:PRIMARY> db.runCommand({shardCollection: db.coll._fullName, key: { university: "hashed"}});
{
        "_t" : "ShardCollectionResponse",
        "ok" : 1,
        "collectionsharded" : "test.coll"
}
globaldb:PRIMARY> db.coll.createIndex( { "student_id" : 1, "university" : 1 }, {unique:true})
{
        "_t" : "CreateIndexesResponse",
        "ok" : 1,
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 3,
        "numIndexesAfter" : 4
}
```

Если в приведенном выше примере пропустить предложение ```"university":1```, будет возвращено следующее сообщение об ошибке:

```"cannot create unique index over {student_id : 1.0} with shard key pattern { university : 1.0 }"```

## <a name="ttl-indexes"></a>Индексы срока жизни

Чтобы установить срок действия документа в определенной коллекции, нужно создать [индекс срока жизни](../cosmos-db/time-to-live.md). Это индекс для поля _ts со значением "expireAfterSeconds".

Пример:

```JavaScript
globaldb:PRIMARY> db.coll.createIndex({"_ts":1}, {expireAfterSeconds: 10})
```

Предыдущая команда приведет к удалению всех документов коллекции ```db.coll```, которые не менялись последние 10 секунд.

> [!NOTE]
> **_ts** является специфическим полем Cosmos DB и не доступно клиентам MongoDB. Это зарезервированное (системное) свойство, содержащее метку времени последнего изменения документа.

## <a name="migrating-collections-with-indexes"></a>Перемещение коллекций с индексами

В настоящее время создание уникальных индексов возможно только в том случае, если коллекция не содержит документов. Популярные средства перемещения MongoDB пытаются создавать уникальные индексы после импорта данных. Чтобы обойти эту ошибку, рекомендуется, чтобы пользователи вручную создали соответствующие коллекции и уникальные индексы, вместо того чтобы разрешать средство миграции (для ```mongorestore``` это поведение достигается с помощью флага `--noIndexRestore` в командной строке).

## <a name="next-steps"></a>Дальнейшие действия

* [Индексирование в Azure Cosmos DB](../cosmos-db/index-policy.md)
* [Срок жизни для данных Azure Cosmos DB](../cosmos-db/time-to-live.md)
