---
title: Индексирование в API Azure Cosmos DB для MongoDB
description: Обзор возможностей индексирования в API Azure Cosmos DB для MongoDB.
ms.service: cosmos-db
ms.subservice: cosmosdb-mongo
ms.devlang: nodejs
ms.topic: conceptual
ms.date: 12/26/2018
author: sivethe
ms.author: sivethe
ms.openlocfilehash: c8879884cf3d882e6a6b441244ed139072bedeeb
ms.sourcegitcommit: f0f73c51441aeb04a5c21a6e3205b7f520f8b0e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2020
ms.locfileid: "77029475"
---
# <a name="indexing-using-azure-cosmos-dbs-api-for-mongodb"></a>Индексирование с помощью API Azure Cosmos DB для MongoDB

API Azure Cosmos DB для MongoDB использует возможности автоматического управления индексами Cosmos DB. В результате у пользователей появляется доступ к стандартным политикам индексации Cosmos DB. Таким образом, если индексы не были определены пользователем и ни один индекс не был удален, тогда все поля будут автоматически проиндексированы по умолчанию в момент вставки в коллекцию. В большинстве случаев рекомендуется использовать набор политик индексирования по умолчанию, установленный в учетной записи.

## <a name="indexing-for-version-36"></a>Индексирование для версии 3,6

Учетные записи, обслуживающие протокол проводной версии 3,6, предоставляют политику индексирования по умолчанию, отличную от политики более ранних версий. По умолчанию индексируется только поле _id. Чтобы индексировать дополнительные поля, пользователь должен применить команды управления индексами MongoDB. Чтобы применить сортировку к запросу, в настоящее время необходимо создать индекс для полей, используемых в операции сортировки.

### <a name="dropping-the-default-indexes-36"></a>Удаление индексов по умолчанию (3,6)

Для учетных записей, обслуживающих протокол связи версии 3,6, единственным индексом по умолчанию является _id, который не может быть удален.

### <a name="creating-a-compound-index-36"></a>Создание составного индекса (3,6)

Истинные составные индексы поддерживаются для учетных записей, использующих протокол Wire 3,6. Следующая команда создаст составной индекс для полей "a" и "b": `db.coll.createIndex({a:1,b:1})`

Составные индексы можно использовать для эффективной сортировки нескольких полей одновременно, например: `db.coll.find().sort({a:1,b:1})`

### <a name="track-the-index-progress"></a>Отслеживать ход выполнения индекса

Версия 3,6 API Azure Cosmos DB для учетных записей MongoDB поддерживает команду `currentOp()` для отслеживания хода выполнения индекса в экземпляре базы данных. Эта команда возвращает документ, содержащий сведения о выполняемых операциях в экземпляре базы данных. Команда `currentOp` используется для отслеживания всех выполняемых операций в машинном MongoDB, в то время как в API Azure Cosmos DB для MongoDB эта команда поддерживает только отслеживание операций с индексами.

Ниже приведены некоторые примеры, демонстрирующие использование команды `currentOp` для отслеживания хода выполнения индекса.

• Получение сведений о ходе выполнения индекса для коллекции:

   ```shell
   db.currentOp({"command.createIndexes": <collectionName>, "command.$db": <databaseName>})
   ```

• Получение индекса для всех коллекций в базе данных:

  ```shell
  db.currentOp({"command.$db": <databaseName>})
  ```

• Получение индекса для всех баз данных и коллекций в учетной записи Azure Cosmos:

  ```shell
  db.currentOp({"command.createIndexes": { $exists : true } })
  ```

Сведения о ходе выполнения индекса содержат процент хода выполнения текущей операции с индексами. В следующем примере показан формат выходного документа для различных этапов выполнения индекса.

1. Если операция с индексами для коллекции "foo" и базы данных "Bar", в которой имеется 60% index, будет иметь следующий выходной документ. в `Inprog[0].progress.total` в качестве целевого завершения отображается 100.

   ```json
   {
        "inprog" : [
        {
                ………………...
                "command" : {
                        "createIndexes" : foo
                        "indexes" :[ ],
                        "$db" : bar
                },
                "msg" : "Index Build (background) Index Build (background): 60 %",
                "progress" : {
                        "done" : 60,
                        "total" : 100
                },
                …………..…..
        }
        ],
        "ok" : 1
   }
   ```

2. Для операции с индексами, только что запущенной для коллекции "foo" и "линейчатой" базы данных, выходной документ может отображать состояние "0%", пока не достигнет измеряемого уровня.

   ```json
   {
        "inprog" : [
        {
                ………………...
                "command" : {
                        "createIndexes" : foo
                        "indexes" :[ ],
                        "$db" : bar
                },
                "msg" : "Index Build (background) Index Build (background): 0 %",
                "progress" : {
                        "done" : 0,
                        "total" : 100
                },
                …………..…..
        }
        ],
       "ok" : 1
   }
   ```

3. После завершения операции с индексами в выходных документах отображаются пустые операции со сведениями о состоянии.

   ```json
   {
      "inprog" : [],
      "ok" : 1
   }
   ```

## <a name="indexing-for-version-32"></a>Индексирование для версии 3,2

### <a name="dropping-the-default-indexes-32"></a>Удаление индексов по умолчанию (3,2)

Можно использовать следующую команду для удаления стандартных индексов коллекции ```coll```:

```JavaScript
> db.coll.dropIndexes()
{ "_t" : "DropIndexesResponse", "ok" : 1, "nIndexesWas" : 3 }
```

### <a name="creating-a-compound-index-32"></a>Создание составного индекса (3,2)

Составные индексы содержат ссылки на множество полей документа. Логически это эквивалентно созданию нескольких отдельных индексов для каждого поля. Чтобы воспользоваться преимуществами оптимизации, предоставляемыми технологиями индексирования Cosmos DB, рекомендуется создать несколько отдельных индексов вместо одного (неуникального) составного индекса.

## <a name="common-indexing-operations"></a>Общие операции индексирования

Следующие операции являются общими для обоих учетных записей, обслуживающих протоколы сети 3,6 и учетных записей, обслуживающих более ранние версии протокола проводной сети. 

## <a name="creating-unique-indexes"></a>Создание уникальных индексов

[Уникальные индексы](unique-keys.md) позволяют гарантировать, что никакие два или больше документов не будут содержать одинаковые значения для индексированных полей.

>[!Important]
> В настоящее время уникальные индексы можно создавать только в том случае, если коллекция пуста (не содержит документов).

Следующая команда создает уникальный индекс для поля "student_id":

```shell
globaldb:PRIMARY> db.coll.createIndex( { "student_id" : 1 }, {unique:true} )
{
        "_t" : "CreateIndexesResponse",
        "ok" : 1,
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 4
}
```

Для сегментированных коллекций при работе с MongoDB создание уникального индекса требует наличия ключа секции (раздела). Иными словами, все уникальные индексы для сегментированной коллекции — это составные индексы, где одно из полей является ключом раздела.

Следующие команды создают сегментированную коллекцию ```coll``` (ключ сегмента — ```university```) с уникальным индексом для полей "student_id" и "university":

```shell
globaldb:PRIMARY> db.runCommand({shardCollection: db.coll._fullName, key: { university: "hashed"}});
{
        "_t" : "ShardCollectionResponse",
        "ok" : 1,
        "collectionsharded" : "test.coll"
}
globaldb:PRIMARY> db.coll.createIndex( { "student_id" : 1, "university" : 1 }, {unique:true})
{
        "_t" : "CreateIndexesResponse",
        "ok" : 1,
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 3,
        "numIndexesAfter" : 4
}
```

Если в приведенном выше примере пропустить предложение ```"university":1```, будет возвращено следующее сообщение об ошибке:

```"cannot create unique index over {student_id : 1.0} with shard key pattern { university : 1.0 }"```

## <a name="ttl-indexes"></a>Индексы срока жизни

Чтобы установить срок действия документа в определенной коллекции, нужно создать [индекс срока жизни](../cosmos-db/time-to-live.md). Это индекс для поля _ts со значением "expireAfterSeconds".

Пример.

```JavaScript
globaldb:PRIMARY> db.coll.createIndex({"_ts":1}, {expireAfterSeconds: 10})
```

Предыдущая команда приведет к удалению всех документов коллекции ```db.coll```, которые не менялись последние 10 секунд.

> [!NOTE]
> **_ts** является специфическим полем Cosmos DB и не доступно клиентам MongoDB. Это зарезервированное (системное) свойство, содержащее метку времени последнего изменения документа.

## <a name="migrating-collections-with-indexes"></a>Перемещение коллекций с индексами

В настоящее время создание уникальных индексов возможно только в том случае, если коллекция не содержит документов. Популярные средства перемещения MongoDB пытаются создавать уникальные индексы после импорта данных. Чтобы обойти эту ошибку, рекомендуется, чтобы пользователи вручную создали соответствующие коллекции и уникальные индексы, вместо того чтобы разрешать средство миграции (для ```mongorestore``` это поведение достигается с помощью флага `--noIndexRestore` в командной строке).

## <a name="next-steps"></a>Следующие шаги

* [Индексирование в Azure Cosmos DB](../cosmos-db/index-policy.md)
* [Срок жизни для данных Azure Cosmos DB](../cosmos-db/time-to-live.md)
