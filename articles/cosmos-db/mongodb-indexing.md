---
title: Индексирование в API Azure Cosmos DB для MongoDB
description: Обзор возможностей индексирования в API Azure Cosmos DB для MongoDB.
ms.service: cosmos-db
ms.subservice: cosmosdb-mongo
ms.devlang: nodejs
ms.topic: conceptual
ms.date: 03/27/2020
author: timsander1
ms.author: tisande
ms.openlocfilehash: 7c75f0d6f74fe8cf1417e0dc40a5ad01615d7057
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "80371080"
---
# <a name="indexing-using-azure-cosmos-dbs-api-for-mongodb"></a>Индексирование с помощью API Azure Cosmos DB для MongoDB

API API Azure Cosmos DB для MongoDB использует основные возможности управления индексами Azure Cosmos DB. В этом документе основное внимание уделяется добавлению индексов с помощью API API Azure Cosmos DB для MongoDB. Вы также можете прочитать [обзор индексирования в Azure Cosmos DB,](index-overview.md) который актуален во всех API.

## <a name="indexing-for-version-36"></a>Индексирование для версии 3.6

Поле `_id` всегда автоматически индексируется и не может быть удалено. API API Azure Cosmos DB для MongoDB `_id` автоматически обеспечивает уникальность поля на ключе осколка.

Чтобы индексировать дополнительные поля, следует применить команды управления индексом MongoDB. Как и в MongoDB, автоматически индексируется только `_id` поле. Эта политика индексирования по умолчанию отличается от API Azure Cosmos DB S'L, который индексирует все поля по умолчанию.

Чтобы применить сортировку к запросу, необходимо создать индекс на полях, используемых в операции сортировки.

## <a name="index-types"></a>Типы индексов

### <a name="single-field"></a>Одно поле

Вы можете создавать индексы на любом поле. Порядок типа единого индекса поля не имеет значения. Следующая команда создаст индекс `name`на поле:

`db.coll.createIndex({name:1})`

В одном запросе будет использовано несколько однополевых индексов, где это возможно.

### <a name="compound-indexes-36"></a>Составные индексы (3,6)

Соединения индексы поддерживаются для счетов с помощью протокола 3.6 провода. В состав индекса можно включить до 8 полей. В отличие от MongoDB, необходимо создать сложный индекс только в том случае, если запрос должен эффективно сортироваться по нескольким полям одновременно. Для запросов с несколькими фильтрами, которые не нужно сортировать, следует создать несколько одиночных индексов поля вместо одного единого индекса соединения.

Следующая команда создаст составной `name` индекс `age`на полях и:

`db.coll.createIndex({name:1,age:1})`

Соединения индексы могут быть использованы для эффективной сортировки на нескольких полях одновременно, таких как:

`db.coll.find().sort({name:1,age:1})`

Вышеуказанный индекс соединения также может быть использован для эффективной сортировки запроса с противоположным порядком сортировки на всех полях. Ниже приведен пример:

`db.coll.find().sort({name:-1,age:-1})`

Однако последовательность путей в индексе соединения должна точно соответствовать запросу. Вот пример запроса, который потребует дополнительного индекса соединения:

`db.coll.find().sort({age:1,name:1})`

### <a name="multikey-indexes"></a>Мультиключевые индексы

Azure Cosmos DB создает многоключевые индексы для индексирования содержимого, хранящегося в массивах. Если индексировать поле со значением массива, Azure Cosmos DB автоматически индексирует каждый элемент массива.

### <a name="geospatial-indexes"></a>Геопространственные индексы

Многие геопространственные операторы выиграют от геопространственных индексов. В настоящее время API API Azure Cosmos `2dsphere` DB для MongoDB поддерживает индексы. `2d`индексы еще не поддерживаются.

Вот пример для создания геопространственного индекса `location` на поле:

`db.coll.createIndex({ location : "2dsphere" })`

### <a name="text-indexes"></a>Текстовые индексы

Текстовые индексы в настоящее время не поддерживаются. Для поиска текста на строках следует использовать интеграцию [Azure Cognitive Search](https://docs.microsoft.com/azure/search/search-howto-index-cosmosdb) с DB Azure Cosmos.

## <a name="index-properties"></a>Свойства индекса

Следующие операции являются общими для обеих учетных записей, обслуживающих версию протокола проводов 3.6, так и для счетов, обслуживающих более ранние версии протоколов проводов. Вы также можете узнать больше о [поддерживаемых индексах и индексированных свойствах.](mongodb-feature-support-36.md#indexes-and-index-properties)

### <a name="unique-indexes"></a>Уникальные индексы

[Уникальные индексы](unique-keys.md) позволяют гарантировать, что никакие два или больше документов не будут содержать одинаковые значения для индексированных полей.

>[!Important]
> Уникальные индексы могут быть созданы только тогда, когда коллекция пуста (не содержит документов).

Следующая команда создает уникальный индекс для поля "student_id":

```shell
globaldb:PRIMARY> db.coll.createIndex( { "student_id" : 1 }, {unique:true} )
{
        "_t" : "CreateIndexesResponse",
        "ok" : 1,
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 4
}
```

Для осколков коллекций для создания уникального индекса требуется предоставление ключа осколка (раздела). Иными словами, все уникальные индексы для сегментированной коллекции — это составные индексы, где одно из полей является ключом раздела.

Следующие команды создают сегментированную коллекцию ```coll``` (ключ сегмента — ```university```) с уникальным индексом для полей "student_id" и "university":

```shell
globaldb:PRIMARY> db.runCommand({shardCollection: db.coll._fullName, key: { university: "hashed"}});
{
        "_t" : "ShardCollectionResponse",
        "ok" : 1,
        "collectionsharded" : "test.coll"
}
globaldb:PRIMARY> db.coll.createIndex( { "student_id" : 1, "university" : 1 }, {unique:true})
{
        "_t" : "CreateIndexesResponse",
        "ok" : 1,
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 3,
        "numIndexesAfter" : 4
}
```

Если в приведенном выше примере пропустить предложение ```"university":1```, будет возвращено следующее сообщение об ошибке:

```"cannot create unique index over {student_id : 1.0} with shard key pattern { university : 1.0 }"```

### <a name="ttl-indexes"></a>Индексы срока жизни

Чтобы установить срок действия документа в определенной коллекции, нужно создать [индекс срока жизни](../cosmos-db/time-to-live.md). Это индекс для поля _ts со значением "expireAfterSeconds".

Пример

```JavaScript
globaldb:PRIMARY> db.coll.createIndex({"_ts":1}, {expireAfterSeconds: 10})
```

Предыдущая команда приведет к удалению всех документов коллекции ```db.coll```, которые не менялись последние 10 секунд.

> [!NOTE]
> **_ts** является полем Для DB Azure Cosmos и недоступно для клиентов MongoDB. Это зарезервированное (системное) свойство, содержащее метку времени последнего изменения документа.

## <a name="track-the-index-progress"></a>Отслеживайте прогресс индекса

3.6 версия API API Azure Cosmos DB для учетных записей MongoDB поддерживает `currentOp()` команду для отслеживания прогресса индекса на экземпляре базы данных. Эта команда возвращает документ, содержащий информацию о незавершенных операциях в экземпляре базы данных. Команда `currentOp` используется для отслеживания всех незавершенных операций в родном MongoDB, в то время как в API Azure Cosmos DB для MongoDB эта команда поддерживает только отслеживание операции индекса.

Вот несколько примеров, которые `currentOp` показывают, как использовать команду для отслеживания прогресса индекса:

* Получите прогресс индекса для коллекции:

   ```shell
   db.currentOp({"command.createIndexes": <collectionName>, "command.$db": <databaseName>})
   ```

* Получите прогресс индекса для всех коллекций в базе данных:

  ```shell
  db.currentOp({"command.$db": <databaseName>})
  ```

* Получите прогресс индекса для всех баз данных и коллекций в учетной записи Azure Cosmos:

  ```shell
  db.currentOp({"command.createIndexes": { $exists : true } })
  ```

Детали прогресса индекса содержат процент прогресса для текущей операции индекса. В следующем примере показан формат вывода документа для различных стадий прогресса индекса:

1. Если операция индекса в базе данных "foo" и "бар", которая имеет 60% индексации завершена будет иметь следующий документ вывода. `Inprog[0].progress.total`показывает 100 в качестве целевого завершения.

   ```json
   {
        "inprog" : [
        {
                ………………...
                "command" : {
                        "createIndexes" : foo
                        "indexes" :[ ],
                        "$db" : bar
                },
                "msg" : "Index Build (background) Index Build (background): 60 %",
                "progress" : {
                        "done" : 60,
                        "total" : 100
                },
                …………..…..
        }
        ],
        "ok" : 1
   }
   ```

2. Для операции индекса, которая только что началась в базе данных "foo" и "бар", выводной документ может отображать 0% прогресса до тех пор, пока он не достигнет измеримого уровня.

   ```json
   {
        "inprog" : [
        {
                ………………...
                "command" : {
                        "createIndexes" : foo
                        "indexes" :[ ],
                        "$db" : bar
                },
                "msg" : "Index Build (background) Index Build (background): 0 %",
                "progress" : {
                        "done" : 0,
                        "total" : 100
                },
                …………..…..
        }
        ],
       "ok" : 1
   }
   ```

3. Когда операция индекса в процессе выполнения завершается, выводной документ показывает пустые операции непрог.

   ```json
   {
      "inprog" : [],
      "ok" : 1
   }
   ```

### <a name="background-index-updates"></a>Обновления фоновых индексов

Независимо от значения, указанного для свойства **фонового** индекса, обновления индекса всегда выполняются в фоновом режиме. Обновления индекса потребляют RU с более низким приоритетом, чем другие операции базы данных. Таким образом, изменения индекса не приведут к простою записей, обновлений или удалений.

При добавлении нового индекса запросы будут немедленно использовать его. Это означает, что запросы могут не возвращать все соответствующие результаты, и будет делать это без возврата каких-либо ошибок. После завершения преобразования индекса результаты запроса будут последовательными. Вы можете [отслеживать прогресс индекса.](#track-the-index-progress)

## <a name="migrating-collections-with-indexes"></a>Перемещение коллекций с индексами

В настоящее время создание уникальных индексов возможно только в том случае, если коллекция не содержит документов. Популярные средства перемещения MongoDB пытаются создавать уникальные индексы после импорта данных. Чтобы обойти эту проблему, предлагается, чтобы пользователи вручную создавали соответствующие коллекции ```mongorestore``` и уникальные индексы, вместо того, чтобы разрешить инструмент миграции (для этого поведение достигается с помощью `--noIndexRestore` флага в командной строке).

## <a name="indexing-for-version-32"></a>Индексирование для версии 3.2

Для учетных записей Azure Cosmos DB, совместимых с версией 3.2 протокола проволоки MongoDB, доступные функции индексации и значения по умолчанию различны. Вы можете [проверить версию вашей учетной записи](mongodb-feature-support-36.md#protocol-support). Вы можете перейти на версию 3.6, подав [запрос на поддержку.](https://portal.azure.com/?#blade/Microsoft_Azure_Support/HelpAndSupportBlade)

Если вы используете версию 3.2, в этом разделе изложены ключевые различия с версией 3.6.

### <a name="dropping-the-default-indexes-32"></a>Удаление индексов по умолчанию (3.2)

В отличие от 3.6 версии API API Azure Cosmos DB для MongoDB, 3.2 версия индексирует каждое свойство по умолчанию. Следующая команда может быть использована для снижения этих индексов по умолчанию для коллекции: ```coll```

```JavaScript
> db.coll.dropIndexes()
{ "_t" : "DropIndexesResponse", "ok" : 1, "nIndexesWas" : 3 }
```

После снижения индексов по умолчанию можно добавить дополнительные индексы, как это делается в версии 3.6.

### <a name="compound-indexes-32"></a>Составные индексы (3,2)

Составные индексы содержат ссылки на множество полей документа. Если вы хотите создать сложный индекс, пожалуйста, пересмотрите до 3.6 версии, подав [запрос на поддержку.](https://portal.azure.com/?#blade/Microsoft_Azure_Support/HelpAndSupportBlade)

## <a name="next-steps"></a>Дальнейшие действия

* [Индексирование в Azure Cosmos DB](../cosmos-db/index-policy.md)
* [Срок жизни для данных Azure Cosmos DB](../cosmos-db/time-to-live.md)
