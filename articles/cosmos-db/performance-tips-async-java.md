---
title: Советы по повышению производительности Azure Cosmos DB пакета SDK для асинхронного Java версии 2
description: Узнайте о параметрах конфигурации клиента, повышающих производительность базы данных Azure Cosmos для асинхронного пакета SDK для Java версии 2
author: anfeldma-ms
ms.service: cosmos-db
ms.devlang: java
ms.topic: conceptual
ms.date: 05/08/2020
ms.author: anfeldma
ms.openlocfilehash: 1a3ec22b9d1375f1c438d24791389284c1d4ee84
ms.sourcegitcommit: 999ccaf74347605e32505cbcfd6121163560a4ae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2020
ms.locfileid: "82982553"
---
# <a name="performance-tips-for-azure-cosmos-db-async-java-sdk-v2"></a>Советы по повышению производительности Azure Cosmos DB пакета SDK для асинхронного Java версии 2

> [!div class="op_single_selector"]
> * [Пакет SDK для Java v4](performance-tips-java-sdk-v4-sql.md)
> * [Пакет SDK для Async Java версии 2](performance-tips-async-java.md)
> * [Пакет SDK для Sync Java версии 2](performance-tips-java.md)
> * [.NET](performance-tips.md)
> 

> [!IMPORTANT]  
> Это *не* самый последний пакет SDK для Java для Azure Cosmos DB! Рассмотрите возможность использования Azure Cosmos DB пакета SDK для Java версии 4 для вашего проекта. Чтобы выполнить обновление, следуйте инструкциям из руководств по [переходу на Azure Cosmos DB пакета SDK для Java версии 4](migrate-java-v4-sdk.md) и [реактора VS рксжава](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples/blob/master/reactor-rxjava-guide.md) . 
> 
> Советы по повышению производительности в этой статье предназначены только для Azure Cosmos DB асинхронного пакета SDK для Java версии 2. Дополнительные сведения см. в статье [заметки о выпуске](sql-api-sdk-async-java.md)пакета SDK для [Maven](https://mvnrepository.com/artifact/com.microsoft.azure/azure-cosmosdb)Async java, а также Azure Cosmos DB в [документе Руководство по устранению неполадок](troubleshoot-java-async-sdk.md) пакета SDK для Async Java версии 2 и Azure Cosmos DB.
>

Azure Cosmos DB — быстрая и гибкая распределенная база данных, которая легко масштабируется с гарантированной задержкой и пропускной способностью. Для масштабирования базы данных с помощью Azure Cosmos DB не нужно вносить в архитектуру существенные изменения или писать сложный код. Для увеличения или уменьшения масштаба достаточно вызвать один метод интерфейса API или пакета SDK. Однако, поскольку доступ к Azure Cosmos DB осуществляется через сетевые вызовы, существуют оптимизации на стороне клиента, которые можно использовать для достижения пиковой производительности при использовании [Azure Cosmos DB Async Java SDK версии 2](sql-api-sdk-async-java.md).

Чтобы повысить производительность базы данных, рассмотрите следующие варианты.

## <a name="networking"></a>Сеть

* **Режим подключения: использование прямого режима**
<a id="direct-connection"></a>
    
    Способ подключения клиента к Azure Cosmos DB имеет важное влияние на производительность, особенно в плане задержки на стороне клиента. *ConnectionMode* — это ключевой параметр конфигурации, доступный для настройки *ConnectionPolicy*клиента. Для Azure Cosmos DB пакета SDK для Java версии 2 доступны два доступных значений:  
      
    * [Gateway](/java/api/com.microsoft.azure.cosmosdb.connectionmode) ("Шлюз", используется по умолчанию);  
    * [Прямой доступ](/java/api/com.microsoft.azure.cosmosdb.connectionmode)

    Режим шлюза поддерживается на всех платформах SDK, и этот параметр настроен по умолчанию. Если приложения работают в корпоративной сети с ограниченными ограничениями брандмауэра, лучшим выбором является режим шлюза, так как он использует стандартный HTTPS-порт и одну конечную точку. Но режим шлюза не обеспечивает максимальную производительность, поскольку задействует дополнительный сетевой узел при каждой операции чтения или записи данных в Azure Cosmos DB. По этой причине прямой режим обеспечивает лучшую производительность из-за меньшего количества прыжков сети.

    *ConnectionMode* настраивается во время создания экземпляра *DocumentClient* с помощью параметра *ConnectionPolicy* .

    ### <a name="async-java-sdk-v2-maven-commicrosoftazureazure-cosmosdb"></a><a id="asyncjava2-connectionpolicy"></a>Async Java SDK v2 (Maven com. Microsoft. Azure:: Azure-cosmosdb)

    ```java
        public ConnectionPolicy getConnectionPolicy() {
          ConnectionPolicy policy = new ConnectionPolicy();
          policy.setConnectionMode(ConnectionMode.Direct);
          policy.setMaxPoolSize(1000);
          return policy;
        }

        ConnectionPolicy connectionPolicy = new ConnectionPolicy();
        DocumentClient client = new DocumentClient(HOST, MASTER_KEY, connectionPolicy, null);
    ```

* Совместное размещение **клиентов в одном регионе Azure для повышения производительности**<a id="same-region"></a>

    По возможности разместите все приложения, вызывающие Azure Cosmos DB, в том же регионе, что и база данных Azure Cosmos. Для приблизительного сравнения: вызовы к Azure Cosmos DB в пределах региона выполняются в течение 1–2 мс, но задержка между восточным и западным побережьем США превышает 50 мс. Значение задержки может отличаться в зависимости от выбранного маршрута при передаче запроса от клиента к границе центра обработки данных Azure. Минимальная возможная задержка достигается при размещении клиентского приложения в том же регионе Azure, в котором предоставляется конечная точка Azure Cosmos DB. Список доступных регионов см. на странице [Регионы Azure](https://azure.microsoft.com/regions/#services).

    ![Пример политики подключения Azure Cosmos DB](./media/performance-tips/same-region.png)

## <a name="sdk-usage"></a>Использование пакета SDK
* **Установка последней версии пакета SDK**

    Пакеты SDK для Azure Cosmos DB постоянно улучшаются, чтобы обеспечивать самую высокую производительность. Дополнительные сведения о последнем пакете SDK и улучшениях см. на страницах [заметок о выпуске](sql-api-sdk-async-java.md) пакета SDK для асинхронной версии Java для Azure Cosmos DB.

* **Использование одноэлементного Azure Cosmos DB клиента в течение времени существования приложения**

    Каждый экземпляр AsyncDocumentClient является потокобезопасным, а также эффективно управляет подключениями и кэширует адреса. Чтобы реализовать возможность управления подключениями и оптимизировать производительность, рекомендуется использовать один экземпляр AsyncDocumentClient для каждого домена в течение жизненного цикла приложения.

   <a id="max-connection"></a>

* **Настройка ConnectionPolicy**

    По умолчанию запросы Cosmos DB прямого режима выполняются по протоколу TCP при использовании Azure Cosmos DB асинхронного пакета SDK для Java версии 2. На внутреннем уровне пакет SDK использует специальную архитектуру прямого режима для динамического управления сетевыми ресурсами и получения наилучшей производительности.

    В Azure Cosmos DB Async Java SDK v2 для повышения производительности базы данных с большинством рабочих нагрузок лучше всего подходит режим Direct. 

    * ***Общие сведения о режиме Direct***

        ![Иллюстрация архитектуры прямого режима](./media/performance-tips-async-java/rntbdtransportclient.png)

        Клиентская архитектура, применяемая в режиме прямого доступа, обеспечивает предсказуемое использование сети и мультиплексированный доступ к Azure Cosmos DB репликам. На схеме выше показано, как прямой режим направляет запросы клиентов на реплики в серверной части Cosmos DB. Архитектура прямого режима выделяет до 10 **каналов** на стороне клиента на каждую реплику базы данных. Канал представляет собой TCP-соединение, которому предшествует буфер запроса, который имеет глубину 30 запросов. Каналы, принадлежащие реплике, динамически распределяются по мере необходимости **конечной точкой службы**реплики. Когда пользователь отправляет запрос в режиме прямого подключения, **транспортклиент** направляет запрос в соответствующую конечную точку службы на основе ключа секции. **Очередь** запросов помещает запросы в буфер перед конечной точкой службы.

    * ***Параметры конфигурации ConnectionPolicy для прямого режима***

        В качестве первого шага используйте следующие рекомендуемые параметры конфигурации ниже. Если у вас возникли проблемы с этой конкретной темой, обратитесь к [группе Azure Cosmos DB](mailto:CosmosDBPerformanceSupport@service.microsoft.com) .

        Если в качестве эталонной базы данных используется Azure Cosmos DB (то есть база данных используется для многих операций чтения точки и несколько операций записи), может быть приемлемым задание значения *идлиндпоинттимеаут* равным 0 (то есть без времени ожидания).


        | Параметр конфигурации       | Значение по умолчанию    |
        | :------------------:       | :-----:    |
        | буфферпажесизе             | 8192       |
        | connectionTimeout          | "PT1M"     |
        | идлечаннелтимеаут         | "PT0S"     |
        | идлиндпоинттимеаут        | "PT1M10S"  |
        | максбуфферкапаЦити          | 8388608    |
        | максчаннелсперендпоинт     | 10         |
        | максрекуестсперчаннел      | 30         |
        | рецеивехангдетектионтиме   | "PT1M5S"   |
        | рекуестекспиринтервал      | PT5S     |
        | requestTimeout             | "PT1M"     |
        | рекуесттимерресолутион     | "PT 0,5 S"   |
        | сендхангдетектионтиме      | "PT10S"    |
        | шутдовнтимеаут            | PT15S    |

    * ***Советы по программированию для прямого режима***

        Изучите статью [Устранение неполадок](troubleshoot-java-async-sdk.md) пакета SDK для асинхронного Java версии 2 Azure Cosmos DB в качестве основы для устранения любых проблем с пакетом SDK.

        Некоторые важные советы по программированию при использовании прямого режима:

        + **Использование многопоточности в приложении для эффективного обмена данными по протоколу TCP** . После выполнения запроса приложение должно подписываться на получение данных в другом потоке. Если этого не сделать, это вызовет непредвиденную операцию "полудуплекс" и последующие запросы блокируются в ожидании ответа предыдущего запроса.

        + **Выполнение рабочих нагрузок с большим объемом вычислений в выделенном потоке** . по тем же причинам, что и в предыдущем TIP, такие операции, как сложная обработка данных, лучше размещать в отдельном потоке. Запрос, который извлекает данные из другого хранилища данных (например, если поток использует одновременно хранилища данных Azure Cosmos DB и Spark), может увеличить задержку и рекомендуется порождать дополнительный поток, ожидающий ответа от другого хранилища данных.

            + Базовый сетевой ввод-вывод в пакете SDK v2 для Azure Cosmos DB Async Java управляется с помощью NETTY. Эти [советы помогут избежать шаблонов программирования, блокирующих потоки ввода-вывода NETTY](troubleshoot-java-async-sdk.md#invalid-coding-pattern-blocking-netty-io-thread).

        + **Моделирование данных** . Azure Cosmos DB SLA предполагает, что размер документа меньше 1 КБ. Оптимизация модели данных и программирования в пользу приоритета меньшего размера документа обычно приводит к уменьшению задержки. Если вам требуется хранение и извлечение документов, превышающих 1 КБ, рекомендуемый подход заключается в том, чтобы документы можно было связывать с данными в хранилище BLOB-объектов Azure.


* **Настройка параллельных запросов для секционированных коллекций**

    Azure Cosmos DB асинхронный пакет SDK для Java версии 2 поддерживает параллельные запросы, позволяющие параллельно запрашивать секционированную коллекцию. Дополнительные сведения см. в [примерах кода](https://github.com/Azure/azure-cosmosdb-java/tree/master/examples/src/test/java/com/microsoft/azure/cosmosdb/rx/examples) для работы с пакетами SDK. Параллельные запросы предназначены для сокращения задержки при обработке запросов и улучшения пропускной способности посредством их последовательных аналогов.

    * ***Настройка setMaxDegreeOfParallelism\:***
    
        Параллельные запросы работают, запрашивая несколько секций параллельно. Однако данные из каждой секционированной коллекции извлекаются в рамках запроса последовательно. С помощью параметра setMaxDegreeOfParallelism установите значение, соответствующее числу секций, что обеспечит максимальную вероятность высокой производительности запроса при сохранении всех остальных параметров системы. Если вы не знаете количество секций, просто используйте высокое значение для setMaxDegreeOfParallelism. Система автоматически выберет минимальное из двух значений: количество секций или число, указанное пользователем.

        Следует отметить, что параллельные запросы обеспечивают больше преимуществ, если данные равномерно распределены во всех секциях по отношению к запросу. Если коллекция секционируется таким образом, что все или большинство данных, возвращаемых запросом, содержатся в нескольких секциях (в худшем случае в одной), это негативно скажется на производительности запроса.

    * ***Настройка setMaxBufferedItemCount\:***
    
        Параллельный запрос предназначен для предварительного выборки результатов, пока текущий пакет результатов обрабатывается клиентом. Предварительная выборка способствует общему уменьшению задержки при обработке запроса. Значение setMaxBufferedItemCount ограничивает количество предварительно выбираемых результатов. Указав для параметра setMaxBufferedItemCount ожидаемое число возвращаемых результатов (или еще более высокое значение), вы обеспечите максимальное влияние предварительной выборки на производительность запросов.

        Предварительная выборка работает одинаково при любом значении параметра MaxDegreeOfParallelism. Для данных из всех секций применяется один буфер.

* **Применение интервала задержки getRetryAfterInMilliseconds.**

    Во время проверки производительности следует увеличивать нагрузку до тех пор, пока регулирование не будет выполняться при небольшой частоте запросов. При регулировании клиентское приложение должно реализовать интервал частоты повтора для частоты повтора сервера. Это гарантирует, что время ожидания между повторными попытками будет минимальным.

* **Развертывание рабочей нагрузки клиента**

    При проверке с высокой пропускной способностью (более 50 000 единиц запроса в секунду) клиентское приложение может стать узким местом из-за того, что на компьютере будут достигнуты максимальные уровни использования ЦП и сети. Если вы достигли этой точки, то можете повысить производительность Azure Cosmos DB, развернув клиентские приложения на нескольких серверах.

* **Адресация на основе имен**

    Используйте адресацию на основе имен, то есть ссылки в формате `dbs/MyDatabaseId/colls/MyCollectionId/docs/MyDocumentId` вместо самоссылающегося (\_self) формата `dbs/<database_rid>/colls/<collection_rid>/docs/<document_rid>`. Это позволит избежать получения идентификаторов для всех ресурсов, требуемых для создания ссылки. Кроме того, кэширование этих данных не увеличит производительность, так как ресурсы могут создаваться заново (иногда с теми же именами).

   <a id="tune-page-size"></a>

* **Оптимизация производительности посредством настройки размера страницы для запросов и каналов чтения**

    Если при массовом чтении документов с помощью функции чтения канала (например, readDocuments) или обработке запроса SQL будет получен слишком большой набор результатов, такие результаты возвращаются частями. По умолчанию результаты возвращаются в пакетах (не более 100 элементов и не более 1 МБ в каждом пакете).

    Чтобы снизить количество сетевых взаимодействий, необходимых для получения всех нужных результатов, попробуйте увеличить размер страницы до 1000 с помощью заголовка запроса [x-ms-max-item-count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers). Чтобы отобразить только некоторые результаты, например, когда пользовательский интерфейс или приложение API возвращает только десять результатов за раз, размер страницы можно уменьшить до 10. Это позволит снизить пропускную способность, используемую на операции чтения и на выполнение запросов.

    Размер страницы также можно изменить с помощью метода setMaxItemCount.

* **Использование надлежащего планировщика (избегайте перехвата потоков цикла обработки событий ввода-вывода netty)**

    Для неблокирующих операций ввода-вывода Azure Cosmos DB пакет SDK для асинхронного Java версии 2 использует [NETTY](https://netty.io/) . В пакете SDK используется фиксированное число потоков цикла обработки событий ввода-вывода netty (это число соответствует числу ядер ЦП на компьютере) для выполнения операций ввода-вывода. Объект Observable, возвращаемый API, выводит результат в один из общих потоков цикла обработки событий ввода-вывода netty. Поэтому важно не блокировать общие потоки цикла обработки событий ввода-вывода netty. Интенсивное использование ЦП или блокировка операции в потоке цикла обработки событий ввода-вывода netty может вызвать взаимоблокировку или значительно уменьшить пропускную способность пакета SDK.

    Например, следующий код выполняет рабочую нагрузку с интенсивной нагрузкой на ЦП в потоке цикла обработки событий ввода-вывода netty.

    ### <a name="async-java-sdk-v2-maven-commicrosoftazureazure-cosmosdb"></a><a id="asyncjava2-noscheduler"></a>Async Java SDK v2 (Maven com. Microsoft. Azure:: Azure-cosmosdb)

    ```java
    Observable<ResourceResponse<Document>> createDocObs = asyncDocumentClient.createDocument(
      collectionLink, document, null, true);

    createDocObs.subscribe(
      resourceResponse -> {
        //this is executed on eventloop IO netty thread.
        //the eventloop thread is shared and is meant to return back quickly.
        //
        // DON'T do this on eventloop IO netty thread.
        veryCpuIntensiveWork();
      });
    ```

    Если необходимо выполнить обработку полученного результата с интенсивной нагрузкой на ЦП, этого нежелательно делать в потоке цикла обработки событий ввода-вывода netty. Вместо этого можно указать собственный планировщик, чтобы выполнить рабочую нагрузку, используя собственный поток.

    ### <a name="async-java-sdk-v2-maven-commicrosoftazureazure-cosmosdb"></a><a id="asyncjava2-scheduler"></a>Async Java SDK v2 (Maven com. Microsoft. Azure:: Azure-cosmosdb)

    ```java
    import rx.schedulers;

    Observable<ResourceResponse<Document>> createDocObs = asyncDocumentClient.createDocument(
      collectionLink, document, null, true);

    createDocObs.subscribeOn(Schedulers.computation())
    subscribe(
      resourceResponse -> {
        // this is executed on threads provided by Scheduler.computation()
        // Schedulers.computation() should be used only when:
        //   1. The work is cpu intensive 
        //   2. You are not doing blocking IO, thread sleep, etc. in this thread against other resources.
        veryCpuIntensiveWork();
      });
    ```

    Следует использовать подходящий планировщик RxJava в зависимости от типа рабочей нагрузки. Прочтите [``Schedulers``](http://reactivex.io/RxJava/1.x/javadoc/rx/schedulers/Schedulers.html)здесь.

    Дополнительные сведения см. на [странице GitHub](https://github.com/Azure/azure-cosmosdb-java) Azure Cosmos DB пакете SDK версии 2 для асинхронного Java.

* **Отключить ведение журнала NETTY**

    Ведение журнала NETTY Library — это беседа, и его необходимо отключить (подавление входа в конфигурацию может быть недостаточно) во избежание дополнительных затрат на ЦП. Если вы не используете режим отладки, полностью отключите ведение журналов netty. Поэтому, если вы используете log4j для сокращения дополнительных затрат на ЦП в связи с ``org.apache.log4j.Category.callAppenders()`` из netty, добавьте следующую строку в базу кода:

    ```java
    org.apache.log4j.Logger.getLogger("io.netty").setLevel(org.apache.log4j.Level.OFF);
    ```

 * **Ограничение ресурсов для открытых файлов ОС**
 
    Некоторые системы Linux (например, Red Hat) имеют верхний предел количества открытых файлов и общее число подключений. Чтобы узнать текущие ограничения, выполните следующую команду:

    ```bash
    ulimit -a
    ```

    Число открытых файлов (nofile) должно быть достаточно большим, чтобы было достаточно места для настроенного размера пула подключений и других открытых файлов в ОС. Это число можно изменить для включения поддержки пула подключений большего размера.

    Откройте файл limits.conf:

    ```bash
    vim /etc/security/limits.conf
    ```
    
    Добавьте или измените следующие строки:

    ```
    * - nofile 100000
    ```

* **Использование собственной реализации TLS/SSL для NETTY**

    NETTY может использовать OpenSSL непосредственно для стека реализации TLS для достижения лучшей производительности. В отсутствие этой конфигурации NETTY будет возвращаться к реализации TLS по умолчанию Java.

    Для Ubuntu:
    ```bash
    sudo apt-get install openssl
    sudo apt-get install libapr1
    ```

    Также добавьте в проект следующие зависимости maven:
    ```xml
    <dependency>
      <groupId>io.netty</groupId>
      <artifactId>netty-tcnative</artifactId>
      <version>2.0.20.Final</version>
      <classifier>linux-x86_64</classifier>
    </dependency>
    ```

Для других платформ (например, RedHat, Windows, Mac и т. д.) воспользуйтесь следующими инструкциями: https://netty.io/wiki/forked-tomcat-native.html

## <a name="indexing-policy"></a>Политика индексации
 
* **Исключить неиспользуемые пути из индексирования для ускорения операций записи**

    Политика индексирования Azure Cosmos DB позволяет добавлять к индексированию или исключать из индексирования определенные пути к документам, используя механизм Indexing Paths (setIncludedPaths и setExcludedPaths). Возможность управления путями индексирования позволяет оптимизировать производительность записи и снизить затраты на хранение индекса для сценариев с заранее определенными шаблонами запросов. Это связано с тем, что затраты на индексирование непосредственно зависят от количества уникальных путей индексирования. Например, в следующем коде показано, как исключить весь раздел документов (также называемых поддеревом) из индексирования с помощью подстановочного знака "*".

    ### <a name="async-java-sdk-v2-maven-commicrosoftazureazure-cosmosdb"></a><a id="asyncjava2-indexing"></a>Async Java SDK v2 (Maven com. Microsoft. Azure:: Azure-cosmosdb)

    ```Java
    Index numberIndex = Index.Range(DataType.Number);
    numberIndex.set("precision", -1);
    indexes.add(numberIndex);
    includedPath.setIndexes(indexes);
    includedPaths.add(includedPath);
    indexingPolicy.setIncludedPaths(includedPaths);
    collectionDefinition.setIndexingPolicy(indexingPolicy);
    ```

    Дополнительные сведения см. в статье [Политики индексации Azure Cosmos DB](indexing-policies.md).

## <a name="throughput"></a>Пропускная способность
<a id="measure-rus"></a>

* **Измерение и настройка расхода единиц запроса/повторного использования**

    Azure Cosmos DB предоставляет обширный набор операций с документами в коллекции базы данных, в том числе реляционные и иерархические запросы с использованием UDF, хранимых процедур и триггеров. Затраты, связанные с каждой из этих операций, зависят от типа процессора, операций ввода-вывода и памяти, необходимой для завершения операции. Вместо того чтобы думать о закупке и управлении аппаратными ресурсами, вы можете думать о единице запроса (RU) как единой меры для ресурсов, необходимых для выполнения различных операций с базами данных и обслуживания запросов приложений.

    Пропускная способность выделяется на основе количества [единиц запроса](request-units.md), заданного для каждого контейнера. Удельный расход единиц запросов оценивается в расчете на одну секунду. Частота запросов для приложений, у которых она превышает подготовленные единицы запросов для контейнера, будет ограничена, пока она не упадет ниже зарезервированного для контейнера уровня. Если приложению требуется более высокий уровень пропускной способности, можно увеличить ее путем выделения дополнительных единиц запросов.

    Сложность запроса влияет на количество единиц запроса, потребляемых операцией. Количество предикатов и их характер, количество определяемых пользователем функций и размер набора исходных данных — все это влияет на плату за операции запроса.

    Чтобы оценить расходы на любую операцию (создание, обновление или удаление), проверьте значение заголовка [x-ms-request-charge](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers). Это значение содержит число единиц запроса, потребляемых соответствующей операцией. Вы также можете просмотреть эквивалентное свойство RequestCharge в ResourceResponse\<t> или FeedResponse\<t>.

    ### <a name="async-java-sdk-v2-maven-commicrosoftazureazure-cosmosdb"></a><a id="asyncjava2-requestcharge"></a>Async Java SDK v2 (Maven com. Microsoft. Azure:: Azure-cosmosdb)

    ```Java
    ResourceResponse<Document> response = asyncClient.createDocument(collectionLink, documentDefinition, null,
                                                     false).toBlocking.single();
    response.getRequestCharge();
    ```

    Стоимость запроса, указанная в этом заголовке, учитывается как часть подготовленной пропускной способности. Например, если вы предоставили 2000 единиц запроса в секунду, а приведенный выше запрос возвращает 1000 документов размером по 1 КБ каждый, затраты на операцию составят 1000 единиц. Таким образом, перед ограничением частоты выполнения последующих запросов сервер за одну секунду выполняет только два таких запроса. Чтобы узнать больше, ознакомьтесь с [единицами запроса](request-units.md) и [калькулятором единиц запроса](https://www.documentdb.com/capacityplanner).

<a id="429"></a>
* **Обработка ограничения скорости / слишком высокая частота запросов**

    Выполнение запроса, который превышает лимит зарезервированной пропускной способности для учетной записи, не приводит к снижению производительности сервера, так как пользователь не сможет превысить это зарезервированное значение. Сервер будет завершать запрос с помощью ошибкой requestratetoolarge (код состояния HTTP 429) и вернуть заголовок [x-MS-Retry-After-MS](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) , указывающий время ожидания (в миллисекундах), по истечении которого пользователь должен подождать, прежде чем повторить попытку запроса.

        HTTP Status 429,
        Status Line: RequestRateTooLarge
        x-ms-retry-after-ms :100

    Пакеты SDK перехватят этот ответ, обработают заголовок retry-after, указанный сервером, и отправят запрос повторно. Если к вашей учетной записи параллельно имеет доступ только один клиент, следующая попытка будет успешной.

    По умолчанию число повторных попыток отправки запроса составляет девять (это значение задается клиентом). Если к вашей учетной записи имеют доступ несколько клиентов и они выполняют запросы одновременно, этого может быть недостаточно. В этом случае клиент выдаст для приложения исключение DocumentClientException с кодом состояния 429. Число повторных попыток по умолчанию можно переопределить в свойстве setRetryOptions экземпляра ConnectionPolicy. По умолчанию в случае превышения заданного счетчика повторов исключение DocumentClientException с кодом состояния 429 возвращается через 30 секунд (совокупное время ожидания). Это происходит, даже если текущее значение количества повторных попыток (по умолчанию (9) или определенное пользователем) меньше максимального значения.

    Хотя автоматическая процедура отправки повторного запроса позволяет улучшить устойчивость приложений и повысить удобство работы с ними, она может снизить производительность, что, в свою очередь, станет причиной появления более длительных задержек. Если настройка производительности повлияла на регулирование сервера и стала причиной автоматической отправки запросов пакетом SDK, это может стать причиной появления пиков задержек на стороне клиента. Чтобы избежать пиков задержек во время настройки производительности, проверьте расход ресурсов на каждую операцию и убедитесь, что значение частоты запросов не превышено. Дополнительные сведения см. в статье [Единицы запросов в DocumentDB](request-units.md).

* **Использование меньших документов для более высокой пропускной способности**

    Стоимость запроса (плата за обработку запроса) для каждой операции напрямую зависит от размера документа. За операции с большими документами взимается больше единиц запроса, чем за операции с мелкими документами.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о создании приложения с высокой масштабируемостью и производительностью см. в статье [Partitioning and scaling in Azure Cosmos DB](partition-data.md) (Секционирование и масштабирование в Azure Cosmos DB).
