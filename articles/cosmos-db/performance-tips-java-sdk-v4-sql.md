---
title: Советы по повышению производительности для Azure Cosmos DB пакета SDK для Java v4
description: Узнайте о параметрах конфигурации клиента, повышающих производительность базы данных Azure Cosmos для пакета SDK для Java v4
author: anfeldma-ms
ms.service: cosmos-db
ms.devlang: java
ms.topic: conceptual
ms.date: 05/08/2020
ms.author: anfeldma
ms.openlocfilehash: ce4e4d11ead41ee8cc4a4bd1d85f1fbad2af4b07
ms.sourcegitcommit: 999ccaf74347605e32505cbcfd6121163560a4ae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2020
ms.locfileid: "82982536"
---
# <a name="performance-tips-for-azure-cosmos-db-java-sdk-v4"></a>Советы по повышению производительности для Azure Cosmos DB пакета SDK для Java v4

> [!div class="op_single_selector"]
> * [Пакет SDK для Java v4](performance-tips-java-sdk-v4-sql.md)
> * [Пакет SDK для Async Java версии 2](performance-tips-async-java.md)
> * [Пакет SDK для Sync Java версии 2](performance-tips-java.md)
> * [.NET](performance-tips.md)
> 

> [!IMPORTANT]  
> Советы по повышению производительности в этой статье предназначены только для Azure Cosmos DB пакета SDK для Java версии 4. Дополнительные сведения см. в разделе Заметки о выпуске Azure Cosmos DB пакета SDK V4, [репозиторий Maven](https://mvnrepository.com/artifact/com.azure/azure-cosmos)и Azure Cosmos DB [руководство по устранению неполадок](troubleshoot-java-sdk-v4-sql.md) пакета Java SDK v4. Если в настоящее время используется более старая версия, чем V4, ознакомьтесь с руководством по [переходу на Azure Cosmos DB пакета SDK для Java версии 4](migrate-java-v4-sdk.md) для получения справки по обновлению до версии v4.
>

Azure Cosmos DB — быстрая и гибкая распределенная база данных, которая легко масштабируется с гарантированной задержкой и пропускной способностью. Для масштабирования базы данных с помощью Azure Cosmos DB не нужно вносить в архитектуру существенные изменения или писать сложный код. Для увеличения или уменьшения масштаба достаточно вызвать один метод интерфейса API или пакета SDK. Однако, поскольку доступ к Azure Cosmos DB осуществляется через сетевые вызовы, можно выполнять оптимизацию на стороне клиента, чтобы добиться пиковой производительности при использовании Azure Cosmos DB пакета SDK для Java версии 4.

Чтобы повысить производительность базы данных, рассмотрите следующие варианты.

## <a name="networking"></a>Сеть

* **Режим подключения: использование прямого режима**
<a id="direct-connection"></a>
    
    Способ подключения клиента к Azure Cosmos DB имеет важное влияние на производительность, особенно в плане задержки на стороне клиента. *ConnectionMode* — это ключевой параметр конфигурации, доступный для настройки *ConnectionPolicy*клиента. Для Azure Cosmos DB пакета SDK для Java версии 4 доступны два доступных *ConnectionMode*:  
      
    * [Gateway](/java/api/com.microsoft.azure.cosmosdb.connectionmode) ("Шлюз", используется по умолчанию);  
    * [Прямой доступ](/java/api/com.microsoft.azure.cosmosdb.connectionmode)

    Эти *ConnectionMode*, по сути, являются условием маршрута, который запрашивает запрос от клиентского компьютера к секциям в серверной части Azure Cosmos DB. Обычно режим Direct является предпочтительным вариантом для лучшей производительности. он позволяет клиенту открывать подключения TCP непосредственно к секциям в Azure Cosmos DB серверных *запросов и передавать запросы напрямую ly*без посредников. В режиме шлюза запросы, выполняемые клиентом, направляются на так называемый «шлюз» сервер в Azure Cosmos DB интерфейсной части, который, в свою очередь, позволяет уменьшить скорость запросов к соответствующим секциям в Azure Cosmos DB серверной части. Если приложение работает в корпоративной сети с ограниченными ограничениями брандмауэра, лучшим выбором является режим шлюза, так как он использует стандартный HTTPS-порт и одну конечную точку. Однако компромисс производительности заключается в том, что режим шлюза включает дополнительный сетевой прыжок (клиент для шлюза и шлюза для секционирования) при каждом считывании или записи данных в Azure Cosmos DB. По этой причине прямой режим обеспечивает лучшую производительность из-за меньшего количества прыжков сети.

    *ConnectionMode* настраивается во время создания экземпляра клиента Azure Cosmos DB с помощью параметра *ConnectionPolicy* :
    
   #### <a name="async"></a>[Async](#tab/api-async)

   ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-connection-policy-async"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    public ConnectionPolicy getConnectionPolicy() {
        ConnectionPolicy policy = new ConnectionPolicy();
        policy.setMaxPoolSize(1000);
        return policy;
    }

    ConnectionPolicy connectionPolicy = new ConnectionPolicy();
    CosmosAsyncClient client = new CosmosClientBuilder()
        .setEndpoint(HOST)
        .setKey(MASTER)
        .setConnectionPolicy(connectionPolicy)
        .buildAsyncClient();
    ```

    #### <a name="sync"></a>[Синхронизация](#tab/api-sync)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-sync-api"></a><a id="java4-connection-policy-sync"></a>API-интерфейс синхронизации пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    public ConnectionPolicy getConnectionPolicy() {
        ConnectionPolicy policy = new ConnectionPolicy();
        policy.setMaxPoolSize(1000);
        return policy;
    }

    ConnectionPolicy connectionPolicy = new ConnectionPolicy();
    CosmosClient client = new CosmosClientBuilder()
        .setEndpoint(HOST)
        .setKey(MASTER)
        .setConnectionPolicy(connectionPolicy)
        .buildClient();
    ```

    --- 

<a name="collocate-clients"></a>
* Совместное размещение **клиентов в одном регионе Azure для повышения производительности**<a id="same-region"></a>

    По возможности разместите все приложения, вызывающие Azure Cosmos DB, в том же регионе, что и база данных Azure Cosmos. Для приблизительного сравнения: вызовы к Azure Cosmos DB в пределах региона выполняются в течение 1–2 мс, но задержка между восточным и западным побережьем США превышает 50 мс. Значение задержки может отличаться в зависимости от выбранного маршрута при передаче запроса от клиента к границе центра обработки данных Azure. Минимальная возможная задержка достигается при размещении клиентского приложения в том же регионе Azure, в котором предоставляется конечная точка Azure Cosmos DB. Список доступных регионов см. на странице [Регионы Azure](https://azure.microsoft.com/regions/#services).

    ![Пример политики подключения Azure Cosmos DB](./media/performance-tips/same-region.png)

    Приложение, взаимодействующее с учетной записью Azure Cosmos DB в нескольких регионах, должно настроить [предпочтительные расположения]() , чтобы обеспечить переход запросов в выровненный регион.

* **Включите ускоренную сеть на виртуальной машине Azure для снижения задержки.**

Рекомендуется выполнить инструкции по включению ускорения сети в [Windows (щелкните](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-powershell) здесь, чтобы получить инструкции) или [Linux (щелкните](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-cli) , чтобы получить инструкции) виртуальная машина Azure, чтобы повысить производительность.

Без ускорения работы с сетью операции ввода-вывода, которые передаются между виртуальной машиной Azure и другими ресурсами Azure, могут быть необязательно маршрутизироваться через узел и виртуальный коммутатор, расположенный между виртуальной машиной и ее сетевой картой. Наличие встроенного и виртуального коммутатора в пути данных не только увеличивает задержку и колебание в коммуникационном канале, но также приводит к краже циклов ЦП виртуальной машины. Благодаря ускоренному подключению к сети виртуальные машины напрямую взаимодействует с сетевым адаптером без посредников; все сведения о политике сети, которые были обработаны узлом и виртуальным коммутатором, теперь обрабатываются оборудованием на сетевом адаптере. узел и виртуальный коммутатор обходятся. Как правило, возможна низкая задержка и более высокая пропускная способность, а также более *последовательная* задержка и снижение загрузки ЦП при включении ускорения сети.

Ограничения. поддержка ускорения сети должна поддерживаться в ОС виртуальной машины. ее можно включить только при остановке и освобождении виртуальной машины. Невозможно развернуть виртуальную машину с Azure Resource Manager.

Дополнительные сведения см. в инструкциях для [Windows](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-powershell) и [Linux](https://docs.microsoft.com/azure/virtual-network/create-vm-accelerated-networking-cli) .

## <a name="sdk-usage"></a>Использование пакета SDK
* **Установка последней версии пакета SDK**

    Пакеты SDK для Azure Cosmos DB постоянно улучшаются, чтобы обеспечивать самую высокую производительность. Сведения об улучшениях в последней версии пакета SDK см. в статье о [пакете SDK для Azure Cosmos DB](sql-api-sdk-async-java.md).

* **Использование одноэлементного Azure Cosmos DB клиента в течение времени существования приложения**

    Каждый экземпляр клиента Azure Cosmos DB является потокобезопасным и выполняет эффективное управление подключениями и кэширование адресов. Чтобы обеспечить эффективное управление подключениями и повысить производительность клиента Azure Cosmos DB, рекомендуется использовать один экземпляр Azure Cosmos DB клиента на AppDomain в течение всего времени существования приложения.

   <a id="max-connection"></a>

* **Используйте минимальный уровень согласованности, необходимый для приложения**

    При создании *космосклиент*используется согласованность по умолчанию, если не задано явно значение *Session*. Если для логики приложения не требуется согласованность *сеанса* , настройте *согласованность* в *конечном итоге*. Примечание. рекомендуется использовать хотя бы согласованность *сеансов* в приложениях, использующих обработчик веб-канала изменений Azure Cosmos DB.

* **Используйте асинхронный API для максимальной подготовленной пропускной способности**

    Azure Cosmos DB пакета SDK для Java v4 объединяет два API, Sync и Async. В общем, асинхронный API реализует функциональность пакета SDK, тогда как API синхронизации — это тонкая оболочка, которая выполняет блокирование вызовов к асинхронному API. Это отличается от более старого Azure Cosmos DB пакета SDK версии 2 для Java, который был только асинхронным, а также более старой Azure Cosmos DB синхронизации пакета SDK версии 2 для Java, который был только синхронизирован и имел полностью отдельную реализацию. 
    
    Вариант API определяется во время инициализации клиента. *космосасинкклиент* поддерживает асинхронный API, а *Космосклиент* поддерживает API синхронизации. 
    
    Асинхронный API реализует неблокирующие операции ввода-вывода и является оптимальным выбором, если ваша цель — максимально высокая пропускная способность при выдаче запросов Azure Cosmos DB. 
    
    Использование API синхронизации может быть правильным выбором, если вам нужен или нужен API, блокирующий ответ на каждый запрос, или если синхронная операция является главным парадигмой в приложении. Например, API синхронизации может потребоваться при сохранении данных в Azure Cosmos DB в приложении микрослужб, если пропускная способность не является критической.  
    
    Просто имейте в виду, что пропускная способность API синхронизации снижается благодаря увеличению времени ответа на запрос, а асинхронный API-интерфейс может задержать все возможности аппаратной пропускания. 
    
    Географическое размещение может обеспечить более высокую и согласованную пропускную способность при использовании API синхронизации (см. раздел Совместное использование [клиентов в одном регионе Azure для повышения производительности](#collocate-clients)), но по-прежнему не ожидается превышение пропускной способности асинхронного API.

    Некоторые пользователи также могут быть незнакомы с [Project реактора](https://projectreactor.io/). это платформа реактивного потока, используемая для реализации асинхронного API-интерфейса пакета SDK для Java v4 Azure Cosmos DB. Если это важно, мы рекомендуем ознакомиться с нашим [руководством по шаблону реактора](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples/blob/master/reactor-pattern-guide.md) , а затем ознакомиться с этим [введением в реактивное программирование](https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/Intro) . Если вы уже использовали Azure Cosmos DB с асинхронным интерфейсом, а использованный пакет SDK был Azure Cosmos DB Async SDK версии 2 для Java, возможно, вы знакомы с[рксжаваом](https://github.com/ReactiveX/RxJava) [ActiveX](http://reactivex.io/)/, но не уверены, что изменилось в Project реактора. В этом случае ознакомьтесь с нашим [руководством по реактора и рксжава](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples/blob/master/reactor-rxjava-guide.md) , чтобы стать знакомым.

    В следующих фрагментах кода показано, как инициализировать клиент Azure Cosmos DB для асинхронной операции API или API синхронизации соответственно:

    #### <a name="async"></a>[Async](#tab/api-async)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-async-client"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    CosmosAsyncClient client = new CosmosClientBuilder()
        .setEndpoint(HOSTNAME)
        .setKey(MASTERKEY)
        .setConnectionPolicy(CONNECTIONPOLICY)
        .setConsistencyLevel(CONSISTENCY)
        .buildAsyncClient();
    ```

    #### <a name="sync"></a>[Синхронизация](#tab/api-sync)
 
    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-sync-api"></a><a id="java4-sync-client"></a>API-интерфейс синхронизации пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    CosmosClient client = new CosmosClientBuilder()
        .setEndpoint(HOSTNAME)
        .setKey(MASTERKEY)
        .setConnectionPolicy(CONNECTIONPOLICY)
        .setConsistencyLevel(CONSISTENCY)
        .buildClient();
    ```    

    ---

* **Настройка ConnectionPolicy**

    По умолчанию запросы Cosmos DB в режиме прямого режима выполняются по протоколу TCP при использовании Azure Cosmos DB пакета SDK для Java версии 4. На внутреннем уровне пакет SDK использует специальную архитектуру прямого режима для динамического управления сетевыми ресурсами и получения наилучшей производительности.

    В Azure Cosmos DB пакете SDK для Java версии 4 для повышения производительности базы данных с большинством рабочих нагрузок лучше всего подходит режим Direct. 

    * ***Общие сведения о режиме Direct***

        ![Иллюстрация архитектуры прямого режима](./media/performance-tips-async-java/rntbdtransportclient.png)

        Клиентская архитектура, применяемая в режиме прямого доступа, обеспечивает предсказуемое использование сети и мультиплексированный доступ к Azure Cosmos DB репликам. На схеме выше показано, как прямой режим направляет запросы клиентов на реплики в серверной части Cosmos DB. Архитектура прямого режима выделяет до 10 **каналов** на стороне клиента на каждую реплику базы данных. Канал представляет собой TCP-соединение, которому предшествует буфер запроса, который имеет глубину 30 запросов. Каналы, принадлежащие реплике, динамически распределяются по мере необходимости **конечной точкой службы**реплики. Когда пользователь отправляет запрос в режиме прямого подключения, **транспортклиент** направляет запрос в соответствующую конечную точку службы на основе ключа секции. **Очередь** запросов помещает запросы в буфер перед конечной точкой службы.

    * ***Параметры конфигурации ConnectionPolicy для прямого режима***

        Эти параметры конфигурации управляют поведением архитектуры РНТБД, которая управляет поведением пакета SDK прямого режима.
        
        В качестве первого шага используйте следующие рекомендуемые параметры конфигурации ниже. Эти параметры *ConnectionPolicy* являются дополнительными параметрами конфигурации, которые могут повлиять на производительность пакета SDK непредвиденным образом. рекомендуется избегать изменения этих пользователей, если только они не кажутся очень удобными для понимания компромиссов и абсолютно необходимы. Если у вас возникли проблемы с этой конкретной темой, обратитесь к [группе Azure Cosmos DB](mailto:CosmosDBPerformanceSupport@service.microsoft.com) .

        Если в качестве эталонной базы данных используется Azure Cosmos DB (то есть база данных используется для многих операций чтения точки и несколько операций записи), может быть приемлемым задание значения *идлиндпоинттимеаут* равным 0 (то есть без времени ожидания).


        | Параметр конфигурации       | Значение по умолчанию    |
        | :------------------:       | :-----:    |
        | буфферпажесизе             | 8192       |
        | connectionTimeout          | "PT1M"     |
        | идлечаннелтимеаут         | "PT0S"     |
        | идлиндпоинттимеаут        | "PT1M10S"  |
        | максбуфферкапаЦити          | 8388608    |
        | максчаннелсперендпоинт     | 10         |
        | максрекуестсперчаннел      | 30         |
        | рецеивехангдетектионтиме   | "PT1M5S"   |
        | рекуестекспиринтервал      | PT5S     |
        | requestTimeout             | "PT1M"     |
        | рекуесттимерресолутион     | "PT 0,5 S"   |
        | сендхангдетектионтиме      | "PT10S"    |
        | шутдовнтимеаут            | PT15S    |

* **Настройка параллельных запросов для секционированных коллекций**

    Azure Cosmos DB пакет SDK для Java версии 4 поддерживает параллельные запросы, позволяющие параллельно запрашивать секционированную коллекцию. Дополнительные сведения см. в разделе [примеры кода](https://github.com/Azure-Samples/azure-cosmos-java-sql-api-samples) , относящиеся к работе с пакетом SDK для Azure Cosmos DB для Java версии 4. Параллельные запросы предназначены для сокращения задержки при обработке запросов и улучшения пропускной способности посредством их последовательных аналогов.

    * ***Настройка setMaxDegreeOfParallelism\:***
    
        Параллельные запросы работают, запрашивая несколько секций параллельно. Однако данные из каждой секционированной коллекции извлекаются в рамках запроса последовательно. С помощью параметра setMaxDegreeOfParallelism установите значение, соответствующее числу секций, что обеспечит максимальную вероятность высокой производительности запроса при сохранении всех остальных параметров системы. Если вы не знаете количество секций, просто используйте высокое значение для setMaxDegreeOfParallelism. Система автоматически выберет минимальное из двух значений: количество секций или число, указанное пользователем.

        Следует отметить, что параллельные запросы обеспечивают больше преимуществ, если данные равномерно распределены во всех секциях по отношению к запросу. Если коллекция секционируется таким образом, что все или большинство данных, возвращаемых запросом, содержатся в нескольких секциях (в худшем случае в одной), это негативно скажется на производительности запроса.

    * ***Настройка setMaxBufferedItemCount\:***
    
        Параллельный запрос предназначен для предварительного выборки результатов, пока текущий пакет результатов обрабатывается клиентом. Предварительная выборка способствует общему уменьшению задержки при обработке запроса. Значение setMaxBufferedItemCount ограничивает количество предварительно выбираемых результатов. Указав для параметра setMaxBufferedItemCount ожидаемое число возвращаемых результатов (или еще более высокое значение), вы обеспечите максимальное влияние предварительной выборки на производительность запросов.

        Предварительная выборка работает одинаково при любом значении параметра MaxDegreeOfParallelism. Для данных из всех секций применяется один буфер.

* **Развертывание рабочей нагрузки клиента**

    При тестировании на высоких уровнях пропускной способности клиентское приложение может стать узким местом из-за того, что компьютер закрывается при использовании ЦП или использования сети. Если вы достигли этой точки, то можете повысить производительность Azure Cosmos DB, развернув клиентские приложения на нескольких серверах.

    Хорошее правило не превышает >50% использования ЦП на любом заданном сервере, чтобы сократить задержку.

   <a id="tune-page-size"></a>

* **Оптимизация производительности посредством настройки размера страницы для запросов и каналов чтения**

    При выполнении неполного считывания документов с помощью функции чтения канала (например, *реадитемс*) или при выдаче SQL-запроса (*куеритемс*) результаты возвращаются в сегментированном виде, если результирующий набор слишком велик. По умолчанию результаты возвращаются в пакетах (не более 100 элементов и не более 1 МБ в каждом пакете).

    Предположим, что приложение отправляет запрос Azure Cosmos DB и предположим, что приложению требуется полный набор результатов запроса для выполнения задачи. Чтобы уменьшить количество круговых путей, необходимых для получения всех применимых результатов, можно увеличить размер страницы, изменив поле заголовка запроса [x-MS-Max-Item-Count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) . 

    * Для запросов с одной секцией Настройка значения поля [x-MS-Max-Item-Count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) в значение-1 (отсутствие ограничения на размер страницы) увеличивает задержку, минимизируя количество страниц ответов на запросы: либо полный результирующий набор вернется на одной странице, либо если запрос занимает больше времени, чем время ожидания, а полный результирующий набор будет возвращен на минимально допустимое число страниц. Это экономит несколько раз во времени приема-передачи запроса.
    
    * Для запросов между секциями установите для поля [x-MS-Max-Item-Count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) значение – 1 и удалите риски с ограничением размера страницы, которые ПЕРЕГРУЖАЮТ пакет SDK с неуправляемыми размерами страниц. В случае между секциями мы рекомендуем увеличить предельный размер страницы до большого, но конечного значения (возможно, 1000), чтобы сократить задержку. 
    
    В некоторых приложениях может не требоваться полный набор результатов запроса. Если необходимо отобразить только несколько результатов, например, если пользовательский интерфейс или API приложения возвращают только 10 результатов за раз, можно также уменьшить размер страницы до 10, чтобы уменьшить пропускную способность, потребляемую для операций чтения и запросов.

    Можно также задать предпочтительный аргумент размера страницы для метода *бипаже* , вместо того чтобы изменять поле заголовка остальное напрямую. Следует иметь в виду, что [x-MS-Max-Item-Count](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) или предпочтительный аргумент размера страницы *бипаже* устанавливает только верхний предел размера страницы, а не абсолютное требование. так что по ряду причин может появиться Azure Cosmos DB вернуть страницы, размер которых меньше, чем ваш предпочтительный размер страницы. 

* **Использование надлежащего планировщика (избегайте перехвата потоков цикла обработки событий ввода-вывода netty)**

    Асинхронные функции Azure Cosmos DB пакета SDK для Java основаны на неблокирующих операциях ввода-вывода [NETTY](https://netty.io/) . В пакете SDK используется фиксированное число потоков цикла обработки событий ввода-вывода netty (это число соответствует числу ядер ЦП на компьютере) для выполнения операций ввода-вывода. Flux, возвращенный API, выдает результат на один из потоков NETTY общих операций ввода-вывода. Поэтому важно не блокировать общие потоки цикла обработки событий ввода-вывода netty. Интенсивное использование ЦП или блокировка операции в потоке цикла обработки событий ввода-вывода netty может вызвать взаимоблокировку или значительно уменьшить пропускную способность пакета SDK.

    Например, следующий код выполняет рабочую нагрузку с интенсивной нагрузкой на ЦП в потоке цикла обработки событий ввода-вывода netty.
    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-noscheduler"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    Mono<CosmosAsyncItemResponse<CustomPOJO>> createItemPub = asyncContainer.createItem(item);
    createItemPub.subscribe(
        itemResponse -> {
            //this is executed on eventloop IO netty thread.
            //the eventloop thread is shared and is meant to return back quickly.
            //
            // DON'T do this on eventloop IO netty thread.
            veryCpuIntensiveWork();                
        });
    ```

    Если необходимо выполнить обработку полученного результата с интенсивной нагрузкой на ЦП, этого нежелательно делать в потоке цикла обработки событий ввода-вывода netty. Вместо этого можно предоставить собственный планировщик, чтобы предоставить собственный поток для выполнения работы, как показано ниже.

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-scheduler"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    import reactor.core.scheduler.Schedulers;
    Mono<CosmosAsyncItemResponse<CustomPOJO>> createItemPub = asyncContainer.createItem(item);
    createItemPub
        .subscribeOn(Schedulers.elastic())
        .subscribe(
        itemResponse -> {
            //this is executed on eventloop IO netty thread.
            //the eventloop thread is shared and is meant to return back quickly.
            //
            // DON'T do this on eventloop IO netty thread.
            veryCpuIntensiveWork();                
        });
    ```

    В зависимости от типа работы следует использовать для работы соответствующий планировщик реактора. Прочтите [``Schedulers``](https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html)здесь.

    Дополнительные сведения о Azure Cosmos DB пакете SDK для Java v4 см. в [Cosmos DB каталоге пакета Azure SDK для Java на сайте GitHub](https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/cosmos/azure-cosmos).

* **Оптимизация параметров ведения журнала в приложении**

    По различным причинам вам может потребоваться добавить ведение журнала в поток, который создает высокую пропускную способность запроса. Если ваша цель заключается в полной нагрузке подготовленной пропускной способности контейнера с запросами, создаваемыми этим потоком, Оптимизация ведения журнала может значительно повысить производительность.

    * ***Настройка асинхронного средства ведения журнала***

        Задержка синхронного средства ведения журнала обязательно учитывается в общем вычислении задержки для потока, создающего запросы. Асинхронное средство ведения журнала, такое как [log4j2](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Flogging.apache.org%2Flog4j%2Flog4j-2.3%2Fmanual%2Fasync.html&data=02%7C01%7CCosmosDBPerformanceInternal%40service.microsoft.com%7C36fd15dea8384bfe9b6b08d7c0cf2113%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637189868158267433&sdata=%2B9xfJ%2BWE%2F0CyKRPu9AmXkUrT3d3uNA9GdmwvalV3EOg%3D&reserved=0) , рекомендуется использовать для разделения операций записи в журнал из потоков приложений с высокой производительностью.

    * ***Отключить ведение журнала NETTY***

        Ведение журнала NETTY Library — это беседа, и его необходимо отключить (подавление входа в конфигурацию может быть недостаточно) во избежание дополнительных затрат на ЦП. Если вы не используете режим отладки, полностью отключите ведение журналов netty. Поэтому, если вы используете log4j для сокращения дополнительных затрат на ЦП в связи с ``org.apache.log4j.Category.callAppenders()`` из netty, добавьте следующую строку в базу кода:

        ```java
        org.apache.log4j.Logger.getLogger("io.netty").setLevel(org.apache.log4j.Level.OFF);
        ```

 * **Ограничение ресурсов для открытых файлов ОС**
 
    Некоторые системы Linux (например, Red Hat) имеют верхний предел количества открытых файлов и общее число подключений. Чтобы узнать текущие ограничения, выполните следующую команду:

    ```bash
    ulimit -a
    ```

    Число открытых файлов (nofile) должно быть достаточно большим, чтобы было достаточно места для настроенного размера пула подключений и других открытых файлов в ОС. Это число можно изменить для включения поддержки пула подключений большего размера.

    Откройте файл limits.conf:

    ```bash
    vim /etc/security/limits.conf
    ```
    
    Добавьте или измените следующие строки:

    ```
    * - nofile 100000
    ```

* **Указание ключа секции в операциях записи точки**

    Чтобы повысить производительность операций записи точки, укажите ключ секции элемента в вызове API точки Write, как показано ниже:

    #### <a name="async"></a>[Async](#tab/api-async)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-createitem-good-async"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    asyncContainer.createItem(item,new PartitionKey(pk),new CosmosItemRequestOptions()).block();
    ```

    #### <a name="sync"></a>[Синхронизация](#tab/api-sync)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-sync-api"></a><a id="java4-createitem-good-sync"></a>API-интерфейс синхронизации пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    syncContainer.createItem(item,new PartitionKey(pk),new CosmosItemRequestOptions());
    ```

    ---

    Вместо того, чтобы предоставлять только экземпляр элемента, как показано ниже:

    #### <a name="async"></a>[Async](#tab/api-async)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-createitem-bad-async"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    asyncContainer.createItem(item).block();
    ```

    #### <a name="sync"></a>[Синхронизация](#tab/api-sync)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-sync-api"></a><a id="java4-createitem-bad-sync"></a>API-интерфейс синхронизации пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    syncContainer.createItem(item);
    ```

    ---

    Последняя поддерживается, но добавляет задержку в приложение; пакет SDK должен проанализировать элемент и извлечь ключ секции.

## <a name="indexing-policy"></a>Политика индексации
 
* **Исключить неиспользуемые пути из индексирования для ускорения операций записи**

    Политика индексирования Azure Cosmos DB позволяет добавлять к индексированию или исключать из индексирования определенные пути к документам, используя механизм Indexing Paths (setIncludedPaths и setExcludedPaths). Возможность управления путями индексирования позволяет оптимизировать производительность записи и снизить затраты на хранение индекса для сценариев с заранее определенными шаблонами запросов. Это связано с тем, что затраты на индексирование непосредственно зависят от количества уникальных путей индексирования. Например, в следующем коде показано, как исключить весь раздел документов (также называемых поддеревом) из индексирования с помощью подстановочного знака "*".

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos"></a><a id="java4-indexing"></a>Пакет SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)
    ```java
    Index numberIndex = Index.Range(DataType.Number);
    indexes.add(numberIndex);
    includedPath.setIndexes(indexes);
    includedPaths.add(includedPath);
    indexingPolicy.setIncludedPaths(includedPaths);        
    containerProperties.setIndexingPolicy(indexingPolicy);
    ``` 

    Дополнительные сведения см. в статье [Политики индексации Azure Cosmos DB](indexing-policies.md).

## <a name="throughput"></a>Пропускная способность
<a id="measure-rus"></a>

* **Измерение и настройка расхода единиц запроса/повторного использования**

    Azure Cosmos DB предоставляет обширный набор операций с документами в коллекции базы данных, в том числе реляционные и иерархические запросы с использованием UDF, хранимых процедур и триггеров. Затраты, связанные с каждой из этих операций, зависят от типа процессора, операций ввода-вывода и памяти, необходимой для завершения операции. Вместо того чтобы думать о закупке и управлении аппаратными ресурсами, вы можете думать о единице запроса (RU) как единой меры для ресурсов, необходимых для выполнения различных операций с базами данных и обслуживания запросов приложений.

    Пропускная способность выделяется на основе количества [единиц запроса](request-units.md), заданного для каждого контейнера. Удельный расход единиц запросов оценивается в расчете на одну секунду. Частота запросов для приложений, у которых она превышает подготовленные единицы запросов для контейнера, будет ограничена, пока она не упадет ниже зарезервированного для контейнера уровня. Если приложению требуется более высокий уровень пропускной способности, можно увеличить ее путем выделения дополнительных единиц запросов.

    Сложность запроса влияет на количество единиц запроса, потребляемых операцией. Количество предикатов и их характер, количество определяемых пользователем функций и размер набора исходных данных — все это влияет на плату за операции запроса.

    Чтобы оценить расходы на любую операцию (создание, обновление или удаление), проверьте значение заголовка [x-ms-request-charge](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers). Это значение содержит число единиц запроса, потребляемых соответствующей операцией. Вы также можете просмотреть эквивалентное свойство RequestCharge в ResourceResponse\<t> или FeedResponse\<t>.

    #### <a name="async"></a>[Async](#tab/api-async)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-async-api"></a><a id="java4-request-charge-async"></a>Асинхронный API пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)

    ```java
    CosmosAsyncItemResponse<CustomPOJO> response = asyncContainer.createItem(item).block();

    response.getRequestCharge();
    ```     

    #### <a name="sync"></a>[Синхронизация](#tab/api-sync)

    ### <a name="java-sdk-v4-maven-comazureazure-cosmos-sync-api"></a><a id="java4-request-charge-sync"></a>API-интерфейс синхронизации пакета SDK для Java V4 (Maven com. Azure:: Azure-Cosmos)    

    ```java
    CosmosItemResponse<CustomPOJO> response = syncContainer.createItem(item);

    response.getRequestCharge();
    ```     

    ---

    Стоимость запроса, указанная в этом заголовке, учитывается как часть подготовленной пропускной способности. Например, если вы предоставили 2000 единиц запроса в секунду, а приведенный выше запрос возвращает 1000 документов размером по 1 КБ каждый, затраты на операцию составят 1000 единиц. Таким образом, перед ограничением частоты выполнения последующих запросов сервер за одну секунду выполняет только два таких запроса. Чтобы узнать больше, ознакомьтесь с [единицами запроса](request-units.md) и [калькулятором единиц запроса](https://www.documentdb.com/capacityplanner).

<a id="429"></a>
* **Обработка ограничения скорости / слишком высокая частота запросов**

    Выполнение запроса, который превышает лимит зарезервированной пропускной способности для учетной записи, не приводит к снижению производительности сервера, так как пользователь не сможет превысить это зарезервированное значение. Сервер будет завершать запрос с помощью ошибкой requestratetoolarge (код состояния HTTP 429) и вернуть заголовок [x-MS-Retry-After-MS](/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) , указывающий время ожидания (в миллисекундах), по истечении которого пользователь должен подождать, прежде чем повторить попытку запроса.

        HTTP Status 429,
        Status Line: RequestRateTooLarge
        x-ms-retry-after-ms :100

    Пакеты SDK перехватят этот ответ, обработают заголовок retry-after, указанный сервером, и отправят запрос повторно. Если к вашей учетной записи параллельно имеет доступ только один клиент, следующая попытка будет успешной.

    При наличии более чем одного клиента, постоянно работающего над частотой запросов, число повторных попыток по умолчанию, установленное на уровне 9, может быть недостаточным. в этом случае клиент выдает приложению исключение *космосклиентексцептион* с кодом состояния 429. Число повторных попыток по умолчанию можно переопределить в свойстве setRetryOptions экземпляра ConnectionPolicy. По умолчанию *космосклиентексцептион* с кодом состояния 429 возвращается после совокупного времени ожидания 30 секунд, если запрос будет продолжать работать выше скорости запросов. Это происходит, даже если текущее значение количества повторных попыток (по умолчанию (9) или определенное пользователем) меньше максимального значения.

    Хотя автоматическая процедура отправки повторного запроса позволяет улучшить устойчивость приложений и повысить удобство работы с ними, она может снизить производительность, что, в свою очередь, станет причиной появления более длительных задержек. Если настройка производительности повлияла на регулирование сервера и стала причиной автоматической отправки запросов пакетом SDK, это может стать причиной появления пиков задержек на стороне клиента. Чтобы избежать пиков задержек во время настройки производительности, проверьте расход ресурсов на каждую операцию и убедитесь, что значение частоты запросов не превышено. Дополнительные сведения см. в статье [Единицы запросов в DocumentDB](request-units.md).

* **Использование меньших документов для более высокой пропускной способности**

    Стоимость запроса (плата за обработку запроса) для каждой операции напрямую зависит от размера документа. За операции с большими документами взимается больше единиц запроса, чем за операции с мелкими документами. В идеале вы можете спроектировать приложение и рабочие процессы, чтобы размер элемента был не 1 КБ, или иметь одинаковый порядок или величину. Для приложений, учитывающих задержку, следует избегать работы документов с несколькими МЕГАБАЙТами, что замедляет работу приложения.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о создании приложения с высокой масштабируемостью и производительностью см. в статье [Partitioning and scaling in Azure Cosmos DB](partition-data.md) (Секционирование и масштабирование в Azure Cosmos DB).
