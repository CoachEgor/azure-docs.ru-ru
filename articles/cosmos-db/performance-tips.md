---
title: Советы по повышению производительности Azure Cosmos DB и .NET
description: Изучите параметры конфигурации клиента, чтобы повысить производительность DB Azure Cosmos.
author: SnehaGunda
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 01/15/2020
ms.author: sngun
ms.openlocfilehash: 68a9a7d5f90831bb2e0c9284cb71ae4b92edffad
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "80131406"
---
# <a name="performance-tips-for-azure-cosmos-db-and-net"></a>Советы по повышению производительности для .NET в Azure Cosmos DB

> [!div class="op_single_selector"]
> * [Async Java](performance-tips-async-java.md)
> * [Java](performance-tips-java.md)
> * [.NET](performance-tips.md)
> 

Azure Cosmos DB — быстрая и гибкая распределенная база данных, которая легко масштабируется с гарантированной задержкой и пропускной способностью. Вам не нужно вносить значительные изменения архитектуры или писать сложный код для масштабирования базы данных с помощью Azure Cosmos DB. Для увеличения или уменьшения масштаба достаточно выполнить один вызов API. Дополнительные сведения см. в разделах [о подготовке пропускной способности контейнера](how-to-provision-container-throughput.md) и [о подготовке пропускной способности базы данных](how-to-provision-database-throughput.md). Но поскольку доступ к Azure Cosmos DB доступен через сетевые звонки, есть оптимизация на стороне клиента, которые вы можете сделать для достижения максимальной производительности при использовании [S'L .NET SDK.](sql-api-sdk-dotnet-standard.md)

Итак, если вы пытаетесь улучшить производительность базы данных, рассмотрим следующие параметры:

## <a name="hosting-recommendations"></a>Рекомендации по хостингу

**Для обработки рабочих нагрузок с интенсивными запросами используйте Windows 64-разрядная вместо Linux или 32-битной обработки хоста windows**

Мы рекомендуем Windows 64-разрядная обработка хоста для повышения производительности. SDK с S'L включает в себя наиболее ServiceInterop.dll для разбора и оптимизации запросов локально. ServiceInterop.dll поддерживается только на платформе Windows x64. Для Linux и других неподдерживаемых платформ, где ServiceInterop.dll недоступен, к шлюзу делается дополнительный сетевой вызов для получения оптимизированного запроса. Следующие типы приложений используют 32-битную обработку хоста по умолчанию. Чтобы изменить обработку хоста на 64-битную обработку, выполните следующие действия, в зависимости от типа приложения:

- Для исполняемых приложений можно изменить обработку хоста, установив [цель платформы](https://docs.microsoft.com/visualstudio/ide/how-to-configure-projects-to-target-platforms?view=vs-2019) **на x64** в окне **Project Properties** на вкладке **«Сборка».**

- Для тестовых проектов на основе VSTest можно изменить обработку хоста, выбрав **Test** > **тестовую настройку** > **по умолчанию в качестве X64** в меню Визуальной студии **испытаний.**

- Для локально развернутых ASP.NET веб-приложений можно изменить обработку хоста, выбрав **64-битную версию IIS Express для веб-сайтов и проектов** в рамках**проектов** > и**веб-проектов** **«Инструменты** > **параметры».** > 

- Для ASP.NET веб-приложений, развернутых в Azure, можно изменить обработку хоста, выбрав **64-битную** платформу в **настройках приложений** на портале Azure.

> [!NOTE] 
> По умолчанию новые проекты Visual Studio устанавливаются на **любой процессор.** Мы рекомендуем настроить проект на **x64,** чтобы он не переключался на **x86.** Проект, установленный для **любого процессора,** может легко переключиться на **x86,** если добавлена зависимость только для x86.<br/>
> ServiceInterop.dll должен быть в папке, из которого выполняется SDK DLL. Это должно вызывать беспокойство только в том случае, если вы вручную копируете DLL или имеете пользовательские системы сборки/развертывания.
    
**Включите сбор мусора на стороне сервера (GC)**

Снижение частоты вывоза мусора может помочь в некоторых случаях. В .NET установите `true` [gcServer](https://msdn.microsoft.com/library/ms229357.aspx) .

**Масштабирование рабочей нагрузки клиента**

Если вы тестируете на высоком уровне пропускной связи (более 50 000 ru/s), клиентское приложение может стать узким местом из-за того, что машина укупорки на процессоре или использование сети. Если вы достигли этой точки, то можете повысить производительность Azure Cosmos DB, развернув клиентские приложения на нескольких серверах.

> [!NOTE] 
> Высокое использование процессора может привести к увеличению задержки и исключениям тайм-аута запроса.

## <a name="networking"></a>Сети
<a id="direct-connection"></a>

**Политика подключения: использование режима прямого подключения**

То, как клиент подключается к DB Azure Cosmos, имеет важные последствия для производительности, особенно для наблюдаемой задержки на стороне клиента. Для настройки политики подключения клиента доступны две настройки ключевых параметров: *режим* подключения и *протокол*соединения.  DocumentDB предоставляет два режима подключения:

   * Режим шлюза
      
     Режим шлюза поддерживается на всех платформах SDK и является настроенным по умолчанию для [Microsoft.Azure.DocumentDB SDK.](sql-api-sdk-dotnet.md) Если приложение работает в корпоративной сети со строгими ограничениями брандмауэра, режим шлюза является лучшим выбором, поскольку он использует стандартный порт HTTPS и одну конечную точку. Компромисс производительности, однако, заключается в том, что режим шлюза включает в себя дополнительный сетевой переход каждый раз, когда данные считываются или записываются в Azure Cosmos DB. Таким образом, прямой режим обеспечивает лучшую производительность, поскольку количество сетевого хмеля меньше. Мы также рекомендуем режим подключения шлюза при запуске приложений в средах, которые имеют ограниченное количество соединений розетки.

     При использовании SDK в функциях Azure, особенно в [плане потребления,](../azure-functions/functions-scale.md#consumption-plan)следует знать о [текущих ограничениях на соединения.](../azure-functions/manage-connections.md) В этом случае режим шлюза может быть лучше, если вы также работаете с другими клиентами на основе HTTP в приложении Azure Functions.

   * Прямой режим

     Прямой режим поддерживает подключение через протокол TCP и является режимом подключения по умолчанию, если вы используете [Microsoft.Azure.Cosmos/.NET V3 SDK.](sql-api-sdk-dotnet-standard.md)

В режиме шлюза Azure Cosmos DB использует порт 443 и порты 10250, 10255 и 10256 при использовании API DB Azure Cosmos DB для MongoDB. Порт 10250 карты по умолчанию MongoDB экземпляр без гео-репликации. Порты 10255 и 10256 карта на экземпляр MongoDB, который имеет георепликацию.
     
При использовании TCP в прямом режиме, в дополнение к портам шлюза, необходимо обеспечить, чтобы диапазон портов между 10000 и 20000 был открыт, потому что Azure Cosmos DB использует динамические порты TCP. Если эти порты не открыты и вы пытаетесь использовать TCP, вы получаете ошибку 503 Службы Недоступной. В этой таблице показаны режимы подключения, доступные для различных API и портов служб, используемых для каждого API:

|Режим подключения  |Поддерживаемый протокол  |Поддерживаемые пакеты SDK  |API и порт службы  |
|---------|---------|---------|---------|
|Шлюз  |   HTTPS    |  Все SDK    |   СЗЛ (443), MongoDB (10250, 10255, 10256), Таблица (443), Кассандра (10350), График (443)    |
|Прямой доступ    |     TCP    |  Пакет SDK для .NET    | Порты в диапазоне от 10000 до 20000 |

Azure Cosmos DB предлагает простую, открытую модель программирования RESTful по сравнению с HTTPS. Кроме того, предлагается эффективный протокол TCP, который также является RESTful в своей коммуникационной модели и доступен через клиентский пакет SDK для .NET. Протокол TCP использует SSL для первоначальной аутентификации и шифрования трафика. Чтобы добиться лучшей производительности, рекомендуется по возможности использовать протокол TCP.

Для SDK V3 вы настраиваете режим `CosmosClient` соединения при `CosmosClientOptions`создании экземпляра в. Помните, что прямой режим по умолчанию.

```csharp
var serviceEndpoint = new Uri("https://contoso.documents.net");
var authKey = "your authKey from the Azure portal";
CosmosClient client = new CosmosClient(serviceEndpoint, authKey,
new CosmosClientOptions
{
    ConnectionMode = ConnectionMode.Gateway // ConnectionMode.Direct is the default
});
```

Для Microsoft.Azure.DocumentDB SDK вы настраиваете режим соединения `DocumentClient` во время `ConnectionPolicy` построения экземпляра с помощью параметра. Если вы используете `Protocol` прямой режим, вы `ConnectionPolicy` также можете установить с помощью параметра.

```csharp
var serviceEndpoint = new Uri("https://contoso.documents.net");
var authKey = "your authKey from the Azure portal";
DocumentClient client = new DocumentClient(serviceEndpoint, authKey,
new ConnectionPolicy
{
   ConnectionMode = ConnectionMode.Direct, // ConnectionMode.Gateway is the default
   ConnectionProtocol = Protocol.Tcp
});
```

Поскольку TCP поддерживается только в прямом режиме, если вы используете режим шлюза, протокол HTTPS всегда используется для связи с шлюзом, и `Protocol` значение в `ConnectionPolicy` игнорируется.

![Политика подключения Azure Cosmos DB](./media/performance-tips/connection-policy.png)

**Использование вызовов OpenAsync для избежания задержки при выполнении первого запроса**

По умолчанию первый запрос имеет более высокую задержку, поскольку он должен получить таблицу адресной рамы. При использовании [SDK V2,](sql-api-sdk-dotnet.md)вызов `OpenAsync()` один раз во время инициализации, чтобы избежать этой задержки запуска по первому запросу:

    await client.OpenAsync();

> [!NOTE] 
> `OpenAsync`будет генерировать запросы для получения таблицы адресной рамини для всех контейнеров в учетной записи. Для учетных записей, которые имеют много контейнеров, `OpenAsync` но приложение которого получает доступ к подмножестве из них, будет генерировать ненужный объем трафика, что сделает инициализацию медленной. Поэтому `OpenAsync` использование может оказаться нецелесообразным в этом сценарии, поскольку замедляет запуск приложения.

   <a id="same-region"></a>
**Для производительности, collocate клиентов в том же регионе Azure**

По возможности разместите приложения, которые называются Azure Cosmos DB, в том же регионе, что и база данных Azure Cosmos DB. Вот приблизительное сравнение: звонки в Azure Cosmos DB в пределах 1 мс до 2 мс, но задержка между западным и восточным побережьем США составляет более 50 мс. Эта задержка может варьироваться от запроса к запросу, в зависимости от маршрута, проложенного запросом при переходе от клиента к границе центра обработки данных Azure. Вы можете получить наименьшую задержку, гарантируя, что приложение вызова находится в пределах того же региона Azure, что и подготовленная конечная точка Azure Cosmos DB. Список доступных регионов можно найти в [регионах Azure.](https://azure.microsoft.com/regions/#services)

![Политика](./media/performance-tips/same-region.png) подключения Azure Cosmos DB<a id="increase-threads"></a>

**Увеличьте количество потоков/задач**

Поскольку звонки в DB Azure Cosmos выполняются по сети, возможно, потребуется изменить степень параллелизма запросов, чтобы клиентское приложение проводило минимальное время в ожидании между запросами. Например, если вы используете [«Параллельную библиотеку задач](https://msdn.microsoft.com//library/dd460717.aspx).NET», создайте в порядке сотни задач, которые читаются или пишутся в Azure Cosmos DB.

**Включить ускоренную сеть**
 
 Чтобы уменьшить задержку и дразните процессора, мы рекомендуем включить ускоренную сеть на клиентских виртуальных машинах. Смотрите [Создать виртуальную машину Windows с ускоренной сети](../virtual-network/create-vm-accelerated-networking-powershell.md) или создать Linux [виртуальную машину с ускоренной сети.](../virtual-network/create-vm-accelerated-networking-cli.md)

## <a name="sdk-usage"></a>Использование пакета SDK
**Установка последней версии пакета SDK**

Пакеты SDK для Azure Cosmos DB постоянно улучшаются, чтобы обеспечивать самую высокую производительность. Сведения об улучшениях в последней версии пакета SDK см. в статье о [пакете SDK для Azure Cosmos DB](sql-api-sdk-dotnet-standard.md).

**Использование stream AIS**

[.NET SDK V3](sql-api-sdk-dotnet-standard.md) содержит Stream AIS, которые могут получать и возвращать данные без сериализации. 

Приложения среднего уровня, которые не потребляют ответы непосредственно из SDK, но передают их другим уровням приложений, могут извлечь выгоду из AIS потока. Ознакомьтесь с примерами [управления элементами](https://github.com/Azure/azure-cosmos-dotnet-v3/blob/master/Microsoft.Azure.Cosmos.Samples/Usage/ItemManagement) для примеров обработки потоков.

**Используйте однотонный DB-клиент Azure Cosmos в течение всего срока службы приложения**

`DocumentClient` Каждый `CosmosClient` экземпляр является безопасным для потоков и выполняет эффективное управление подключением и кэширование мейкинга при работе в прямом режиме. Для обеспечения эффективного управления подключением и повышения производительности клиента `AppDomain` SDK мы рекомендуем использовать один экземпляр за время службы приложения.

   <a id="max-connection"></a>

**Увеличьте System.Net MaxConnections на узла при использовании режима шлюза**

Запросы Azure Cosmos DB выполняются по httpS/REST при использовании режима шлюза. Они подвергаются ограничению подключения по умолчанию на имя хоста или IP-адрес. Возможно, потребуется `MaxConnections` установить более высокое значение (от 100 до 1000), чтобы библиотека клиентов могла использовать несколько одновременных подключений к DB Azure Cosmos. В .NET SDK 1.8.0 и позже значение по умолчанию для [ServicePointManager.DefaultConnectionLimit](https://msdn.microsoft.com/library/system.net.servicepointmanager.defaultconnectionlimit.aspx) составляет 50. Чтобы изменить значение, можно установить [Documents.Client.ConnectionPolicy.MaxConnectionLimit](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.connectionpolicy.maxconnectionlimit.aspx) на более высокое значение.

**Настройка параллельных запросов для разделенных коллекций**

S'L .NET SDK 1.9.0 и позже поддерживают параллельные запросы, которые позволяют параллельно запрашивать разделительную коллекцию. Дополнительные сведения см. в [примерах кода](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/Queries/Program.cs) для работы с пакетами SDK. Параллельные запросы предназначены для обеспечения лучшей задержки запроса и пропускной их пропускной ситуации, чем их серийный аналог. Параллельные запросы предоставляют два параметра, которые можно настроить в соответствии с требованиями: 
- `MaxDegreeOfParallelism`контролирует максимальное количество разделов, которые могут быть запрошены параллельно. 
- `MaxBufferedItemCount`контролирует количество предварительных результатов.

***Степень тюнинга параллелизма***

Параллельный запрос работает путем параллельного запроса нескольких разделов. Но данные из отдельного раздела извлекаются последовательно по отношению к запросу. Установка `MaxDegreeOfParallelism` в [SDK V2](sql-api-sdk-dotnet.md) или `MaxConcurrency` в [SDK V3](sql-api-sdk-dotnet-standard.md) на количество разделов имеет наилучшие шансы на достижение самого перформативного запроса при условии, что все остальные системные условия останутся прежними. Если вы не знаете количество разделов, вы можете установить степень параллелизма до большого числа. Система будет выбирать минимальную (количество разделов, пользовательский входный) в качестве степени параллелизма.

Обратите внимание, что параллельные запросы приносят наибольшую пользу, если данные равномерно распределены по всем разделам по отношению к запросу. Если разделительный сбор разделен таким образом, чтобы все или большая часть данных, возвращенных запросом, была сосредоточена в нескольких разделах (один раздел является наихудшим случаем), эти разделы будут узкой стороной производительности запроса.

***Тюнинг MaxBufferedItemCount***
    
Параллельный запрос предназначен для предварительных результатов, в то время как текущая партия результатов обрабатывается клиентом. Это предварительное извлечение помогает улучшить общую задержку запроса. Параметр `MaxBufferedItemCount` ограничивает количество предварительных результатов. Установите `MaxBufferedItemCount` ожидаемое количество возвращенных результатов (или большее число), чтобы запрос получил максимальную выгоду от предварительного получения.

Предварительная обработка работает одинаково, независимо от степени параллелизма, и есть единый буфер для данных из всех разделов.  

**Реализация интервала задержки для RetryAfter**

Во время тестирования производительности следует увеличивать нагрузку до тех пор, пока не будет задушена небольшая скорость запросов. Если запросы задушены, клиентское приложение должно отступить на дроссельной заслонке для сервера, указанного в интервале повтора. Уважение backoff гарантирует, что вы тратите минимальное количество времени на ожидание между повторами. 

Поддержка политики повторного рейза включена в следующие SDK:
- Версия 1.8.0 и более поздняя [версия .NET SDK для S'L](sql-api-sdk-dotnet.md) и [Java SDK для S'L](sql-api-sdk-java.md)
- Версия 1.9.0 и более поздняя [SDK Node.js для S'L](sql-api-sdk-node.md) и [Python SDK для S'L](sql-api-sdk-python.md)
- Все поддерживаемые версии [SDK .NET Core](sql-api-sdk-dotnet-core.md) 

Для получения дополнительной [информации, см. RetryAfter](https://msdn.microsoft.com/library/microsoft.azure.documents.documentclientexception.retryafter.aspx).
    
В версии 1.19 и позднее .NET SDK существует механизм регистрации дополнительной диагностической информации и проблем с задержкой устранения неполадок, как показано в следующем примере. Вы можете зарегистрировать строку диагностики для запросов с высокой задержкой чтения. Захваченная диагностическая строка поможет вам понять, сколько раз вы получили 429 ошибок для данного запроса.

```csharp
ResourceResponse<Document> readDocument = await this.readClient.ReadDocumentAsync(oldDocuments[i].SelfLink);
readDocument.RequestDiagnosticsString 
```

**Кэширование URI документов для снижения задержки чтения**

Чтобы повысить производительность операций чтения, по возможности выполняйте кэширование URI документов. Необходимо определить логику для кэша идентификатора ресурса при создании ресурса. Поиски, основанные на идообработке ресурсов, быстрее, чем поиск на основе имен, поэтому кэширование этих значений повышает производительность.

   <a id="tune-page-size"></a>
**Настройте размер страницы для запросов/чтения каналов для повышения производительности**

При массовом чтении документов с помощью функциональности `ReadDocumentFeedAsync`чтения (например, ) или при выдаче запроса на S'L результаты возвращаются сегментированным способом, если набор результатов слишком велик. По умолчанию результаты возвращаются в пакетах (не более 100 элементов и не более 1 МБ в каждом пакете).

Чтобы уменьшить количество сетевых поездок, необходимых для получения всех применимых результатов, можно увеличить размер страницы, используя [x-ms-max-item-count,](https://docs.microsoft.com/rest/api/cosmos-db/common-cosmosdb-rest-request-headers) чтобы запросить до 1000 заголовков. Когда вам нужно отобразить только несколько результатов, например, если пользовательский интерфейс или API приложения возвращает только 10 результатов одновременно, можно также уменьшить размер страницы до 10, чтобы уменьшить пропускную выемку, потребленную для чтения и запросов.

> [!NOTE] 
> Свойство `maxItemCount` не должно быть использовано только для pagination. Его основное использование заключается в повышении производительности запросов за счет сокращения максимального количества элементов, возвращенных на одной странице.  

Вы также можете установить размер страницы, используя доступные SDK Azure Cosmos DB. Свойство [MaxItemCount](/dotnet/api/microsoft.azure.documents.client.feedoptions.maxitemcount?view=azure-dotnet) в `FeedOptions` позволяет установить максимальное количество элементов, которые будут возвращены в операции перечисления. При `maxItemCount` установке на -1 SDK автоматически находит оптимальное значение в зависимости от размера документа. Пример:
    
```csharp
IQueryable<dynamic> authorResults = client.CreateDocumentQuery(documentCollection.SelfLink, "SELECT p.Author FROM Pages p WHERE p.Title = 'About Seattle'", new FeedOptions { MaxItemCount = 1000 });
```
    
При выполнении запроса полученные данные отправляются в пакет TCP. Если указать слишком `maxItemCount`низкое значение для, количество поездок, необходимых для отправки данных в пакете TCP, является высоким, что влияет на производительность. Так что если вы не уверены, `maxItemCount` какое значение установить для свойства, лучше установить его до -1 и позволить SDK выбрать значение по умолчанию.

**Увеличьте количество потоков/задач**

[См. Увеличьте количество потоков/задач](#increase-threads) в разделе Сетевые сети этой статьи.

## <a name="indexing-policy"></a>Политика индексации
 
**Исключить неиспользованные пути от индексации для более быстрой записи**

Политика индексирования Azure Cosmos DB также позволяет указать, какие пути документа включать или исключать из индексации с помощью траекторий индексации (IndexingPolicy.IncludedPaths и IndexingPolicy.ExcludedPaths). Пути индексирования могут повысить производительность записи и уменьшить хранилище индексов для сценариев, в которых заранее известны шаблоны запросов. Это связано с тем, что затраты на индексацию напрямую коррелируют с числом индексированных уникальных путей. Например, в этом коде показано, как исключить весь раздел документов (подтри) из индексации с помощью подстановочного знака "К":

```csharp
var collection = new DocumentCollection { Id = "excludedPathCollection" };
collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/*" });
collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");
collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), excluded);
```

Дополнительные сведения см. в статье [Политики индексации Azure Cosmos DB](index-policy.md).

## <a name="throughput"></a>Пропускная способность
<a id="measure-rus"></a>

**Измерение и настройка для более низких единиц запроса/второго использования**

Azure Cosmos DB предлагает богатый набор операций с базами данных. Эти операции включают реляционные и иерархические запросы с UDF, сохраненные процедуры и триггеры, все работающие на документах в коллекции баз данных. Затраты, связанные с каждой из этих операций, варьируются в зависимости от процессора, исправления и памяти, необходимых для завершения операции. Вместо того, чтобы думать о аппаратных ресурсах и управлять ими, можно считать группу запросов (RU) единой мерой для ресурсов, необходимых для выполнения различных операций базы данных и обслуживания запроса приложения.

Пропускная стоимость предоставляется в зависимости от количества [единиц запроса,](request-units.md) установленных для каждого контейнера. Потребление единицы запроса оценивается как ставка в секунду. Заявки, превышаюющие установленную коэффициентом единицы запроса для контейнера, ограничены до тех пор, пока ставка не опустится ниже установленного уровня для контейнера. Если ваше приложение требует более высокого уровня пропускной выхастовой пропускной выемы, вы можете увеличить пропускную стоимость за счет предоставления дополнительных единиц запроса.

Сложность запроса влияет на количество единиц запроса, потребляемых для операции. Количество предикатов, характер предикатов, количество ОДС и размер исходного набора данных влияют на стоимость операций запроса.

Чтобы измерить накладные расходы любой операции (создать, обновить или удалить), проинспектировать `FeedResponse\<T>` заголовок [x-ms-request-charge](https://docs.microsoft.com/rest/api/cosmos-db/common-cosmosdb-rest-response-headers) (или эквивалентное `RequestCharge` свойство в `ResourceResponse\<T>` или в .NET SDK) для измерения количества единиц запроса, потребляемых в ходе операций:

```csharp
// Measure the performance (Request Units) of writes
ResourceResponse<Document> response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);
Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);
// Measure the performance (Request Units) of queries
IDocumentQuery<dynamic> queryable = client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();
while (queryable.HasMoreResults)
    {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>();
        Console.WriteLine("Query batch consumed {0} request units", queryResponse.RequestCharge);
    }
```             

Плата за запрос, возвращенная в этом заголовке, составляет часть вашей прокладки (т.е. 2000 RUs/second). Например, если предыдущий запрос возвращает 1000 документов 1-KB, стоимость операции составляет 1000. Таким образом, в течение одной секунды сервер выполняет только два таких запроса, прежде чем скорость, ограничивающая более поздние запросы. Для получения дополнительной информации [Request Unit calculator](https://www.documentdb.com/capacityplanner) [см.](request-units.md)
<a id="429"></a>

**Обработка ограничения скорости / слишком высокая частота запросов**

Когда клиент пытается превысить зарезервированную пропускную способность для учетной записи, на сервере нет снижения производительности и нет использования пропускной способности сверх зарезервированного уровня. Сервер упреждаю, завершит запрос с помощью RequestRateTooLarge (код статуса HTTP 429). Он вернет [заголовок x-ms-retry-after-ms,](https://docs.microsoft.com/rest/api/cosmos-db/common-cosmosdb-rest-response-headers) указывающий количество времени в миллисекундах, которое пользователь должен подождать, прежде чем пытаться снова поставить запрос.

    HTTP Status 429,
    Status Line: RequestRateTooLarge
    x-ms-retry-after-ms :100

Пакеты SDK перехватят этот ответ, обработают заголовок retry-after, указанный сервером, и отправят запрос повторно. Если к вашей учетной записи параллельно имеет доступ только один клиент, следующая попытка будет успешной.

Если у вас более одного клиента, совокупно работающего последовательно выше скорости запроса, количество повторений по умолчанию, установленное в настоящее время до 9 внутренне клиентом, может не хватить. В этом случае клиент бросает в приложение DocumentClientException с кодом статуса 429. 

Можно изменить значение повторного выполнения `RetryOptions` по `ConnectionPolicy` умолчанию, установив экземпляр. По умолчанию в случае превышения заданного счетчика повторов исключение DocumentClientException с кодом состояния 429 возвращается через 30 секунд (совокупное время ожидания). Эта ошибка возвращается даже тогда, когда текущее количество повтора меньше, чем максимальное количество повторений, независимо от того, является ли текущее значение значением по умолчанию 9 или значением, определенным пользователем.

Автоматизированное поведение повтора помогает повысить устойчивость и удобство использования для большинства приложений. Но это может быть не лучшим поведением, когда вы делаете тесты производительности, особенно когда вы измеряете задержку. Если настройка производительности повлияла на регулирование сервера и стала причиной автоматической отправки запросов пакетом SDK, это может стать причиной появления пиков задержек на стороне клиента. Чтобы избежать пиков задержек во время настройки производительности, проверьте расход ресурсов на каждую операцию и убедитесь, что значение частоты запросов не превышено. Для получения дополнительной информации [см.](request-units.md)

**Для более высокой пропускной воды, дизайн для небольших документов**

Плата за запрос (т.е. стоимость обработки запросов) данной операции напрямую коррелирует с размером документа. Операции по крупным документам стоят дороже, чем операции по небольшим документам.

## <a name="next-steps"></a>Дальнейшие действия
Для примера приложения, используемого для оценки Azure Cosmos DB для высокопроизводительных сценариев на нескольких клиентских машинах, см. [Производительность и масштаб тестирования с Azure Cosmos DB.](performance-testing.md)

Дополнительные сведения о создании приложения с высокой масштабируемостью и производительностью см. в статье [Partitioning and scaling in Azure Cosmos DB](partition-data.md) (Секционирование и масштабирование в Azure Cosmos DB).
