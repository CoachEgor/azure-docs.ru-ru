---
title: Моделирование данных в Azure Cosmos DB
titleSuffix: Azure Cosmos DB
description: Сведения о моделировании данных в базах данных NoSQL и различиях между моделированием данных в реляционной базе данных и базе данных документов.
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 07/23/2019
ms.openlocfilehash: 523049ea3286445117f41147f3dd12a2c911d1ae
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "72755014"
---
# <a name="data-modeling-in-azure-cosmos-db"></a>Моделирование данных в Azure Cosmos DB

В то время как базы данных, свободные от схем, такие как Azure Cosmos DB, позволяют очень легко хранить и заготавливать неструктурированные и полуструктурированные данные, следует потратить некоторое время на обдумывание модели данных, чтобы получить максимальную отдачу от сервиса с точки зрения производительности и масштабируемости и самой низкой Стоимость.

Как данные будут храниться? Как приложение будет получать данные и выполнять запросы по ним? Является ли ваше приложение читать-тяжелый, или писать тяжелые?

После прочтения этой статьи вы сможете ответить на следующие вопросы:

* Что такое моделирование данных и почему оно так важно?
* Чем моделирование данных в Azure Cosmos DB отличается от реляционной базы данных?
* Как выразить связи данных в нереляционной базе данных?
* Когда следует внедрять данные, а когда — связывать?

## <a name="embedding-data"></a>Внедрение данных

При запуске моделирования данных в Azure Cosmos DB старайтесь рассматривать объекты как **автономные элементы,** представленные в виде документов JSON.

Для сравнения давайте сначала посмотрим, как мы можем моделировать данные в реляционной базе данных. В следующем примере показано, как можно сохранить в реляционной базе данных человека.

![Модель реляционной базы данных](./media/sql-api-modeling-data/relational-data-model.png)

При работе с реляционными базами данных стратегия заключается в нормализации всех данных. Нормализация данных обычно включает в себя принятие сущности, например человека, и разбиение ее на отдельные компоненты. В приведенном выше примере человек может иметь несколько записей контактных данных, а также несколько записей адресов. Контактные данные могут быть дополнительно разбиты путем дальнейшего извлечения общих полей, как тип. То же самое относится и к адресу, каждая запись может быть типа *Главная* или *Бизнес*.

Руководящий принцип при нормализации данных заключается в том, чтобы **избегать хранения избыточных данных** в каждой записи и использовать только ссылки на эти данные. В этом примере, чтобы прочитать человека, со всеми его контактными данными и адресами, необходимо использовать JOINS для эффективного составления обратно (или денормализации) ваших данных во время выполнения.

    SELECT p.FirstName, p.LastName, a.City, cd.Detail
    FROM Person p
    JOIN ContactDetail cd ON cd.PersonId = p.Id
    JOIN ContactDetailType cdt ON cdt.Id = cd.TypeId
    JOIN Address a ON a.PersonId = p.Id

Чтобы обновить сведения о контактах и адреса для отдельного человека, требуется выполнить операции записи для множества отдельных таблиц.

Теперь давайте взглянем на то, как мы будем моделировать те же данные, что и автономная сущность в Azure Cosmos DB.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "addresses": [
            {
                "line1": "100 Some Street",
                "line2": "Unit 1",
                "city": "Seattle",
                "state": "WA",
                "zip": 98012
            }
        ],
        "contactDetails": [
            {"email": "thomas@andersen.com"},
            {"phone": "+1 555 555-5555", "extension": 5555}
        ]
    }

Используя подход выше, мы **денормализировали** запись человека, **встраивая** всю информацию, связанную с этим человеком, например, его контактные данные и адреса, в единый документ *JSON.*
Кроме того, отсутствие привязки к фиксированной схеме повышает гибкость работы, например, мы можем использовать сведения о контактах в самых разных формах.

Извлечение полной записи о человеке из базы данных теперь является **одной операцией чтения** против одного контейнера и для одного элемента. Обновление записи человека с его контактными данными и адресами также является **одной операцией записи** против одного элемента.

Благодаря денормализации данных ваше приложение может использовать меньше запросов и обновлений для выполнения распространенных операций.

### <a name="when-to-embed"></a>Когда следует использовать внедрение

В общем случае модели внедренных данных следует использовать в следующих ситуациях:

* Существуют **содержащиеся** отношения между сущностями.
* между сущностями существуют связи **один к нескольким** ;
* имеются внедренные данные, которые **редко изменяются**;
* Существует встроенные данные, которые не будут расти **без связаны**.
* Существует встроенные данные, которые **часто запрашиваются вместе.**

> [!NOTE]
> Обычно модели денормализованных данных обеспечивают повышенную производительность при **чтении** .

### <a name="when-not-to-embed"></a>Когда внедрение использовать не следует

В то время как эмпирическое правило в Azure Cosmos DB заключается в денормализации всего и встраивании всех данных в один элемент, это может привести к некоторым ситуациям, которых следует избегать.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "comments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            …
            {"id": 100001, "author": "jane", "comment": "and on we go ..."},
            …
            {"id": 1000000001, "author": "angry", "comment": "blah angry blah angry"},
            …
            {"id": ∞ + 1, "author": "bored", "comment": "oh man, will this ever end?"},
        ]
    }

Так могла бы выглядеть сущность публикации с внедренными комментариями, если бы мы моделировали обычный блог или систему CMS. Проблема с данным примером заключается в том, что массив комментариев является **неограниченным**, то есть не существует (фактического) предела для количества комментариев, которое может иметь отдельная публикация. Это может стать проблемой, так как размер элемента может расти бесконечно большим.

По мере роста размера элемента будет влиять возможность передачи данных по проводу, а также чтение и обновление товара в масштабе.

В этом случае было бы лучше рассмотреть следующую модель данных.

    Post item:
    {
        "id": "1",
        "name": "What's new in the coolest Cloud",
        "summary": "A blog post by someone real famous",
        "recentComments": [
            {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
            {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
            {"id": 3, "author": "jane", "comment": "....."}
        ]
    }

    Comment items:
    {
        "postId": "1"
        "comments": [
            {"id": 4, "author": "anon", "comment": "more goodness"},
            {"id": 5, "author": "bob", "comment": "tails from the field"},
            ...
            {"id": 99, "author": "angry", "comment": "blah angry blah angry"}
        ]
    },
    {
        "postId": "1"
        "comments": [
            {"id": 100, "author": "anon", "comment": "yet more"},
            ...
            {"id": 199, "author": "bored", "comment": "will this ever end?"}
        ]
    }

Эта модель имеет три последних комментария, встроенных в контейнер столба, который представляет собой массив с фиксированным набором атрибутов. Другие комментарии сгруппированы в пакеты из 100 комментариев и хранятся в виде отдельных элементов. Размер пакета был выбран равным 100, поскольку наше условное приложение позволяет пользователю отправить 100 комментариев за один раз.  

Другой случай, когда встраивание данных не является хорошей идеей, когда встроенные данные часто используются между элементами и часто меняются.

Рассмотрим этот фрагмент кода JSON.

    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            {
                "numberHeld": 100,
                "stock": { "symbol": "zaza", "open": 1, "high": 2, "low": 0.5 }
            },
            {
                "numberHeld": 50,
                "stock": { "symbol": "xcxc", "open": 89, "high": 93.24, "low": 88.87 }
            }
        ]
    }

Этот код может представлять биржевой портфель человека. Мы решили внедрить информацию об акциях в каждый документ портфеля. В среде, где связанные данные регулярно изменяются, например, в приложении биржевых торгов, внедрение часто изменяемых данных означает, что вы постоянно обновляете каждый документ портфеля при выполнении торговой операции с каждой акцией.

В течение дня акции *zaza* могут покупать и продавать сотни раз, и *zaza* могут входить в портфели тысяч пользователей. В случае использования описанной выше модели данных нам пришлось бы обновлять многие тысячи документов портфелей каждый день, что затруднило бы масштабирование системы.

## <a name="referencing-data"></a>Использование ссылок на данные

Встраивание данных работает хорошо во многих случаях, но Есть сценарии, когда денормализация данных вызовет больше проблем, чем это стоит. Что же нам делать теперь?

Связи между сущностями можно задавать не только в реляционных базах данных. В базе данных документов можно иметь информацию в одном документе, который относится к данным в других документах. Мы не рекомендуем строить системы, которые лучше подходят для реляционной базы данных в Azure Cosmos DB или любой другой базы данных документов, но простые отношения прекрасны и могут быть полезны.

В приведенном ниже коде JSON мы решили использовать использованный ранее пример биржевого портфеля, однако здесь мы не внедряем элемент акции в портфеле, а ссылаемся на него. Если элемент акции часто изменяется в течение дня, то обновлять требуется единственный документ акции.

    Person document:
    {
        "id": "1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "holdings": [
            { "numberHeld":  100, "stockId": 1},
            { "numberHeld":  50, "stockId": 2}
        ]
    }

    Stock documents:
    {
        "id": "1",
        "symbol": "zaza",
        "open": 1,
        "high": 2,
        "low": 0.5,
        "vol": 11970000,
        "mkt-cap": 42000000,
        "pe": 5.89
    },
    {
        "id": "2",
        "symbol": "xcxc",
        "open": 89,
        "high": 93.24,
        "low": 88.87,
        "vol": 2970200,
        "mkt-cap": 1005000,
        "pe": 75.82
    }

Недостаток такого подхода проявляется, когда приложению нужно отобразить информацию о каждой имеющейся акции в портфеле человека; в этом случае потребуется выполнить множество обращений к базе данных, чтобы загрузить информацию для каждого документа акции. Здесь мы приняли решение повысить эффективность операций записи, которые часто выполняются в течение дня, однако это затруднило выполнение операций чтения, которые оказывают меньшее влияние на производительность всей данной системы.

> [!NOTE]
> Модели нормализованных данных **могут потребовать больше круговых путей** к серверу.

### <a name="what-about-foreign-keys"></a>Сведения о внешнем ключе

Поскольку в настоящий момент концепция ограничения, основанная на внешнем ключе или чем-либо другом, отсутствует, все связи между документами представляют собой "слабые звенья" и не проверяются базой данных. Если вы хотите убедиться, что данные, на которые ссылается документ, действительно существуют, это нужно сделать в приложении либо с помощью триггеров на стороне сервера или хранимых процедур в Azure Cosmos DB.

### <a name="when-to-reference"></a>Когда следует использовать ссылки

В общем случае модели нормализованных данных следует использовать в следующих ситуациях:

* Осуществляется представление связей **один ко многим** .
* Осуществляется представление связей **многие ко многим** .
* Связанные данные **часто изменяются**.
* Данные, на которые указывает ссылка, могут быть **неограниченными**.

> [!NOTE]
> Обычно нормализация обеспечивает повышенную производительность при **записи** .

### <a name="where-do-i-put-the-relationship"></a>Куда следует поместить связь

Рост связи поможет определить, в каком документе следует сохранить ссылку.

Давайте рассмотрим следующий код JSON, моделирующий издателей и книги.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press",
        "books": [ 1, 2, 3, ..., 100, ..., 1000]
    }

    Book documents:
    {"id": "1", "name": "Azure Cosmos DB 101" }
    {"id": "2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "3", "name": "Taking over the world one JSON doc at a time" }
    ...
    {"id": "100", "name": "Learn about Azure Cosmos DB" }
    ...
    {"id": "1000", "name": "Deep Dive into Azure Cosmos DB" }

Если на издателя приходится небольшое число книг, а рост ограничен, то может оказаться удобным хранить ссылку на книгу в документе издателя. Однако если число книг на издателя не имеет ограничений, эта модель данных приведет к изменяемым и разрастающимся массивам, как в приведенном выше примере с документом издателя.

Небольшая доработка помогает получить модель, которая все еще представляет те же данные, однако избавляется от крупных изменяемых коллекций.

    Publisher document:
    {
        "id": "mspress",
        "name": "Microsoft Press"
    }

    Book documents:
    {"id": "1","name": "Azure Cosmos DB 101", "pub-id": "mspress"}
    {"id": "2","name": "Azure Cosmos DB for RDBMS Users", "pub-id": "mspress"}
    {"id": "3","name": "Taking over the world one JSON doc at a time"}
    ...
    {"id": "100","name": "Learn about Azure Cosmos DB", "pub-id": "mspress"}
    ...
    {"id": "1000","name": "Deep Dive into Azure Cosmos DB", "pub-id": "mspress"}

В приведенном выше примере мы помещали неограниченную коллекцию в документ издателя. Вместо этого мы просто воспользуемся ссылкой на издателя в каждом документе книги.

### <a name="how-do-i-model-manymany-relationships"></a>Как моделировать связи "многие ко многим"

В реляционной базе данных связи *многие ко многим* часто моделируются с помощью таблиц JOIN, которые просто соединяют вместе записи из других таблиц.

![Объединенные таблицы](./media/sql-api-modeling-data/join-table.png)

У вас может возникнуть желание реплицировать это с помощью документов и создать модель данных, аналогичную приведенной ниже.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen" }
    {"id": "a2", "name": "William Wakefield" }

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101" }
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users" }
    {"id": "b3", "name": "Taking over the world one JSON doc at a time" }
    {"id": "b4", "name": "Learn about Azure Cosmos DB" }
    {"id": "b5", "name": "Deep Dive into Azure Cosmos DB" }

    Joining documents:
    {"authorId": "a1", "bookId": "b1" }
    {"authorId": "a2", "bookId": "b1" }
    {"authorId": "a1", "bookId": "b2" }
    {"authorId": "a1", "bookId": "b3" }

Такой подход будет работать. Однако при загрузке автора вместе с его книгами или книги вместе с ее автором всегда потребуется отправлять два дополнительных запроса в базу данных. Один запрос отправляется в документ присоединения, а другой — для получения самого присоединяемого документа.

Если эта таблица JOIN всего лишь соединяет два элемента данных, почему бы просто не отказаться от нее?
Давайте рассмотрим следующее.

    Author documents:
    {"id": "a1", "name": "Thomas Andersen", "books": ["b1, "b2", "b3"]}
    {"id": "a2", "name": "William Wakefield", "books": ["b1", "b4"]}

    Book documents:
    {"id": "b1", "name": "Azure Cosmos DB 101", "authors": ["a1", "a2"]}
    {"id": "b2", "name": "Azure Cosmos DB for RDBMS Users", "authors": ["a1"]}
    {"id": "b3", "name": "Learn about Azure Cosmos DB", "authors": ["a1"]}
    {"id": "b4", "name": "Deep Dive into Azure Cosmos DB", "authors": ["a2"]}

Теперь, если бы у меня был автор, я сразу же знаю, какие книги они написали, и, наоборот, если бы я книгу документ загружен я бы знал, идентификции автора (ы). Это позволяет отказаться от промежуточного запроса к таблице JOIN и сократить количество круговых путей для вашего приложения.

## <a name="hybrid-data-models"></a>Гибридные модели данных

Мы рассмотрели внедрение данных (или денормализацию) и использование ссылок на данные (или нормализацию), а также преимущества и недостатки этих подходов.

Однако далеко не всегда следует придерживаться лишь одного из подходов, можно попробовать совместить их.

Учитывая применяемые в приложении схемы использования и рабочие нагрузки, в некоторых случаях совмещение внедрения и ссылок может иметь смысл и позволяет упростить логическую схему приложения, сократить число круговых путей к серверу и при этом сохранить высокий уровень производительности.

Давайте рассмотрим следующий код JSON.

    Author documents:
    {
        "id": "a1",
        "firstName": "Thomas",
        "lastName": "Andersen",
        "countOfBooks": 3,
        "books": ["b1", "b2", "b3"],
        "images": [
            {"thumbnail": "https://....png"}
            {"profile": "https://....png"}
            {"large": "https://....png"}
        ]
    },
    {
        "id": "a2",
        "firstName": "William",
        "lastName": "Wakefield",
        "countOfBooks": 1,
        "books": ["b1"],
        "images": [
            {"thumbnail": "https://....png"}
        ]
    }

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
            {"id": "a2", "name": "William Wakefield", "thumbnailUrl": "https://....png"}
        ]
    },
    {
        "id": "b2",
        "name": "Azure Cosmos DB for RDBMS Users",
        "authors": [
            {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
        ]
    }

Здесь мы в большей степени придерживались модели внедрения, где данные из других сущностей внедряются в документ верхнего уровня, однако для остальных данных используются ссылки.

Если взглянуть на документ книги, можно заметить несколько интересных полей в массиве авторов. Существует поле, которое является полем, `id` которое мы используем для обозначения авторского документа, `name` `thumbnailUrl`стандартной практики в нормализованной модели, но тогда у нас также есть и . Мы могли бы `id` застряли с и оставили приложение, чтобы получить любую дополнительную информацию, необходимую из соответствующего авторского документа с использованием "ссылка", а потому, что наше приложение отображает имя автора и эскиз картину с каждой книги отображается мы можем сохранить туда и обратно на сервер на книгу в списке, денормализации **некоторых** данных от автора.

Конечно, если имя автора изменилось или они хотели бы обновить свои фотографии мы должны пойти и обновить каждую книгу, которую они когда-либо опубликованных, но для нашего приложения, на основе предположения, что авторы не меняют свои имена часто, это приемлемое решение дизайн.  

В этом примере имеются **предварительно рассчитанные значения агрегатов** для сохранения дорогостоящей обработки на операции чтения. В данном примере некоторые данные, внедренные в документ автора, вычисляются во время выполнения. Каждый раз при публикации новой книги создается документ книги, **и** для поля countOfBooks задается вычисленное значение, зависящее от числа существующих для данного автора документов книги. Такая оптимизация хорошо подходит для систем с большим количеством операций чтения, где можно выполнять вычисления в операциях записи для повышения производительности операций чтения.

Использование модели с предварительно вычисленными значениями в полях стало возможным благодаря тому, что Azure Cosmos DB поддерживает **транзакции с несколькими документами**. Многие хранилища NoSQL не позволяют выполнять транзакции между документами, что вынуждает слепо следовать правилу "всегда внедряйте все, что можно". В Azure Cosmos DB вы можете использовать триггеры на стороне сервера или хранимые процедуры, которые вставляют книги и обновляют авторов в рамках транзакции ACID. Теперь вам не **обязательно** внедрять все в один документ просто для того, чтобы обеспечить согласованность данных.

## <a name="distinguishing-between-different-document-types"></a>Различие между различными типами документов

В некоторых сценариях может потребоваться смешивать различные типы документов в одной и той же коллекции; обычно это происходит, когда требуется несколько связанных с этим документов, чтобы сидеть в одном и том же [разделе.](partitioning-overview.md) Например, можно поместить как книги, так и обзоры `bookId`книг в одну и ту же коллекцию и разделить ее. В такой ситуации обычно требуется добавить в свои документы поле, которое определяет их тип, чтобы дифференцировать их.

    Book documents:
    {
        "id": "b1",
        "name": "Azure Cosmos DB 101",
        "bookId": "b1",
        "type": "book"
    }

    Review documents:
    {
        "id": "r1",
        "content": "This book is awesome",
        "bookId": "b1",
        "type": "review"
    },
    {
        "id": "r2",
        "content": "Best book ever!",
        "bookId": "b1",
        "type": "review"
    }

## <a name="next-steps"></a>Дальнейшие действия

Основная идея этой статьи заключается в том, что моделирование данных без фиксированных схем не теряет своей актуальности.

Как не существует единственного способа представить элемент данных на экране, нет такого способа и для моделирования данных. Необходимо разобраться в принципах работы приложения, его механизмах формирования, использования и обработки данных. После этого с помощью представленных здесь рекомендаций вы можете приступить к созданию модели, которая оптимально соответствует основным потребностям вашего приложения. Благодаря отсутствию схемы в базе данных вы можете оперативно вносить изменения в приложения и легко корректировать модель данных соответствующим образом.

Дополнительные сведения об Azure Cosmos DB см. на странице [документации](https://azure.microsoft.com/documentation/services/cosmos-db/) по этой службе.

Чтобы понять, как сегментировать данные по нескольким разделам, ознакомьтесь со статьей [Секционирование, ключи секции и масштабирование в DocumentDB](sql-api-partition-data.md).

Чтобы узнать, как моделировать и перегородки данных на Azure Cosmos DB на примере реального мира, обратитесь к [моделированию данных и разделу - примеру реального мира.](how-to-model-partition-example.md)
