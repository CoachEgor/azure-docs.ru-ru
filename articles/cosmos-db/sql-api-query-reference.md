---
title: Синтаксис языка SQL в Azure Cosmos DB
description: В этой статье описывается синтаксис языка запросов SQL, используемых в Azure Cosmos DB, различные операторы и ключевые слова, доступные на этом языке.
author: markjbrown
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: conceptual
ms.date: 05/06/2019
ms.author: mjbrown
ms.custom: seodec18
ms.openlocfilehash: 1d874b9c8f14b1489ab5e5b8bbdddaff0669165e
ms.sourcegitcommit: f6ba5c5a4b1ec4e35c41a4e799fb669ad5099522
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65145191"
---
# <a name="sql-language-reference-for-azure-cosmos-db"></a>Справочник по языку SQL для Azure Cosmos DB 

Azure Cosmos DB позволяет выполнять запросы к документам с помощью знакомой грамматики SQL, например к иерархическим файлам JSON, без использования явных схем или создания вторичных индексов. В этой статье содержится документация по синтаксис языка запросов SQL, используемый в учетные записи SQL API. Пример SQL-запросов, см. в разделе [примеры запросов SQL в Cosmos DB](how-to-sql-query.md).  
  
Посетите [площадку для запросов](https://www.documentdb.com/sql/demo), где можно попробовать Cosmos DB и выполнять запросы SQL к примера набора данных.  
  
## <a name="select-query"></a>Запрос SELECT  
Каждый запрос состоит из предложения SELECT и необязательных предложений FROM и WHERE в соответствии со стандартами ANSI-SQL. Как правило для каждого запроса перечисляется источника в предложении FROM, а затем применяется фильтр в предложении WHERE в источнике, для извлечения подмножества документов JSON. И наконец, предложение SELECT используется для проекции запрошенных значений JSON в списке выборки. Смотреть [примеры запроса SELECT](how-to-sql-query.md#SelectClause)
  
**Синтаксис**  
  
```sql
<select_query> ::=  
SELECT <select_specification>   
    [ FROM <from_specification>]   
    [ WHERE <filter_condition> ]  
    [ ORDER BY <sort_specification> ] 
    [ OFFSET <offset_amount> LIMIT <limit_amount>]
```  
  
 **Примечания**  
  
 Сведения о каждом из этих предложений см. в следующих разделах:  
  
-   [Предложение SELECT](#bk_select_query)    
-   [Предложение FROM](#bk_from_clause)    
-   [Предложение WHERE](#bk_where_clause)    
-   [Предложение ORDER BY](#bk_orderby_clause)  
-   [Предложение LIMIT СМЕЩЕНИЯ](#bk_offsetlimit_clause)

  
Предложения в инструкции SELECT необходимо упорядочить, как показано выше. Необязательные предложения можно опустить, но если вы используете их, их необходимо упорядочить в правильном порядке.  
  
### <a name="logical-processing-order-of-the-select-statement"></a>Логические этапы обработки инструкции SELECT  
  
Порядок обработки предложений:  

1.  [Предложение FROM](#bk_from_clause)  
2.  [Предложение WHERE](#bk_where_clause)  
3.  [Предложение ORDER BY](#bk_orderby_clause)  
4.  [Предложение SELECT](#bk_select_query)
5.  [Предложение LIMIT СМЕЩЕНИЯ](#bk_offsetlimit_clause)

Обратите внимание, что этот порядок отличается от порядка в синтаксисе. Такое упорядочение связано с тем, что все новые символы, представленные в обработанном предложении, отображаются. Их можно использовать на следующих этапах. Например, псевдонимы, объявленные в предложении FROM, доступны в предложениях WHERE и SELECT.  

### <a name="whitespace-characters-and-comments"></a>Пробелы и комментарии  

Все пробели за пределами строки в кавычках или нестандартного идентификатора не входят в грамматику языка. Во время синтаксического анализа они игнорируются.  

Язык запросов поддерживает комментарии T-SQL. Например:  

-   Инструкция SQL `-- comment text [newline]`  

Пробелы и комментарии не имеют значения в грамматике. Их следует использовать для разделения лексем. Например, `-1e5` представляет лексему с одним номером, а `: – 1 e5` — лексему "минус" (–), за которой следует номер 1 и идентификатор e5.  

##  <a name="bk_select_query"></a>Предложение SELECT  
Предложения в инструкции SELECT необходимо упорядочить, как показано выше. Необязательные предложения можно опустить, но если вы используете их, их необходимо упорядочить в правильном порядке. Подробнее о [примерах запроса SELECT](how-to-sql-query.md#SelectClause).

**Синтаксис**  

```sql
SELECT <select_specification>  

<select_specification> ::=   
      '*'   
      | [DISTINCT] <object_property_list>   
      | [DISTINCT] VALUE <scalar_expression> [[ AS ] value_alias]  
  
<object_property_list> ::=   
{ <scalar_expression> [ [ AS ] property_alias ] } [ ,...n ]  
  
```  
  
 **Аргументы**  
  
- `<select_specification>`  

  Свойства или значения, выбираемые для результирующего набора.  
  
- `'*'`  

  Указывает, что значение необходимо извлечь без внесения изменений. В частности, если обработанное значение — это объект, извлекаются все свойства.  
  
- `<object_property_list>`  
  
  Указывает список свойств, которые требуется извлечь. Каждое возвращаемое значение представляет собой объект с указанными свойствами.  
  
- `VALUE`  

  Указывает, что следует извлечь только значение JSON, а не весь объект JSON. Этот аргумент, в отличие от аргумента `<property_list>`, не выделяет прогнозируемое значение в объекте.  
 
- `DISTINCT`
  
  Указывает, что дубликаты прогнозируемых свойств должны быть удалены.  

- `<scalar_expression>`  

  Выражение, представляющее вычисляемое значение. Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
**Примечания**  
  
Если предложение FROM объявило один псевдоним, действителен только синтаксис `SELECT *`. Синтаксис `SELECT *` обеспечивает проекцию удостоверения, что может пригодиться, если проекция не требуется. Кроме того, это * единственный действительный синтаксис, если в предложении FROM указан один источник входных данных.  
  
`SELECT <select_list>` и `SELECT *` — это "синтаксический сахар". При необходимости их можно выразить с помощью простых инструкций SELECT, как показано ниже.  
  
1. `SELECT * FROM ... AS from_alias ...`  
  
   эквивалентно правилу  
  
   `SELECT from_alias FROM ... AS from_alias ...`  
  
2. `SELECT <expr1> AS p1, <expr2> AS p2,..., <exprN> AS pN [other clauses...]`  
  
   эквивалентно правилу  
  
   `SELECT VALUE { p1: <expr1>, p2: <expr2>, ..., pN: <exprN> }[other clauses...]`  
  
**См. также**  
  
[Скалярные выражения](#bk_scalar_expressions)  
[Предложение SELECT](#bk_select_query)  
  
##  <a name="bk_from_clause"></a>Предложение FROM  
Это предложение указывает источник или несколько соединенных источников. Предложение FROM является необязательным, если далее в запросе источник не фильтруется и не отображается в запросе. Назначение данного выражения заключается в указании источника данных, с которым работает запрос. Как правило, в качестве источника выступает весь контейнер, но можно указать определенное подмножество вместо целого контейнера. Если это предложение не указано, другие предложения по-прежнему будут выполняться, как если бы предложение FROM предоставило единый документ. Смотреть [примеры предложения FROM](how-to-sql-query.md#FromClause)
  
**Синтаксис**  
  
```sql  
FROM <from_specification>  
  
<from_specification> ::=   
        <from_source> {[ JOIN <from_source>][,...n]}  
  
<from_source> ::=   
          <container_expression> [[AS] input_alias]  
        | input_alias IN <container_expression>  
  
<container_expression> ::=   
        ROOT   
     | container_name  
     | input_alias  
     | <container_expression> '.' property_name  
     | <container_expression> '[' "property_name" | array_index ']'  
```  
  
**Аргументы**  
  
- `<from_source>`  
  
  Указывает источник данных с псевдонимом или без него. Если псевдоним не указан, он выводится из аргумента `<container_expression>` на основе следующих правил:  
  
  -  При использовании выражения container_name оно указывается в качестве псевдонима.  
  
  -  При использовании выражения `<container_expression>` в качестве псевдонима указывается свойство property_name. При использовании выражения container_name оно указывается в качестве псевдонима.  
  
- AS `input_alias`  
  
  Указывает, что аргумент `input_alias` — это набор значений, возвращенный базовым выражением контейнера.  
 
- `input_alias` IN  
  
  Указывает, что аргумент `input_alias` должен представлять набор значений, полученных путем итерации всех элементов в каждом массиве, возвращенном базовым выражением контейнера. Значения, возвращенные базовым выражением контейнера, которые не являются массивом, игнорируются.  
  
- `<container_expression>`  
  
  Указывает выражение контейнера, используемое для получения документов.  
  
- `ROOT`  
  
  Указывает, что документ необходимо извлечь из подключенного в настоящий момент контейнера по умолчанию.  
  
- `container_name`  
  
  Указывает, что документ необходимо извлечь из предоставленного контейнера. Имя этого контейнера должно совпадать с именем подключенного в настоящий момент контейнера.  
  
- `input_alias`  
  
  Указывает, что документ необходимо извлечь из источника, определенного предоставленным псевдонимом.  
  
- `<container_expression> '.' property_`  
  
  Указывает, что документ необходимо извлечь из свойства `property_name` или элемента массива array_index всех документов, полученных указанным выражением контейнера.  
  
- `<container_expression> '[' "property_name" | array_index ']'`  
  
  Указывает, что документ необходимо извлечь из свойства `property_name` или элемента массива array_index всех документов, полученных указанным выражением контейнера.  
  
**Примечания**  
  
Все псевдонимы, предоставленные или выведенные в аргументе `<from_source>(`, должны быть уникальными. Синтаксис `<container_expression>.`property_name совпадает с синтаксисом `<container_expression>' ['"property_name"']'`. Второй синтаксис можно использовать, если имя свойства содержит знак, не являющийся идентификатором.  
  
### <a name="handling-missing-properties-missing-array-elements-and-undefined-values"></a>Обработка отсутствующих свойств, элементов массива и неопределенных значений
  
Если выражение контейнера обращается к свойствам или элементам массива и необходимое значение отсутствует, это значение игнорируется и не проходит дальнейшую обработку.  
  
### <a name="container-expression-context-scoping"></a>Определение области контекста выражения контейнера  
  
Выражение контейнера может указываться на уровне контейнера или документа:  
  
-   Если в качестве базового источника выражения контейнера используется ROOT или `container_name`, выражение определено на уровне контейнера. Такое выражение представляет набор документов, полученный напрямую из контейнера. Оно не зависит от обработки других выражений контейнера.  
  
-   Если в качестве базового источника выражения контейнера используется аргумент `input_alias`, сформированный ранее в запросе, выражение определено на уровне документа. Такое выражение представляет набор документов, полученный при оценке выражения контейнера в области каждого документа, который входит в набор, связанный с контейнером, содержащей псевдоним.  Результирующий набор в этом случае представляет собой ряд наборов, полученных в результате вычисления выражения контейнера для всех документов в базовом наборе.  
  
### <a name="joins"></a>Соединения 
  
В текущем выпуске Cosmos DB поддерживает внутренние соединения. Дополнительные возможности соединения будут добавлены позже. 

Результат внутренних соединений —это полное векторное произведение множеств, участвующих в соединении. Результатом других типов соединений является набор кортежей элементов того же типа, где каждое значение в кортеже связано с набором с псевдонимом, участвующим в соединении. Доступ к этому набору можно получить, создав ссылку на этот псевдоним в остальных предложениях. Смотреть [примеры ключевого слова JOIN](how-to-sql-query.md#Joins)
  
Вычисление соединения зависит от области контекста участвующих наборов:  
  
- Результатом соединения набора элементов набора A и набора Б уровня контейнера является векторное произведение всех элементов в наборе А и Б.
  
- Соединение набора A и набора Б уровня документа приводит к объединению всех наборов, полученных при оценке набора Б уровня документа для каждого документа из набора А.  
  
  В текущем выпуске обработчик запросов поддерживает максимум одно выражение уровня контейнера.  
  
### <a name="examples-of-joins"></a>Примеры соединений  
  
Рассмотрим следующее выражение FROM: `<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>`.  
  
 Разрешите каждому источнику определить `input_alias1, input_alias2, …, input_aliasN`. Это предложение FROM возвращает набор N-кортежей (кортежей, у которых число значений равно N). Каждый кортеж будет со значениями, полученными путем итерации всех псевдонимов контейнера среди их наборов.  
  
**Пример 1** — 2 источника  
  
- Определите аргумент `<from_source1>` на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2>` вернутся следующие кортежи:  
  
    (`input_alias1, input_alias2`):  
  
    `(A, 1), (A, 2), (B, 3), (C, 4), (C, 5)`  
  
**Пример 2** — 3 источника  
  
- Определите аргумент `<from_source1>` на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на `input_alias1`. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` на уровне документа и добавьте ссылку на `input_alias2`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = 1,`;  
  
    {300} для `input_alias2 = 3,`;  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` вернутся следующие кортежи:  
  
    (input_alias1, input_alias2, input_alias3):  
  
    (A, 1, 100), (A, 1, 200), (B, 3, 300)  
  
  > [!NOTE]
  > Другие значения `input_alias1`, например `input_alias2`, для которых `<from_source3>` не вернул значения, не имеют кортежей.  
  
**Пример 3** — 3 источника  
  
- Определите аргумент <from_source1> на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент `<from_source1>` на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент <from_source2> на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` в области `input_alias1`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = A,`;  
  
    {300} для `input_alias2 = C,`;  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` вернутся следующие кортежи:  
  
    (`input_alias1, input_alias2, input_alias3`):  
  
    (A, 1, 100), (A, 1, 200), (A, 2, 100), (A, 2, 200),  (C, 4, 300) ,  (C, 5, 300)  
  
  > [!NOTE]
  > В результате этого соединения образовалось векторное произведение между `<from_source2>` и `<from_source3>`. Это связано с тем, что оба этих аргумента относятся к аргументу `<from_source1>`.  Это привело к созданию 4 (2 x 2) кортежей со значением A, 0 кортежей (1 x 0) со значением B и 2 (2x1) кортежей со значением C.  
  
**См. также**  
  
 [Предложение SELECT](#bk_select_query)  
  
##  <a name="bk_where_clause"></a>Предложение WHERE  
 Это предложение указывает условие поиска для документов, возвращенных запросом. Смотреть [примеры предложения WHERE](how-to-sql-query.md#WhereClause)
  
 **Синтаксис**  
  
```sql  
WHERE <filter_condition>  
<filter_condition> ::= <scalar_expression>  
  
```  
  
 **Аргументы**  
  
- `<filter_condition>`  
  
   Указывает рекомендованное условие для возвращаемых документов.  
  
- `<scalar_expression>`  
  
   Выражение, представляющее вычисляемое значение. Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
  **Примечания**  
  
  Чтобы вернуть документ, выражение, указанное в качестве условия фильтра, должно иметь значение true. Только логическое значение true соответствует условию. Все остальные значения, например undefined, Null, false, число, массив, объект, не подходят.  
  
##  <a name="bk_orderby_clause"></a>Предложение ORDER BY  
 Это предложение указывает порядок сортировки результатов, возвращаемых запросом. Смотреть [примеры предложения ORDER BY](how-to-sql-query.md#OrderByClause)
  
 **Синтаксис**  
  
```sql  
ORDER BY <sort_specification>  
<sort_specification> ::= <sort_expression> [, <sort_expression>]  
<sort_expression> ::= {<scalar_expression> [ASC | DESC]} [ ,...n ]  
  
```  

 **Аргументы**  
  
- `<sort_specification>`  
  
   Указывает свойство или выражение, по которому производится сортировка результирующего набора запроса. Столбец сортировки можно указать как имя или свойство псевдоним.  
  
   Можно указать несколько свойств. Имена свойств должны быть уникальными. Последовательность параметров сортировки в предложении ORDER BY определяет организацию упорядоченного результирующего набора. То есть результирующий набор сортируется по первому свойству, а затем упорядоченный список сортируется по второму свойству и т. д.  
  
   Имена свойств, на которые ссылается предложение ORDER BY должны соответствовать к свойству в списке выбора или свойство, определенное в коллекции, указанной в предложении FROM.  
  
- `<sort_expression>`  
  
   Указывает один или несколько свойств, или выражения, по которому производится сортировка результирующего набора запроса.  
  
- `<scalar_expression>`  
  
   Дополнительные сведения см. в разделе [Скалярные выражения](#bk_scalar_expressions).  
  
- `ASC | DESC`  
  
   Указывает порядок сортировки значений в указанном столбце (по возрастанию или по убыванию). Если указать ASC, значения сортируются по возрастанию, а если DESC — по убыванию. По умолчанию значения сортируются по возрастанию. Значения Null рассматриваются как минимальные возможные значения.  
  
  **Примечания**  
  
   Предложение ORDER BY требует, политику индексирования индекс для поля сортировки. Среда выполнения запросов Azure Cosmos DB поддерживает сортировку с именем свойства, а не по вычисляемым свойствам. Azure Cosmos DB поддерживает несколько свойств ORDER BY. Чтобы выполнить запрос с несколькими свойствами ORDER BY, следует определить [составной индекс](index-policy.md#composite-indexes) для сортируемых полей.


##  <a name=bk_offsetlimit_clause></a> Предложение LIMIT СМЕЩЕНИЯ

Указывает количество пропущенных элементов и количество возвращаемых элементов. Примеры, см. в разделе [примеры предложения OFFSET ограничение](how-to-sql-query.md#OffsetLimitClause)
  
 **Синтаксис**  
  
```sql  
OFFSET <offset_amount> LIMIT <limit_amount>
```  
  
 **Аргументы**  
 
- `<offset_amount>`

   Указывает целое число элементов, которые следует пропустить результаты запроса.


- `<limit_amount>`
  
   Указывает целое число элементов, которые следует включать в результаты запроса

  **Примечания**  
  
  Величина СМЕЩЕНИЯ и счетчика ограничение необходимы в предложение LIMIT СМЕЩЕНИЯ. Если необязательный `ORDER BY` используется предложение, выполнив пропустить через упорядоченные значения создается результирующий набор. В противном случае запрос будет возвращать фиксированный порядок значений.

##  <a name="bk_scalar_expressions"></a>Скалярные выражения  
 Скалярное выражение — это сочетание символов и операторов, в результате вычисления которых возвращается одно значение. К простым выражениям можно отнести константы, ссылки на свойства, ссылки на элементы массива, ссылки на псевдонимы или вызовы функций. C помощью операторов простые выражения можно объединить в сложные. Смотреть [примеры скалярных выражений](how-to-sql-query.md#scalar-expressions)
  
 Дополнительные сведения о значениях скалярных выражений см. в разделе [Константы](#bk_constants).  
  
 **Синтаксис**  
  
```sql  
<scalar_expression> ::=  
       <constant>   
     | input_alias   
     | parameter_name  
     | <scalar_expression>.property_name  
     | <scalar_expression>'['"property_name"|array_index']'  
     | unary_operator <scalar_expression>  
     | <scalar_expression> binary_operator <scalar_expression>    
     | <scalar_expression> ? <scalar_expression> : <scalar_expression>  
     | <scalar_function_expression>  
     | <create_object_expression>   
     | <create_array_expression>  
     | (<scalar_expression>)   
  
<scalar_function_expression> ::=  
        'udf.' Udf_scalar_function([<scalar_expression>][,…n])  
        | builtin_scalar_function([<scalar_expression>][,…n])  
  
<create_object_expression> ::=  
   '{' [{property_name | "property_name"} : <scalar_expression>][,…n] '}'  
  
<create_array_expression> ::=  
   '[' [<scalar_expression>][,…n] ']'  
  
```  
  
 **Аргументы**  
  
- `<constant>`  
  
   Представляет значение константы. Дополнительные сведения см. в разделе [Константы](#bk_constants).  
  
- `input_alias`  
  
   Представляет значение, определяемое аргументом `input_alias` в предложении `FROM`.  
  Выражение гарантировано не может принять значение **undefined**. Значения **undefined** пропускаются.  
  
- `<scalar_expression>.property_name`  
  
   Представляет значение свойства объекта. Если свойство не существует или ссылается на значение, которое не является объектом, выражение принимает значение **undefined**.  
  
- `<scalar_expression>'['"property_name"|array_index']'`  
  
   Представляет значение свойства с именем `property_name` или элемент массива с индексом `array_index` из объекта или массива. Если объект или массив не существует или ссылается на значение, которое не является объектом или массивом, выражение принимает значение undefined.  
  
- `unary_operator <scalar_expression>`  
  
   Представляет оператор, применяемый к одному значению. Дополнительные сведения см. в разделе [Операторы](#bk_operators).  
  
- `<scalar_expression> binary_operator <scalar_expression>`  
  
   Представляет оператор, применяемый к двум значениям. Дополнительные сведения см. в разделе [Операторы](#bk_operators).  
  
- `<scalar_function_expression>`  
  
   Представляет значение, определяемое результатом вызова функции.  
  
- `udf_scalar_function`  
  
   Имя определяемой пользователем скалярной функции.  
  
- `builtin_scalar_function`  
  
   Имя встроенной скалярной функции.  
  
- `<create_object_expression>`  
  
   Представляет значение, полученное в процессе создания объекта с заданными свойствами и их значениями.  
  
- `<create_array_expression>`  
  
   Представляет значение, полученное в процессе создания массива с заданными значениями в качестве элементов.  
  
- `parameter_name`  
  
   Представляет значение указанного имени параметра. Имена параметров должны начинаться с одного символа \@.  
  
  **Примечания**  
  
  При вызове встроенной или определяемой пользователем скалярной функции необходимо определить все аргументы. Если любой из аргументов не определен, функция не будет вызвана, и значение не будет определено.  
  
  При создании объекта все свойства со значением undefined пропускаются и не включаются в созданный объект.  
  
  При создании массива все элементы со значением **undefined** пропускаются и не включаются в созданный объект. В этом случае место неопределенного элемента занимает следующий определенный элемент, таким образом в созданном массиве не будет пропущенных индексов.  
  
##  <a name="bk_operators"></a>Операторы  
 В этом разделе описываются поддерживаемые операторы. Каждый оператор может назначаться только одной категории.  
  
 В таблице **Категории операторов** ниже приведены сведения об обработке значений **undefined**, требованиях к типу входных значений и обработке значений несоответствующего типа.  
  
 **Категории операторов**  
  
|**Категория**|**Сведения**|  
|-|-|  
|**Арифметические**|Ожидаемые входные и выходные данные — числа. Если любое входное значение **не определено** или имеет другой тип (не число), выражение принимает значение **undefined**.|  
|**Битовые**|Ожидаемые входные и выходные данные — 32-разрядные целые числа со знаками.<br /><br /> Все нецелочисленные значения округляются. Положительные значения округляются в меньшую сторону, а отрицательные — в большую.<br /><br /> Все не 32-разрядные целые числа со знаками преобразовываются (берутся последние 32 бита их нотации дополнительного кода).<br /><br /> Если любое входное значение **не определено** или имеет другой тип (не число), выражение принимает значение **undefined**.<br /><br /> **Примечание.** Описанное выше поведение совместимо с поведением побитового оператора JavaScript.|  
|**Логические**|Ожидаемые входные и выходные данные — логические значения.<br />Если любое входное значение **не определено** или имеет другой тип (не логический), выражение принимает значение **undefined**.|  
|**Сравнение**|Ожидаемые входные данные — определенные значения одного типа. Выходные данные — логические значения.<br /><br /> Если любое входное значение **не определено** или тип входных данных не совпадает, выражение принимает значение **undefined**.<br /><br /> Сведения об упорядочении значений см. в таблице **Упорядочение сравниваемых значений**.|  
|**string**|Ожидаемые входные и выходные данные — строки.<br />Если любое входное значение **не определено** или имеет другой тип (не строка), выражение принимает значение **undefined**.|  
  
 **Унарные операторы**  
  
|**Имя**|**Оператор**|**Сведения**|  
|-|-|-|  
|**Арифметические**|+<br /><br /> -|Возвращает числовое значение.<br /><br /> Выполняет побитовую операцию. Возвращает отрицательное числовое значение.|  
|**Битовые**|~|Дополнение. Возвращает дополнение числового значения.|  
|**Логические**|**NOT**|Отрицание. Возвращает отрицательное логическое значение.|  
  
 **Бинарные операторы**  
  
|**Имя**|**Оператор**|**Сведения**|  
|-|-|-|  
|**Арифметические**|+<br /><br /> -<br /><br /> *<br /><br /> /<br /><br /> %|Сложение.<br /><br /> Вычитание.<br /><br /> Умножение.<br /><br /> Деление.<br /><br /> Модуляция.|  
|**Битовые**|&#124;<br /><br /> &<br /><br /> ^<br /><br /> <<<br /><br /> >><br /><br /> >>>|Битовый OR.<br /><br /> Битовый AND.<br /><br /> Битовый XOR.<br /><br /> Сдвиг влево.<br /><br /> Сдвиг вправо.<br /><br /> Сдвиг вправо с заполнением нулями.|  
|**Логические**|**AND**<br /><br /> **OR**|Логическое умножение. Возвращает значение **true**, если оба аргумента имеют значение **true**. В противном случае возвращает **false**.<br /><br /> Дизъюнкция. Возвращает значение **true**, если любой из аргументов имеет значение **true**. В противном случае возвращает **false**.|  
|**Сравнение**|**=**<br /><br /> **!=, <>**<br /><br /> **>**<br /><br /> **>=**<br /><br /> **<**<br /><br /> **<=**<br /><br /> **??**|Равно. Возвращает значение **true**, если оба аргумента равны. В противном случае возвращает **false**.<br /><br /> Не равно. Возвращает значение **true**, если оба аргумента не равны. В противном случае возвращает **false**.<br /><br /> Больше. Возвращает значение **true**, если первый аргумент больше второго. В противном случае возвращает **false**.<br /><br /> Больше или равно. Возвращает значение **true**, если первый аргумент больше второго или равен ему. В противном случае возвращает **false**.<br /><br /> Меньше. Возвращает значение **true**, если первый аргумент меньше второго. В противном случае возвращает **false**.<br /><br /> Меньше или равно. Возвращает значение **true**, если первый аргумент меньше второго или равен ему. В противном случае возвращает **false**.<br /><br /> Слияние. Возвращает второй аргумент, если первый аргумент имеет значение **undefined**.|  
|**Строка**|**&#124;&#124;**|Объединение. Возвращает объединение обоих аргументов.|  
  
 **Тернарные операторы**  

|**Имя**|**Оператор**|**Сведения**| 
|-|-|-|  
|Тернарный оператор|?|Возвращает второй аргумент, если первый аргумент принимает значение **true**. В противном случае возвращает третий аргумент.|  

  
 **Упорядочение сравниваемых значений**  
  
|**Тип**|**Порядок значений**|  
|-|-|  
|**Неопределенное**|Невозможно сравнить.|  
|**Null**|Доступное значение: **Null**|  
|**Число**|Натуральное вещественное число.<br /><br /> Отрицательное значение бесконечности меньше любого другого числового значения.<br /><br /> Положительное значение бесконечности больше любого другого числового значения. Значение **NaN** невозможно сравнить. При сравнение с **NaN** возвращается значение **undefined**.|  
|**Строка**|Лексикографический порядок.|  
|**Массив**|Не поддерживает упорядочивание, но равнозначные.|  
|**Объект**|Не поддерживает упорядочивание, но равнозначные.|  
  
 **Примечания**  
  
 В базе данных Cosmos DB типы значений часто невозможно определить до их извлечения. Чтобы обеспечить эффективное выполнение запросов, большинство операторов имеют строгие требования к типам. Кроме того, операторы сами по себе не выполняют неявное преобразование.  
  
 Это означает, что запрос, такой как SELECT * FROM ROOT r WHERE r.Age = 21, вернет только документы со свойством Age равным числу 21. Документы со свойством Age равным строке "21" или "0021" не соответствуют, так как выражение "21" = 21 принимает значение undefined. Это позволяет лучше использовать индексы, так как поиск конкретного значения (например, числа 21) выполняется быстрее, чем поиск неопределенного количества возможных совпадений (числа 21 или строк "21", "021", "21.0" и т. д.). Это отличается от способа вычисления операторов в значениях различных типов на языке JavaScript.  
  
 **Равенство и сравнение массивов и объектов**  
  
 При сравнении значений массивов или объектов с использованием операторов диапазона (>, >=, <, <=) возвращается значение undefined, так как порядок этих значений не определен. Но выполнить структурное сравнение можно с помощью операторов равенства и неравенства (=, !=, <>).  
  
 Два массива считаются равными, если они имеют одинаковое число элементов и сопоставляемые элементы также равны. Если при сравнении пары элементов возвращается значение undefined, сравнение массива также вернет значение undefined.  
  
 Два объекта считаются равными, если они имеют одинаковые свойства и сопоставляемые свойства также равны. Если при сравнении пары значений свойств возвращается значение undefined, сравнение объекта также вернет значение undefined.  
  
##  <a name="bk_constants"></a>Константы  
 Константа (также известная как литерал или скаляр) — это символ, представляющий определенное значение данных. Формат константы зависит от типа данных значения, которое она представляет.  
  
 **Поддерживаемые скалярные типы данных**  
  
|**Тип**|**Порядок значений**|  
|-|-|  
|**Неопределенное**|Доступное значение: **undefined**|  
|**Null**|Доступное значение: **Null**|  
|**Логический**|Доступные значения: **false**, **true**|  
|**Число**|Число с плавающей запятой двойной точности, стандарт IEEE 754.|  
|**Строка**|Последовательности из нуля или более знаков Юникода. Строки необходимо заключить в одинарные или двойные кавычки.|  
|**Массив**|Последовательность из нуля или более элементов. Каждый элемент может иметь значение любого скалярного типа данных (за исключением типа "Неопределенное").|  
|**Объект**|Неупорядоченный набор из нуля или более пар "имя — значение". Имя является строкой Юникода. Значение может иметь любой скалярный тип данных (за исключением типа **Неопределенное**).|  
  
 **Синтаксис**  
  
```sql  
<constant> ::=  
   <undefined_constant>  
     | <null_constant>   
     | <boolean_constant>   
     | <number_constant>   
     | <string_constant>   
     | <array_constant>   
     | <object_constant>   
  
<undefined_constant> ::= undefined  
  
<null_constant> ::= null  
  
<boolean_constant> ::= false | true  
  
<number_constant> ::= decimal_literal | hexadecimal_literal  
  
<string_constant> ::= string_literal  
  
<array_constant> ::=  
    '[' [<constant>][,...n] ']'  
  
<object_constant> ::=   
   '{' [{property_name | "property_name"} : <constant>][,...n] '}'  
  
```  
  
 **Аргументы**  
  
* `<undefined_constant>; undefined`  
  
  Представляет неопределенное значение типа "Неопределенное".  
  
* `<null_constant>; null`  
  
  Представляет значение **Null** типа **Null**.  
  
* `<boolean_constant>`  
  
  Представляет константу типа "Логический".  
  
* `false`  
  
  Представляет значение **false** типа "Логический".  
  
* `true`  
  
  Представляет значение **true** типа "Логический".  
  
* `<number_constant>`  
  
  Представляет константу.  
  
* `decimal_literal`  
  
  Десятичные литералы — это числа, представленные в десятичном или экспоненциальном представлении.  
  
* `hexadecimal_literal`  
  
  Шестнадцатеричные литералы — это числа, представленные с помощью префикса 0x, за которым следуют одна или несколько шестнадцатеричных цифр.  
  
* `<string_constant>`  
  
  Представляет константу типа "Строка".  
  
* `string _literal`  
  
  Строковые литералы — это строки Юникода, представленные в виде последовательности из нуля или более знаков Юникода или escape-последовательностей. Строковые литералы заключаются в одинарные кавычки (апостроф — ') или двойные кавычки (кавычки — ").  
  
  Допускаются следующие escape-последовательности:  
  
|**escape-последовательность**|**Описание**|**Символ Юникода**|  
|-|-|-|  
|\\'|Апостроф (')|U+0027|  
|\\"|Кавычки (")|U+0022|  
|\\\ |Обратная косая черта (\\)|U+005C|  
|\\/|Косая черта (/)|U+002F|  
|\b|BACKSPACE|U+0008|  
|\f|Смена страницы|U+000C|  
|\n|Перевод строки|U+000A|  
|\r|Возврат каретки|U+000D|  
|\t|TAB|U+0009|  
|\uXXXX|Символ Юникода, определяемый 4 шестнадцатеричными цифрами.|U+XXXX|  
  
##  <a name="bk_query_perf_guidelines"></a> Рекомендации по повышению производительности запросов  
 Чтобы повысить эффективность запросов для больших контейнеров, следует применить фильтры, которые могут обрабатываться одним или несколькими индексами.  
  
 При поиске по индексу можно применять следующие фильтры:  
  
- Используйте оператор равенства (=) с выражением пути к документу и константой.  
  
- Используйте операторы диапазона (<, \<=, >, >=) с выражением пути к документу и числовыми константами.  
  
- Выражение пути к документу — это любое выражение, которое определяет постоянный путь в документах из указанного контейнера баз данных.  
  
  **Выражение пути к документу**  
  
  Выражения пути к документу — это выражения, которые оценивают путь свойства или индексатор массива в документе из контейнера баз данных. Этот путь позволяет определить расположение значений, указанных в фильтре непосредственно в документах из контейнера баз данных.  
  
  Чтобы выражение рассматривалось как выражение пути к документу, оно должно:  
  
1.  Ссылаться непосредственно на корневой контейнер.  
  
2.  Ссылаться на свойство или индексатор массива констант любого выражения пути к документу.  
  
3.  Ссылаться на псевдоним, который представляет выражение пути к документу.  
  
     **Соглашения о синтаксисе**  
  
     В таблице ниже указаны соглашения, используемые для описания синтаксиса в следующем справочнике по SQL.  
  
    |**Соглашение**|**Область использования**|  
    |-|-|    
    |Прописные буквы|Ключевые слова, не учитывающие регистр.|  
    |Нижний регистр|Ключевые слова, учитывающие регистр.|  
    |\<Нетерминальный символ>|Нетерминальный символ, определяется отдельно.|  
    |\<Нетерминальный символ> ::=|Определение синтаксиса нетерминального символа.|  
    |Другие терминальные символы|Терминальный символ (лексема) подробно описывается в словах.|  
    |Идентификатор|Идентификатор. Поддерживает только следующие знаки: a–z, A–Z, 0–9. Первый знак не может быть цифрой.|  
    |Строка|Строка в кавычках. Разрешает любые допустимые строки. См. описание аргумента string_literal.|  
    |Символ|Литеральный символ, который является частью синтаксиса.|  
    |&#124; (вертикальная линия)|Варианты элементов синтаксиса. Можно использовать только один из указанных элементов.|  
    |[ ] /(квадратные скобки)|В квадратных скобках указывается один или несколько дополнительных элементов.|  
    |[ ,…n ]|Указывает, что предшествующий элемент может повторяться несколько раз. Отдельные вхождения элемента разделяются запятыми.|  
    |[ …n ]|Указывает, что предшествующий элемент может повторяться несколько раз. Отдельные вхождения элемента разделяются пробелами.|  
  
##  <a name="bk_built_in_functions"></a>Встроенные функции  
 Cosmos DB предоставляет множество встроенных функций SQL. Ниже перечислены их категории.  
  
|Функция|ОПИСАНИЕ|  
|--------------|-----------------|  
|[Математические функции](#bk_mathematical_functions)|Математические функции выполняют вычисление, которое обычно основано на входных значениях, предоставляемых в форме аргументов, и возвращают числовое значение.|  
|[Функции проверки типа](#bk_type_checking_functions)|Функции проверки типа позволяют проверять тип выражения в запросах SQL.|  
|[Строковые функции](#bk_string_functions)|Cтроковые функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение.|  
|[Функции массивов](#bk_array_functions)|Функции массивов выполняют операцию над входным массивом и возвращают числовое, логическое значение либо массив.|
|[Функции даты и времени](#bk_date_and_time_functions)|Функции даты и времени позволяют получить текущую дату в формате UTC и время в двух формах; числовые метки времени, значение которого равно начала эпохи Unix, в миллисекундах, или как строка, которая соответствует формату ISO 8601.|
|[Пространственные функции](#bk_spatial_functions)|Пространственные функции выполняют операцию над входным пространственным объектом и возвращают числовое или логическое значение.|  
  
###  <a name="bk_mathematical_functions"></a>Математические функции  
 Следующие функции выполняют вычисление, которое обычно основано на входных значениях, предоставляемых в форме аргументов, и возвращают числовое значение.  
  
||||  
|-|-|-|  
|[ABS](#bk_abs)|[ACOS](#bk_acos)|[ASIN](#bk_asin)|  
|[ATAN](#bk_atan)|[ATN2](#bk_atn2)|[CEILING](#bk_ceiling)|  
|[COS](#bk_cos)|[COT](#bk_cot)|[DEGREES](#bk_degrees)|  
|[EXP](#bk_exp)|[FLOOR](#bk_floor)|[LOG](#bk_log)|  
|[LOG10](#bk_log10)|[PI](#bk_pi)|[POWER](#bk_power)|  
|[RADIANS](#bk_radians)|[ROUND](#bk_round)|[SIN](#bk_sin)|  
|[SQRT](#bk_sqrt)|[SQUARE](#bk_square)|[SIGN](#bk_sign)|  
|[TAN](#bk_tan)|[TRUNC](#bk_trunc)||  
  
####  <a name="bk_abs"></a> ABS  
 Возвращает модуль (положительное значение) указанного числового выражения.  
  
 **Синтаксис**  
  
```  
ABS (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В приведенном ниже примере показаны результаты применения функции ABS к трем различным числам.  
  
```  
SELECT ABS(-1) AS abs1, ABS(0) AS abs2, ABS(1) AS abs3 
```  
  
 Результирующий набор:  
  
```  
[{abs1: 1, abs2: 0, abs3: 1}]  
```  
  
####  <a name="bk_acos"></a> ACOS  
 Возвращает угол в радианах, косинус которого равен указанному числовому выражению; также называется арккосинусом.  
  
 **Синтаксис**  
  
```  
ACOS(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает значение функции ACOS от –1.  
  
```  
SELECT ACOS(-1) AS acos 
```  
  
 Результирующий набор:  
  
```  
[{"acos": 3.1415926535897931}]  
```  
  
####  <a name="bk_asin"></a> ASIN  
 Возвращает угол в радианах, синус которого равен указанному числовому выражению. Также называется арксинусом.  
  
 **Синтаксис**  
  
```  
ASIN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает значение функции ASIN от –1.  
  
```  
SELECT ASIN(-1) AS asin  
```  
  
 Результирующий набор:  
  
```  
[{"asin": -1.5707963267948966}]  
```  
  
####  <a name="bk_atan"></a> ATAN  
 Возвращает угол в радианах, тангенс которого равен указанному числовому выражению. Также называется арктангенсом.  
  
 **Синтаксис**  
  
```  
ATAN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает значение функции ASIN от указанного значения.  
  
```  
SELECT ATAN(-45.01) AS atan  
```  
  
 Результирующий набор:  
  
```  
[{"atan": -1.5485826962062663}]  
```  
  
####  <a name="bk_atn2"></a> ATN2  
 Возвращает основное значение арктангенса y/x, выраженное в радианах.  
  
 **Синтаксис**  
  
```  
ATN2(<numeric_expression>, <numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже вычисляется ATN2 для указанных компонентов x и y.  
  
```  
SELECT ATN2(35.175643, 129.44) AS atn2  
```  
  
 Результирующий набор:  
  
```  
[{"atn2": 1.3054517947300646}]  
```  
  
####  <a name="bk_ceiling"></a> CEILING  
 Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению.  
  
 **Синтаксис**  
  
```  
CEILING (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже показаны положительные числовые, отрицательные и нулевые значения функции CEILING.  
  
```  
SELECT CEILING(123.45) AS c1, CEILING(-123.45) AS c2, CEILING(0.0) AS c3  
```  
  
 Результирующий набор:  
  
```  
[{c1: 124, c2: -123, c3: 0}]  
```  
  
####  <a name="bk_cos"></a> COS  
 Возвращает тригонометрический косинус указанного угла в радианах в указанном выражении.  
  
 **Синтаксис**  
  
```  
COS(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже вычисляется COS указанного угла.  
  
```  
SELECT COS(14.78) AS cos  
```  
  
 Результирующий набор:  
  
```  
[{"cos": -0.59946542619465426}]  
```  
  
####  <a name="bk_cot"></a> COT  
 Возвращает тригонометрический котангенс указанного угла в радианах в указанном числовом выражении.  
  
 **Синтаксис**  
  
```  
COT(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже вычисляется COT указанного угла.  
  
```  
SELECT COT(124.1332) AS cot  
```  
  
 Результирующий набор:  
  
```  
[{"cot": -0.040311998371148884}]  
```  
  
####  <a name="bk_degrees"></a> DEGREES  
 Возвращает соответствующее значение угла в градусах для угла, указанного в радианах.  
  
 **Синтаксис**  
  
```  
DEGREES (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Следующий пример возвращает число градусов в угле, равном PI/2 радиан.  
  
```  
SELECT DEGREES(PI()/2) AS degrees  
```  
  
 Результирующий набор:  
  
```  
[{"degrees": 90}]  
```  
  
####  <a name="bk_floor"></a> FLOOR  
 Возвращает наибольшее целочисленное значение, которое меньше или равно указанному числовому выражению.  
  
 **Синтаксис**  
  
```  
FLOOR (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже показаны положительные числовые, отрицательные и нулевые значения функции FLOOR.  
  
```  
SELECT FLOOR(123.45) AS fl1, FLOOR(-123.45) AS fl2, FLOOR(0.0) AS fl3  
```  
  
 Результирующий набор:  
  
```  
[{fl1: 123, fl2: -124, fl3: 0}]  
```  
  
####  <a name="bk_exp"></a> EXP  
 Возвращает значение экспоненты для указанного числового выражения.  
  
 **Синтаксис**  
  
```  
EXP (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примечания**  
  
  Константа **e** (2,718281…) является основанием натуральных логарифмов.  
  
  Экспонента числа — это константа **e** степени числа. Например, EXP(1.0) = e^1.0 = 2,71828182845905 и EXP(10) = e^10 = 22026,4657948067.  
  
  Экспонента натурального логарифма числа — это само число. Например, EXP (LOG (n)) = n. Натуральный логарифм экспоненты числа — это само число. Например, LOG (EXP (n)) = n.  
  
  **Примеры**  
  
  В примере ниже объявляется переменная и возвращается значение экспоненты указанной переменной (10).  
  
```  
SELECT EXP(10) AS exp  
```  
  
 Результирующий набор:  
  
```  
[{exp: 22026.465794806718}]  
```  
  
 Пример ниже возвращает значение экспоненты от натурального логарифма 20 и натуральный логарифм экспоненты 20. Так как эти функции обратные, в обоих случаях возвращается значение 20 (после округления до плавающей запятой).  
  
```  
SELECT EXP(LOG(20)) AS exp1, LOG(EXP(20)) AS exp2  
```  
  
 Результирующий набор:  
  
```  
[{exp1: 19.999999999999996, exp2: 20}]  
```  
  
####  <a name="bk_log"></a> LOG  
 Возвращает натуральный логарифм от указанного числового выражения.  
  
 **Синтаксис**  
  
```  
LOG (<numeric_expression> [, <base>])  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
- `base`  
  
   Дополнительный числовой аргумент, который задает основание логарифма.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примечания**  
  
  По умолчанию функция LOG() возвращает натуральный логарифм. Основание логарифма можно изменить с помощью дополнительного параметра основания.  
  
  Натуральный логарифм — это логарифм с основанием **e**, где **e** — это иррациональная константа приблизительно равная 2,718281828.  
  
  Натуральный логарифм экспоненты числа — это само число. Например, LOG( EXP( n ) ) = n. Экспонента натурального логарифма числа — это само число. Например, EXP( LOG( n ) ) = n.  
  
  **Примеры**  
  
  В примере ниже объявляется переменная и возвращается значение логарифма указанной переменной (10).  
  
```  
SELECT LOG(10) AS log  
```  
  
 Результирующий набор:  
  
```  
[{log: 2.3025850929940459}]  
```  
  
 В примере ниже вычисляется логарифм экспоненты числа.  
  
```  
SELECT EXP(LOG(10)) AS expLog  
```  
  
 Результирующий набор:  
  
```  
[{expLog: 10.000000000000002}]  
```  
  
####  <a name="bk_log10"></a> LOG10  
 Возвращает десятичный логарифм от указанного числового выражения.  
  
 **Синтаксис**  
  
```  
LOG10 (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примечания**  
  
  Функции LOG10 и POWER обратно связаны друг с другом. Например, 10 ^ LOG10(n) = n.  
  
  **Примеры**  
  
  В примере ниже объявляется переменная и возвращается значение LOG10 указанной переменной (100).  
  
```  
SELECT LOG10(100) AS log10 
```  
  
 Результирующий набор:  
  
```  
[{log10: 2}]  
```  
  
####  <a name="bk_pi"></a> PI  
 Возвращает значение константы "пи".  
  
 **Синтаксис**  
  
```  
PI ()  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает значение PI.  
  
```  
SELECT PI() AS pi 
```  
  
 Результирующий набор:  
  
```  
[{"pi": 3.1415926535897931}]  
```  
  
####  <a name="bk_power"></a> POWER  
 Возвращает результат возведения указанного числового выражения в заданную степень.  
  
 **Синтаксис**  
  
```  
POWER (<numeric_expression>, <y>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
- `y`  
  
   Степень для возведения аргумента `numeric_expression`.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В следующем примере показано возведение числа в третью степень (куб числа).  
  
```  
SELECT POWER(2, 3) AS pow1, POWER(2.5, 3) AS pow2  
```  
  
 Результирующий набор:  
  
```  
[{pow1: 8, pow2: 15.625}]  
```  
  
####  <a name="bk_radians"></a> RADIANS  
 Возвращает значение угла в радианах для числового значения, указанного в градусах.  
  
 **Синтаксис**  
  
```  
RADIANS (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже берется несколько углов в качестве входных данных и возвращаются их соответствующие значения в радианах.  
  
```  
SELECT RADIANS(-45.01) AS r1, RADIANS(-181.01) AS r2, RADIANS(0) AS r3, RADIANS(0.1472738) AS r4, RADIANS(197.1099392) AS r5  
```  
  
 Результирующий набор:  
  
```  
[{  
       "r1": -0.7855726963226477,  
       "r2": -3.1592204790349356,  
       "r3": 0,  
       "r4": 0.0025704127119236249,  
       "r5": 3.4402174274458375  
   }]  
```  
  
####  <a name="bk_round"></a> ROUND  
 Возвращает числовое значение, округленное до ближайшего целого значения в большую сторону.  
  
 **Синтаксис**  
  
```  
ROUND(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже положительные и отрицательные числа округляются до ближайшего целого.  
  
```  
SELECT ROUND(2.4) AS r1, ROUND(2.6) AS r2, ROUND(2.5) AS r3, ROUND(-2.4) AS r4, ROUND(-2.6) AS r5  
```  
  
 Результирующий набор:  
  
```  
[{r1: 2, r2: 3, r3: 3, r4: -2, r5: -3}]  
```  
  
####  <a name="bk_sign"></a> SIGN  
 Возвращает знак указанного числового выражения (+1 для положительных чисел, 0 для нуля или -1 для отрицательных).  
  
 **Синтаксис**  
  
```  
SIGN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает значения SIGN для чисел от –2 до 2.  
  
```  
SELECT SIGN(-2) AS s1, SIGN(-1) AS s2, SIGN(0) AS s3, SIGN(1) AS s4, SIGN(2) AS s5  
```  
  
 Результирующий набор:  
  
```  
[{s1: -1, s2: -1, s3: 0, s4: 1, s5: 1}]  
```  
  
####  <a name="bk_sin"></a> SIN  
 Возвращает тригонометрический синус заданного угла в радианах для указанного выражения.  
  
 **Синтаксис**  
  
```  
SIN(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже вычисляется синус указанного угла.  
  
```  
SELECT SIN(45.175643) AS sin  
```  
  
 Результирующий набор:  
  
```  
[{"sin": 0.929607286611012}]  
```  
  
####  <a name="bk_sqrt"></a> SQRT  
 Возвращает квадратный корень из указанного числового значения.  
  
 **Синтаксис**  
  
```  
SQRT(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает квадратный корень для чисел 1–3.  
  
```  
SELECT SQRT(1) AS s1, SQRT(2.0) AS s2, SQRT(3) AS s3  
```  
  
 Результирующий набор:  
  
```  
[{s1: 1, s2: 1.4142135623730952, s3: 1.7320508075688772}]  
```  
  
####  <a name="bk_square"></a> SQUARE  
 Возвращает квадратный корень из указанного числового значения.  
  
 **Синтаксис**  
  
```  
SQUARE(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает квадраты для чисел 1–3.  
  
```  
SELECT SQUARE(1) AS s1, SQUARE(2.0) AS s2, SQUARE(3) AS s3  
```  
  
 Результирующий набор:  
  
```  
[{s1: 1, s2: 4, s3: 9}]  
```  
  
####  <a name="bk_tan"></a> TAN  
 Возвращает тангенс заданного угла в радианах для указанного выражения.  
  
 **Синтаксис**  
  
```  
TAN (<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже вычисляет тангенс от PI()/2.  
  
```  
SELECT TAN(PI()/2) AS tan 
```  
  
 Результирующий набор:  
  
```  
[{"tan": 16331239353195370 }]  
```  
  
####  <a name="bk_trunc"></a> TRUNC  
 Возвращает числовое значение, округленное до ближайшего целого значения в меньшую сторону.  
  
 **Синтаксис**  
  
```  
TRUNC(<numeric_expression>)  
```  
  
 **Аргументы**  
  
- `numeric_expression`  
  
   Числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже положительные и отрицательные числа усекаются до ближайшего целого значения.  
  
```  
SELECT TRUNC(2.4) AS t1, TRUNC(2.6) AS t2, TRUNC(2.5) AS t3, TRUNC(-2.4) AS t4, TRUNC(-2.6) AS t5  
```  
  
 Результирующий набор:  
  
```  
[{t1: 2, t2: 2, t3: 2, t4: -2, t5: -2}]  
```  
  
###  <a name="bk_type_checking_functions"></a> Функции проверки типа  
 Следующие функции поддерживают проверку типа входных значений и возвращают логическое значение.  
  
||||  
|-|-|-|  
|[IS_ARRAY](#bk_is_array)|[IS_BOOL](#bk_is_bool)|[IS_DEFINED](#bk_is_defined)|  
|[IS_NULL](#bk_is_null)|[IS_NUMBER](#bk_is_number)|[IS_OBJECT](#bk_is_object)|  
|[IS_PRIMITIVE](#bk_is_primitive)|[IS_STRING](#bk_is_string)||  
  
####  <a name="bk_is_array"></a> IS_ARRAY  
 Возвращает логическое значение, указывающее, является ли указанное выражение массивом.  
  
 **Синтаксис**  
  
```  
IS_ARRAY(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_ARRAY проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
 IS_ARRAY(true) AS isArray1,   
 IS_ARRAY(1) AS isArray2,  
 IS_ARRAY("value") AS isArray3,  
 IS_ARRAY(null) AS isArray4,  
 IS_ARRAY({prop: "value"}) AS isArray5,   
 IS_ARRAY([1, 2, 3]) AS isArray6,  
 IS_ARRAY({prop: "value"}.prop2) AS isArray7  
```  
  
 Результирующий набор:  
  
```  
[{"isArray1":false,"isArray2":false,"isArray3":false,"isArray4":false,"isArray5":false,"isArray6":true,"isArray7":false}]
```  
  
####  <a name="bk_is_bool"></a> IS_BOOL  
 Возвращает логическое значение, указывающее, является ли указанное выражение логическим значением.  
  
 **Синтаксис**  
  
```  
IS_BOOL(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_BOOL проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_BOOL(true) AS isBool1,   
    IS_BOOL(1) AS isBool2,  
    IS_BOOL("value") AS isBool3,   
    IS_BOOL(null) AS isBool4,  
    IS_BOOL({prop: "value"}) AS isBool5,   
    IS_BOOL([1, 2, 3]) AS isBool6,  
    IS_BOOL({prop: "value"}.prop2) AS isBool7  
```  
  
 Результирующий набор:  
  
```  
[{"isBool1":true,"isBool2":false,"isBool3":false,"isBool4":false,"isBool5":false,"isBool6":false,"isBool7":false}]
```  
  
####  <a name="bk_is_defined"></a> IS_DEFINED  
 Возвращает логическое значение, указывающее, назначено ли свойству значение.  
  
 **Синтаксис**  
  
```  
IS_DEFINED(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже проверяется наличие свойства в указанном документе JSON. Первый пример возвращает значение true, так как присутствует значение "a", но второй возвращает значение false, так как значение "b" отсутствует.  
  
```  
SELECT IS_DEFINED({ "a" : 5 }.a) AS isDefined1, IS_DEFINED({ "a" : 5 }.b) AS isDefined2 
```  
  
 Результирующий набор:  
  
```  
[{"isDefined1":true,"isDefined2":false}]  
```  
  
####  <a name="bk_is_null"></a> IS_NULL  
 Возвращает логическое значение, указывающее, является ли указанное выражение значением Null.  
  
 **Синтаксис**  
  
```  
IS_NULL(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_NULL проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_NULL(true) AS isNull1,   
    IS_NULL(1) AS isNull2,  
    IS_NULL("value") AS isNull3,   
    IS_NULL(null) AS isNull4,  
    IS_NULL({prop: "value"}) AS isNull5,   
    IS_NULL([1, 2, 3]) AS isNull6,  
    IS_NULL({prop: "value"}.prop2) AS isNull7  
```  
  
 Результирующий набор:  
  
```  
[{"isNull1":false,"isNull2":false,"isNull3":false,"isNull4":true,"isNull5":false,"isNull6":false,"isNull7":false}]
```  
  
####  <a name="bk_is_number"></a> IS_NUMBER  
 Возвращает логическое значение, указывающее, является ли указанное выражение числовым значением.  
  
 **Синтаксис**  
  
```  
IS_NUMBER(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_NULL проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_NUMBER(true) AS isNum1,   
    IS_NUMBER(1) AS isNum2,  
    IS_NUMBER("value") AS isNum3,   
    IS_NUMBER(null) AS isNum4,  
    IS_NUMBER({prop: "value"}) AS isNum5,   
    IS_NUMBER([1, 2, 3]) AS isNum6,  
    IS_NUMBER({prop: "value"}.prop2) AS isNum7  
```  
  
 Результирующий набор:  
  
```  
[{"isNum1":false,"isNum2":true,"isNum3":false,"isNum4":false,"isNum5":false,"isNum6":false,"isNum7":false}]  
```  
  
####  <a name="bk_is_object"></a> IS_OBJECT  
 Возвращает логическое значение, указывающее, является ли указанное выражение объектом JSON.  
  
 **Синтаксис**  
  
```  
IS_OBJECT(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_OBJECT проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
    IS_OBJECT(true) AS isObj1,   
    IS_OBJECT(1) AS isObj2,  
    IS_OBJECT("value") AS isObj3,   
    IS_OBJECT(null) AS isObj4,  
    IS_OBJECT({prop: "value"}) AS isObj5,   
    IS_OBJECT([1, 2, 3]) AS isObj6,  
    IS_OBJECT({prop: "value"}.prop2) AS isObj7  
```  
  
 Результирующий набор:  
  
```  
[{"isObj1":false,"isObj2":false,"isObj3":false,"isObj4":false,"isObj5":true,"isObj6":false,"isObj7":false}]
```  
  
####  <a name="bk_is_primitive"></a> IS_PRIMITIVE  
 Возвращает логическое значение, указывающее, является ли указанное выражение примитивом (строкой, логическим значением, числовым значением или значением Null).  
  
 **Синтаксис**  
  
```  
IS_PRIMITIVE(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_PRIMITIVE проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
           IS_PRIMITIVE(true) AS isPrim1,   
           IS_PRIMITIVE(1) AS isPrim2,  
           IS_PRIMITIVE("value") AS isPrim3,   
           IS_PRIMITIVE(null) AS isPrim4,  
           IS_PRIMITIVE({prop: "value"}) AS isPrim5,   
           IS_PRIMITIVE([1, 2, 3]) AS isPrim6,  
           IS_PRIMITIVE({prop: "value"}.prop2) AS isPrim7  
```  
  
 Результирующий набор:  
  
```  
[{"isPrim1": true, "isPrim2": true, "isPrim3": true, "isPrim4": true, "isPrim5": false, "isPrim6": false, "isPrim7": false}]  
```  
  
####  <a name="bk_is_string"></a> IS_STRING  
 Возвращает логическое значение, указывающее, является ли указанное выражение строковым значением.  
  
 **Синтаксис**  
  
```  
IS_STRING(<expression>)  
```  
  
 **Аргументы**  
  
- `expression`  
  
   Любое допустимое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже с помощью функции IS_STRING проверяются логические значения JSON, числа, строки, значения Null, объекты, массивы и неопределенные типы.  
  
```  
SELECT   
       IS_STRING(true) AS isStr1,   
       IS_STRING(1) AS isStr2,  
       IS_STRING("value") AS isStr3,   
       IS_STRING(null) AS isStr4,  
       IS_STRING({prop: "value"}) AS isStr5,   
       IS_STRING([1, 2, 3]) AS isStr6,  
       IS_STRING({prop: "value"}.prop2) AS isStr7  
```  
  
 Результирующий набор:  
  
```  
[{"isStr1":false,"isStr2":false,"isStr3":true,"isStr4":false,"isStr5":false,"isStr6":false,"isStr7":false}] 
```  
  
###  <a name="bk_string_functions"></a> Строковые функции  
 Следующие скалярные функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение.  
  
||||  
|-|-|-|  
|[CONCAT](#bk_concat)|[CONTAINS](#bk_contains)|[ENDSWITH](#bk_endswith)|  
|[INDEX_OF](#bk_index_of)|[LEFT](#bk_left)|[LENGTH](#bk_length)|  
|[LOWER](#bk_lower)|[LTRIM](#bk_ltrim)|[REPLACE](#bk_replace)|  
|[REPLICATE](#bk_replicate)|[REVERSE](#bk_reverse)|[RIGHT](#bk_right)|  
|[RTRIM](#bk_rtrim)|[STARTSWITH](#bk_startswith)|[StringToArray](#bk_stringtoarray)|
|[StringToBoolean](#bk_stringtoboolean)|[StringToNull](#bk_stringtonull)|[StringToNumber](#bk_stringtonumber)|
|[StringToObject](#bk_stringtoobject)|[SUBSTRING](#bk_substring)|[ToString](#bk_tostring)|
|[TRIM](#bk_trim)|[UPPER](#bk_upper)||
  
####  <a name="bk_concat"></a> CONCAT  
 Возвращает строку, являющуюся результатом объединения двух или более строковых значений.  
  
 **Синтаксис**  
  
```  
CONCAT(<str_expr>, <str_expr> [, <str_expr>])  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает объединенную строку указанных значений.  
  
```  
SELECT CONCAT("abc", "def") AS concat  
```  
  
 Результирующий набор:  
  
```  
[{"concat": "abcdef"}  
```  
  
####  <a name="bk_contains"></a> CONTAINS  
 Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе.  
  
 **Синтаксис**  
  
```  
CONTAINS(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  Пример ниже проверяет, содержит ли строка "abc"вхождения "ab" и "d".  
  
```  
SELECT CONTAINS("abc", "ab") AS c1, CONTAINS("abc", "d") AS c2 
```  
  
 Результирующий набор:  
  
```  
[{"c1": true, "c2": false}]  
```  
  
####  <a name="bk_endswith"></a> ENDSWITH  
 Возвращает значение логического типа, указывающее, заканчивается ли первое строковое выражение вторым.  
  
 **Синтаксис**  
  
```  
ENDSWITH(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает строки "abc", в конце которых есть "b" и "bc".  
  
```  
SELECT ENDSWITH("abc", "b") AS e1, ENDSWITH("abc", "bc") AS e2 
```  
  
 Результирующий набор:  
  
```  
[{"e1": false, "e2": true}]  
```  
  
####  <a name="bk_index_of"></a> INDEX_OF  
 Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или –1, если строка не найдена.  
  
 **Синтаксис**  
  
```  
INDEX_OF(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает индекс различных подстрок в строке "abc".  
  
```  
SELECT INDEX_OF("abc", "ab") AS i1, INDEX_OF("abc", "b") AS i2, INDEX_OF("abc", "c") AS i3 
```  
  
 Результирующий набор:  
  
```  
[{"i1": 0, "i2": 1, "i3": -1}]  
```  
  
####  <a name="bk_left"></a> LEFT  
 Возвращает левую часть строки с указанным количеством символов.  
  
 **Синтаксис**  
  
```  
LEFT(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
- `num_expr`  
  
   Любое допустимое числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает левую часть строки "abc" для значений различной длины.  
  
```  
SELECT LEFT("abc", 1) AS l1, LEFT("abc", 2) AS l2 
```  
  
 Результирующий набор:  
  
```  
[{"l1": "a", "l2": "ab"}]  
```  
  
####  <a name="bk_length"></a> LENGTH  
 Возвращает число символов указанного строкового выражения.  
  
 **Синтаксис**  
  
```  
LENGTH(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает длину строки.  
  
```  
SELECT LENGTH("abc") AS len 
```  
  
 Результирующий набор:  
  
```  
[{"len": 3}]  
```  
  
####  <a name="bk_lower"></a> LOWER  
 Возвращает строковое выражение после преобразования символов верхнего регистра в нижний.  
  
 **Синтаксис**  
  
```  
LOWER(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции LOWER в запросе.  
  
```  
SELECT LOWER("Abc") AS lower
```  
  
 Результирующий набор:  
  
```  
[{"lower": "abc"}]  
  
```  
  
####  <a name="bk_ltrim"></a> LTRIM  
 Возвращает строковое выражение после удаления начальных пробелов.  
  
 **Синтаксис**  
  
```  
LTRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции LTRIM в запросе.  
  
```  
SELECT LTRIM("  abc") AS l1, LTRIM("abc") AS l2, LTRIM("abc   ") AS l3 
```  
  
 Результирующий набор:  
  
```  
[{"l1": "abc", "l2": "abc", "l3": "abc   "}]  
```  
  
####  <a name="bk_replace"></a> REPLACE  
 Заменяет все вхождения указанного строкового значения другим строковым значением.  
  
 **Синтаксис**  
  
```  
REPLACE(<str_expr>, <str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции REPLACE в запросе.  
  
```  
SELECT REPLACE("This is a Test", "Test", "desk") AS replace 
```  
  
 Результирующий набор:  
  
```  
[{"replace": "This is a desk"}]  
```  
  
####  <a name="bk_replicate"></a> REPLICATE  
 Повторяет строковое значение указанное число раз.  
  
 **Синтаксис**  
  
```  
REPLICATE(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
- `num_expr`  
  
   Любое допустимое числовое выражение. Если значение num_expr является отрицательным или бесконечным, результат не определяется.

  > [!NOTE]
  > Максимальная длина результата — 10 000 символов, т. е. (length(str_expr) * num_expr) < = 10 000.
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции REPLICATE в запросе.  
  
```  
SELECT REPLICATE("a", 3) AS replicate  
```  
  
 Результирующий набор:  
  
```  
[{"replicate": "aaa"}]  
```  
  
####  <a name="bk_reverse"></a> REVERSE  
 Возвращает обратный порядок строкового значения.  
  
 **Синтаксис**  
  
```  
REVERSE(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции REVERSE в запросе.  
  
```  
SELECT REVERSE("Abc") AS reverse  
```  
  
 Результирующий набор:  
  
```  
[{"reverse": "cbA"}]  
```  
  
####  <a name="bk_right"></a> RIGHT  
 Возвращает правую часть строки с указанным количеством символов.  
  
 **Синтаксис**  
  
```  
RIGHT(<str_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
- `num_expr`  
  
   Любое допустимое числовое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает правую часть строки "abc" для значений различной длины.  
  
```  
SELECT RIGHT("abc", 1) AS r1, RIGHT("abc", 2) AS r2 
```  
  
 Результирующий набор:  
  
```  
[{"r1": "c", "r2": "bc"}]  
```  
  
####  <a name="bk_rtrim"></a> RTRIM  
 Возвращает строковое выражение после удаления конечных пробелов.  
  
 **Синтаксис**  
  
```  
RTRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции RTRIM в запросе.  
  
```  
SELECT RTRIM("  abc") AS r1, RTRIM("abc") AS r2, RTRIM("abc   ") AS r3  
```  
  
 Результирующий набор:  
  
```  
[{"r1": "   abc", "r2": "abc", "r3": "abc"}]  
```  
  
####  <a name="bk_startswith"></a> STARTSWITH  
 Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым.  
  
 **Синтаксис**  
  
```  
STARTSWITH(<str_expr>, <str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  Пример ниже проверяет, начинается ли строка "abc" с "b" и "a".  
  
```  
SELECT STARTSWITH("abc", "b") AS s1, STARTSWITH("abc", "a") AS s2  
```  
  
 Результирующий набор:  
  
```  
[{"s1": false, "s2": true}]  
```  

  ####  <a name="bk_stringtoarray"></a> StringToArray  
 Возвращает выражение, преобразованное в массив. Если выражение не может быть преобразован, возвращает значение undefined.  
  
 **Синтаксис**  
  
```  
StringToArray(<expr>)  
```  
  
 **Аргументы**  
  
- `expr`  
  
   — Это любое допустимое скалярное выражение, вычисляемое как выражение массива JSON. Обратите внимание на то, что вложенные строковые значения должны писаться с двойные кавычки, чтобы быть допустимыми. Дополнительные сведения о формате JSON, см. в разделе [json.org](https://json.org/)
  
  **Типы возвращаемого значения**  
  
  Возвращает выражение массива или не определено.  
  
  **Примеры**  
  
  В следующем примере показано, как ведет себя StringToArray различными типами. 
  
 Ниже приведены примеры с допустимыми входными данными.

```
SELECT 
    StringToArray('[]') AS a1, 
    StringToArray("[1,2,3]") AS a2,
    StringToArray("[\"str\",2,3]") AS a3,
    StringToArray('[["5","6","7"],["8"],["9"]]') AS a4,
    StringToArray('[1,2,3, "[4,5,6]",[7,8]]') AS a5
```

Результирующий набор:

```
[{"a1": [], "a2": [1,2,3], "a3": ["str",2,3], "a4": [["5","6","7"],["8"],["9"]], "a5": [1,2,3,"[4,5,6]",[7,8]]}]
```

Ниже приведен пример недопустимые входные данные. 
   
 Одинарные кавычки в пределах массива не являются допустимым кодом JSON.
Несмотря на то, что они являются допустимыми в рамках запроса, они не будет анализировать допустимым массивов. Строки в строку массив либо должны быть экранированы «[\\"\\«]» или окружающей кавычки должен состоять из одного" [»»] ".

```
SELECT
    StringToArray("['5','6','7']")
```

Результирующий набор:

```
[{}]
```

Ниже приведены примеры недопустимых входных данных.
   
 Выражение, передаваемое будет проанализирована как массив JSON; следующее не вычисляют типа array и таким образом вернуть неопределенным.
   
```
SELECT
    StringToArray("["),
    StringToArray("1"),
    StringToArray(NaN),
    StringToArray(false),
    StringToArray(undefined)
```

Результирующий набор:

```
[{}]
```

####  <a name="bk_stringtoboolean"></a> StringToBoolean  
 Возвращает выражение, преобразованное в логический тип. Если выражение не может быть преобразован, возвращает значение undefined.  
  
 **Синтаксис**  
  
```  
StringToBoolean(<expr>)  
```  
  
 **Аргументы**  
  
- `expr`  
  
   — Любое допустимое скалярное выражение, для оценки в качестве логического выражения.  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение или не определено.  
  
  **Примеры**  
  
  В следующем примере показано, как ведет себя StringToBoolean различными типами. 
 
 Ниже приведены примеры с допустимыми входными данными.

Пробел допускается только до или после «true «/» false».

```  
SELECT 
    StringToBoolean("true") AS b1, 
    StringToBoolean("    false") AS b2,
    StringToBoolean("false    ") AS b3
```  
  
 Результирующий набор:  
  
```  
[{"b1": true, "b2": false, "b3": false}]
```  

Ниже приведены примеры, содержащими Недопустимый ввод.

 Логические значения чувствительны к регистру и должны писаться с все строчные буквы, т. е. «true» и «false».

```  
SELECT 
    StringToBoolean("TRUE"),
    StringToBoolean("False")
```  

Результирующий набор:  
  
```  
[{}]
``` 

Выражение, передаваемое будет проанализирована как логическое выражение; Эти входные данные не вычисляют логический тип и таким образом вернуть неопределенным.

```  
SELECT 
    StringToBoolean("null"),
    StringToBoolean(undefined),
    StringToBoolean(NaN), 
    StringToBoolean(false), 
    StringToBoolean(true)
```  

Результирующий набор:  
  
```  
[{}]
```  

####  <a name="bk_stringtonull"></a> StringToNull  
 Возвращает выражение, преобразованное в значение null. Если выражение не может быть преобразован, возвращает значение undefined.  
  
 **Синтаксис**  
  
```  
StringToNull(<expr>)  
```  
  
 **Аргументы**  
  
- `expr`  
  
   — Любое допустимое скалярное выражение, для оценки в качестве выражения null.
  
  **Типы возвращаемого значения**  
  
  Возвращает выражение, значение null или не определено.  
  
  **Примеры**  
  
  В следующем примере показано, как ведет себя StringToNull различными типами. 

Ниже приведены примеры с допустимыми входными данными.

 Пробел допускается только до или после «null».

```  
SELECT 
    StringToNull("null") AS n1, 
    StringToNull("  null ") AS n2,
    IS_NULL(StringToNull("null   ")) AS n3
```  
  
 Результирующий набор:  
  
```  
[{"n1": null, "n2": null, "n3": true}]
```  

Ниже приведены примеры, содержащими Недопустимый ввод.

NULL чувствительно к регистру и должны писаться с всех символов нижнего регистра т. е. «null».

```  
SELECT    
    StringToNull("NULL"),
    StringToNull("Null")
```  
  
 Результирующий набор:  
  
```  
[{}]
```  

Выражение, передаваемое будет проанализирована как выражение null; Эти входные данные не вычисляют введите значение null и таким образом вернуть неопределенным.

```  
SELECT    
    StringToNull("true"), 
    StringToNull(false), 
    StringToNull(undefined),
    StringToNull(NaN) 
```  
  
 Результирующий набор:  
  
```  
[{}]
```  

####  <a name="bk_stringtonumber"></a> StringToNumber  
 Возвращает выражение, преобразованное в число. Если выражение не может быть преобразован, возвращает значение undefined.  
  
 **Синтаксис**  
  
```  
StringToNumber(<expr>)  
```  
  
 **Аргументы**  
  
- `expr`  
  
   — Это любое допустимое скалярное выражение, вычисляемое как выражение числу JSON. Числа в формате JSON должно быть целое число или число с плавающей запятой. Дополнительные сведения о формате JSON, см. в разделе [json.org](https://json.org/)  
  
  **Типы возвращаемого значения**  
  
  Возвращает выражение, определяющее номер или не определено.  
  
  **Примеры**  
  
  В следующем примере показано, как ведет себя StringToNumber различными типами. 

Пробел допускается только до или после номера.

```  
SELECT 
    StringToNumber("1.000000") AS num1, 
    StringToNumber("3.14") AS num2,
    StringToNumber("   60   ") AS num3, 
    StringToNumber("-1.79769e+308") AS num4
```  
  
 Результирующий набор:  
  
```  
{{"num1": 1, "num2": 3.14, "num3": 60, "num4": -1.79769e+308}}
```  

В формате JSON, либо должен быть допустимым числом быть целое число или число с плавающей запятой.

```  
SELECT   
    StringToNumber("0xF")
```  
  
 Результирующий набор:  
  
```  
{{}}
```  

Выражение, передаваемое будет проанализирована как выражения; Эти входные данные не вычисляют введите номер и таким образом вернуть неопределенным. 

```  
SELECT 
    StringToNumber("99     54"),   
    StringToNumber(undefined),
    StringToNumber("false"),
    StringToNumber(false),
    StringToNumber(" "),
    StringToNumber(NaN)
```  
  
 Результирующий набор:  
  
```  
{{}}
```  

####  <a name="bk_stringtoobject"></a> StringToObject  
 Возвращает выражение, преобразованное в объект. Если выражение не может быть преобразован, возвращает значение undefined.  
  
 **Синтаксис**  
  
```  
StringToObject(<expr>)  
```  
  
 **Аргументы**  
  
- `expr`  
  
   — Любое допустимое скалярное выражение, для оценки в качестве выражению объекта JSON. Обратите внимание на то, что вложенные строковые значения должны писаться с двойные кавычки, чтобы быть допустимыми. Дополнительные сведения о формате JSON, см. в разделе [json.org](https://json.org/)  
  
  **Типы возвращаемого значения**  
  
  Возвращает выражение, или не определено.  
  
  **Примеры**  
  
  В следующем примере показано, как ведет себя StringToObject различными типами. 
  
 Ниже приведены примеры с допустимыми входными данными.

``` 
SELECT 
    StringToObject("{}") AS obj1, 
    StringToObject('{"A":[1,2,3]}') AS obj2,
    StringToObject('{"B":[{"b1":[5,6,7]},{"b2":8},{"b3":9}]}') AS obj3, 
    StringToObject("{\"C\":[{\"c1\":[5,6,7]},{\"c2\":8},{\"c3\":9}]}") AS obj4
``` 

Результирующий набор:

```
[{"obj1": {}, 
  "obj2": {"A": [1,2,3]}, 
  "obj3": {"B":[{"b1":[5,6,7]},{"b2":8},{"b3":9}]},
  "obj4": {"C":[{"c1":[5,6,7]},{"c2":8},{"c3":9}]}}]
```

 Ниже приведены примеры, содержащими Недопустимый ввод.
Несмотря на то, что они являются допустимыми в рамках запроса, они не проанализировать действительными объектами. Строки в строке объекта необходимо экранировать либо «{\\«\\«:\\«str\\«}» или окружающей кавычки должен состоять из одного "{«»: «str»}".

Одинарными кавычками, окружающими имена свойств не являются допустимым кодом JSON.

``` 
SELECT 
    StringToObject("{'a':[1,2,3]}")
```

Результирующий набор:

```  
[{}]
```  

Имена свойств без окружающих кавычек не допустимых данных JSON.

``` 
SELECT 
    StringToObject("{a:[1,2,3]}")
```

Результирующий набор:

```  
[{}]
``` 

Ниже приведены примеры, содержащими Недопустимый ввод.

 Выражение, передаваемое будет проанализирована как объект JSON; Эти входные данные не вычисляют типа object и таким образом вернуть неопределенным.

``` 
SELECT 
    StringToObject("}"),
    StringToObject("{"),
    StringToObject("1"),
    StringToObject(NaN), 
    StringToObject(false), 
    StringToObject(undefined)
``` 
 
 Результирующий набор:

```
[{}]
```

####  <a name="bk_substring"></a> SUBSTRING  
 Возвращает часть строкового выражения, начиная с указанной позиции (отсчет начинается с нуля) и до достижения указанной длины (или до конца строки).  
  
 **Синтаксис**  
  
```  
SUBSTRING(<str_expr>, <num_expr>, <num_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
- `num_expr`  
  
   Любое допустимое числовое выражение для обозначения символа начала и окончания.    
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Пример ниже возвращает подстроку "abc", которая начинается с 1 и имеет длину в 1 знак.  
  
```  
SELECT SUBSTRING("abc", 1, 1) AS substring  
```  
  
 Результирующий набор:  
  
```  
[{"substring": "b"}]  
```  
####  <a name="bk_tostring"></a> ToString  
 Возвращает строковое представление скалярного выражения. 
  
 **Синтаксис**  
  
```  
ToString(<expr>)
```  
  
 **Аргументы**  
  
- `expr`  
  
   Любое допустимое скалярное выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  В следующем примере демонстрируется поведение ToString с различными типами.   
  
```  
SELECT 
    ToString(1.0000) AS str1, 
    ToString("Hello World") AS str2, 
    ToString(NaN) AS str3, 
    ToString(Infinity) AS str4,
    ToString(IS_STRING(ToString(undefined))) AS str5, 
    ToString(0.1234) AS str6, 
    ToString(false) AS str7, 
    ToString(undefined) AS str8
```  
  
 Результирующий набор:  
  
```  
[{"str1": "1", "str2": "Hello World", "str3": "NaN", "str4": "Infinity", "str5": "false", "str6": "0.1234", "str7": "false"}]  
```  
 Для следующих входных данных:
```  
{"Products":[{"ProductID":1,"Weight":4,"WeightUnits":"lb"},{"ProductID":2,"Weight":32,"WeightUnits":"kg"},{"ProductID":3,"Weight":400,"WeightUnits":"g"},{"ProductID":4,"Weight":8999,"WeightUnits":"mg"}]}
```    
 Следующий пример демонстрирует использование ToString с другими строковыми функциями, такими как CONCAT.   
 
```  
SELECT 
CONCAT(ToString(p.Weight), p.WeightUnits) 
FROM p in c.Products 
```  

Результирующий набор:  
  
```  
[{"$1":"4lb" },
{"$1":"32kg"},
{"$1":"400g" },
{"$1":"8999mg" }]

```  
Для следующих входных данных.
```
{"id":"08259","description":"Cereals ready-to-eat, KELLOGG, KELLOGG'S CRISPIX","nutrients":[{"id":"305","description":"Caffeine","units":"mg"},{"id":"306","description":"Cholesterol, HDL","nutritionValue":30,"units":"mg"},{"id":"307","description":"Sodium, NA","nutritionValue":612,"units":"mg"},{"id":"308","description":"Protein, ABP","nutritionValue":60,"units":"mg"},{"id":"309","description":"Zinc, ZN","nutritionValue":null,"units":"mg"}]}
```
Следующий пример демонстрирует использование ToString с другими строковыми функциями, такими как REPLACE.   
```
SELECT 
    n.id AS nutrientID,
    REPLACE(ToString(n.nutritionValue), "6", "9") AS nutritionVal
FROM food 
JOIN n IN food.nutrients
```
Результирующий набор:  
 ```
[{"nutrientID":"305"},
{"nutrientID":"306","nutritionVal":"30"},
{"nutrientID":"307","nutritionVal":"912"},
{"nutrientID":"308","nutritionVal":"90"},
{"nutrientID":"309","nutritionVal":"null"}]
``` 
 
####  <a name="bk_trim"></a> TRIM  
 Возвращает строковое выражение после удаления начальных и конечных пробелов.  
  
 **Синтаксис**  
  
```  
TRIM(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции TRIM в запросе.  
  
```  
SELECT TRIM("   abc") AS t1, TRIM("   abc   ") AS t2, TRIM("abc   ") AS t3, TRIM("abc") AS t4
```  
  
 Результирующий набор:  
  
```  
[{"t1": "abc", "t2": "abc", "t3": "abc", "t4": "abc"}]  
``` 
####  <a name="bk_upper"></a> UPPER  
 Возвращает строковое выражение после преобразования символов нижнего регистра в верхний.  
  
 **Синтаксис**  
  
```  
UPPER(<str_expr>)  
```  
  
 **Аргументы**  
  
- `str_expr`  
  
   Любое допустимое строковое выражение.  
  
  **Типы возвращаемого значения**  
  
  Возвращает строковое выражение.  
  
  **Примеры**  
  
  Ниже представлен пример использования функции UPPER в запросе.  
  
```  
SELECT UPPER("Abc") AS upper  
```  
  
 Результирующий набор:  
  
```  
[{"upper": "ABC"}]  
```  
  
###  <a name="bk_array_functions"></a> Функции массивов  
 Следующие скалярные функции выполняют операцию над входным массивом и возвращают числовое или логическое значение, либо массив.  
  
||||  
|-|-|-|  
|[ARRAY_CONCAT](#bk_array_concat)|[ARRAY_CONTAINS](#bk_array_contains)|[ARRAY_LENGTH](#bk_array_length)|  
|[ARRAY_SLICE](#bk_array_slice)|||  
  
####  <a name="bk_array_concat"></a> ARRAY_CONCAT  
 Возвращает массив, который является результатом объединения значений двух или более массивов.  
  
 **Синтаксис**  
  
```  
ARRAY_CONCAT (<arr_expr>, <arr_expr> [, <arr_expr>])  
```  
  
 **Аргументы**  
  
- `arr_expr`  
  
   Любое допустимое выражение массива.  
  
  **Типы возвращаемого значения**  
  
  Возвращает выражение массива.  
  
  **Примеры**  
  
  В примере ниже показано, как объединить два массива.  
  
```  
SELECT ARRAY_CONCAT(["apples", "strawberries"], ["bananas"]) AS arrayConcat 
```  
  
 Результирующий набор:  
  
```  
[{"arrayConcat": ["apples", "strawberries", "bananas"]}]  
```  
  
####  <a name="bk_array_contains"></a> ARRAY_CONTAINS  
Возвращает логическое значение, указывающее, содержит ли массив указанное значение. Вы можете проверить частичное или полное совпадение объекта с помощью логического выражение в команде. 

**Синтаксис**  
  
```  
ARRAY_CONTAINS (<arr_expr>, <expr> [, bool_expr])  
```  
  
 **Аргументы**  
  
- `arr_expr`  
  
   Любое допустимое выражение массива.  
  
- `expr`  
  
   Любое допустимое выражение.  

- `bool_expr`  
  
   Любое логическое выражение. Если задано значение true, а заданное значение поиска является объектом, команда проверяет частичное совпадение (объект поиска является подмножеством одного из объектов). Если задано значение false, команда проверяет полное совпадение всех объектов в массиве. Если не задано, по умолчанию используется значение false. 
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое значение.  
  
  **Примеры**  
  
  В примере ниже показано, как проверить членство в массиве с помощью функции ARRAY_CONTAINS.  
  
```  
SELECT   
           ARRAY_CONTAINS(["apples", "strawberries", "bananas"], "apples") AS b1,  
           ARRAY_CONTAINS(["apples", "strawberries", "bananas"], "mangoes") AS b2  
```  
  
 Результирующий набор:  
  
```  
[{"b1": true, "b2": false}]  
```  

В примере ниже показано, как проверить частичное совпадение JSON в массиве с помощью функции ARRAY_CONTAINS.  
  
```  
SELECT  
    ARRAY_CONTAINS([{"name": "apples", "fresh": true}, {"name": "strawberries", "fresh": true}], {"name": "apples"}, true) AS b1, 
    ARRAY_CONTAINS([{"name": "apples", "fresh": true}, {"name": "strawberries", "fresh": true}], {"name": "apples"}) AS b2,
    ARRAY_CONTAINS([{"name": "apples", "fresh": true}, {"name": "strawberries", "fresh": true}], {"name": "mangoes"}, true) AS b3 
```  
  
 Результирующий набор:  
  
```  
[{
  "b1": true,
  "b2": false,
  "b3": false
}] 
```  
  
####  <a name="bk_array_length"></a> ARRAY_LENGTH  
 Возвращает число элементов массива, указанного в выражении.  
  
 **Синтаксис**  
  
```  
ARRAY_LENGTH(<arr_expr>)  
```  
  
 **Аргументы**  
  
- `arr_expr`  
  
   Любое допустимое выражение массива.  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение.  
  
  **Примеры**  
  
  В примере ниже показано, как получить длину массива с помощью функции ARRAY_LENGTH.  
  
```  
SELECT ARRAY_LENGTH(["apples", "strawberries", "bananas"]) AS len  
```  
  
 Результирующий набор:  
  
```  
[{"len": 3}]  
```  
  
####  <a name="bk_array_slice"></a> ARRAY_SLICE  
 Возвращает часть выражения массива.
  
 **Синтаксис**  
  
```  
ARRAY_SLICE (<arr_expr>, <num_expr> [, <num_expr>])  
```  
  
 **Аргументы**  
  
- `arr_expr`  
  
   Любое допустимое выражение массива.  
  
- `num_expr`  
  
   Отсчитываемый от нуля числовой индекс, с которого начинается массив. Отрицательные значения могут использоваться для указания начального значения индекса относительно последнего элемента массива. Например, значение –1 представляет собой последний элемент в массиве.  

- `num_expr`  

   Максимальное количество элементов в результирующем массиве.    

  **Типы возвращаемого значения**  
  
  Возвращает выражение массива.  
  
  **Примеры**  
  
  В примере ниже показано, как получить различные срезы массива с помощью функции ARRAY_SLICE.  
  
```  
SELECT   
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1) AS s1,  
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1, 1) AS s2,
           ARRAY_SLICE(["apples", "strawberries", "bananas"], -2, 1) AS s3,
           ARRAY_SLICE(["apples", "strawberries", "bananas"], -2, 2) AS s4,
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1, 0) AS s5,
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1, 1000) AS s6,
           ARRAY_SLICE(["apples", "strawberries", "bananas"], 1, -100) AS s7      
  
```  
  
 Результирующий набор:  
  
```  
[{  
           "s1": ["strawberries", "bananas"],   
           "s2": ["strawberries"],
           "s3": ["strawberries"],  
           "s4": ["strawberries", "bananas"], 
           "s5": [],
           "s6": ["strawberries", "bananas"],
           "s7": [] 
}]  
```  

###  <a name="bk_date_and_time_functions"></a> Функции даты и времени
 Следующие скалярные функции позволяют получить текущую дату в формате UTC и время в двух формах; числовые метки времени, значение которого равно начала эпохи Unix, в миллисекундах, или как строка, которая соответствует формату ISO 8601. 

|||
|-|-|
|[GetCurrentDateTime](#bk_get_current_date_time)|[GetCurrentTimestamp](#bk_get_current_timestamp)||

####  <a name="bk_get_current_date_time"></a> GetCurrentDateTime
 Возвращает текущую дату в формате UTC и время в виде строки ISO 8601.
  
 **Синтаксис**
  
```
GetCurrentDateTime ()
```
  
  **Типы возвращаемого значения**
  
  Возвращает текущее время UTC даты и времени ISO 8601 строковое значение. 

  Это выражается в формате гггг-мм-DDThh:mm:ss.sssZ где:
  
  |||
  |-|-|
  |YYYY|четыре цифры года|
  |ММ|две цифры месяца (01 = январь, и т.д.)|
  |DD|двузначным днем месяца (от 01 до 31)|
  |T|signifier для начала элементов времени|
  |hh|час из двух цифр (от 00 до 23)|
  |ММ|минута из двух цифр (от 00 до 59)|
  |ss|секунда из двух цифр (от 00 до 59)|
  |.SSS|три цифры дробные десятичные значения долей секунды|
  |Z|Обозначение UTC (время по Гринвичу)||
  
  Дополнительные сведения о формате ISO 8601 см. в разделе [ISO_8601](https://en.wikipedia.org/wiki/ISO_8601)

  **Примечания**

  GetCurrentDateTime является недетерминированной функцией. 
  
  Возвращаемый результат — UTC (время по Гринвичу).

  **Примеры**  
  
  В следующем примере показано, как получить текущее время в формате UTC дату с помощью встроенной функции GetCurrentDateTime.
  
```  
SELECT GetCurrentDateTime() AS currentUtcDateTime
```  
  
 Ниже приведен пример результирующего набора.
  
```  
[{
  "currentUtcDateTime": "2019-05-03T20:36:17.784Z"
}]  
```  

####  <a name="bk_get_current_timestamp"></a> GetCurrentTimestamp
 Возвращает количество миллисекунд, прошедших с 00:00:00 Четверг, 1 января 1970 г. 
  
 **Синтаксис**  
  
```  
GetCurrentTimestamp ()  
```  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое значение, текущее количество миллисекунд, истекших с начала эпохи Unix обеспечения т. е. количество миллисекунд, прошедших с 00:00:00 Четверг, 1 января 1970 г.

  **Примечания**

  GetCurrentTimestamp является недетерминированной функцией. 
  
  Возвращаемый результат — UTC (время по Гринвичу).

  **Примеры**  
  
  В следующем примере показано, как получить текущую метку времени, с помощью встроенной функции GetCurrentTimestamp.
  
```  
SELECT GetCurrentTimestamp() AS currentUtcTimestamp
```  
  
 Ниже приведен пример результирующего набора.
  
```  
[{
  "currentUtcTimestamp": 1556916469065
}]  
```  

###  <a name="bk_spatial_functions"></a> Пространственные функции  
 Скалярные функции выполняют операцию над входным пространственным объектом и возвращают числовое или логическое значение.  
  
|||||
|-|-|-|-|
|[ST_DISTANCE](#bk_st_distance)|[ST_WITHIN](#bk_st_within)|[ST_INTERSECTS](#bk_st_intersects)|[ST_ISVALID](#bk_st_isvalid)|
|[ST_ISVALIDDETAILED](#bk_st_isvaliddetailed)||||
  
####  <a name="bk_st_distance"></a> ST_DISTANCE  
 Возвращает расстояние между двумя выражениями точек GeoJSON, многоугольников или объектов LineString.  
  
 **Синтаксис**  
  
```  
ST_DISTANCE (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
- `spatial_expr`  
  
   Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
  **Типы возвращаемого значения**  
  
  Возвращает числовое выражение, указывающее расстояние. При использовании эталонной системы по умолчанию это значение указывается в метрах.  
  
  **Примеры**  
  
  В примере ниже показано, как вернуть все документы семейств, которые находятся в пределах 30 км от заданного расположения, с помощью встроенной функции ST_DISTANCE. .  
  
```  
SELECT f.id   
FROM Families f   
WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000  
```  
  
 Результирующий набор:  
  
```  
[{  
  "id": "WakefieldFamily"  
}]  
```  
  
####  <a name="bk_st_within"></a> ST_WITHIN  
 Возвращает логическое выражение, указывающее, располагается ли объект GeoJSON (точка, многоугольник или LineString), указанный в первом аргументе, внутри второго объекта GeoJSON (точка, многоугольник или LineString).  
  
 **Синтаксис**  
  
```  
ST_WITHIN (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
- `spatial_expr`  
  
   Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
 
- `spatial_expr`  
  
   Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое значение.  
  
  **Примеры**  
  
  В следующем примере показано, как найти все документы семейства внутри многоугольника с помощью функции ST_WITHIN.  
  
```  
SELECT f.id   
FROM Families f   
WHERE ST_WITHIN(f.location, {  
    'type':'Polygon',   
    'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]  
})  
```  
  
 Результирующий набор:  
  
```  
[{ "id": "WakefieldFamily" }]  
```  

####  <a name="bk_st_intersects"></a> ST_INTERSECTS  
 Возвращает логическое выражение, указывающее, пересекается ли объект GeoJSON (точка, многоугольник или LineString), указанный в первом аргументе, со вторым объектом GeoJSON (точка, многоугольник или LineString).  
  
 **Синтаксис**  
  
```  
ST_INTERSECTS (<spatial_expr>, <spatial_expr>)  
```  
  
 **Аргументы**  
  
- `spatial_expr`  
  
   Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
 
- `spatial_expr`  
  
   Любое допустимое выражение объекта GeoJSON (точка, многоугольник или LineString).  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое значение.  
  
  **Примеры**  
  
  В примере ниже показано, как найти все области, пересекающиеся с заданным многоугольником.  
  
```  
SELECT a.id   
FROM Areas a   
WHERE ST_INTERSECTS(a.location, {  
    'type':'Polygon',   
    'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]  
})  
```  
  
 Результирующий набор:  
  
```  
[{ "id": "IntersectingPolygon" }]  
```  
  
####  <a name="bk_st_isvalid"></a> ST_ISVALID  
 Возвращает логическое значение, указывающее, является ли действительным выражение GeoJSON (точка, многоугольник или LineString).  
  
 **Синтаксис**  
  
```  
ST_ISVALID(<spatial_expr>)  
```  
  
 **Аргументы**  
  
- `spatial_expr`  
  
   Любое допустимое выражение GeoJSON (точка, многоугольник или LineString).  
  
  **Типы возвращаемого значения**  
  
  Возвращает логическое выражение.  
  
  **Примеры**  
  
  В примере ниже показано, как проверить допустимость точки с помощью функции ST_VALID.  
  
  Например, эта точка может иметь значение широты, которое не входит в допустимый диапазон значений (от –90 до 90), из-за чего запрос возвращает значение false.  
  
  По спецификации GeoJSON для многоугольника последняя пара координат должна совпадать с первой, чтобы фигура стала замкнутой. Точки внутри многоугольника должны указываться в порядке против часовой стрелки. Если точки указаны в порядке по часовой стрелке, то многоугольник представляет регион, расположенный снаружи от него.  
  
```  
SELECT ST_ISVALID({ "type": "Point", "coordinates": [31.9, -132.8] }) AS b 
```  
  
 Результирующий набор:  
  
```  
[{ "b": false }]  
```  
  
####  <a name="bk_st_isvaliddetailed"></a> ST_ISVALIDDETAILED  
 Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение GeoJSON (точка, многоугольник или LineString) действительным. Если оно является недействительным, то возвращаемое значение также содержит строку с описанием причины.  
  
 **Синтаксис**  
  
```  
ST_ISVALIDDETAILED(<spatial_expr>)  
```  
  
 **Аргументы**  
  
- `spatial_expr`  
  
   Любое допустимое выражение точки или многоугольника GeoJSON.  
  
  **Типы возвращаемого значения**  
  
  Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение точки или многоугольника GeoJSON действительным. Если оно является недействительным, возвращаемое значение также содержит строку с описанием причины.  
  
  **Примеры**  
  
  В примере ниже показано, как проверить допустимость (с подробными сведениями) с помощью функции ST_ISVALIDDETAILED.  
  
```  
SELECT ST_ISVALIDDETAILED({   
  "type": "Polygon",   
  "coordinates": [[ [ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] ]]  
}) AS b  
```  
  
 Результирующий набор:  
  
```  
[{  
  "b": {   
    "valid": false,   
    "reason": "The Polygon input is not valid because the start and end points of the ring number 1 are not the same. Each ring of a polygon must have the same start and end points."   
  }  
}]  
```  
 
## <a name="next-steps"></a>Дальнейшие действия  

- [Запрос данных Azure Cosmos DB с помощью SQL-запросов](how-to-sql-query.md)

- [Документация по базе данных Azure Cosmos](https://docs.microsoft.com/azure/cosmos-db/)  
