---
title: Запросы SQL для Azure Cosmos DB
description: Сведения о синтаксисе SQL, основных понятиях баз данных и запросах SQL для Azure Cosmos DB. Использует SQL в качестве языка запросов Azure Cosmos DB JSON.
author: markjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 05/28/2019
ms.author: mjbrown
ms.openlocfilehash: 943ed63aed0f64ae6cbd62c52731c6ec73ddd0bd
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "66388484"
---
# <a name="sql-query-examples-for-azure-cosmos-db"></a>Примеры SQL-запросов для Azure Cosmos DB

Azure учетные записи Cosmos DB SQL API поддерживает запросы элементов, с помощью Structured Query Language (SQL) как языка запросов JSON. Цели разработки языка запросов Azure Cosmos DB, чтобы:

* Поддерживает SQL, один из наиболее знакомы и популярные языки запросов, вместо того чтобы изобретать новый язык запросов. SQL предоставляет формальную модель программирования для выполнения многофункциональных запросов над элементы JSON.  

* Используйте модель программирования JavaScript в как основа для языка запросов. Система типов, вычисления выражений и вызовов функций JavaScript являются корни API-интерфейса SQL. Эти корни предоставляют естественную модель программирования для функций, как реляционных проекций, иерархической навигации среди элементов JSON, самосоединений пространственных запросов и вызов определяемых пользователем функций (UDF), написанных полностью на JavaScript.

В этой статье описывается некоторые примеры запросов SQL в простые элементы JSON. Дополнительные сведения о синтаксисе языка Azure Cosmos DB SQL, см. в разделе [Справочник по синтаксису SQL](sql-api-query-reference.md).

## <a id="GettingStarted"></a>Начало работы с SQL-запросов

В учетной записи SQL API Cosmos DB, создайте контейнер с именем `Families`. Создайте два простых элемента JSON в контейнере и выполните несколько простых запросов к ним.

### <a name="create-json-items"></a>Создание элементов JSON

Следующий код создает два простых элемента JSON о семейств. Простые элементы JSON для семейства Андерсен и Wakefield включают родительских, дочерних и домашних животных, адрес и сведения о регистрации. Первый элемент имеет строки, числа, логические значения, массивы и вложенные свойства.


```json
{
  "id": "AndersenFamily",
  "lastName": "Andersen",
  "parents": [
     { "firstName": "Thomas" },
     { "firstName": "Mary Kay"}
  ],
  "children": [
     {
         "firstName": "Henriette Thaulow",
         "gender": "female",
         "grade": 5,
         "pets": [{ "givenName": "Fluffy" }]
     }
  ],
  "address": { "state": "WA", "county": "King", "city": "Seattle" },
  "creationDate": 1431620472,
  "isRegistered": true
}
```

Второй элемент использует `givenName` и `familyName` вместо `firstName` и `lastName`.

```json
{
  "id": "WakefieldFamily",
  "parents": [
      { "familyName": "Wakefield", "givenName": "Robin" },
      { "familyName": "Miller", "givenName": "Ben" }
  ],
  "children": [
      {
        "familyName": "Merriam",
        "givenName": "Jesse",
        "gender": "female", 
        "grade": 1,
        "pets": [
            { "givenName": "Goofy" },
            { "givenName": "Shadow" }
        ]
      },
      { 
        "familyName": "Miller",
         "givenName": "Lisa",
         "gender": "female",
         "grade": 8 }
  ],
  "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
  "creationDate": 1431620462,
  "isRegistered": false
}
```

### <a name="query-the-json-items"></a>Запрос элементов JSON

Попробуем сформировать несколько запросов к данным JSON, чтобы понять некоторые ключевые аспекты языка запросов SQL Azure Cosmos DB.

Следующий запрос возвращает элементы где `id` поле соответствует `AndersenFamily`. Так как это `SELECT *` запрос, выходные данные запроса — это полный элемент JSON. Дополнительные сведения о синтаксис SELECT см. в разделе [инструкции SELECT](sql-api-query-reference.md#select-query). 

```sql
    SELECT *
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Ниже приведены результаты запроса. 

```json
    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "Seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]
```

Следующий запрос изменяет формат выходных данных JSON в другую форму. Запрос проецирует новые JSON `Family` объект с двумя выбранными полями, `Name` и `City`, когда адрес города совпадает со значением состояния. «Нью-ЙОРК, Нью-ЙОРК» соответствует этот случай.

```sql
    SELECT {"Name":f.id, "City":f.address.city} AS Family
    FROM Families f
    WHERE f.address.city = f.address.state
```

Ниже приведены результаты запроса.

```json
    [{
        "Family": {
            "Name": "WakefieldFamily",
            "City": "NY"
        }
    }]
```

Следующий запрос возвращает все заданные имена детей в семье, `id` соответствует `WakefieldFamily`, упорядоченные по городу.

```sql
    SELECT c.givenName
    FROM Families f
    JOIN c IN f.children
    WHERE f.id = 'WakefieldFamily'
    ORDER BY f.address.city ASC
```

Получаются такие результаты:

```json
    [
      { "givenName": "Jesse" },
      { "givenName": "Lisa"}
    ]
```

В предыдущих примерах показано несколько аспектов языка запросов Cosmos DB:  

* SQL API работает со значениями JSON, имеет дело с сущностями древовидной вместо строк и столбцов. Можно ссылаться на узлы дерева любой произвольной вложенности, например `Node1.Node2.Node3…..Nodem`, аналогичную ссылку на двух частей `<table>.<column>` в ANSI SQL.

* Так, как работает язык запросов с помощью LINQ к бессхемным данным, динамически должен быть привязан к системе типов. Одно и то же выражение может возвращать различные типы у разных элементов. Результатом запроса является допустимым значением JSON, но не обязательно иметь фиксированную схему.  

* Azure Cosmos DB поддерживает только элементы, строго соответствующие JSON. Система типов и выражения могут обрабатывать только с типами JSON. Дополнительные сведения см. в разделе [спецификации JSON](https://www.json.org/).  

* Контейнер Cosmos DB является коллекцией элементов JSON, не имеющей схемы. Отношения внутри и между элементами контейнера неявно захвачены сдерживанием, не по первичный ключ и внешними ключами. Эта возможность важна для соединений внутри элемента, который обсуждается далее в этой статье.

## <a id="SelectClause"></a>Предложение SELECT

Каждый запрос состоит из предложения SELECT и FROM необязательно и в предложениях WHERE, за стандартов ANSI SQL. Как правило источник в предложении FROM перечисляется, и предложение WHERE применяется фильтр в источнике, для извлечения подмножества элементов JSON. Предложение SELECT затем проецирует запрошенных значений JSON в списке выбора. Дополнительные сведения о синтаксисе см. в разделе [инструкции SELECT](sql-api-query-reference.md#select-query).

Следующая инструкция SELECT запрос возвращает пример `address` из `Families` которого `id` соответствует `AndersenFamily`:

```sql
    SELECT f.address
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Получаются такие результаты:

```json
    [{
      "address": {
        "state": "WA",
        "county": "King",
        "city": "Seattle"
      }
    }]
```

## <a id="EscapingReservedKeywords"></a>Доступ к свойству, заключенному в кавычки
Свойства с помощью operator [] заключенного в кавычки свойства доступны. Например, выражение `SELECT c.grade` and `SELECT c["grade"]` являются эквивалентными. Этот синтаксис полезен для экранирования свойство, которое содержит пробелы, специальные символы или имеет имя, совпадающее с именем ключевого слова SQL или зарезервированное слово.

```sql
    SELECT f["lastName"]
    FROM Families f
    WHERE f["id"] = "AndersenFamily"
```

## <a name="nested-properties"></a>Вложенные свойства

В следующем примере проецируется два вложенных свойства `f.address.state` и `f.address.city`.

```sql
    SELECT f.address.state, f.address.city
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Получаются такие результаты:

```json
    [{
      "state": "WA",
      "city": "Seattle"
    }]
```

## <a name="json-expressions"></a>Выражения JSON

Проекция также поддерживает выражения JSON, как показано в следующем примере:

```sql
    SELECT { "state": f.address.state, "city": f.address.city, "name": f.id }
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Получаются такие результаты:

```json
    [{
      "$1": {
        "state": "WA",
        "city": "Seattle",
        "name": "AndersenFamily"
      }
    }]
```

В приведенном выше примере предложение SELECT необходимо создавать объект JSON, и поскольку образец предоставляет без ключа, предложении используется имя переменной неявный аргумент `$1`. Следующий запрос возвращает две неявные переменные аргументов: `$1` и `$2`.

```sql
    SELECT { "state": f.address.state, "city": f.address.city },
           { "name": f.id }
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Получаются такие результаты:

```json
    [{
      "$1": {
        "state": "WA",
        "city": "Seattle"
      }, 
      "$2": {
        "name": "AndersenFamily"
      }
    }]
```

## <a id="ValueKeyword"></a>Ключевое слово VALUE

VALUE-ключевое слово предоставляет способ вернуть только значение JSON. Например, приведенный ниже запрос возвращает скалярное выражение `"Hello World"` вместо `{$1: "Hello World"}`:

```sql
    SELECT VALUE "Hello World"
```

Следующий запрос возвращает значения JSON без `address` метки:

```sql
    SELECT VALUE f.address
    FROM Families f
```

Получаются такие результаты:

```json
    [
      {
        "state": "WA",
        "county": "King",
        "city": "Seattle"
      }, 
      {
        "state": "NY", 
        "county": "Manhattan",
        "city": "NY"
      }
    ]
```

В следующем примере показано, как вернуть примитивные значения JSON (конечном уровне дерева JSON):


```sql
    SELECT VALUE f.address.state
    FROM Families f
```

Получаются такие результаты:

```json
    [
      "WA",
      "NY"
    ]
```

## <a id="DistinctKeyword"></a>Ключевое слово DISTINCT

Ключевое слово DISTINCT удаляет дубликаты в проекции запроса.

```sql
SELECT DISTINCT VALUE f.lastName
FROM Families f
```

В этом примере запрос проецирует значения для каждой фамилии.

Получаются такие результаты:

```json
[
    "Andersen"
]
```

Вы также можете проецировать уникальных объектов. В этом случае поле lastName не существует в одном из двух документов, поэтому запрос возвращает пустой объект.

```sql
SELECT DISTINCT f.lastName
FROM Families f
```

Получаются такие результаты:

```json
[
    {
        "lastName": "Andersen"
    },
    {}
]
```

Ключевое слово DISTINCT, также может использоваться в проекции во вложенном запросе:

```sql
SELECT f.id, ARRAY(SELECT DISTINCT VALUE c.givenName FROM c IN f.children) as ChildNames
FROM f
```

Этот запрос проецирует массив, содержащий givenName каждый дочерний элемент с удаленными повторениями. Этот массив используется псевдоним ChildNames после чего во внешнем запросе.

Получаются такие результаты:

```json
[
    {
        "id": "AndersenFamily",
        "ChildNames": []
    },
    {
        "id": "WakefieldFamily",
        "ChildNames": [
            "Jesse",
            "Lisa"
        ]
    }
]
```

## <a name="aliasing"></a>Псевдонимы

Вы можете явно псевдоним значения в запросах. Если в запросе присутствует два свойства с тем же именем, используйте псевдонимы для переименования одного или обоих свойств, поэтому они являетесь неоднозначность в отображаемом результате.

Ключевое слово, используемое для создания псевдонимов является необязательным, как показано в следующем примере при отображении второго значения в виде `NameInfo`:

```sql
    SELECT 
           { "state": f.address.state, "city": f.address.city } AS AddressInfo,
           { "name": f.id } NameInfo
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Получаются такие результаты:

```json
    [{
      "AddressInfo": {
        "state": "WA",
        "city": "Seattle"
      },
      "NameInfo": {
        "name": "AndersenFamily"
      }
    }]
```

## <a id="FromClause"></a>Предложение FROM

FROM (`FROM <from_specification>`) предложение является необязательным, если источник фильтруется и проецируется в запросе в дальнейшем. Дополнительные сведения о синтаксисе см. в разделе [из синтаксиса](sql-api-query-reference.md#bk_from_clause). Запрос, такой как `SELECT * FROM Families` перечисляет всего `Families` контейнера. Также можно использовать специальный идентификатор ROOT для контейнера вместо использования имени контейнера.

Предложение FROM применяет следующие правила в запросе:

* Контейнер может иметь псевдоним, например `SELECT f.id FROM Families AS f` или просто `SELECT f.id FROM Families f`. Здесь `f` — это псевдоним для `Families`. Так как необязательное ключевое слово для псевдонима идентификатора.  

* После создания псевдонима исходное имя источника не может быть привязана. Например `SELECT Families.id FROM Families f` является синтаксически неверным, так как идентификатор `Families` был задан псевдоним и больше не может быть разрешен.  

* Всех ссылочных свойств должно быть полным избежать любых неоднозначных привязок в отсутствие строгого следования схеме. Например `SELECT id FROM Families f` является синтаксически неверным, так как свойство `id` не присоединена.

### <a name="get-subitems-by-using-the-from-clause"></a>Получение дополнительных данных с помощью предложения FROM

Предложение FROM может уменьшить источник в еще меньшее подмножество. Для перечисления только поддерево в каждом элементе, корень вложенного дерева может стать источником, как показано в следующем примере:

```sql
    SELECT *
    FROM Families.children
```

Получаются такие результаты:

```json
    [
      [
        {
            "firstName": "Henriette Thaulow",
            "gender": "female",
            "grade": 5,
            "pets": [
              {
                  "givenName": "Fluffy"
              }
            ]
        }
      ],
      [
       {
            "familyName": "Merriam",
            "givenName": "Jesse",
            "gender": "female",
            "grade": 1
        },
        {
            "familyName": "Miller",
            "givenName": "Lisa",
            "gender": "female",
            "grade": 8
        }
      ]
    ]
```

Предыдущий запрос используется массив в качестве источника, но можно также использовать объект как источник. Запрос считает, что любое значение JSON допустимым, определенные в источнике для включения в результат. В следующем примере будет исключается `Families` , не имеющими `address.state` значение.

```sql
    SELECT *
    FROM Families.address.state
```

Получаются такие результаты:

```json
    [
      "WA",
      "NY"
    ]
```

## <a id="WhereClause"></a>Предложение WHERE

Необязательное предложение WHERE (`WHERE <filter_condition>`) указывает условия должны удовлетворять что исходных элементов JSON для запроса включить их в результатах. Элемент JSON должны иметь указанных условий `true` следует учитывать для результата. На уровне индекса использует предложение WHERE для определения наименьшего подмножества исходных элементов, которые могут быть часть результата. Дополнительные сведения о синтаксисе см. в разделе [синтаксис WHERE](sql-api-query-reference.md#bk_where_clause).

В следующем запросе элементы запросы, содержащие `id` свойство, значение которого равно `AndersenFamily`. Это исключит любой элемент, который не имеет `id` свойство или значение которого не соответствует `AndersenFamily`.

```sql
    SELECT f.address
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

Получаются такие результаты:

```json
    [{
      "address": {
        "state": "WA",
        "county": "King",
        "city": "Seattle"
      }
    }]
```

### <a name="scalar-expressions-in-the-where-clause"></a>Скалярные выражения в предложении WHERE

В предыдущем примере показан простой запрос с условием равенства. SQL API также поддерживает различные [скалярные выражения](#scalar-expressions). Наиболее часто используются бинарные и унарные выражения. Ссылки на свойства исходного объекта JSON также являются допустимыми выражениями.

Можно использовать следующие поддерживаемые бинарные операторы:  

|**Тип оператора**  | **Значения** |
|---------|---------|
|Арифметические | +,-,*,/,% |
|Побитовые    | \|, &, ^, <<, >>, >>> (сдвиг вправо с заполнением нулями) |
|Логические    | AND, OR, NOT      |
|Сравнение | =, !=, &lt;, &gt;, &lt;=, &gt;=, <> |
|String     |  \|\| (объединение) |

В следующих запросах используется бинарные операторы:

```sql
    SELECT *
    FROM Families.children[0] c
    WHERE c.grade % 2 = 1     -- matching grades == 5, 1

    SELECT *
    FROM Families.children[0] c
    WHERE c.grade ^ 4 = 1    -- matching grades == 5

    SELECT *
    FROM Families.children[0] c
    WHERE c.grade >= 5    -- matching grades == 5
```

Можно также использовать унарные операторы +,-, ~, а не в запросах, как показано в следующих примерах:

```sql
    SELECT *
    FROM Families.children[0] c
    WHERE NOT(c.grade = 5)  -- matching grades == 1

    SELECT *
    FROM Families.children[0] c
    WHERE (-c.grade = -5)  -- matching grades == 5
```

Можно также использовать ссылки на свойства в запросах. Например `SELECT * FROM Families f WHERE f.isRegistered` возвращает элемент JSON, содержащий свойство `isRegistered` со значением, равным `true`. Любое другое значение, например `false`, `null`, `Undefined`, `<number>`, `<string>`, `<object>`, или `<array>`, исключает элемент из результата. 

### <a name="equality-and-comparison-operators"></a>Операторы равенства и сравнения

Ниже приведена таблица, в которой собраны результаты сравнения равенства в SQL API между любыми двумя типами JSON.

| **Оператор** | **Неопределенное** | **Null** | **Логический** | **Число** | **Строка** | **Объект** | **Массив** |
|---|---|---|---|---|---|---|---|
| **Неопределенное** | Не определено | Не определено | Не определено | Не определено | Не определено | Не определено | Не определено |
| **Null** | Не определено | **Допустимо** | Не определено | Не определено | Не определено | Не определено | Не определено |
| **Логический** | Не определено | Не определено | **Допустимо** | Не определено | Не определено | Не определено | Не определено |
| **Число** | Не определено | Не определено | Не определено | **Допустимо** | Не определено | Не определено | Не определено |
| **Строка** | Не определено | Не определено | Не определено | Не определено | **Допустимо** | Не определено | Не определено |
| **Объект** | Не определено | Не определено | Не определено | Не определено | Не определено | **Допустимо** | Не определено |
| **Массив** | Не определено | Не определено | Не определено | Не определено | Не определено | Не определено | **Допустимо** |

Для операторов сравнения, такие как `>`, `>=`, `!=`, `<`, и `<=`, сравнения разных типов, либо между двумя объекты или массивы, создает `Undefined`.  

Если результат скалярного выражения `Undefined`, элемент не включается в результат, так как `Undefined` не равно `true`.

### <a name="logical-and-or-and-not-operators"></a>Логические операторы (AND, OR или NOT)

Логические операторы работают над значениями типа Boolean. В следующих таблицах показаны таблицы истинности для этих операторов:

**Оператор OR**

| Или | Истина | False | Не определено |
| --- | --- | --- | --- |
| Истина |Истина |Истина |Истина |
| False |Истина |False |Не определено |
| Не определено |Истина |Не определено |Не определено |

**Оператор AND**

| И | Истина | False | Не определено |
| --- | --- | --- | --- |
| Истина |Истина |False |Не определено |
| False |False |False |False |
| Не определено |Не определено |False |Не определено |

**Оператор NOT**

| НЕ |  |
| --- | --- |
| Истина |False |
| False |Истина |
| Не определено |Не определено |

## <a name="between-keyword"></a>Ключевое слово BETWEEN (МЕЖДУ)

Как и в ANSI SQL можно использовать ключевое слово BETWEEN для выражения запросов к диапазонам строку или числовые значения. Например следующий запрос возвращает все элементы, в которых первый ребенок учится является 1-5, включительно.

```sql
    SELECT *
    FROM Families.children[0] c
    WHERE c.grade BETWEEN 1 AND 5
```

В отличие от ANSI SQL, можно также использовать предложение BETWEEN в предложении FROM, как показано в следующем примере.

```sql
    SELECT (c.grade BETWEEN 0 AND 10)
    FROM Families.children[0] c
```

В API SQL, в отличие от ANSI SQL можно выразить запросы в диапазоне для свойств. Например `grade` может быть номер like `5` некоторые элементы и строкой как `grade4` в других случаях. В таких случаях, как в JavaScript, результатом сравнения между двумя разными типами `Undefined`, поэтому он пропускается.

> [!TIP]
> Сократить время выполнения запроса создайте политику индексации, который использует тип индекса диапазона для числовых свойств или путей, которые выполняют фильтрацию в предложении BETWEEN.

## <a name="in-keyword"></a>Ключевое слово IN

Чтобы проверить, соответствует ли указанное значение любое значение в списке, используйте ключевое слово IN. Например, следующий запрос возвращает все элементы семейства где `id` — `WakefieldFamily` или `AndersenFamily`.

```sql
    SELECT *
    FROM Families
    WHERE Families.id IN ('AndersenFamily', 'WakefieldFamily')
```

В следующем примере возвращаются все элементы, где состояние — это любые из указанных значений:

```sql
    SELECT *
    FROM Families
    WHERE Families.address.state IN ("NY", "WA", "CA", "PA", "OH", "OR", "MI", "WI", "MN", "FL")
```

## <a name="-operator"></a>* оператор

Специальный оператор * проецирует весь элемент, как есть. При его использовании должно быть единственное отображаемое поле. Запрос, такой как `SELECT * FROM Families f` является допустимым, но `SELECT VALUE * FROM Families f` и `SELECT *, f.id FROM Families f` являются недопустимыми. [Сначала запроса, описанным в этой статье](#query-the-json-items) использовать * оператор. 

## <a name="-and--operators"></a>? и?? Операторы

Вы можете использовать Ternary (?) и Coalesce (?) операторы для построения условных выражений, как и языков программирования, как C# и JavaScript. 

Можно использовать? оператор для создания новых свойств JSON в режиме реального времени. Например, следующий запрос классифицирует уровни корпоративного класса в `elementary` или `other`:

```sql
     SELECT (c.grade < 5)? "elementary": "other" AS gradeLevel
     FROM Families.children[0] c
```

Можно также вложить вызовы к? оператор, как в следующем запросе: 

```sql
    SELECT (c.grade < 5)? "elementary": ((c.grade < 9)? "junior": "high") AS gradeLevel
    FROM Families.children[0] c
```

Как и в случае с другими операторами запроса? оператор исключает элементы, если свойства, на которые имеются ссылки, отсутствуют или сравниваемые типы различны.

Используйте?? оператор для выполнения эффективной проверки для свойства в элемент при запросах к частично структурированные или смешанного типа данных. Например, следующий запрос возвращает `lastName` при его наличии, или `surname` Если `lastName` отсутствует.

```sql
    SELECT f.lastName ?? f.surname AS familyName
    FROM Families f
```

## <a id="TopKeyword"></a>Оператор TOP

Ключевое слово TOP возвращаются первые `N` число результатов запроса в неопределенном порядке. Рекомендуется, использовать TOP с предложением ORDER BY для ограничения результатов к первому `N` число упорядоченные значения. Объединение этих двух предложениях является единственным способом, который позволяет предсказуемо указать которой строк влияет на верхний.

То можно использовать с постоянным значением, как показано в следующем примере, или с переменным значением посредством параметризованных запросов. Дополнительные сведения см. в разделе [параметризованные запросы](#parameterized-queries) раздел.

```sql
    SELECT TOP 1 *
    FROM Families f
```

Получаются такие результаты:

```json
    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "Seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]
```

## <a id="OrderByClause"></a>Предложение ORDER BY

Как и в ANSI SQL может включать необязательное предложение ORDER BY в запросах. Необязательный аргумент ASC или DESC признак для получения результатов в порядке возрастания или убывания. По умолчанию используется ASC.

Например ниже приведен запрос, возвращающий семьи по возрастанию по городу проживания.

```sql
    SELECT f.id, f.address.city
    FROM Families f
    ORDER BY f.address.city
```

Получаются такие результаты:

```json
    [
      {
        "id": "WakefieldFamily",
        "city": "NY"
      },
      {
        "id": "AndersenFamily",
        "city": "Seattle"
      }
    ]
```

Следующий запрос получает семейство `id`s в порядке их даты создания элемента. Элемент `creationDate` представляет число *виде времени эпохи*, или прошло времени с 1 января 1970 года в секундах.

```sql
    SELECT f.id, f.creationDate
    FROM Families f
    ORDER BY f.creationDate DESC
```

Получаются такие результаты:

```json
    [
      {
        "id": "WakefieldFamily",
        "creationDate": 1431620462
      },
      {
        "id": "AndersenFamily",
        "creationDate": 1431620472
      }
    ]
```

Кроме того можно сортировать по нескольким свойствам. Требуется запрос, который упорядочивает элементы по нескольким свойствам [составной индекс](index-policy.md#composite-indexes). Рассмотрим следующий запрос:

```sql
    SELECT f.id, f.creationDate
    FROM Families f
    ORDER BY f.address.city ASC, f.creationDate DESC
```

Этот запрос извлекает семейства `id` по возрастанию название города. Если несколько элементов же название города, запрос будет Упорядочить по `creationDate` в порядке убывания.

## <a id="OffsetLimitClause"></a>Предложение LIMIT СМЕЩЕНИЯ

СМЕЩЕНИЕ ограничение — необязательное предложение, которое необходимо пропустить, а затем выполним некоторое количество значения из запроса. Величина СМЕЩЕНИЯ и счетчика ограничения необходимы в предложение LIMIT СМЕЩЕНИЯ. В настоящее время это предложение поддерживается для запросов в одной секции, запросы между секциями еще не поддерживают его. 

При СМЕЩЕНИЕ ограничение используется в сочетании с предложением ORDER BY, результирующий набор получается, выполнив skip и принимают упорядоченного значения. Если используется предложение ORDER BY, это приведет к порядок значений.

Например ниже приведен запрос, который пропускает первое значение и возвращает второе значение (в порядке по городу проживания).

```sql
    SELECT f.id, f.address.city
    FROM Families f
    ORDER BY f.address.city
    OFFSET 1 LIMIT 1
```

Получаются такие результаты:

```json
    [
      {
        "id": "AndersenFamily",
        "city": "Seattle"
      }
    ]
```

Ниже приведен запрос, который пропускает первое значение и возвращает значение второго (без упорядочение).

```sql
   SELECT f.id, f.address.city
    FROM Families f
    OFFSET 1 LIMIT 1
```

Получаются такие результаты:

```json
    [
      {
        "id": "WakefieldFamily",
        "city": "Seattle"
      }
    ]
```




## <a name="scalar-expressions"></a>Скалярные выражения

Предложение SELECT поддерживает скалярные выражения, такие как константы, арифметические выражения и логические выражения. В следующем запросе используется скалярное выражение:


```sql
    SELECT ((2 + 11 % 7)-2)/3
```

Получаются такие результаты:

```json
    [{
      "$1": 1.33333
    }]
```

В следующем запросе результат скалярного выражения является логическое значение:


```sql
    SELECT f.address.city = f.address.state AS AreFromSameCityState
    FROM Families f
```

Получаются такие результаты:

```json
    [
      {
        "AreFromSameCityState": false
      },
      {
        "AreFromSameCityState": true
      }
    ]
```

## <a name="object-and-array-creation"></a>Создание объектов и массивов

Ключевой особенностью SQL API — Создание массива и объекта. Предыдущий пример создал новый объект JSON, `AreFromSameCityState`. Можно также создавать массивы, как показано в следующем примере:


```sql
    SELECT [f.address.city, f.address.state] AS CityState
    FROM Families f
```

Получаются такие результаты:

```json
    [
      {
        "CityState": [
          "Seattle",
          "WA"
        ]
      },
      {
        "CityState": [
          "NY", 
          "NY"
        ]
      }
    ]
```

В следующем запросе SQL — это еще один пример использования массива внутри во вложенных запросах. Этот запрос возвращает все различные заданные имена дочерних элементов в массиве.

```sql
SELECT f.id, ARRAY(SELECT DISTINCT VALUE c.givenName FROM c IN f.children) as ChildNames
FROM f
```


## <a id="Iteration"></a>Итерация

SQL API обеспечивает поддержку перебора массивов JSON, с добавленным ключевое слово IN в исходное выражение FROM новую конструкцию. В следующем примере:

```sql
    SELECT *
    FROM Families.children
```

Получаются такие результаты:

```json
    [
      [
        {
          "firstName": "Henriette Thaulow",
          "gender": "female",
          "grade": 5,
          "pets": [{ "givenName": "Fluffy"}]
        }
      ], 
      [
        {
            "familyName": "Merriam",
            "givenName": "Jesse",
            "gender": "female",
            "grade": 1
        }, 
        {
            "familyName": "Miller",
            "givenName": "Lisa",
            "gender": "female",
            "grade": 8
        }
      ]
    ]
```

Следующий запрос выполняет итерацию по `children` в `Families` контейнера. Выходной массив отличается от предыдущего запроса. Этот пример разбивает `children`и собирает результаты в один массив:  

```sql
    SELECT *
    FROM c IN Families.children
```

Получаются такие результаты:

```json
    [
      {
          "firstName": "Henriette Thaulow",
          "gender": "female",
          "grade": 5,
          "pets": [{ "givenName": "Fluffy" }]
      },
      {
          "familyName": "Merriam",
          "givenName": "Jesse",
          "gender": "female",
          "grade": 1
      },
      {
          "familyName": "Miller",
          "givenName": "Lisa",
          "gender": "female",
          "grade": 8
      }
    ]
```

Вы можете отфильтровать далее в каждой конкретной записи массива, как показано в следующем примере:

```sql
    SELECT c.givenName
    FROM c IN Families.children
    WHERE c.grade = 8
```

Получаются такие результаты:

```json
    [{
      "givenName": "Lisa"
    }]
```

Можно также объединить над результатом итерации массива. Например следующий запрос подсчитывает число детей во всех семьях:

```sql
    SELECT COUNT(child)
    FROM child IN Families.children
```

Получаются такие результаты:

```json
    [
      {
        "$1": 3
      }
    ]
```

## <a id="Joins"></a>Соединения

В реляционной базе данных логическое следствие проектирования нормализованных схем являются соединения между таблицами. В противоположность этому, SQL API использует денормализованной моделью данных элементов схемы, к которой логический эквивалент *самосоединение*.

Язык поддерживает синтаксис `<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>`. Этот запрос возвращает набор кортежей с `N` значения. Каждый кортеж будет со значениями, полученными путем итерации всех псевдонимов контейнера среди их наборов. Другими словами, этот запрос выполняет полное векторное произведение множеств, участвующих в соединении.

Ниже приведены примеры, иллюстрирующие работу соединений. В следующем примере результат пуст, так как векторное произведение каждого элемента из источника, и пустой набор пуст:

```sql
    SELECT f.id
    FROM Families f
    JOIN f.NonExistent
```

Результат:

```json
    [{
    }]
```

В следующем примере соединения является векторное произведение между двумя объектами JSON, корневой элемент `id` и `children` корень вложенного дерева. Тот факт, `children` является массив не подходит для объединения, поскольку он имеет дело с одним корнем, который является `children` массива. Результат содержит только два результата, так как векторное произведение каждого элемента с массивом дает точно только один элемент.

```sql
    SELECT f.id
    FROM Families f
    JOIN f.children
```

Получаются такие результаты:

```json
    [
      {
        "id": "AndersenFamily"
      },
      {
        "id": "WakefieldFamily"
      }
    ]
```

Следующий пример является более традиционным присоединением:

```sql
    SELECT f.id
    FROM Families f
    JOIN c IN f.children
```

Получаются такие результаты:

```json
    [
      {
        "id": "AndersenFamily"
      },
      {
        "id": "WakefieldFamily"
      },
      {
        "id": "WakefieldFamily"
      }
    ]
```

Источник предложения JOIN FROM является итератором. Таким образом процесс в предыдущем примере выглядит:  

1. Развернуть все дочерние элементы `c` в массиве.
2. Примените векторное произведение с корневого элемента `f` с каждым дочерним элементом `c` , первым шагом в плоскую структуру.
3. Наконец, проект корневой объект `f` `id` свойство отдельно.

Первый элемент, `AndersenFamily`, содержит только одну `children` элемент, поэтому результирующий набор содержит только один объект. Второй элемент, `WakefieldFamily`, содержит два `children`, поэтому векторное произведение создает два объекта: один для каждого `children` элемент. Корневые поля в обоих этих элементах будут такими же, как и ожидаемые при векторном произведении.

Реальное применение предложения JOIN заключается в формировании кортежей из векторного произведения в форме, которую не так, то в проект. В приведенном ниже примере фильтры на сочетание кортеж, который позволяет пользователю выбрать условие удовлетворены общую кортежи.

```sql
    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName
    FROM Families f
    JOIN c IN f.children
    JOIN p IN c.pets
```

Получаются такие результаты:

```json
    [
      {
        "familyName": "AndersenFamily",
        "childFirstName": "Henriette Thaulow",
        "petName": "Fluffy"
      },
      {
        "familyName": "WakefieldFamily",
        "childGivenName": "Jesse",
        "petName": "Goofy"
      }, 
      {
       "familyName": "WakefieldFamily",
       "childGivenName": "Jesse",
       "petName": "Shadow"
      }
    ]
```

Следующее расширение в предыдущем примере выполняет двойное соединение. Векторное произведение можно просмотреть как следующий псевдокод:

```
    for-each(Family f in Families)
    {
        for-each(Child c in f.children)
        {
            for-each(Pet p in c.pets)
            {
                return (Tuple(f.id AS familyName,
                  c.givenName AS childGivenName,
                  c.firstName AS childFirstName,
                  p.givenName AS petName));
            }
        }
    }
```

`AndersenFamily` имеет один дочерний элемент, у кого есть одно животное, поэтому векторное произведение представляет собой одну строку (1\*1\*1) в случае этого семейства. `WakefieldFamily` имеет два дочерних элемента, только один из которых есть питомцы, но этот потомок содержит два питомца. Векторное произведение для этого семейства представляет собой 1\*1\*2 = 2 строк.

В следующем примере имеется дополнительный фильтр на `pet`, который исключает все кортежи, у которых имя питомца не равно `Shadow`. Можно построить кортежи из массивов, установить фильтр на любой из элементов кортежа и проецировать любую комбинацию из элементов.

```sql
    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName
    FROM Families f
    JOIN c IN f.children
    JOIN p IN c.pets
    WHERE p.givenName = "Shadow"
```

Получаются такие результаты:

```json
    [
      {
       "familyName": "WakefieldFamily",
       "childGivenName": "Jesse",
       "petName": "Shadow"
      }
    ]
```

## <a id="UserDefinedFunctions"></a>Определяемые пользователем функции (UDF)

SQL API поддерживает определяемые пользователем функции (UDF). С определяемые пользователем скалярные функции вы можете передать в ноль или несколько аргументов и возвращают результат один аргумент. API проверяет каждый аргумент допустимым значениям JSON.  

API расширяет синтаксис SQL для поддержки настраиваемой логики приложения с помощью определяемых пользователем функций. Регистрация определяемых пользователем функций с помощью SQL API и ссылаться на них в SQL-запросов. На самом деле пользовательские функции специально предназначены для вызовов из запросов. Как следствие определяемых пользователем функций нет доступа к объекту контекста, как и других типов JavaScript, таких как хранимые процедуры и триггеры. Запросов доступны только для чтения и могут запускаться на первичной или вторичной реплики. Определяемые пользователем функции, в отличие от других типов JavaScript, предназначены для работы на вторичных репликах.

В следующем примере регистрируется определяемой пользователем функции в разделе контейнер элементов в базе данных Cosmos DB. В примере создается определяемая пользователем Функция с именем `REGEX_MATCH`. Он принимает два строковых значения JSON, `input` и `pattern`, и проверяет, предварительно сравниваются шаблоном, указанным во втором с помощью JavaScript `string.match()` функции.

```javascript
       UserDefinedFunction regexMatchUdf = new UserDefinedFunction
       {
           Id = "REGEX_MATCH",
           Body = @"function (input, pattern) {
                      return input.match(pattern) !== null;
                   };",
       };

       UserDefinedFunction createdUdf = client.CreateUserDefinedFunctionAsync(
           UriFactory.CreateDocumentCollectionUri("myDatabase", "families"),
           regexMatchUdf).Result;  
```

Теперь можно Используйте эту определяемую пользователем Функцию в проекции запроса. Определяемые пользователем функции необходимо уточнить дополнять префиксом `udf.` при вызове их в запросах.

```sql
    SELECT udf.REGEX_MATCH(Families.address.city, ".*eattle")
    FROM Families
```

Получаются такие результаты:

```json
    [
      {
        "$1": true
      },
      {
        "$1": false
      }
    ]
```

Можно использовать определяемую пользователем Функцию, дополнены `udf.` префикс в фильтре, как показано в следующем примере:

```sql
    SELECT Families.id, Families.address.city
    FROM Families
    WHERE udf.REGEX_MATCH(Families.address.city, ".*eattle")
```

Получаются такие результаты:

```json
    [{
        "id": "AndersenFamily",
        "city": "Seattle"
    }]
```

По сути определяемые пользователем функции являются корректными скалярными выражениями, которые можно использовать в проекциях и фильтрах.

Чтобы расширить возможности определяемых пользователем функций, рассмотрим другой пример с условной логикой:

```javascript
       UserDefinedFunction seaLevelUdf = new UserDefinedFunction()
       {
           Id = "SEALEVEL",
           Body = @"function(city) {
                   switch (city) {
                       case 'Seattle':
                           return 520;
                       case 'NY':
                           return 410;
                       case 'Chicago':
                           return 673;
                       default:
                           return -1;
                    }"
            };

            UserDefinedFunction createdUdf = await client.CreateUserDefinedFunctionAsync(
                UriFactory.CreateDocumentCollectionUri("myDatabase", "families"),
                seaLevelUdf);
```

Следующий пример выполняет определяемую пользователем Функцию:

```sql
    SELECT f.address.city, udf.SEALEVEL(f.address.city) AS seaLevel
    FROM Families f
```

Получаются такие результаты:

```json
     [
      {
        "city": "Seattle",
        "seaLevel": 520
      },
      {
        "city": "NY",
        "seaLevel": 410
      }
    ]
```

Если свойства ссылались на по определяемой пользователем функции недоступны параметры в значения JSON, параметр рассматривается как не указано, и вызов определяемой пользователем функции пропускается. Аналогично Если результат определяемой пользователем функции не определен, он не включается в результат.

Как показано в предыдущих примерах, определяемые пользователем функции объединяют мощь языка JavaScript с помощью SQL API. Определяемые пользователем функции предоставляют богатый программируемый интерфейс для реализации сложной процедурной, условной логики с помощью встроенных возможностей исполнения JavaScript. SQL API на передает аргументы в определяемые пользователем функции для каждого исходного элемента текущего WHERE или SELECT этап обработки. Результат оно встраивается в общую выполнения конвейера. Таким образом определяемые пользователем функции являются отличным средством для реализации сложной бизнес-логики в результате запроса.

## <a id="Aggregates"></a>Агрегатные функции

Агрегатные функции выполняют вычисление на наборе значений в предложении SELECT и возвращают одиночное значение. Например, следующий запрос возвращает количество элементов в пределах `Families` контейнера:

```sql
    SELECT COUNT(1)
    FROM Families f
```

Получаются такие результаты:

```json
    [{
        "$1": 2
    }]
```

Можно также возвращать только скалярное значение, агрегатной функции с помощью ключевого слова значение. Например следующий запрос возвращает число значений как одно число:

```sql
    SELECT VALUE COUNT(1)
    FROM Families f
```

Получаются такие результаты:

```json
    [ 2 ]
```

Можно также объединять агрегаты с фильтрами. Например, следующий запрос возвращает количество элементов с состоянием адрес `WA`.

```sql
    SELECT VALUE COUNT(1)
    FROM Families f
    WHERE f.address.state = "WA"
```

Получаются такие результаты:

```json
    [ 1 ]
```

SQL API поддерживает следующие агрегатные функции. SUM и AVG работают с числовыми значениями и COUNT, MIN и MAX работать на числа, строки, логические значения и значения NULL.

| Функция | Описание |
|-------|-------------|
| COUNT | Возвращает число элементов в выражении. |
| SUM   | Возвращает сумму всех элементов в выражении. |
| MIN   | Возвращает минимальное значение в выражении. |
| MAX   | Возвращает максимальное значение в выражении. |
| AVG   | Возвращает среднее арифметическое значений в выражении. |

Можно также объединить над результатом итерации массива. Дополнительные сведения см. в разделе [итерации](#Iteration) раздел.

> [!NOTE]
> В обозревателе данных на портале Azure статистических запросов может выполняться статистическое вычисление частичные результаты на странице только один запрос. Пакет SDK создает одно совокупное значение для всех страниц. Для выполнения статистических запросов с помощью кода, необходимо .NET SDK 1.12.0, пакет SDK для .NET Core 1.1.0 или пакета SDK для Java версии 1.9.5 или выше.
>

## <a id="BuiltinFunctions"></a>Встроенные функции

Cosmos DB также поддерживает ряд встроенных функций для общих операций, которые можно использовать в запросах как определяемые пользователем функции (UDF).

| Группа функций | Операции |
|---------|----------|
| Математические функции | ABS, CEILING, EXP, FLOOR, LOG, LOG10, POWER, ROUND, SIGN, SQRT, SQUARE, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, DEGREES, PI, RADIANS, SIN, TAN |
| Проверка типов функций | IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED, IS_PRIMITIVE |
| Строковые функции | CONCAT, CONTAINS, ENDSWITH, INDEX_OF, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, STARTSWITH, SUBSTRING, UPPER |
| Функции массивов | ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH и ARRAY_SLICE |
| Пространственные функции | ST_DISTANCE, ST_WITHIN, ST_INTERSECTS, ST_ISVALID, ST_ISVALIDDETAILED |

Если вы сейчас используете определяемые пользователем функции (UDF) для которого доступна встроенная функция, соответствующую встроенную функцию будет быстрее и эффективнее.

Основное различие между функциями Cosmos DB и функции ANSI SQL — это что Cosmos DB функции предназначены для работы с LINQ к бессхемным и смешанном схемы данных. Например, если свойство отсутствует или имеет нечисловое значение, например `unknown`, вместо возвращения ошибка пропускается элемента.

### <a name="mathematical-functions"></a>Математические функции

Математические функции выполняют вычисление, которое основано на входных значениях, предоставляемых в форме аргументов, и возвращают числовое значение. Здесь приведен список поддерживаемых встроенных математических функций.

| Использование | Описание |
|----------|--------|
| ABS (num_expr) | Возвращает модуль (положительное значение) указанного числового выражения. |
| CEILING (num_expr) | Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению. |
| FLOOR (num_expr) | Возвращает наибольшее целочисленное значение, которое меньше или равно указанному числовому выражению. |
| EXP (num_expr) | Возвращает значение экспоненты для указанного числового выражения. |
| LOG (num_expr, базовый) | Возвращает натуральный логарифм от указанного числового выражения либо логарифм по заданному основанию. |
| LOG10 (num_expr) | Возвращает десятичный логарифм от указанного числового выражения. |
| ROUND (num_expr) | Возвращает числовое значение, округленное до ближайшего целого значения в большую сторону. |
| TRUNC (num_expr) | Возвращает числовое значение, округленное до ближайшего целого значения в меньшую сторону. |
| SQRT (num_expr) | Возвращает квадратный корень из указанного числового выражения. |
| SQUARE (num_expr) | Возвращает указанное числовое выражение, возведенное в квадрат. |
| POWER (num_expr, num_expr) | Возвращает указанное числовое выражение, возведенное в заданную степень. |
| SIGN (num_expr) | Возвращает значение, обозначающее знак (-1, 0, 1) указанного числового выражения. |
| ACOS (num_expr) | Возвращает угол в радианах, косинус которого равен указанному числовому выражению; также называется арккосинусом. |
| ASIN (num_expr) | Возвращает угол в радианах, синус которого равен указанному числовому выражению. Также называется арксинусом. |
| ATAN (num_expr) | Возвращает угол в радианах, тангенс которого равен указанному числовому выражению. Эта функция также называется арктангенсом. |
| ATN2 (num_expr) | Возвращает угол в радианах между положительным направлением оси x и лучом, проведенным из начала координат в точку (y, x), где x и y — значения двух заданных выражений с плавающей запятой. |
| COS (num_expr) | Возвращает тригонометрический косинус указанного угла в радианах в указанном выражении. |
| COT (num_expr) | Возвращает тригонометрический котангенс указанного угла в радианах в указанном числовом выражении. |
| DEGREES (num_expr) | Возвращает соответствующее значение угла в градусах для угла, указанного в радианах. |
| PI () | Возвращает значение константы "пи". |
| RADIANS (num_expr) | Возвращает значение угла в радианах для числового значения, указанного в градусах. |
| SIN (num_expr) | Возвращает тригонометрический синус заданного угла в радианах для указанного выражения. |
| TAN (num_expr) | Возвращает тангенс угла для указанного выражения. |

Вы можете выполнять запросы, как в следующем примере:

```sql
    SELECT VALUE ABS(-4)
```

Результат:

```json
    [4]
```

### <a name="type-checking-functions"></a>Проверка типов функций

Функции проверки типа позволяют проверять тип выражения в запросе SQL. Функции проверки типов можно использовать для определения типов свойств элементов в режиме реального времени, когда они переменной или неизвестен. Ниже приведен список поддерживаемых встроенных функциях проверки типов:

| **Использование** | **Описание** |
|-----------|------------|
| [IS_ARRAY (expr)](sql-api-query-reference.md#bk_is_array) | Возвращает логическое значение, указывающее, является ли значение массивом. |
| [IS_BOOL (expr)](sql-api-query-reference.md#bk_is_bool) | Возвращает логическое значение, указывающее, является ли значение логическим выражением. |
| [IS_NULL (expr)](sql-api-query-reference.md#bk_is_null) | Возвращает логическое значение, указывающее, имеет ли значение тип NULL. |
| [IS_NUMBER (expr)](sql-api-query-reference.md#bk_is_number) | Возвращает логическое значение, указывающее, является ли значение числом. |
| [IS_OBJECT (expr)](sql-api-query-reference.md#bk_is_object) | Возвращает логическое значение, указывающее, является ли значение объектом JSON. |
| [IS_STRING (expr)](sql-api-query-reference.md#bk_is_string) | Возвращает логическое значение, указывающее, является ли значение строкой. |
| [IS_DEFINED (expr)](sql-api-query-reference.md#bk_is_defined) | Возвращает логическое значение, указывающее, назначено ли свойству значение. |
| [IS_PRIMITIVE (expr)](sql-api-query-reference.md#bk_is_primitive) | Возвращает логическое значение, указывающее, если тип значения — строка, число, логическое значение или значение null. |

Используя эти функции, запросы можно выполнять как в следующем примере:

```sql
    SELECT VALUE IS_NUMBER(-4)
```

Результат:

```json
    [true]
```

### <a name="string-functions"></a>Строковые функции

Следующие скалярные функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение. Ниже приведена таблица встроенных строковых функций:

| Использование | Описание |
| --- | --- |
| [LENGTH (str_expr)](sql-api-query-reference.md#bk_length) | Возвращает число символов указанного строкового выражения. |
| [CONCAT (str_expr, str_expr [, str_expr])](sql-api-query-reference.md#bk_concat) | Возвращает строку, являющуюся результатом объединения двух или более строковых значений. |
| [SUBSTRING (str_expr, num_expr, num_expr)](sql-api-query-reference.md#bk_substring) | Возвращает часть строкового выражения. |
| [STARTSWITH (str_expr, str_expr)](sql-api-query-reference.md#bk_startswith) | Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым. |
| [ENDSWITH (str_expr, str_expr)](sql-api-query-reference.md#bk_endswith) | Возвращает значение логического типа, указывающее, заканчивается ли первое строковое выражение вторым. |
| [CONTAINS (str_expr, str_expr)](sql-api-query-reference.md#bk_contains) | Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе. |
| [INDEX_OF (str_expr, str_expr)](sql-api-query-reference.md#bk_index_of) | Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или значение -1, если строка не найдена. |
| [LEFT (str_expr, num_expr)](sql-api-query-reference.md#bk_left) | Возвращает левую часть строки с указанным количеством символов. |
| [RIGHT (str_expr, num_expr)](sql-api-query-reference.md#bk_right) | Возвращает правую часть строки с указанным количеством символов. |
| [LTRIM (str_expr)](sql-api-query-reference.md#bk_ltrim) | Возвращает строковое выражение после удаления начальных пробелов. |
| [RTRIM (str_expr)](sql-api-query-reference.md#bk_rtrim) | Возвращает строковое выражение после усечения всех конечных пробелов. |
| [LOWER (str_expr)](sql-api-query-reference.md#bk_lower) | Возвращает строковое выражение после преобразования символов верхнего регистра в нижний. |
| [UPPER (str_expr)](sql-api-query-reference.md#bk_upper) | Возвращает строковое выражение после преобразования символов нижнего регистра в верхний. |
| [REPLACE (str_expr, str_expr, str_expr)](sql-api-query-reference.md#bk_replace) | Заменяет все вхождения указанного строкового значения другим строковым значением. |
| [REPLICATE (str_expr, num_expr)](sql-api-query-reference.md#bk_replicate) | Повторяет строковое значение указанное число раз. |
| [REVERSE (str_expr)](sql-api-query-reference.md#bk_reverse) | Возвращает обратный порядок строкового значения. |

Используя эти функции, запросы можно выполнять следующим образом, который возвращает семейство `id` в верхнем регистре:

```sql
    SELECT VALUE UPPER(Families.id)
    FROM Families
```

Получаются такие результаты:

```json
    [
        "WAKEFIELDFAMILY",
        "ANDERSENFAMILY"
    ]
```

Или объединения строк, как в этом примере:

```sql
    SELECT Families.id, CONCAT(Families.address.city, ",", Families.address.state) AS location
    FROM Families
```

Получаются такие результаты:

```json
    [{
      "id": "WakefieldFamily",
      "location": "NY,NY"
    },
    {
      "id": "AndersenFamily",
      "location": "Seattle,WA"
    }]
```

Можно также использовать функции обработки строк в предложении WHERE для фильтрации результатов, как в следующем примере:

```sql
    SELECT Families.id, Families.address.city
    FROM Families
    WHERE STARTSWITH(Families.id, "Wakefield")
```

Получаются такие результаты:

```json
    [{
      "id": "WakefieldFamily",
      "city": "NY"
    }]
```

### <a name="array-functions"></a>Функции массивов

Следующие скалярные функции выполняют операцию над входным массивом и возвращают числовое, логическое значение или значения массива. Ниже приведена таблица встроенных функций над массивом:

| Использование | Описание |
| --- | --- |
| [ARRAY_LENGTH (arr_expr)](sql-api-query-reference.md#bk_array_length) |Возвращает число элементов массива, указанного в выражении. |
| [ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])](sql-api-query-reference.md#bk_array_concat) |Возвращает массив, который является результатом объединения значений двух или более массивов. |
| [ARRAY_CONTAINS (arr_expr, expr [, bool_expr])](sql-api-query-reference.md#bk_array_contains) |Возвращает логическое значение, указывающее, содержит ли массив указанное значение. Можно указать, будет ли сопоставление полным или частичным. |
| [ARRAY_SLICE (arr_expr, num_expr [, num_expr])](sql-api-query-reference.md#bk_array_slice) |Возвращает часть выражения массива. |

Используйте функции массива для обработки массивов в JSON. Например, ниже приведен запрос, возвращающий все элементы `id`s там, где один из `parents` — `Robin Wakefield`: 

```sql
    SELECT Families.id 
    FROM Families 
    WHERE ARRAY_CONTAINS(Families.parents, { givenName: "Robin", familyName: "Wakefield" })
```

Результат:

```json
    [{
      "id": "WakefieldFamily"
    }]
```

Можно указать часть фрагмента для сопоставления элементов в массиве. Следующий запрос находит все элемент `id`, имеющие `parents` с `givenName` из `Robin`:

```sql
    SELECT Families.id 
    FROM Families 
    WHERE ARRAY_CONTAINS(Families.parents, { givenName: "Robin" }, true)
```

Результат:

```json
    [{
      "id": "WakefieldFamily"
    }]
```

Вот еще один пример, использующий функцию ARRAY_LENGTH для получения числа `children` на семейство:

```sql
    SELECT Families.id, ARRAY_LENGTH(Families.children) AS numberOfChildren
    FROM Families 
```

Получаются такие результаты:

```json
    [{
      "id": "WakefieldFamily",
      "numberOfChildren": 2
    },
    {
      "id": "AndersenFamily",
      "numberOfChildren": 1
    }]
```

### <a name="spatial-functions"></a>Пространственные функции

Cosmos DB поддерживает следующие встроенные функции открытого геопространственного консорциума (OGC) для геопространственные запросы: 

| Использование | Описание |
| --- | --- |
| ST_DISTANCE (point_expr, point_expr) | Возвращает расстояние между двумя GeoJSON `Point`, `Polygon`, или `LineString` выражения. |
| T_WITHIN (point_expr, polygon_expr) | Возвращает логическое выражение, указывающее, является ли первый объект GeoJSON (`Point`, `Polygon`, или `LineString`) находится в пределах второго объекта GeoJSON (`Point`, `Polygon`, или `LineString`). |
| ST_INTERSECTS (spatial_expr, spatial_expr) | Возвращает логическое выражение, указывающее, является ли указанные объекты GeoJSON (`Point`, `Polygon`, или `LineString`) пересекаются. |
| ST_ISVALID | Возвращает логическое значение, указывающее, является ли указанный GeoJSON `Point`, `Polygon`, или `LineString` выражение является допустимым. |
| ST_ISVALIDDETAILED | Возвращает значение JSON, содержащее логическое значение, если указанный GeoJSON `Point`, `Polygon`, или `LineString` выражение является допустимым и если недействительным, причина как строковое значение. |

Пространственные функции можно использовать для выполнения запросов близости к пространственным данным. Например ниже приведен запрос, возвращающий все семейства элементов в пределах 30 км от заданного расположения, с помощью встроенной функции ST_DISTANCE.

```sql
    SELECT f.id
    FROM Families f
    WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000
```

Результат:

```json
    [{
      "id": "WakefieldFamily"
    }]
```

Дополнительные сведения см. в статье о [работе с геопространственными данными в Azure Cosmos DB](geospatial.md). 

## <a name="parameterized-queries"></a>Параметризованные запросы

Cosmos DB поддерживает запросы с параметрами, выраженными с привычной нотации @. Параметризованный SQL обеспечивает надежную обработку и экранирование пользовательского ввода и предотвращает случайное раскрытие данных путем внедрения кода SQL.

Например, можно написать запрос, который принимает `lastName` и `address.state` как параметры и выполните его для различных значений `lastName` и `address.state` на основе ввода пользователя.

```sql
    SELECT *
    FROM Families f
    WHERE f.lastName = @lastName AND f.address.state = @addressState
```

Затем можно отправить этот запрос к Cosmos DB качестве параметризованного запроса JSON следующим образом:

```sql
    {
        "query": "SELECT * FROM Families f WHERE f.lastName = @lastName AND f.address.state = @addressState",
        "parameters": [
            {"name": "@lastName", "value": "Wakefield"},
            {"name": "@addressState", "value": "NY"},
        ]
    }
```

В следующем примере задается аргумент TOP с параметризованным запросом: 

```sql
    {
        "query": "SELECT TOP @n * FROM Families",
        "parameters": [
            {"name": "@n", "value": 10},
        ]
    }
```

Значения параметров могут быть любые допустимые JSON: строки, числа, логические значения, null, даже массивы или вложенные JSON. Так как Cosmos DB является бессхемным, параметры не проверяются на соответствие любого типа.

## <a id="JavaScriptIntegration"></a>Интеграция JavaScript

Azure Cosmos DB предоставляет модель программирования для реализации логики приложения на основе JavaScript непосредственно в контейнеры, с помощью хранимых процедур и триггеров. Эта модель поддерживает:

* Высокопроизводительных транзакционных CRUD и запросов к элементов в контейнере, благодаря глубокой интеграции среды выполнения JavaScript в ядро базы данных.
* Добиться естественного моделирования потока управления, переменных области видимости и назначение и интеграции обработки исключений примитивов с транзакциями базы данных. 

Дополнительные сведения об интеграции Azure Cosmos DB JavaScript, см. в разделе [API серверной части JavaScript](#JavaScriptServerSideApi) раздел.

### <a name="operator-evaluation"></a>Оценивание операторов

Cosmos DB, только на основании того, база данных JSON, проводит параллели с операторами JavaScript и семантика оценки. Cosmos DB старается сохранить семантику JavaScript в плане поддержки JSON, но оценка операторов в некоторых случаях не совпадает.

В SQL API в отличие от традиционного SQL, типы значений зачастую неизвестны до API извлекает значения из базы данных. Для того чтобы эффективно выполнять запросы, большинство операторов имеют строгие требования к типам.

В отличие от JavaScript SQL API не выполняет неявные преобразования. Например, запрос, такой как `SELECT * FROM Person p WHERE p.Age = 21` соответствует элементы, содержащие `Age` свойство, значение которого равно `21`. Он не соответствует ни одному других элементов, `Age` соответствует вариациям как `twenty-one`, `021`, или `21.0`. Эта ситуация отличается от JavaScript, где строковые значения, неявно приводятся к чисел в зависимости от оператора, например: `==`. Это поведение API-интерфейса SQL имеет решающее значение для эффективного индекса соответствия.

## <a id="ExecutingSqlQueries"></a>Выполнение запроса SQL

Любой язык, позволяющего отправлять запросы HTTP/HTTPS можно вызвать Cosmos DB REST API. Кроме того, Cosmos DB предлагает программные библиотеки для языков программирования .NET, Node.js, JavaScript и Python. REST API и библиотеки поддерживают запросы через SQL и пакета SDK для .NET также поддерживает [запросов LINQ](#Linq).

Следующие примеры показывают, как создать запрос и выполнить его в учетной записи базы данных Cosmos DB.

### <a id="RestAPI"></a>REST API

Cosmos DB предлагает простую и открытую модель программирования RESTful поверх HTTP. Модель ресурсов состоит из набора ресурсов под учетной записью базы данных, который подготавливает подписку Azure. Учетная запись базы данных состоит из набора *баз данных*, каждый из которых может содержать несколько *контейнеры*, который в свою очередь содержать *элементы*, определяемые пользователем функции и другие типы ресурсов. Каждый ресурс Cosmos DB доступен по логическому постоянному URI. Набор ресурсов называется *веб-канала*. 

Базовая модель взаимодействия с этими ресурсами осуществляется через команды HTTP `GET`, `PUT`, `POST`, и `DELETE`, с их стандартной интерпретации. Используйте `POST` для создания нового ресурса, выполнения хранимой процедуры, или выдать запрос Cosmos DB. Запросы всегда включают только операции чтения без побочных эффектов.

В приведенных ниже примерах `POST` API SQL для запроса к образцов элементов. Запрос имеет простой фильтр на JSON `name` свойство. `x-ms-documentdb-isquery` И Content-Type: `application/query+json` заголовки указывают, что операция является запросом. Замените `mysqlapicosmosdb.documents.azure.com:443` с URI для вашей учетной записи Cosmos DB.

```json
    POST https://mysqlapicosmosdb.documents.azure.com:443/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/query+json

    {
        "query": "SELECT * FROM Families f WHERE f.id = @familyId",
        "parameters": [
            {"name": "@familyId", "value": "AndersenFamily"}
        ]
    }
```

Получаются такие результаты:

```json
    HTTP/1.1 200 Ok
    x-ms-activity-id: 8b4678fa-a947-47d3-8dd3-549a40da6eed
    x-ms-item-count: 1
    x-ms-request-charge: 0.32

    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "id":"AndersenFamily",
             "lastName":"Andersen",
             "parents":[  
                {  
                   "firstName":"Thomas"
                },
                {  
                   "firstName":"Mary Kay"
                }
             ],
             "children":[  
                {  
                   "firstName":"Henriette Thaulow",
                   "gender":"female",
                   "grade":5,
                   "pets":[  
                      {  
                         "givenName":"Fluffy"
                      }
                   ]
                }
             ],
             "address":{  
                "state":"WA",
                "county":"King",
                "city":"Seattle"
             },
             "_rid":"u1NXANcKogEcAAAAAAAAAA==",
             "_ts":1407691744,
             "_self":"dbs\/u1NXAA==\/colls\/u1NXANcKogE=\/docs\/u1NXANcKogEcAAAAAAAAAA==\/",
             "_etag":"00002b00-0000-0000-0000-53e7abe00000",
             "_attachments":"_attachments\/"
          }
       ],
       "count":1
    }
```

Далее, более сложный запрос возвращает несколько результатов из соединения:

```json
    POST https://https://mysqlapicosmosdb.documents.azure.com:443/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/query+json

    {
        "query": "SELECT
                     f.id AS familyName,
                     c.givenName AS childGivenName,
                     c.firstName AS childFirstName,
                     p.givenName AS petName
                  FROM Families f
                  JOIN c IN f.children
                  JOIN p in c.pets",
        "parameters": [] 
    }
```

Получаются такие результаты: 

```json
    HTTP/1.1 200 Ok
    x-ms-activity-id: 568f34e3-5695-44d3-9b7d-62f8b83e509d
    x-ms-item-count: 1
    x-ms-request-charge: 7.84

    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "familyName":"AndersenFamily",
             "childFirstName":"Henriette Thaulow",
             "petName":"Fluffy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Goofy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Shadow"
          }
       ],
       "count":3
    }
```

Если результаты запроса не помещаются на одной странице, REST API возвращает токен продолжения в `x-ms-continuation-token` заголовок ответа. Клиенты могут разбивать результаты на страницы, включая заголовок в последующие результаты. Можно также управлять количество результатов на странице через `x-ms-max-item-count` заголовок номера. 

Если запрос содержит статистическую функцию как число, на странице запроса могут возвращать частично агрегированное значение только одна страница результатов. Клиенты должны выполнить статистическую обработку второго уровня этих результатов, чтобы получить окончательные результаты. Например сумму чисел, возвращенных на отдельных страницах, для получения общего числа.

Для управления политикой согласованности данных для запросов, используйте `x-ms-consistency-level` заголовка, как и все запросы REST API. Согласованность уровня сеанса также требует, предоставляющим последнюю версию `x-ms-session-token` заголовок cookie в запросе. Политика индексации запрашиваемого контейнера также может повлиять на согласованность результатов запроса. По умолчанию, параметры политики для контейнеров индексирования, индекс всегда является текущее содержимое элемента, и результаты запроса соответствуют выбранным для данных. Дополнительные сведения см. в разделе [уровней согласованности Azure Cosmos DB][consistency-levels].

Если настроенная политика индексации в контейнере не поддерживает указанный запрос, сервер Azure Cosmos DB возвращает 400 «Bad Request». Это сообщение об ошибке возвращает для запросов с путями, явно исключенным из индексации. Можно указать `x-ms-documentdb-query-enable-scan` заголовок, чтобы разрешить запрос, чтобы выполнить проверку, если индекс недоступен.

Можно получить подробные метрики выполнения запроса, задав `x-ms-documentdb-populatequerymetrics` для заголовка `true`. Дополнительные сведения см. в статье [Tuning query performance with Azure Cosmos DB](sql-api-query-metrics.md) (Настройка производительности запросов с помощью Azure Cosmos DB).

### <a id="DotNetSdk"></a>C#(ПАКЕТ SDK ДЛЯ .NET)

Пакет .NET SDK поддерживает запросы как LINQ, так и SQL. В следующем примере показано, как выполнить предыдущий запрос фильтра с помощью .NET:

```csharp
    foreach (var family in client.CreateDocumentQuery(containerLink,
        "SELECT * FROM Families f WHERE f.id = \"AndersenFamily\""))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }

    SqlQuerySpec query = new SqlQuerySpec("SELECT * FROM Families f WHERE f.id = @familyId");
    query.Parameters = new SqlParameterCollection();
    query.Parameters.Add(new SqlParameter("@familyId", "AndersenFamily"));

    foreach (var family in client.CreateDocumentQuery(containerLink, query))
    {
        Console.WriteLine("\tRead {0} from parameterized SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery(containerLink)
        where f.Id == "AndersenFamily"
        select f))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }

    foreach (var family in client.CreateDocumentQuery(containerLink)
        .Where(f => f.Id == "AndersenFamily")
        .Select(f => f))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }
```

В следующем примере сравниваются два свойства для определения равенства внутри каждого элемента и использует анонимные проекции.

```csharp
    foreach (var family in client.CreateDocumentQuery(containerLink,
        @"SELECT {""Name"": f.id, ""City"":f.address.city} AS Family
        FROM Families f
        WHERE f.address.city = f.address.state"))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery<Family>(containerLink)
        where f.address.city == f.address.state
        select new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }

    foreach (var family in
        client.CreateDocumentQuery<Family>(containerLink)
        .Where(f => f.address.city == f.address.state)
        .Select(f => new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }
```

В следующем примере показано объединение, выражаемое через LINQ `SelectMany`.

```csharp
    foreach (var pet in client.CreateDocumentQuery(containerLink,
          @"SELECT p
            FROM Families f
                 JOIN c IN f.children
                 JOIN p in c.pets
            WHERE p.givenName = ""Shadow"""))
    {
        Console.WriteLine("\tRead {0} from SQL", pet);
    }

    // Equivalent in Lambda expressions:
    foreach (var pet in
        client.CreateDocumentQuery<Family>(containerLink)
        .SelectMany(f => f.children)
        .SelectMany(c => c.pets)
        .Where(p => p.givenName == "Shadow"))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", pet);
    }
```

Клиент .NET автоматически перебирает все страницы результатов запроса в `foreach` блокирует, как показано в предыдущем примере. Параметры запроса появился в [REST API](#RestAPI) раздел также доступны в пакете SDK .NET с помощью `FeedOptions` и `FeedResponse` классы в `CreateDocumentQuery` метод. Число страниц, которые можно контролировать с помощью `MaxItemCount` параметр.

Можно также явно управлять разбиение по страницам путем создания `IDocumentQueryable` с помощью `IQueryable` объекта, а затем считывая `ResponseContinuationToken` значения и передавая их обратно как `RequestContinuationToken` в `FeedOptions`. Можно задать `EnableScanInQuery` Включение сканирования, когда запрос не поддерживается службой настроенная политика индексации. Для секционированных контейнеров, можно использовать `PartitionKey` для выполнения запроса с одной секцией, несмотря на то, что Azure Cosmos DB может автоматически извлекать этот ключ из текста запроса. Можно использовать `EnableCrossPartitionQuery` для выполнения запросов к нескольким секциям.

Дополнительные примеры кода .NET с запросами, см. в разделе [примеры Azure Cosmos DB .NET](https://github.com/Azure/azure-cosmosdb-dotnet) в GitHub.

### <a id="JavaScriptServerSideApi"></a>Интерфейс API для серверного JavaScript

Cosmos DB предоставляет модель программирования для реализации логики приложения на основе JavaScript непосредственно в контейнеры, с помощью хранимых процедур и триггеров. Логика JavaScript регистрируется на уровне контейнера, может выполнять операции с базой данных для элементов заданного контейнера, в оболочку оборачиваются транзакциями ACID.

В следующем примере показано, как использовать `queryDocuments` на сервере JavaScript API, чтобы формировать запросы изнутри хранимых процедур и триггеров:

```javascript
    function findName(givenName, familyName) {
        var context = getContext();
        var containerManager = context.getCollection();
        var containerLink = containerManager.getSelfLink()

        // create a new item.
        containerManager.createDocument(containerLink,
            { givenName: givenName, familyName: familyName },
            function (err, documentCreated) {
                if (err) throw new Error(err.message);

                // filter items by familyName
                var filterQuery = "SELECT * from root r WHERE r.familyName = 'Wakefield'";
                containerManager.queryDocuments(containerLink,
                    filterQuery,
                    function (err, matchingDocuments) {
                        if (err) throw new Error(err.message);
    context.getResponse().setBody(matchingDocuments.length);

                        // Replace the familyName for all items that satisfied the query.
                        for (var i = 0; i < matchingDocuments.length; i++) {
                            matchingDocuments[i].familyName = "Robin Wakefield";
                            // we don't need to execute a callback because they are in parallel
                            containerManager.replaceDocument(matchingDocuments[i]._self,
                                matchingDocuments[i]);
                        }
                    })
            });
    }
```

## <a id="Linq"></a>API LINQ to SQL

LINQ — это модель программирования .NET, которая выражает вычисления в виде запросов потоков объектов. Cosmos DB обеспечивает клиентскую библиотеку для взаимодействия с LINQ путем облегчения преобразования между JSON и объектами .NET и сопоставления подмножества запросов LINQ с запросами Cosmos DB.

Следующей схеме показана архитектура поддержки запросов LINQ с помощью Cosmos DB. Используя клиент Cosmos DB, можно создать `IQueryable` объект, который непосредственно запросы к поставщику запросов Cosmos DB и транслирует запросы LINQ в запросы Cosmos DB. Затем запрос передается на сервер Cosmos DB, который извлекает набор результатов в формате JSON. Десериализатор JSON преобразует результаты в поток объектов .NET на стороне клиента.

![Архитектура поддержки запросов LINQ с помощью SQL API — синтаксис SQL, язык запросов JSON, основные понятия баз данных и SQL-запросы][1]

### <a name="net-and-json-mapping"></a>Сопоставление .NET и JSON

Сопоставление между объектами .NET и элементы JSON является естественным. Каждый член поля данных сопоставляется с объектом JSON, где имя сопоставляется *ключ* сопоставляется с частью объекта, а значение рекурсивно *значение* часть объекта. В следующем примере кода maps `Family` класса с элементом JSON, а затем создает `Family` объекта:

```csharp
    public class Family
    {
        [JsonProperty(PropertyName="id")]
        public string Id;
        public Parent[] parents;
        public Child[] children;
        public bool isRegistered;
    };

    public struct Parent
    {
        public string familyName;
        public string givenName;
    };

    public class Child
    {
        public string familyName;
        public string givenName;
        public string gender;
        public int grade;
        public List<Pet> pets;
    };

    public class Pet
    {
        public string givenName;
    };

    public class Address
    {
        public string state;
        public string county;
        public string city;
    };

    // Create a Family object.
    Parent mother = new Parent { familyName= "Wakefield", givenName="Robin" };
    Parent father = new Parent { familyName = "Miller", givenName = "Ben" };
    Child child = new Child { familyName="Merriam", givenName="Jesse", gender="female", grade=1 };
    Pet pet = new Pet { givenName = "Fluffy" };
    Address address = new Address { state = "NY", county = "Manhattan", city = "NY" };
    Family family = new Family { Id = "WakefieldFamily", parents = new Parent [] { mother, father}, children = new Child[] { child }, isRegistered = false };
```

В предыдущем примере создается следующий элемент JSON:

```json
    {
        "id": "WakefieldFamily",
        "parents": [
            { "familyName": "Wakefield", "givenName": "Robin" },
            { "familyName": "Miller", "givenName": "Ben" }
        ],
        "children": [
            {
                "familyName": "Merriam",
                "givenName": "Jesse",
                "gender": "female",
                "grade": 1,
                "pets": [
                    { "givenName": "Goofy" },
                    { "givenName": "Shadow" }
                ]
            },
            { 
              "familyName": "Miller",
              "givenName": "Lisa",
              "gender": "female",
              "grade": 8
            }
        ],
        "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
        "isRegistered": false
    };
```

### <a name="linq-to-sql-translation"></a>Трансляция из LINQ в SQL

Поставщик запросов Cosmos DB пытается как можно правильнее отобразить соответствие запроса LINQ запросу SQL Cosmos DB. Со следующим описанием предполагается Знакомство с LINQ.

Система типов поставщик запросов поддерживает только примитивные типы JSON: числовые, логические значения, строка и null. 

Поставщик запросов поддерживает следующие скалярные выражения:

- Константные значения, включая постоянные значения примитивных типов данных во время оценки запроса.
  
- Выражения индекса или массив, которые относятся к свойствам объекта или элемента массива. Пример:
  
  ```
    family.Id;
    family.children[0].familyName;
    family.children[0].grade;
    family.children[n].grade; //n is an int variable
  ```
  
- Арифметические выражения, включая общие арифметические выражения на основе численных и логических значений. Полный список см. в разделе [спецификации Azure Cosmos DB SQL](https://go.microsoft.com/fwlink/p/?LinkID=510612).
  
  ```
    2 * family.children[0].grade;
    x + y;
  ```
  
- Выражения сравнения строки, которые включают сравнение строкового значения к некоторым постоянным строковым значением.  
  
  ```
    mother.familyName == "Wakefield";
    child.givenName == s; //s is a string variable
  ```
  
- Выражения создания объекта или массива, которые возвращают объект комбинированного типа или анонимного типа, или массив таких объектов. Эти значения можно вкладывать.
  
  ```
    new Parent { familyName = "Wakefield", givenName = "Robin" };
    new { first = 1, second = 2 }; //an anonymous type with two fields  
    new int[] { 3, child.grade, 5 };
  ```

### <a id="SupportedLinqOperators"></a>Поддерживаемых операторов LINQ

Поставщик LINQ, включенный в состав пакета SDK для .NET SQL поддерживает следующие операторы:

- **Select**. Проекции, преобразуются SQL SELECT, включая создание объектов.
- **Where**. Фильтры преобразуются в SQL WHERE и поддерживают преобразование `&&`, `||`, и `!` в операторы SQL.
- **SelectMany**. Позволяет выполнять очистку массивов в предложение SQL JOIN. Используйте для цепочки или создания вложенных выражений для фильтрации по элементам массива.
- **OrderBy** и **OrderByDescending**: Перевод для предложения ORDER BY с ASC или DESC.
- Операторы для агрегирования **Count**, **Sum**, **Min**, **Max**, **Average** и их асинхронные эквиваленты **CountAsync**, **SumAsync**, **MinAsync**, **MaxAsync** и **AverageAsync**.
- **CompareTo**. Выполняет преобразование в сравнение диапазонов. Обычно используется для строк, так как их нельзя сравнивать в .NET.
- **Take**. Выполняет преобразование в SQL TOP для ограничения результатов запроса.
- **Математические функции**: Поддерживает преобразование из .NET `Abs`, `Acos`, `Asin`, `Atan`, `Ceiling`, `Cos`, `Exp`, `Floor`, `Log`, `Log10`, `Pow`, `Round`, `Sign`, `Sin`, `Sqrt`, `Tan`, и `Truncate` в эквивалентные встроенные функции SQL.
- **Строковые функции**: Поддерживает преобразование из .NET `Concat`, `Contains`, `Count`, `EndsWith`,`IndexOf`, `Replace`, `Reverse`, `StartsWith`, `SubString`, `ToLower`, `ToUpper`, `TrimEnd`, и `TrimStart` в эквивалентные встроенные функции SQL.
- **Функции массивов**: Поддерживает преобразование из .NET `Concat`, `Contains`, и `Count` в эквивалентные встроенные функции SQL.
- **Функции расширения геопространственных**: Поддерживает преобразование из методы-заглушки `Distance`, `IsValid`, `IsValidDetailed`, и `Within` в эквивалентные встроенные функции SQL.
- **Определяемая пользователем функция расширение функции**: Поддерживает преобразование из метода-заглушки `UserDefinedFunctionProvider.Invoke` для соответствующего определяемой пользователем функции.
- **Miscellaneous**. Поддерживает преобразование операторов `Coalesce` и условные операторы. Можно легко преобразовать `Contains` в строку CONTAINS, ARRAY_CONTAINS или SQL IN в зависимости от контекста.

### <a name="sql-query-operators"></a>Операторы SQL-запросов

В следующих примерах показано, как некоторые из стандартных операторов запросов LINQ преобразуются в запросы Cosmos DB.

#### <a name="select-operator"></a>Выберите оператор

Синтаксис: `input.Select(x => f(x))`, где `f` — скалярное выражение.

**Выберите оператор, пример 1:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Select(family => family.parents[0].familyName);
  ```
  
- **SQL** 
  
  ```sql
      SELECT VALUE f.parents[0].familyName
      FROM Families f
    ```
  
**Выберите оператор, пример 2:** 

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Select(family => family.children[0].grade + c); // c is an int variable
  ```
  
- **SQL**
  
  ```sql
      SELECT VALUE f.children[0].grade + c
      FROM Families f
  ```
  
**Выберите оператор, пример 3:**

- **Лямбда-выражение LINQ**
  
  ```csharp
    input.Select(family => new
    {
        name = family.children[0].familyName,
        grade = family.children[0].grade + 3
    });
  ```
  
- **SQL** 
  
  ```sql
      SELECT VALUE {"name":f.children[0].familyName,
                    "grade": f.children[0].grade + 3 }
      FROM Families f
  ```

#### <a name="selectmany-operator"></a>Оператор SelectMany

Синтаксис: `input.SelectMany(x => f(x))`, где `f` — скалярное выражение, возвращающее тип контейнера.

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.SelectMany(family => family.children);
  ```
  
- **SQL**

  ```sql
      SELECT VALUE child
      FROM child IN Families.children
  ```

#### <a name="where-operator"></a>Оператор Where

Синтаксис: `input.Where(x => f(x))`, где `f` — скалярное выражение, возвращающее логическое значение.

**Когда оператор, пример 1:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Where(family=> family.parents[0].familyName == "Wakefield");
  ```
  
- **SQL**
  
  ```sql
      SELECT *
      FROM Families f
      WHERE f.parents[0].familyName = "Wakefield"
  ```
  
**Когда оператор, пример 2:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Where(
          family => family.parents[0].familyName == "Wakefield" &&
          family.children[0].grade < 3);
  ```
  
- **SQL**
  
  ```sql
      SELECT *
      FROM Families f
      WHERE f.parents[0].familyName = "Wakefield"
      AND f.children[0].grade < 3
  ```

### <a name="composite-sql-queries"></a>Составные SQL-запросы

Можно составить перечисленные выше операторы, чтобы формировать более расширенные запросы. Так как Cosmos DB поддерживает вложенные контейнеры, можно объединить или вложить композиции.

#### <a name="concatenation"></a>Объединение

Синтаксис: `input(.|.SelectMany())(.Select()|.Where())*`. Объединенный запрос может начинаться с необязательного `SelectMany` запроса, за которым идет несколько `Select` или `Where` операторы.

**Объединение, пример 1:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Select(family=>family.parents[0])
          .Where(familyName == "Wakefield");
  ```

- **SQL**
  
  ```sql
      SELECT *
      FROM Families f
      WHERE f.parents[0].familyName = "Wakefield"
  ```

**Объединение, пример 2:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Where(family => family.children[0].grade > 3)
          .Select(family => family.parents[0].familyName);
  ```

- **SQL**
  
  ```sql
      SELECT VALUE f.parents[0].familyName
      FROM Families f
      WHERE f.children[0].grade > 3
  ```

**Объединение, пример 3:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.Select(family => new { grade=family.children[0].grade}).
          Where(anon=> anon.grade < 3);
  ```
  
- **SQL**
  
  ```sql
      SELECT *
      FROM Families f
      WHERE ({grade: f.children[0].grade}.grade > 3)
  ```

**Объединение, пример 4:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.SelectMany(family => family.parents)
          .Where(parent => parents.familyName == "Wakefield");
  ```
  
- **SQL**
  
  ```sql
      SELECT *
      FROM p IN Families.parents
      WHERE p.familyName = "Wakefield"
  ```

#### <a name="nesting"></a>Вложенные операторы

Синтаксис `input.SelectMany(x=>x.Q())` где `Q` — `Select`, `SelectMany`, или `Where` оператор.

Вложенный запрос применяет внутренний запрос к каждому элементу внешнего контейнера. Одной важной особенностью является то, что внутренний запрос может ссылаться на поля элементов внешнего контейнера, как самосоединение.

**Вложенность, пример 1:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.SelectMany(family=>
          family.parents.Select(p => p.familyName));
  ```

- **SQL**
  
  ```sql
      SELECT VALUE p.familyName
      FROM Families f
      JOIN p IN f.parents
  ```

**Вложенность, пример 2:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.SelectMany(family =>
          family.children.Where(child => child.familyName == "Jeff"));
  ```

- **SQL**
  
  ```sql
      SELECT *
      FROM Families f
      JOIN c IN f.children
      WHERE c.familyName = "Jeff"
  ```

**Вложенность, пример 3:**

- **Лямбда-выражение LINQ**
  
  ```csharp
      input.SelectMany(family => family.children.Where(
          child => child.familyName == family.parents[0].familyName));
  ```

- **SQL**
  
  ```sql
      SELECT *
      FROM Families f
      JOIN c IN f.children
      WHERE c.familyName = f.parents[0].familyName
  ```

## <a id="References"></a>Справочные материалы

- [DocumentDB SQL Syntax](https://go.microsoft.com/fwlink/p/?LinkID=510612) (Синтаксис SQL в DocumentDB)
- [ANSI SQL 2011](https://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)
- [JSON](https://json.org/)
- [Спецификация JavaScript](https://www.ecma-international.org/publications/standards/Ecma-262.htm) 
- [LINQ](/previous-versions/dotnet/articles/bb308959(v=msdn.10)) 
- Graefe Goetz. [Методы оценки запроса для больших баз данных](https://dl.acm.org/citation.cfm?id=152611). *ACM, вычисления опросы* 25, нет. 2 (1993).
- Graefe ж. «Каскадные платформы для оптимизации запросов.» *IEEE данных Eng. Bull.* 18, нет. 3 (1995).
- Lu, Ooi, Tan. «Обработка запросов в параллельных реляционных СУБД.» *IEEE Computer Society Press* (1994).
- Olston, Кристофер, Бенджамин Рид, Utkarsh Srivastava, Рави Кумар и Andrew Tomkins. «Pig Latin: Not-So-Foreign Language для обработки данных.» *SIGMOD* (2008).

## <a name="next-steps"></a>Дальнейшие действия

- [Знакомство со службой Azure Cosmos DB. API DocumentDB][introduction]
- [Примеры .NET для Azure Cosmos DB](https://github.com/Azure/azure-cosmosdb-dotnet)
- [Настраиваемые уровни согласованности Azure Cosmos DB][consistency-levels]

[1]: ./media/how-to-sql-query/sql-query1.png
[introduction]: introduction.md
[consistency-levels]: consistency-levels.md
