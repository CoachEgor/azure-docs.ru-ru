---
title: Проблемы с устранением проблем при использовании Azure Cosmos DB
description: Узнайте, как выявлять, диагностировать и устранить проблемы запроса Azure Cosmos DB S'L.
author: timsander1
ms.service: cosmos-db
ms.topic: troubleshooting
ms.date: 04/20/2020
ms.author: tisande
ms.subservice: cosmosdb-sql
ms.reviewer: sngun
ms.openlocfilehash: 4a8b61f3719a60af567d10f8839987e613babc9e
ms.sourcegitcommit: af1cbaaa4f0faa53f91fbde4d6009ffb7662f7eb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81870455"
---
# <a name="troubleshoot-query-issues-when-using-azure-cosmos-db"></a>Проблемы с устранением проблем при использовании Azure Cosmos DB

В этой статье рекомендуется использовать общий рекомендуемый подход к устранению неполадок в Azure Cosmos DB. Хотя не следует рассматривать шаги, изложенные в этой статье, полной защитой от потенциальных проблем запроса, мы включили наиболее распространенные советы по производительности. Эту статью следует использовать в качестве отправной площадки для устранения медленных или дорогостоящих запросов в aPI API Azure Cosmos DB. Вы также можете использовать [журналы диагностики](cosmosdb-monitor-resource-logs.md) для выявления запросов, которые являются медленными или которые потребляют значительное количество пропускной однако.

Оптимизацию запросов можно классифицировать в DB Azure Cosmos DB:

- Оптимизация, снижающая плату за запрос группы запросов (RU)
- Оптимизация, которая только уменьшает задержку

Если снизить плату RU запроса, вы почти наверняка уменьшите задержку.

В этой статье приводятся примеры, которые можно воссоздать с помощью набора данных [о питании.](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json)

## <a name="common-sdk-issues"></a>Общие проблемы SDK

- Для лучшей производительности, следуйте [советам производительности](performance-tips.md).
    > [!NOTE]
    > Для повышения производительности мы рекомендуем обработку 64-разрядного хоста Windows. SDK с S'L включает в себя наиболее ServiceInterop.dll для разбора и оптимизации запросов локально. ServiceInterop.dll поддерживается только на платформе Windows x64. Для Linux и других неподдерживаемых платформ, где ServiceInterop.dll недоступен, дополнительный сетевой вызов будет сделан в шлюз, чтобы получить оптимизированный запрос.
- Вы можете `MaxItemCount` установить для своих запросов, но вы не можете указать минимальный отсчет элементов.
    - Код должен обрабатывать любой `MaxItemCount`размер страницы, от нуля до .
    - Количество элементов на странице всегда будет меньше `MaxItemCount`указанного. Тем `MaxItemCount` не менее, это строго максимум, и не может быть меньше результатов, чем эта сумма.
- Иногда в запросах могут быть пустые страницы, даже если на будущей странице есть результаты. Причины этого могут быть:
    - SDK может делать несколько сетевых вызовов.
    - Запрос может занять много времени для получения документов.
- Все запросы имеют маркер продолжения, который позволит продолжить запрос. Не забудьте полностью истощить запрос. Посмотрите на образцы SDK `while` и `FeedIterator.HasMoreResults` используйте цикл, чтобы истощить весь запрос.

## <a name="get-query-metrics"></a>Получить метрики запроса

При оптимизации запроса в Azure Cosmos DB первым шагом всегда является [получение метрик запроса](profile-sql-api-query.md) для вашего запроса. Эти метрики также доступны через портал Azure:

[![Получение метрик](./media/troubleshoot-query-performance/obtain-query-metrics.png) запроса](./media/troubleshoot-query-performance/obtain-query-metrics.png#lightbox)

После получения метрик запроса сравните количество извлеченных документов с отсчетом вывода документов для вашего запроса. Используйте это сравнение для определения соответствующих разделов для рассмотрения в этой статье.

Подсчет восстановленных документов — это количество документов, необходимых для загрузки запроса. Отсчет выходных документов — это количество документов, необходимых для результатов запроса. Если количество полученных документов значительно превышает количество выходных документов, существует по крайней мере одна часть запроса, которая не смогла использовать индекс и должна была сделать сканирование.

Обратитесь к следующим разделам, чтобы понять соответствующие оптимизации запросов для вашего сценария.

### <a name="querys-ru-charge-is-too-high"></a>Ru заряд запроса слишком высок

#### <a name="retrieved-document-count-is-significantly-higher-than-output-document-count"></a>Извлеченный отсчет документов значительно выше, чем количество выходных документов

- [Включить необходимые пути в политику индексирования.](#include-necessary-paths-in-the-indexing-policy)

- [Понять, какие системные функции используют индекс.](#understand-which-system-functions-use-the-index)

- [Понять, какие агрегированные запросы используют индекс.](#understand-which-aggregate-queries-use-the-index)

- [Изменять запросы, которые имеют как фильтр, так и оговорку ORDER BY.](#modify-queries-that-have-both-a-filter-and-an-order-by-clause)

- [Оптимизируйте выражения JOIN с помощью подвоха.](#optimize-join-expressions-by-using-a-subquery)

<br>

#### <a name="retrieved-document-count-is-approximately-equal-to-output-document-count"></a>Извлеченный отсчет документов примерно равен отсчету выходных документов

- [Избегайте перекрестных запросов разделов.](#avoid-cross-partition-queries)

- [Оптимизация запросов с фильтрами на нескольких свойствах.](#optimize-queries-that-have-filters-on-multiple-properties)

- [Изменять запросы, которые имеют как фильтр, так и оговорку ORDER BY.](#modify-queries-that-have-both-a-filter-and-an-order-by-clause)

<br>

### <a name="querys-ru-charge-is-acceptable-but-latency-is-still-too-high"></a>Ru заряд запроса является приемлемым, но задержка по-прежнему слишком высока

- [Улучшение близости.](#improve-proximity)

- [Увеличение просаживаемых пропускной однако.](#increase-provisioned-throughput)

- [Увеличьте MaxConcurrency.](#increase-maxconcurrency)

- [Увеличьте MaxBufferedItemCount.](#increase-maxbuffereditemcount)

## <a name="queries-where-retrieved-document-count-exceeds-output-document-count"></a>Запросы, в которых количество полученных документов превышает количество выходных документов

 Подсчет восстановленных документов — это количество документов, необходимых для загрузки запроса. Отсчет выходных документов — это количество документов, необходимых для результатов запроса. Если количество полученных документов значительно превышает количество выходных документов, существует по крайней мере одна часть запроса, которая не смогла использовать индекс и должна была сделать сканирование.

Вот пример запроса сканирования, который не был полностью обслужен индексом:

Запрос:

 ```sql
SELECT VALUE c.description
FROM c
WHERE UPPER(c.description) = "BABYFOOD, DESSERT, FRUIT DESSERT, WITHOUT ASCORBIC ACID, JUNIOR"
 ```

Показатели запроса:

```
Retrieved Document Count                 :          60,951
Retrieved Document Size                  :     399,998,938 bytes
Output Document Count                    :               7
Output Document Size                     :             510 bytes
Index Utilization                        :            0.00 %
Total Query Execution Time               :        4,500.34 milliseconds
  Query Preparation Times
    Query Compilation Time               :            0.09 milliseconds
    Logical Plan Build Time              :            0.05 milliseconds
    Physical Plan Build Time             :            0.04 milliseconds
    Query Optimization Time              :            0.01 milliseconds
  Index Lookup Time                      :            0.01 milliseconds
  Document Load Time                     :        4,177.66 milliseconds
  Runtime Execution Times
    Query Engine Times                   :          322.16 milliseconds
    System Function Execution Time       :           85.74 milliseconds
    User-defined Function Execution Time :            0.00 milliseconds
  Document Write Time                    :            0.01 milliseconds
Client Side Metrics
  Retry Count                            :               0
  Request Charge                         :        4,059.95 RUs
```

Количество полученных документов (60 951) значительно выше, чем количество выходных документов (7), поэтому этот запрос должен был сделать сканирование. В этом случае функция системы [UPPER()](sql-query-upper.md) не использует индекс.

### <a name="include-necessary-paths-in-the-indexing-policy"></a>Включить необходимые пути в политику индексации

Ваша политика индексирования должна охватывать `WHERE` любые `ORDER BY` свойства, `JOIN`включенные в положения, положения и большинство системных функций. Путь, указанный в политике индекса, должен соответствовать (чувствительному к делу) свойству в документах JSON.

Если вы запустите простой запрос на наборе данных [о питании,](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) при индексации свойства в пункте свойство в оговорке `WHERE` наблюдается гораздо более низкая плата RU:

#### <a name="original"></a>Исходное значение

Запрос:

```sql
SELECT * FROM c WHERE c.description = "Malabar spinach, cooked"
```

Политика индексирования:

```json
{
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
        {
            "path": "/*"
        }
    ],
    "excludedPaths": [
        {
            "path": "/description/*"
        }
    ]
}
```

**Ru заряд:** 409.51 RUs

#### <a name="optimized"></a>Оптимизирован

Обновленная политика индексирования:

```json
{
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
        {
            "path": "/*"
        }
    ],
    "excludedPaths": []
}
```

**Ru заряд:** 2.98 RUs

Вы можете добавить свойства в политику индексирования в любое время, без какого-либо влияния на доступность или производительность записи. При добавлении нового свойства в индекс в запросах, которые используют свойство, немедленно будет использоваться новый доступный индекс. Запрос будет использовать новый индекс во время его построения. Таким образом, результаты запроса могут быть несовместимыми во время восстановления индекса. При индексации нового свойства при восстановлении индекса не будут затронуты запросы, в которых используются только существующие индексы. Вы можете [отслеживать прогресс преобразования индекса.](https://docs.microsoft.com/azure/cosmos-db/how-to-manage-indexing-policy#use-the-net-sdk-v3)

### <a name="understand-which-system-functions-use-the-index"></a>Понять, какие системные функции используют индекс

Если выражение может быть переведено в диапазон значений строки, оно может использовать индекс. В противном случае, он не может.

Вот список некоторых общих функций строки, которые могут использовать индекс:

- STARTSWITH(str_expr, str_expr);
- LEFT(str_expr, num_expr) = str_expr;
- SUBSTRING (str_expr, num_expr, num_expr) - str_expr, но только в том случае, если первая num_expr 0

Ниже приведены некоторые общие системные функции, которые не используют индекс и должны загружать каждый документ:

| **Функция системы**                     | **Идеи для оптимизации**             |
| --------------------------------------- |------------------------------------------------------------ |
| CONTAINS                                | Используйте поиск Azure для полнотекстовых поисков.                        |
| ВЕРХНИЙ/НИЖНИЙ                             | Вместо того, чтобы использовать системную функцию для нормализации данных для сравнения, нормализовать оболочку при вставке. Запрос, как ```SELECT * FROM c WHERE UPPER(c.name) = 'BOB'``` ```SELECT * FROM c WHERE c.name = 'BOB'```становится . |
| Математические функции (неагрегаты) | Если вам необходимо часто вычислять значение в запросе, подумайте о хранении значения как свойства в документе JSON. |

------

Другие части запроса могут по-прежнему использовать индекс, даже если функции системы не используются.

### <a name="understand-which-aggregate-queries-use-the-index"></a>Понять, какие агрегированные запросы используют индекс

В большинстве случаев агрегированные функции системы в Azure Cosmos DB будут использовать индекс. Однако, в зависимости от фильтров или дополнительных положений в агрегированном запросе, для загрузки большого количества документов может потребоваться движок запроса. Как правило, в движке запросов сначала применяются фильтры равенства и диапазона. После применения этих фильтров движок запроса может оценить дополнительные фильтры и прибегнуть к загрузке оставшихся документов для вычисления агрегата, если это необходимо.

Например, с учетом этих двух выборочных запросов `CONTAINS` запрос с фильтром равенства и системных функций, как правило, будет более эффективным, чем запрос с фильтром системной `CONTAINS` функции. Это связано с тем, что фильтр равенства применяется в первую `CONTAINS` очередь и использует индекс до того, как документы должны быть загружены для более дорогого фильтра.

Запрос с `CONTAINS` только фильтром - более высокая плата RU:

```sql
SELECT COUNT(1) FROM c WHERE CONTAINS(c.description, "spinach")
```

Запрос с фильтром `CONTAINS` равенства и фильтром - более низкая плата RU:

```sql
SELECT AVG(c._ts) FROM c WHERE c.foodGroup = "Sausages and Luncheon Meats" AND CONTAINS(c.description, "spinach")
```

Ниже приведены дополнительные примеры агрегированных запросов, которые не будут в полной мере использовать индекс:

#### <a name="queries-with-system-functions-that-dont-use-the-index"></a>Запросы с системными функциями, не использоваваемыми индексом

Вы должны обратиться к [странице соответствующей функции системы,](sql-query-system-functions.md) чтобы увидеть, использует ли он индекс.

```sql
SELECT MAX(c._ts) FROM c WHERE CONTAINS(c.description, "spinach")
```

#### <a name="aggregate-queries-with-user-defined-functionsudfs"></a>Агрегированные запросы с функциями, определяемыми пользователем (UDF).

```sql
SELECT AVG(c._ts) FROM c WHERE udf.MyUDF("Sausages and Luncheon Meats")
```

#### <a name="queries-with-group-by"></a>Запросы с GROUP BY

Ru заряд `GROUP BY` будет увеличиваться, как кардинальность `GROUP BY` свойств в оговорке увеличивается. В этом примере движок запроса должен `c.foodGroup = "Sausages and Luncheon Meats"` загрузить каждый документ, который соответствует фильтру, поэтому ожидается, что плата RU будет высокой.

```sql
SELECT COUNT(1) FROM c WHERE c.foodGroup = "Sausages and Luncheon Meats" GROUP BY c.description
```

Если вы планируете часто запускать одни и те же агрегированные запросы, возможно, будет более эффективным создавать материализованное представление в реальном времени с [помощью канала dB Azure Cosmos,](change-feed.md) чем выполнение отдельных запросов.

### <a name="modify-queries-that-have-both-a-filter-and-an-order-by-clause"></a>Изменение запросов, которые имеют как фильтр, так и положение ORDER BY

Хотя запросы, в которых `ORDER BY` есть фильтр и оговорка, обычно используют индекс диапазона, они будут более эффективными, если они могут быть поданы из композитного индекса. В дополнение к изменению политики индексирования следует добавить все `ORDER BY` свойства в составном индексе к оговорке. Это изменение запроса гарантирует использование композитного индекса.  Вы можете наблюдать влияние, запустив запрос на набор [еде:](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json)

#### <a name="original"></a>Исходное значение

Запрос:

```sql
SELECT * FROM c WHERE c.foodGroup = "Soups, Sauces, and Gravies" ORDER BY c._ts ASC
```

Политика индексирования:

```json
{

        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[]
}
```

**Ru заряд:** 44.28 RUs

#### <a name="optimized"></a>Оптимизирован

Обновленный запрос (включает оба `ORDER BY` свойства в оговорке):

```sql
SELECT * FROM c
WHERE c.foodGroup = "Soups, Sauces, and Gravies"
ORDER BY c.foodGroup, c._ts ASC
```

Обновленная политика индексирования:

```json
{  
        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[],
        "compositeIndexes":[  
            [  
                {  
                    "path":"/foodGroup",
                    "order":"ascending"
        },
                {  
                    "path":"/_ts",
                    "order":"ascending"
                }
            ]
        ]
    }

```

**Ru заряд:** 8.86 RUs

### <a name="optimize-join-expressions-by-using-a-subquery"></a>Оптимизация выражений JOIN с помощью подвоха
Мульти-значение подзапросов `JOIN` может оптимизировать выражения, нажав предикатов после каждого `WHERE` выбора много выражения, а не после того, как все крест соединения в оговорке.

Рассмотрим следующий запрос:

```sql
SELECT Count(1) AS Count
FROM c
JOIN t IN c.tags
JOIN n IN c.nutrients
JOIN s IN c.servings
WHERE t.name = 'infant formula' AND (n.nutritionValue > 0
AND n.nutritionValue < 10) AND s.amount > 1
```

**Ru заряд:** 167.62 RUs

Для этого запроса индекс будет соответствовать любому документу с тегом с названием "младенческая формула", питаниеСтоимость больше 0, и количество порций больше 1. Выражение `JOIN` здесь будет выполнять кросс-продукт всех элементов тегов, питательных веществ и сервитутов массивов для каждого соответствующего документа, прежде чем любой фильтр применяется. Затем `WHERE` в пункте будет применяться `<c, t, n, s>` предикат фильтра на каждом tuple.

Например, если соответствующий документ содержит по 10 элементов в каждом из трех массивов, он расширится до 1 x 10 x 10 x 10 (т.е. 1000) в уходе. Использование субзапросов может помочь отфильтровать объединенные элементы массива, прежде чем присоединиться к следующему выражению.

Этот запрос эквивалентен предыдущему, но использует подзапросы:

```sql
SELECT Count(1) AS Count
FROM c
JOIN (SELECT VALUE t FROM t IN c.tags WHERE t.name = 'infant formula')
JOIN (SELECT VALUE n FROM n IN c.nutrients WHERE n.nutritionValue > 0 AND n.nutritionValue < 10)
JOIN (SELECT VALUE s FROM s IN c.servings WHERE s.amount > 1)
```

**Ru заряд:** 22.17 RUs

Предположим, что только один элемент в массиве тегов соответствует фильтру и что есть пять элементов как для питательных веществ, так и для массивов порций. Выражения `JOIN` расширятся до 1 x 1 x 5 x 5 х 25 элементов, в отличие от 1000 элементов в первом запросе.

## <a name="queries-where-retrieved-document-count-is-equal-to-output-document-count"></a>Запросы, в которых количество полученных документов равно значат количество выходных документов

Если количество извлеченных документов примерно равно счету вывода документов, запросу не пришлось сканировать много ненужных документов. Для многих запросов, например, для запросов, в которых используется ключевое слово TOP, количество полученных документов может превысить количество выходных документов на 1. Вам не нужно беспокоиться об этом.

### <a name="avoid-cross-partition-queries"></a>Избегайте перекрестных запросов перегородки

Azure Cosmos DB использует [разделдля](partitioning-overview.md) отдельных контейнеров по мере увеличения потребностей в хранении запросов и хранении данных. Каждая физическая часть имеет отдельный и независимый индекс. Если в запросе есть фильтр равенства, соответствующий ключу раздела контейнера, необходимо проверить только соответствующий индекс раздела. Эта оптимизация уменьшает общее количество RUs, которые требуются запросу.

Если у вас есть большое количество подготовленных RUs (более 30 000) или большой объем хранящихся данных (более 100 ГБ), у вас, вероятно, есть достаточно большой контейнер, чтобы увидеть значительное снижение сборов RU запроса.

Например, при создании контейнера с разделом ключевой foodGroup следующие запросы должны будут проверить только одну физическую перегородку:

```sql
SELECT * FROM c
WHERE c.foodGroup = "Soups, Sauces, and Gravies" and c.description = "Mushroom, oyster, raw"
```

Эти запросы будут также оптимизированы за счет добавления ключа раздела в запросе:

```sql
SELECT * FROM c
WHERE c.foodGroup IN("Soups, Sauces, and Gravies", "Vegetables and Vegetable Products") and c.description = "Mushroom, oyster, raw"
```

Запросы, которые имеют фильтры диапазона на ключе раздела или не имеют фильтров на ключе раздела, должны проверять индекс каждого физического раздела на наличие результатов:

```sql
SELECT * FROM c
WHERE c.description = "Mushroom, oyster, raw"
```

```sql
SELECT * FROM c
WHERE c.foodGroup > "Soups, Sauces, and Gravies" and c.description = "Mushroom, oyster, raw"
```

### <a name="optimize-queries-that-have-filters-on-multiple-properties"></a>Оптимизация запросов с фильтрами на нескольких свойствах

Хотя запросы, в которых есть фильтры на нескольких свойствах, обычно используют индекс диапазона, они будут более эффективными, если их можно обслуживать из композитного индекса. Для небольших объемов данных эта оптимизация не окажет существенного влияния. Однако он может быть полезен для больших объемов данных. Можно оптимизировать только один фильтр неравенства на составной индекс. Если в запросе есть несколько фильтров, не связанных с равенством, выберите один из них, который будет использовать составной индекс. Остальные будут продолжать использовать индексы диапазона. Фильтр неравенства должен быть определен последним в составном индексе. [Подробнее о составных индексах.](index-policy.md#composite-indexes)

Вот несколько примеров запросов, которые могут быть оптимизированы с составным индексом:

```sql
SELECT * FROM c
WHERE c.foodGroup = "Vegetables and Vegetable Products" AND c._ts = 1575503264
```

```sql
SELECT * FROM c
WHERE c.foodGroup = "Vegetables and Vegetable Products" AND c._ts > 1575503264
```

Вот соответствующий составной индекс:

```json
{  
        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[],
        "compositeIndexes":[  
            [  
                {  
                    "path":"/foodGroup",
                    "order":"ascending"
                },
                {  
                    "path":"/_ts",
                    "order":"ascending"
                }
            ]
        ]
}
```

## <a name="optimizations-that-reduce-query-latency"></a>Оптимизация, снижая задержку запроса

Во многих случаях плата RU может быть приемлемой, когда задержка запроса все еще слишком высока. В следующих разделах приведен обзор советов по сокращению задержки запроса. Если вы запустите один и тот же запрос несколько раз на одном и том же наборе данных, он будет иметь одиниковую плату RU каждый раз. Но задержка запроса может варьироваться между выполнением запросов.

### <a name="improve-proximity"></a>Улучшение близости

Запросы, запущенные из другого региона, чем учетная запись Azure Cosmos DB, будут иметь более высокую задержку, чем если бы они были запущены в одном регионе. Например, если вы работаете с кодом на настольном компьютере, следует ожидать, что задержка будет на десятки или сотни миллисекунд выше (или больше), чем если бы запрос пришел из виртуальной машины в том же регионе Azure, что и Azure Cosmos DB. Глобально [распространять данные в Azure Cosmos DB](distribute-data-globally.md) просто, чтобы обеспечить приближение данных к приложению.

### <a name="increase-provisioned-throughput"></a>Увеличение просаживаемых пропускной однако

В Azure Cosmos DB ваша просрященная пропускная связь измеряется в единицах запроса (RUs). Представьте, что у вас есть запрос, который потребляет 5 RUs пропускной всей. Например, если вы предоставляете 1000 RUs, вы сможете запустить этот запрос 200 раз в секунду. Если вы попыталась запустить запрос, когда не было достаточной пропускной выгоды, Azure Cosmos DB вернул ошибку HTTP 429. Любой из текущих SPI-иного воков (S'L) автоматически повторно завершает этот запрос после ожидания в течение короткого времени. Загруженные запросы занимают больше времени, поэтому увеличение просрочки может улучшить задержку запроса. Общее количество [задушенных запросов](use-metrics.md#understand-how-many-requests-are-succeeding-or-causing-errors) можно наблюдать на лезвии **метрик** портала Azure.

### <a name="increase-maxconcurrency"></a>Увеличьте MaxConcurrency

Параллельные запросы работают параллельно, запрашивая несколько разделов. Но данные из отдельного разделительного сбора извлекаются последовательно по отношению к запросу. Таким образом, если вы установите MaxConcurrency на количество разделов, у вас есть наилучшие шансы на достижение наиболее перформативного запроса, при условии, что все другие системные условия останутся прежними. Если вы не знаете количество разделов, вы можете установить MaxConcurrency (или MaxDegreesOfParallelism в старых версиях SDK) на большое число. Система будет выбирать минимальную (количество разделов, пользовательский входный данный) в качестве максимальной степени параллелизма.

### <a name="increase-maxbuffereditemcount"></a>Увеличьте MaxBufferedItemCount

Запросы предназначены для предварительных результатов, в то время как текущая партия результатов обрабатывается клиентом. Предварительная доставка помогает улучшить общую задержку запроса. Установка MaxBufferedItemCount ограничивает количество предварительных результатов. Если вы установите это значение до ожидаемого количества возвращенных результатов (или более высокого числа), запрос может получить наибольшую выгоду от предварительного получения. Если вы установите это значение до -1, система автоматически определит количество элементов для буфера.

## <a name="next-steps"></a>Дальнейшие действия
Ознакомьтесь со следующими статьями о том, как измерять RUs за запрос, получить статистику выполнения для настройки запросов и многое другое:

* [Получите метрики выполнения запроса s'L с помощью .NET SDK](profile-sql-api-query.md)
* [Настройка производительности запросов в Azure Cosmos DB](sql-api-sql-query-metrics.md)
* [Советы по повышению производительности при использовании пакета SDK для .NET](performance-tips.md)
