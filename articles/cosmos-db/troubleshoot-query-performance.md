---
title: Устранение проблем с запросами при использовании Azure Cosmos DB
description: Узнайте, как определять, диагностировать и устранять неполадки Azure Cosmos DB запросов SQL.
author: timsander1
ms.service: cosmos-db
ms.topic: troubleshooting
ms.date: 04/22/2020
ms.author: tisande
ms.subservice: cosmosdb-sql
ms.reviewer: sngun
ms.openlocfilehash: b3c6926f17e8378fd3b53bfd59a7c5ea8141adb4
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "82097240"
---
# <a name="troubleshoot-query-issues-when-using-azure-cosmos-db"></a>Устранение проблем с запросами при использовании Azure Cosmos DB

В этой статье рассматривается общий рекомендуемый подход для устранения неполадок запросов в Azure Cosmos DB. Несмотря на то, что не следует думать о том, как выполнить действия, описанные в этой статье, полностью защититься от потенциальных проблем с запросами, мы включили наиболее распространенные советы по повышению производительности. Эту статью следует использовать в качестве начального места для устранения проблем с ресурсоемкими или дорогостоящими запросами в API Azure Cosmos DB Core (SQL). Кроме того, [журналы диагностики](cosmosdb-monitor-resource-logs.md) можно использовать для того, чтобы узнать, какие запросы выполняются слишком долго или потребляют значительный объем пропускной способности.

Оптимизацию запросов можно разделить на Azure Cosmos DB:

- Оптимизации, снижающие затраты единиц запросов (RU) запроса
- Оптимизации, которые просто сокращают задержку

Если вы сократите количество единиц запроса, то вы почти наверняка сокращаете задержку.

В этой статье приведены примеры, которые можно создать повторно с помощью набора данных [информации питании](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) .

## <a name="common-sdk-issues"></a>Распространенные проблемы с пакетом SDK

Прежде чем приступить к работе с этим руководством, рекомендуется рассмотреть распространенные проблемы с пакетом SDK, не связанные с обработчиком запросов.

- Для достижения оптимальной производительности следуйте этим [советам по повышению производительности](performance-tips.md).
    > [!NOTE]
    > Для повышения производительности рекомендуется использовать Windows 64-разрядную обработку узлов. Пакет SDK для SQL содержит собственную ServiceInterop. dll для локального анализа и оптимизации запросов. ServiceInterop. dll поддерживается только на платформе Windows x64. Для Linux и других неподдерживаемых платформ, где ServiceInterop. DLL недоступен, для получения оптимизированного запроса будет выполнен дополнительный сетевой вызов шлюза.
- Пакет SDK позволяет задать для `MaxItemCount` ваших запросов, но нельзя указать минимальное число элементов.
    - Код должен поддерживать любой размер страницы, от нуля до `MaxItemCount`.
    - Количество элементов на странице всегда будет меньше или равно указанному `MaxItemCount`значению. Тем не `MaxItemCount` менее, является строго максимальным, и количество результатов может быть меньше этого значения.
- Иногда запросы могут содержать пустые страницы, даже если на следующей странице есть результаты. Это может быть вызвано следующими причинами.
    - Пакет SDK может выполнять несколько сетевых вызовов.
    - Для получения документов может потребоваться много времени.
- Все запросы имеют токен продолжения, позволяющий продолжить выполнение запроса. Не забудьте полностью очистить запрос. Взгляните на примеры пакета SDK и используйте `while` цикл `FeedIterator.HasMoreResults` для очистки всего запроса.

## <a name="get-query-metrics"></a>Получение метрик запроса

При оптимизации запроса в Azure Cosmos DB первым шагом всегда будет [Получение метрик запроса](profile-sql-api-query.md) для запроса. Эти метрики также доступны в портал Azure. После выполнения запроса в обозреватель данных метрики запроса отображаются рядом с вкладкой **результаты** :

[![Получение метрик](./media/troubleshoot-query-performance/obtain-query-metrics.png) запроса](./media/troubleshoot-query-performance/obtain-query-metrics.png#lightbox)

После получения метрик запроса Сравните **полученное число документов** с **числом выходных документов** для запроса. Используйте это сравнение, чтобы указать соответствующие разделы для проверки в этой статье.

**Полученное число документов** — это число документов, которые подсистема обработки запросов загрузила. **Число выходных документов** — это количество документов, которые были необходимы для результатов запроса. Если **полученное число документов** значительно превышает **число выходных документов**, существовала хотя бы одна часть запроса, которая не смогла использовать индекс и требуется для проверки.

Ознакомьтесь со следующими разделами, чтобы получить представление о оптимизированных для вашего сценариях оптимизациях запросов.

### <a name="querys-ru-charge-is-too-high"></a>Плата за ЕДИНИЦу запроса слишком высока

#### <a name="retrieved-document-count-is-significantly-higher-than-output-document-count"></a>Число извлеченных документов значительно превышает число выходных документов

- [Включите необходимые пути в политику индексирования.](#include-necessary-paths-in-the-indexing-policy)

- [Узнайте, какие системные функции используют индекс.](#understand-which-system-functions-use-the-index)

- [Понимать, какие статистические запросы используют индекс.](#understand-which-aggregate-queries-use-the-index)

- [Оптимизируйте запросы, имеющие как фильтр, так и предложение ORDER BY.](#optimize-queries-that-have-both-a-filter-and-an-order-by-clause)

- [Оптимизируйте выражения объединения с помощью вложенного запроса.](#optimize-join-expressions-by-using-a-subquery)

<br>

#### <a name="retrieved-document-count-is-approximately-equal-to-output-document-count"></a>Число полученных документов приблизительно равно числу выходных документов

- [Сократите количество запросов между секциями.](#minimize-cross-partition-queries)

- [Оптимизируйте запросы с фильтрами для нескольких свойств.](#optimize-queries-that-have-filters-on-multiple-properties)

- [Оптимизируйте запросы, имеющие как фильтр, так и предложение ORDER BY.](#optimize-queries-that-have-both-a-filter-and-an-order-by-clause)

<br>

### <a name="querys-ru-charge-is-acceptable-but-latency-is-still-too-high"></a>Плата за ЕДИНИЦу запроса приемлема, но задержка по-прежнему слишком высока

- [Повышение близости.](#improve-proximity)

- [Увеличьте подготовленную пропускную способность.](#increase-provisioned-throughput)

- [Увеличьте Максконкурренци.](#increase-maxconcurrency)

- [Увеличьте MaxBufferedItemCount.](#increase-maxbuffereditemcount)

## <a name="queries-where-retrieved-document-count-exceeds-output-document-count"></a>Запросы, в которых количество полученных документов превышает число выходных документов

 **Полученное число документов** — это число документов, которые подсистема обработки запросов загрузила. **Число выходных документов** — это число документов, возвращенных запросом. Если **полученное число документов** значительно превышает **число выходных документов**, существовала хотя бы одна часть запроса, которая не смогла использовать индекс и требуется для проверки.

Ниже приведен пример запроса сканирования, который не был полностью обработан индексом.

Запрос:

 ```sql
SELECT VALUE c.description
FROM c
WHERE UPPER(c.description) = "BABYFOOD, DESSERT, FRUIT DESSERT, WITHOUT ASCORBIC ACID, JUNIOR"
 ```

Метрики запросов:

```
Retrieved Document Count                 :          60,951
Retrieved Document Size                  :     399,998,938 bytes
Output Document Count                    :               7
Output Document Size                     :             510 bytes
Index Utilization                        :            0.00 %
Total Query Execution Time               :        4,500.34 milliseconds
  Query Preparation Times
    Query Compilation Time               :            0.09 milliseconds
    Logical Plan Build Time              :            0.05 milliseconds
    Physical Plan Build Time             :            0.04 milliseconds
    Query Optimization Time              :            0.01 milliseconds
  Index Lookup Time                      :            0.01 milliseconds
  Document Load Time                     :        4,177.66 milliseconds
  Runtime Execution Times
    Query Engine Times                   :          322.16 milliseconds
    System Function Execution Time       :           85.74 milliseconds
    User-defined Function Execution Time :            0.00 milliseconds
  Document Write Time                    :            0.01 milliseconds
Client Side Metrics
  Retry Count                            :               0
  Request Charge                         :        4,059.95 RUs
```

**Полученное число документов** (60 951) значительно превышает **число выходных документов** (7), что подразумевает, что этот запрос привел к просмотру документа. В этом случае системная функция [Upper ()](sql-query-upper.md) не использует индекс.

### <a name="include-necessary-paths-in-the-indexing-policy"></a>Включить необходимые пути в политику индексирования

Политика индексирования должна охватывать все свойства, входящие `WHERE` в предложения, `ORDER BY` предложения, `JOIN`и большинство системных функций. Требуемые пути, указанные в политике индекса, должны соответствовать свойствам в документах JSON.

> [!NOTE]
> Свойства в Azure Cosmos DB политики индексирования учитывают регистр

Если выполнить следующий простой запрос к набору данных [информации питании](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) , то при индексировании свойства в `WHERE` предложении будет взиматься более низкая плата за единицу.

#### <a name="original"></a>До преобразования

Запрос:

```sql
SELECT *
FROM c
WHERE c.description = "Malabar spinach, cooked"
```

Политика индексации:

```json
{
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
        {
            "path": "/*"
        }
    ],
    "excludedPaths": [
        {
            "path": "/description/*"
        }
    ]
}
```

**Плата за единицу:** 409,51 RUs

#### <a name="optimized"></a>Оптимизирован

Обновленная политика индексирования:

```json
{
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
        {
            "path": "/*"
        }
    ],
    "excludedPaths": []
}
```

**Плата за единицу:** 2,98 RUs

Вы можете в любое время добавить свойства в политику индексирования без влияния на доступность или производительность записи. Если добавить в индекс новое свойство, то запросы, использующие свойство, будут немедленно использовать новый доступный индекс. При построении запрос будет использовать новый индекс. Поэтому результаты запроса могут быть непоследовательными, пока выполняется перестроение индекса. Если новое свойство индексируется, запросы, использующие только существующие индексы, не будут затронуты при перестроении индекса. Можно [отслеживать ход преобразования индекса](https://docs.microsoft.com/azure/cosmos-db/how-to-manage-indexing-policy#use-the-net-sdk-v3).

### <a name="understand-which-system-functions-use-the-index"></a>Сведения о том, какие системные функции используют индекс

Если выражение может быть преобразовано в диапазон строковых значений, оно может использовать индекс. В противном случае он не может.

Ниже приведен список некоторых общих строковых функций, которые могут использовать индекс:

- STARTSWITH(str_expr, str_expr);
- LEFT(str_expr, num_expr) = str_expr;
- SUBSTRING (str_expr, num_expr, num_expr) = str_expr, но только в том случае, если первый num_expr равен 0

Ниже приведены некоторые распространенные системные функции, которые не используют индекс и должны загружать каждый документ:

| **Системная функция**                     | **Идеи для оптимизации**             |
| --------------------------------------- |------------------------------------------------------------ |
| CONTAINS                                | Используйте поиск Azure для полнотекстового поиска.                        |
| ВЕРХНИЙ ИЛИ НИЖНИЙ                             | Вместо использования системной функции для нормализации данных для сравнения следует нормализовать регистр при вставке. Запрос имеет вид ```SELECT * FROM c WHERE UPPER(c.name) = 'BOB'``` ```SELECT * FROM c WHERE c.name = 'BOB'```. |
| Математические функции (не статистические выражения) | Если необходимо часто вычислить значение в запросе, рекомендуется сохранить значение как свойство в документе JSON. |

------

Другие части запроса могут по-прежнему использовать индекс, даже если системные функции не работают.

### <a name="understand-which-aggregate-queries-use-the-index"></a>Понимать, какие статистические запросы используют индекс

В большинстве случаев агрегатные системные функции в Azure Cosmos DB будут использовать индекс. Однако в зависимости от фильтров или дополнительных предложений в статистическом запросе для загрузки большого количества документов может потребоваться обработчик запросов. Как правило, обработчик запросов будет применять фильтры по равенству и диапазону первыми. После применения этих фильтров обработчик запросов может оценить дополнительные фильтры и прибегнуть к загрузке оставшихся документов для вычисления статистической функции, если это необходимо.

Например, при наличии этих двух примеров запросов запрос с фильтром "равенство" `CONTAINS` и "системная функция" обычно более эффективен, чем запрос только с `CONTAINS` фильтром системной функции. Это обусловлено тем, что фильтр равенства применяется в первую очередь и использует индекс до того, как документы необходимо загрузить для `CONTAINS` более дорогостоящего фильтра.

Запрос только `CONTAINS` с фильтром — более высокий тариф на единицу:

```sql
SELECT COUNT(1)
FROM c
WHERE CONTAINS(c.description, "spinach")
```

Запрос с фильтром равенства и `CONTAINS` с более низким тарифом на единицу:

```sql
SELECT AVG(c._ts)
FROM c
WHERE c.foodGroup = "Sausages and Luncheon Meats" AND CONTAINS(c.description, "spinach")
```

Ниже приведены дополнительные примеры статистических запросов, которые не будут полностью использовать индекс.

#### <a name="queries-with-system-functions-that-dont-use-the-index"></a>Запросы с системными функциями, которые не используют индекс

Чтобы узнать, использует ли он индекс, необходимо обратиться к соответствующей [странице системной функции](sql-query-system-functions.md) .

```sql
SELECT MAX(c._ts)
FROM c
WHERE CONTAINS(c.description, "spinach")
```

#### <a name="aggregate-queries-with-user-defined-functionsudfs"></a>Статистические запросы с определяемыми пользователем функциями (UDF)

```sql
SELECT AVG(c._ts)
FROM c
WHERE udf.MyUDF("Sausages and Luncheon Meats")
```

#### <a name="queries-with-group-by"></a>Запросы с GROUP BY

ЕДИНИЦа оплаты за запросы с `GROUP BY` будет увеличиваться по мере увеличения количества элементов свойств в `GROUP BY` предложении. В приведенном ниже запросе, например, при увеличении числа уникальных описаний будет увеличиваться плата за ЕДИНИЦу запроса.

Оплата за единицу агрегатной функции с `GROUP BY` предложением будет выше, чем за единицу оплаты за агрегатную функцию. В этом примере обработчик запросов должен загрузить каждый документ, соответствующий `c.foodGroup = "Sausages and Luncheon Meats"` фильтру, чтобы плата за единицу была ожидаемой.

```sql
SELECT COUNT(1)
FROM c
WHERE c.foodGroup = "Sausages and Luncheon Meats"
GROUP BY c.description
```

Если планируется часто выполнять одни и те же статистические запросы, может оказаться более эффективным создание материализованных представлений в режиме реального времени с помощью [веб-канала изменений Azure Cosmos DB](change-feed.md) , чем выполнение отдельных запросов.

### <a name="optimize-queries-that-have-both-a-filter-and-an-order-by-clause"></a>Оптимизация запросов, имеющих предложения Filter и ORDER BY

Хотя запросы с фильтром и `ORDER BY` предложением обычно используют индекс диапазона, они будут более эффективны, если их можно будет обрабатывать из составного индекса. В дополнение к изменению политики индексации в `ORDER BY` предложение необходимо добавить все свойства составного индекса. Это изменение запроса обеспечит использование составного индекса.  Вы можете наблюдать за последствиями выполнения запроса к набору данных [информации питании](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) :

#### <a name="original"></a>До преобразования

Запрос:

```sql
SELECT *
FROM c
WHERE c.foodGroup = "Soups, Sauces, and Gravies"
ORDER BY c._ts ASC
```

Политика индексации:

```json
{

        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[]
}
```

**Плата за единицу:** 44,28 RUs

#### <a name="optimized"></a>Оптимизирован

Обновленный запрос (содержит оба свойства в `ORDER BY` предложении):

```sql
SELECT *
FROM c
WHERE c.foodGroup = "Soups, Sauces, and Gravies"
ORDER BY c.foodGroup, c._ts ASC
```

Обновленная политика индексирования:

```json
{  
        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[],
        "compositeIndexes":[  
            [  
                {  
                    "path":"/foodGroup",
                    "order":"ascending"
        },
                {  
                    "path":"/_ts",
                    "order":"ascending"
                }
            ]
        ]
    }

```

**Плата за единицу:** 8,86 RUs

### <a name="optimize-join-expressions-by-using-a-subquery"></a>Оптимизация выражений объединения с помощью вложенного запроса

Вложенные запросы с несколькими значениями могут `JOIN` оптимизировать выражения, отправляя предикаты после каждого выражения SELECT-many, а не после всех перекрестных соединений в `WHERE` предложении.

Рассмотрим следующий запрос:

```sql
SELECT Count(1) AS Count
FROM c
JOIN t IN c.tags
JOIN n IN c.nutrients
JOIN s IN c.servings
WHERE t.name = 'infant formula' AND (n.nutritionValue > 0
AND n.nutritionValue < 10) AND s.amount > 1
```

**Плата за единицу:** 167,62 RUs

Для этого запроса индекс будет соответствовать любому документу, имеющему тег с именем `infant formula`, `nutritionValue` больше 0 и `amount` больше 1. `JOIN` Выражение здесь выполняет перекрестное произведение всех элементов тегов, нутриентс и обслуживает массивы для каждого соответствующего документа до применения любого фильтра. Затем `WHERE` предложение применит предикат фильтра к каждому `<c, t, n, s>` кортежу.

Например, если в соответствующем документе содержится 10 элементов в каждом из трех массивов, он будет развернут до 1 x 10 x 10 x 10 (то есть 1 000) кортежей. Использование вложенных запросов здесь может помочь отфильтровать соединяемые элементы массива перед присоединением к следующему выражению.

Этот запрос эквивалентен предыдущему, но использует вложенные запросы:

```sql
SELECT Count(1) AS Count
FROM c
JOIN (SELECT VALUE t FROM t IN c.tags WHERE t.name = 'infant formula')
JOIN (SELECT VALUE n FROM n IN c.nutrients WHERE n.nutritionValue > 0 AND n.nutritionValue < 10)
JOIN (SELECT VALUE s FROM s IN c.servings WHERE s.amount > 1)
```

**Плата за единицу:** 22,17 RUs

Предположим, что только один элемент в массиве Tags соответствует фильтру и в нем есть пять элементов для нутриентс и обслуживания массивов. `JOIN` Выражения расширяются до 1 x 1 x 5 x 5 = 25 элементов, а не 1 000 элементов в первом запросе.

## <a name="queries-where-retrieved-document-count-is-equal-to-output-document-count"></a>Запросы, в которых число полученных документов равно числу выходных документов

Если **полученное число документов** приблизительно равно **количеству выходных документов**, обработчику запросов не нужно проверять много ненужных документов. Для многих запросов, таких как использование `TOP` ключевого слова, **полученное число документов** может превысить **число выходных документов** на 1. Вам не нужно беспокоиться об этом.

### <a name="minimize-cross-partition-queries"></a>Сокращение запросов между секциями

Azure Cosmos DB использует [секционирование](partitioning-overview.md) для масштабирования отдельных контейнеров по мере роста единиц запросов и хранилища данных. Каждая физическая секция имеет отдельный и независимый индекс. Если запрос имеет фильтр проверки на равенство, соответствующий ключу секции контейнера, необходимо проверить только индекс соответствующего раздела. Эта оптимизация сокращает общее число запросов, необходимых для запроса.

При наличии большого количества подготовленных протоколов RUs (более 30 000) или большого объема хранимых данных (более чем приблизительно 100 ГБ) у вас, вероятно, будет достаточно большого размера контейнера, чтобы увидеть значительное снижение расходов на запросы к ЕДИНИЦе запросов.

Например, если создать контейнер с ключом секции Фудграуп, то следующие запросы должны будут проверять только одну физическую секцию:

```sql
SELECT *
FROM c
WHERE c.foodGroup = "Soups, Sauces, and Gravies" and c.description = "Mushroom, oyster, raw"
```

Запросы с `IN` фильтром с ключом секции будут проверять только соответствующие физические секции и не будут выключаться из-за:

```sql
SELECT *
FROM c
WHERE c.foodGroup IN("Soups, Sauces, and Gravies", "Vegetables and Vegetable Products") and c.description = "Mushroom, oyster, raw"
```

Запросы, имеющие фильтры диапазонов для ключа секции или не имеющие фильтров по ключу секции, потребуют "перераспределения" и проверки всех результатов в индексе физического раздела:

```sql
SELECT *
FROM c
WHERE c.description = "Mushroom, oyster, raw"
```

```sql
SELECT *
FROM c
WHERE c.foodGroup > "Soups, Sauces, and Gravies" and c.description = "Mushroom, oyster, raw"
```

### <a name="optimize-queries-that-have-filters-on-multiple-properties"></a>Оптимизация запросов с фильтрами для нескольких свойств

Хотя запросы, имеющие фильтры для нескольких свойств, обычно используют индекс диапазона, они будут более эффективны, если их можно будет обрабатывать из составного индекса. Для небольших объемов данных такая оптимизация не окажет существенного влияния. Однако это может быть полезно для больших объемов данных. Для одного составного индекса можно оптимизировать только один фильтр без проверки на равенство. Если в запросе есть несколько фильтров, не имеющих проверки на равенство, выберите один из них, который будет использовать составной индекс. Остальные будут продолжать использовать индексы диапазона. Фильтр без проверки на равенство должен быть определен последним в составном индексе. Дополнительные [сведения о составных индексах](index-policy.md#composite-indexes).

Ниже приведены некоторые примеры запросов, которые можно оптимизировать с помощью составного индекса.

```sql
SELECT *
FROM c
WHERE c.foodGroup = "Vegetables and Vegetable Products" AND c._ts = 1575503264
```

```sql
SELECT *
FROM c
WHERE c.foodGroup = "Vegetables and Vegetable Products" AND c._ts > 1575503264
```

Ниже приведен соответствующий составной индекс:

```json
{  
        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[],
        "compositeIndexes":[  
            [  
                {  
                    "path":"/foodGroup",
                    "order":"ascending"
                },
                {  
                    "path":"/_ts",
                    "order":"ascending"
                }
            ]
        ]
}
```

## <a name="optimizations-that-reduce-query-latency"></a>Оптимизации, снижающие задержку запросов

Во многих случаях оплата за ЕДИНИЦу может быть приемлемой, если задержка запроса по-прежнему слишком высока. В следующих разделах представлен обзор советов по сокращению задержки запросов. Если один и тот же запрос выполняется несколько раз для одного и того же набора данных, каждый раз будет взиматься плата за ЕДИНИЦу. Однако задержка запросов может различаться при выполнении запросов.

### <a name="improve-proximity"></a>Повышение близости

Запросы, которые выполняются из разных регионов, чем учетная запись Azure Cosmos DB, будут иметь большую задержку, чем если бы они работали в одном регионе. Например, если вы выполняете код на настольном компьютере, следует рассчитывать на то, что задержка не превышает десятки или сотни миллисекунд (или больше), чем если бы запрос поступил с виртуальной машины в том же регионе Azure, что и Azure Cosmos DB. Вы можете просто [глобально распределить данные в Azure Cosmos DB](distribute-data-globally.md) , чтобы данные можно было ближе к вашему приложению.

### <a name="increase-provisioned-throughput"></a>Увеличение подготовленной пропускной способности

В Azure Cosmos DB подготовленная пропускная способность измеряется в единицах запроса (RUs). Представьте, что у вас есть запрос, использующий 5-кратную пропускную способность. Например, если вы подготавливаете 1 000 RUs, вы сможете выполнить запрос 200 раз в секунду. Если вы попытались выполнить запрос при недостаточной пропускной способности, Azure Cosmos DB возвращать ошибку HTTP 429. Любой из текущих пакетов SDK для API ядра (SQL) будет автоматически повторять этот запрос после ожидания в течение короткого периода времени. Регулируемые запросы занимают больше времени, поэтому увеличение подготовленной пропускной способности может повысить задержку запросов. Можно наблюдать за [общим числом регулируемых запросов](use-metrics.md#understand-how-many-requests-are-succeeding-or-causing-errors) в колонке **метрики** портал Azure.

### <a name="increase-maxconcurrency"></a>Увеличить Максконкурренци

Параллельные запросы работают, запрашивая несколько секций параллельно. Но данные из отдельной секционированной коллекции извлекаться последовательно по отношению к запросу. Таким образом, если задать для Максконкурренци количество секций, то у вас будет лучший шанс достижения наиболее возможного запроса, при условии, что все остальные системные условия останутся прежними. Если число секций неизвестно, можно задать для Максконкурренци (или Максдегрисофпараллелисм в более старых версиях пакета SDK) большое значение. В качестве максимальной степени параллелизма система выберет минимальное значение (число секций, предоставленных пользователем входных данных).

### <a name="increase-maxbuffereditemcount"></a>Увеличить MaxBufferedItemCount

Запросы предназначены для предварительной выборки, пока текущий пакет результатов обрабатывается клиентом. Предварительная выборка помогает повысить общую задержку запроса. Параметр MaxBufferedItemCount ограничивает количество предварительно выбранных результатов. Если присвоить этому параметру ожидаемое число возвращаемых результатов (или большее число), запрос может получить наибольшее преимущество от предварительной выборки. Если установить это значение равным-1, система автоматически определит количество элементов для буферизации.

## <a name="next-steps"></a>Дальнейшие шаги
Ознакомьтесь со следующими статьями, чтобы получить сведения о том, как измерять число получателей для каждого запроса, получать статистику выполнения для настройки запросов и многое другое.

* [Получение метрик выполнения запросов SQL с помощью пакета SDK для .NET](profile-sql-api-query.md)
* [Настройка производительности запросов в Azure Cosmos DB](sql-api-sql-query-metrics.md)
* [Советы по повышению производительности при использовании пакета SDK для .NET](performance-tips.md)
