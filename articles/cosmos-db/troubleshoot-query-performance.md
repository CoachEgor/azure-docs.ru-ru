---
title: Устранение проблем с запросами при использовании Azure Cosmos DB
description: Узнайте, как определять, диагностировать и устранять неполадки Azure Cosmos DB запросов SQL.
author: timsander1
ms.service: cosmos-db
ms.topic: troubleshooting
ms.date: 02/10/2020
ms.author: tisande
ms.subservice: cosmosdb-sql
ms.reviewer: sngun
ms.openlocfilehash: 34f5de01df72b48d275448e028ab0f8cb71e51f8
ms.sourcegitcommit: f718b98dfe37fc6599d3a2de3d70c168e29d5156
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77132069"
---
# <a name="troubleshoot-query-issues-when-using-azure-cosmos-db"></a>Устранение проблем с запросами при использовании Azure Cosmos DB

В этой статье рассматривается общий рекомендуемый подход для устранения неполадок запросов в Azure Cosmos DB. Хотя шаги, описанные в этом документе, не следует рассматривать как «Catch All» для потенциальных проблем с запросами, мы включили наиболее распространенные советы по повышению производительности. Этот документ следует использовать в качестве начального места для устранения недорогих или ресурсоемких запросов в API-интерфейсе Azure Cosmos DB Core (SQL). Кроме того, [журналы диагностики](cosmosdb-monitor-resource-logs.md) можно использовать для обнаружения длительных запросов или использования значительных объемов пропускной способности.

Оптимизацию запросов можно разбить на категории в Azure Cosmos DB: оптимизации, уменьшающие единицу запроса (RU) для запроса и оптимизации, которые просто сокращают задержку. Уменьшая количество единиц запроса, вы также сможете уменьшить задержку.

В этом документе будут использоваться примеры, которые можно создать повторно с помощью набора данных [информации питании](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) .

### <a name="obtaining-query-metrics"></a>Получение метрик запроса:

При оптимизации запроса в Azure Cosmos DB первым шагом всегда будет [Получение метрик запроса](profile-sql-api-query.md) для запроса. Они также доступны в портал Azure, как показано ниже.

[![получения метрик запроса](./media/troubleshoot-query-performance/obtain-query-metrics.png)](./media/troubleshoot-query-performance/obtain-query-metrics.png#lightbox)

После получения метрик запроса Сравните полученное число документов с количеством выходных документов для запроса. Используйте это сравнение, чтобы указать соответствующие разделы для ссылки ниже.

Полученное число документов — это количество документов, необходимых для загрузки запроса. Число выходных документов — это количество документов, которые были необходимы для результатов запроса. Если полученное число документов значительно превышает число выходных документов, то существовала хотя бы одна часть запроса, которая не смогла использовать индекс и требуется для проверки.

Вы можете обратиться к приведенному ниже разделу, чтобы получить представление о оптимизированных для вашего сценариях оптимизациях запросов.

### <a name="querys-ru-charge-is-too-high"></a>Плата за ЕДИНИЦу запроса слишком высока

#### <a name="retrieved-document-count-is-significantly-greater-than-output-document-count"></a>Число полученных документов значительно превышает число выходных документов

- [Включить необходимые пути в политику индексирования](#include-necessary-paths-in-the-indexing-policy)

- [Сведения о том, какие системные функции используют индекс](#understand-which-system-functions-utilize-the-index)

- [Запросы с предложением Filter и ORDER BY](#queries-with-both-a-filter-and-an-order-by-clause)

- [Оптимизация выражений объединения с помощью вложенного запроса](#optimize-join-expressions-by-using-a-subquery)

<br>

#### <a name="retrieved-document-count-is-approximately-equal-to-output-document-count"></a>Число полученных документов приблизительно равно числу выходных документов

- [Избегайте запросов между секциями](#avoid-cross-partition-queries)

- [Фильтры для нескольких свойств](#filters-on-multiple-properties)

- [Запросы с предложением Filter и ORDER BY](#queries-with-both-a-filter-and-an-order-by-clause)

<br>

### <a name="querys-ru-charge-is-acceptable-but-latency-is-still-too-high"></a>Плата за ЕДИНИЦу запроса приемлема, но задержка по-прежнему слишком высока

- [Повышение близости](#improve-proximity)

- [Увеличение подготовленной пропускной способности](#increase-provisioned-throughput)

- [Увеличить Максконкурренци](#increase-maxconcurrency)

- [Увеличить MaxBufferedItemCount](#increase-maxbuffereditemcount)

## <a name="queries-where-retrieved-document-count-exceeds-output-document-count"></a>Запросы, в которых количество полученных документов превышает число выходных документов

 Полученное число документов — это количество документов, необходимых для загрузки запроса. Число выходных документов — это количество документов, которые были необходимы для результатов запроса. Если полученное число документов значительно превышает число выходных документов, то существовала хотя бы одна часть запроса, которая не смогла использовать индекс и требуется для проверки.

 Ниже приведен пример запроса сканирования, который не был полностью обработан индексом.

Запрос:

 ```sql
SELECT VALUE c.description
FROM c
WHERE UPPER(c.description) = "BABYFOOD, DESSERT, FRUIT DESSERT, WITHOUT ASCORBIC ACID, JUNIOR"
 ```

Метрики запросов:

```
Retrieved Document Count                 :          60,951
Retrieved Document Size                  :     399,998,938 bytes
Output Document Count                    :               7
Output Document Size                     :             510 bytes
Index Utilization                        :            0.00 %
Total Query Execution Time               :        4,500.34 milliseconds
  Query Preparation Times
    Query Compilation Time               :            0.09 milliseconds
    Logical Plan Build Time              :            0.05 milliseconds
    Physical Plan Build Time             :            0.04 milliseconds
    Query Optimization Time              :            0.01 milliseconds
  Index Lookup Time                      :            0.01 milliseconds
  Document Load Time                     :        4,177.66 milliseconds
  Runtime Execution Times
    Query Engine Times                   :          322.16 milliseconds
    System Function Execution Time       :           85.74 milliseconds
    User-defined Function Execution Time :            0.00 milliseconds
  Document Write Time                    :            0.01 milliseconds
Client Side Metrics
  Retry Count                            :               0
  Request Charge                         :        4,059.95 RUs
```

Полученное число документов (60 951) значительно больше, чем число выходных документов (7), поэтому этот запрос необходим для проверки. В этом случае системная функция [Upper ()](sql-query-upper.md) не использует индекс.

## <a name="include-necessary-paths-in-the-indexing-policy"></a>Включить необходимые пути в политику индексирования

Политика индексирования должна охватывать все свойства, входящие в `WHERE` предложения, `ORDER BY` предложения, `JOIN`и большинство системных функций. Путь, указанный в политике индексации, должен соответствовать свойству в документах JSON (с учетом регистра).

Если выполнить простой запрос к набору данных [информации питании](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) , то при индексировании свойства в предложении `WHERE` будет взиматься более низкая плата за единицу.

### <a name="original"></a>Исходное значение

Запрос:

```sql
SELECT * FROM c WHERE c.description = "Malabar spinach, cooked"
```

Политика индексации:

```json
{
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
        {
            "path": "/*"
        }
    ],
    "excludedPaths": [
        {
            "path": "/description/*"
        }
    ]
}
```

**Плата за единицу:** 409,51

### <a name="optimized"></a>Оптимизирован

Обновленная политика индексирования:

```json
{
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
        {
            "path": "/*"
        }
    ],
    "excludedPaths": []
}
```

**Плата за единицу:** 2,98

Вы можете в любое время добавить дополнительные свойства в политику индексирования, не влияя на доступность или производительность. Если добавить в индекс новое свойство, то в запросах, использующих это свойство, будет немедленно использоваться новый доступный индекс. Во время сборки запроса будет использоваться новый индекс. В результате результаты запроса могут быть непоследовательными, так как выполняется перестроение индекса. Если новое свойство индексируется, запросы, использующие только существующие индексы, не будут затронуты при перестроении индекса. Можно [отслеживать ход преобразования индекса](https://docs.microsoft.com/azure/cosmos-db/how-to-manage-indexing-policy#use-the-net-sdk-v3).

## <a name="understand-which-system-functions-utilize-the-index"></a>Сведения о том, какие системные функции используют индекс

Если выражение может быть преобразовано в диапазон строковых значений, значит оно может использовать индекс. В противном случае у него нет такой возможности.

Вот список строковых функций, которые могут использовать индекс:

- STARTSWITH(str_expr, str_expr);
- LEFT(str_expr, num_expr) = str_expr;
- SUBSTRING(str_expr, num_expr, num_expr) = str_expr, но только если значение first num_expr равно 0.

Некоторые распространенные системные функции, которые не используют индекс и должны загружать каждый документ, приведены ниже:

| **Системная функция**                     | **Идеи для оптимизации**             |
| --------------------------------------- |------------------------------------------------------------ |
| CONTAINS                                | Использование поиска Azure для полнотекстового поиска                        |
| ВЕРХНИЙ ИЛИ НИЖНИЙ                             | Вместо использования системной функции для нормализации данных каждый раз при сравнении следует нормализовать регистр при вставке. Затем запрос, такой как ```SELECT * FROM c WHERE UPPER(c.name) = 'BOB'```, просто преобразуется ```SELECT * FROM c WHERE c.name = 'BOB'``` |
| Математические функции (не статистические выражения) | Если необходимо часто вычислить значение в запросе, рекомендуется сохранить это значение как свойство в документе JSON. |

------

Другие части запроса могут по-прежнему использовать индекс, несмотря на то, что системные функции не используют индекс.

## <a name="queries-with-both-a-filter-and-an-order-by-clause"></a>Запросы с предложением Filter и ORDER BY

Хотя запросы с фильтром и предложением `ORDER BY` обычно используют индекс диапазона, они будут более эффективны, если их можно будет обрабатывать из составного индекса. В дополнение к изменению политики индексации необходимо добавить все свойства составного индекса в предложение `ORDER BY`. Такое изменение запроса обеспечит использование составного индекса.  Вы можете наблюдать за последствиями выполнения запроса к набору данных [информации питании](https://github.com/CosmosDB/labs/blob/master/dotnet/setup/NutritionData.json) .

### <a name="original"></a>Исходное значение

Запрос:

```sql
SELECT * FROM c WHERE c.foodGroup = "Soups, Sauces, and Gravies" ORDER BY c._ts ASC
```

Политика индексации:

```json
{

        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[]
}
```

**Плата за единицу:** 44,28

### <a name="optimized"></a>Оптимизирован

Обновленный запрос (включает в себя оба свойства в предложении `ORDER BY`):

```sql
SELECT * FROM c
WHERE c.foodGroup = “Soups, Sauces, and Gravies”
ORDER BY c.foodGroup, c._ts ASC
```

Обновленная политика индексирования:

```json
{  
        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[],
        "compositeIndexes":[  
            [  
                {  
                    "path":"/foodGroup",
                    "order":"ascending"
        },
                {  
                    "path":"/_ts",
                    "order":"ascending"
                }
            ]
        ]
    }

```

**Плата за единицу:** 8,86

## <a name="optimize-join-expressions-by-using-a-subquery"></a>Оптимизация выражений объединения с помощью вложенного запроса
Вложенные запросы с несколькими значениями могут оптимизировать `JOIN` выражения путем принудительной отправки предикатов после каждого выражения SELECT-many, а не после всех перекрестных соединений в предложении `WHERE`.

Обратите внимание на следующий запрос:

```sql
SELECT Count(1) AS Count
FROM c
JOIN t IN c.tags
JOIN n IN c.nutrients
JOIN s IN c.servings
WHERE t.name = 'infant formula' AND (n.nutritionValue > 0
AND n.nutritionValue < 10) AND s.amount > 1
```

**Плата за единицу:** 167,62

Для этого запроса индекс будет соответствовать любому документу с тегом с именем "новорожденный формула", Нутритионвалуе больше 0 и объемом, превышающим 1. `JOIN` выражение здесь выполняет перекрестное произведение всех элементов тегов, нутриентс и обслуживает массивы для каждого соответствующего документа перед применением фильтра. Затем предложение `WHERE` применит предикат фильтра к каждому `<c, t, n, s>` кортежу.

Например, если в соответствующем документе в каждом из трех массивов было 10 элементов, оно будет расширено до 1 x 10 x 10 x 10 (то есть 1 000) кортежей. С помощью вложенных запросов можно фильтровать соединяемые элементы массива перед присоединением к следующему выражению.

Этот запрос эквивалентен предыдущему, но использует вложенные запросы:

```sql
SELECT Count(1) AS Count
FROM c
JOIN (SELECT VALUE t FROM t IN c.tags WHERE t.name = 'infant formula')
JOIN (SELECT VALUE n FROM n IN c.nutrients WHERE n.nutritionValue > 0 AND n.nutritionValue < 10)
JOIN (SELECT VALUE s FROM s IN c.servings WHERE s.amount > 1)
```

**Плата за единицу:** 22,17

Предположим, что только один элемент в массиве Tags соответствует фильтру, а для нутриентс и обслуживания массивов существует пять элементов. После этого `JOIN` выражения разворачиваются до 1 x 1 x 5 x 5 = 25 элементов, а не 1 000 элементов в первом запросе.

## <a name="queries-where-retrieved-document-count-is-equal-to-output-document-count"></a>Запросы, в которых число полученных документов равно числу выходных документов

Если полученное число документов приблизительно равно числу выходных документов, это означает, что запрос не должен проверять много ненужных документов. Для многих запросов, например тех, которые используют ключевое слово TOP, полученное число документов может превышать число выходных документов на 1. Это не должно быть вызвано проблемой.

## <a name="avoid-cross-partition-queries"></a>Избегайте запросов между секциями

Azure Cosmos DB использует [секционирование](partitioning-overview.md) для масштабирования отдельных контейнеров по мере роста единиц запросов и хранилища данных. Каждая физическая секция имеет отдельный и независимый индекс. Если запрос имеет фильтр проверки на равенство, соответствующий ключу секции в контейнере, необходимо будет только проверить индекс соответствующего раздела. Эта оптимизация сокращает общее количество запросов, необходимых запросу.

При наличии большого количества подготовленных единиц запросов (свыше 30 000) или большого объема хранимых данных (свыше 100 ГБ) у вас, вероятно, будет достаточно большого размера контейнера, чтобы увидеть значительное уменьшение расходов на запросы к ЕДИНИЦе запросов.

Например, если мы создаем контейнер с ключом секции Фудграуп, то в следующих запросах потребуется только проверить одну физическую секцию:

```sql
SELECT * FROM c
WHERE c.foodGroup = "Soups, Sauces, and Gravies" and c.description = "Mushroom, oyster, raw"
```

Эти запросы также оптимизируются путем включения ключа секции в запрос:

```sql
SELECT * FROM c
WHERE c.foodGroup IN("Soups, Sauces, and Gravies", "Vegetables and Vegetable Products") and c.description = "Mushroom, oyster, raw"
```

Запросы, имеющие фильтры диапазонов в ключе секции или не имеющие фильтров по ключу секции, потребуют "перераспределения" и проверки всех результатов в индексе физического раздела.

```sql
SELECT * FROM c
WHERE c.description = "Mushroom, oyster, raw"
```

```sql
SELECT * FROM c
WHERE c.foodGroup > "Soups, Sauces, and Gravies" and c.description = "Mushroom, oyster, raw"
```

## <a name="filters-on-multiple-properties"></a>Фильтры для нескольких свойств

Хотя запросы с фильтрами по нескольким свойствам обычно используют индекс диапазона, они будут более эффективны, если их можно будет обрабатывать из составного индекса. Для небольших объемов данных такая оптимизация не окажет существенного влияния. Однако он может оказаться полезным для больших объемов данных. Для одного составного индекса можно оптимизировать только один фильтр без проверки на равенство. Если в запросе есть несколько фильтров, не имеющих проверки на равенство, следует выбрать один из них, который будет использовать составной индекс. Остаток будет продолжать использовать индексы диапазона. Фильтр без проверки на равенство должен быть определен последним в составном индексе. [Дополнительные сведения о составных индексах](index-policy.md#composite-indexes)

Ниже приведены некоторые примеры запросов, которые можно оптимизировать с помощью составного индекса.

```sql
SELECT * FROM c
WHERE c.foodGroup = "Vegetables and Vegetable Products" AND c._ts = 1575503264
```

```sql
SELECT * FROM c
WHERE c.foodGroup = "Vegetables and Vegetable Products" AND c._ts > 1575503264
```

Ниже приведен соответствующий составной индекс:

```json
{  
        "automatic":true,
        "indexingMode":"Consistent",
        "includedPaths":[  
            {  
                "path":"/*"
            }
        ],
        "excludedPaths":[],
        "compositeIndexes":[  
            [  
                {  
                    "path":"/foodGroup",
                    "order":"ascending"
                },
                {  
                    "path":"/_ts",
                    "order":"ascending"
                }
            ]
        ]
}
```

## <a name="optimizations-that-reduce-query-latency"></a>Оптимизации, снижающие задержку запросов:

Во многих случаях оплата за ЕДИНИЦу может быть приемлемой, но задержка запросов по-прежнему слишком высока. В следующих разделах представлен обзор советов по сокращению задержки запросов. Если один и тот же запрос выполняется несколько раз для одного и того же набора данных, каждый раз будет взиматься плата за ЕДИНИЦу. Однако задержка запросов может различаться при выполнении запросов.

## <a name="improve-proximity"></a>Повышение близости

Запросы, которые выполняются из разных регионов, чем учетная запись Azure Cosmos DB, будут иметь большую задержку, чем если бы они работали в одном регионе. Например, если вы выполняли код на настольном компьютере, то задержка должна быть в десятках или сотнях (или больше) миллисекунд больше, чем если бы запрос поступил с виртуальной машины в том же регионе Azure, что и Azure Cosmos DB. Вы можете просто [глобально распределять данные в Azure Cosmos DB](distribute-data-globally.md) , чтобы данные можно было ближе к вашему приложению.

## <a name="increase-provisioned-throughput"></a>Увеличение подготовленной пропускной способности

В Azure Cosmos DB подготовленная пропускная способность измеряется в единицах запроса (RU). Предположим, что у вас есть запрос, который потребляет 5 единиц пропускной способности. Например, если вы подготавливаете 1 000 RU, то сможете выполнить запрос 200 раз в секунду. При попытке выполнить запрос при недостаточной пропускной способности Azure Cosmos DB возвращать ошибку HTTP 429. Любой из текущих пакетов SDK для API ядра (SQL) будет автоматически повторять этот запрос после ожидания в течение короткого периода. Регулируемые запросы занимают больше времени, поэтому увеличение объема подготовленной пропускной способности может повысить задержку запросов. В колонке метрики портал Azure можно просмотреть [Общее число запросов, регулируемых с регулированием](use-metrics.md#understand-how-many-requests-are-succeeding-or-causing-errors) .

## <a name="increase-maxconcurrency"></a>Увеличить Максконкурренци

Параллельные запросы работают, запрашивая несколько секций параллельно. Однако данные из каждой секционированной коллекции извлекаются в рамках запроса последовательно. Таким образом, Настройка Максконкурренци на количество секций имеет максимальную вероятность достижения наиболее возможного запроса, при условии, что все остальные системные условия остаются неизменными. Если число секций неизвестно, можно установить значение Максконкурренци (или Максдегрисофпараллелисм в более ранних версиях пакета SDK), а система выберет минимальное значение (число секций, предоставленных пользователем входных данных) в качестве максимальной степени параллелизма.

## <a name="increase-maxbuffereditemcount"></a>Увеличить MaxBufferedItemCount

Запросы предназначены для предварительной выборки, пока текущий пакет результатов обрабатывается клиентом. Предварительная выборка способствует общему уменьшению задержки при обработке запроса. Установка MaxBufferedItemCount ограничивает количество предварительно выбранных результатов. Если задать для этого параметра ожидаемое число возвращаемых результатов (или большее число), запрос может получить максимальную пользу от предварительной выборки. Установка этого значения равным-1 позволяет системе автоматически определять количество элементов для буферизации.

## <a name="next-steps"></a>Дальнейшие действия
Дополнительные сведения см. в документах, посвященных измерениям для каждого запроса, получению статистики выполнения для настройки запросов и т. д.

* [Получение метрик выполнения SQL-запросов с помощью пакета SDK для .NET](profile-sql-api-query.md)
* [Настройка производительности запросов в Azure Cosmos DB](sql-api-sql-query-metrics.md)
* [Советы по повышению производительности при использовании пакета SDK для .NET](performance-tips.md)
