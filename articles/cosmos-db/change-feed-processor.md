---
title: Изменение библиотеки процессоров кормов в Azure Cosmos DB
description: Узнайте, как использовать библиотеку процессоров для изменения канала Azure Cosmos DB для чтения ленты изменений, компонентов процессора подачи изменений
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.devlang: dotnet
ms.topic: conceptual
ms.date: 12/03/2019
ms.reviewer: sngun
ms.openlocfilehash: e71b2807595aebeb1f0c8682fde119f4e267e55d
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "78273310"
---
# <a name="change-feed-processor-in-azure-cosmos-db"></a>Обработчик канала изменений в Azure Cosmos DB 

Процессор подачи изменений является частью [Azure Cosmos DB SDK V3.](https://github.com/Azure/azure-cosmos-dotnet-v3) Это упрощает процесс чтения канала изменения и эффективного распределения обработки событий между несколькими потребителями.

Основным преимуществом библиотеки процессоров изменов является ее терпимое поведение, которое обеспечивает "по крайней мере один раз" доставку всех событий в ленте изменений.

## <a name="components-of-the-change-feed-processor"></a>Компоненты процессора подачи изменений

Существует четыре основных компонента реализации процессора подачи изменений: 

1. **Отслеживаемый контейнер** — это контейнер с данными, из которых формируется канал изменений. Любые вставки и обновления в контролируемом контейнере отражаются в канале изменения контейнера.

1. **Контейнер для аренды:** Контейнер аренды действует как хранилище состояния и координирует обработку канала изменения между несколькими работниками. Контейнер аренды может храниться в том же аккаунте, что и контролируемый контейнер, или в отдельном. 

1. **Хозяин:** Хост — это экземпляр приложения, который использует процессор подачи изменений для прослушивания изменений. Несколько экземпляров с одинаковой конфигурацией аренды могут работать параллельно, но каждый экземпляр должен иметь другое **имя экземпляра.** 

1. **Делегат:** Делегат — это код, определяющий, что вы, разработчик, хотите делать с каждой порцией изменений, считывается в процессоре подачи изменений. 

Чтобы лучше разобраться, как взаимодействуют эти четыре элемента обработчика для канала изменений, давайте рассмотрим пример, приведенный на схеме ниже. Контролируемый контейнер хранит документы и использует "Город" в качестве ключа раздела. Мы видим, что ключевые значения раздела распределены в диапазонах, содержащих элементы. Существует два экземпляра хоста, и процессор подачи изменений присваивает каждому экземпляру различные диапазоны ключевых значений раздела для максимального распределения вычислений. Каждый диапазон читается параллельно, и его прогресс поддерживается отдельно от других диапазонов в лизинговом контейнере.

![Пример обработчика канала изменений](./media/change-feed-processor/changefeedprocessor.png)

## <a name="implementing-the-change-feed-processor"></a>Внедрение процессора подачи изменений

Точкой входа всегда является контролируемый контейнер, из экземпляра, `Container` который вы называете: `GetChangeFeedProcessorBuilder`

[!code-csharp[Main](~/samples-cosmosdb-dotnet-change-feed-processor/src/Program.cs?name=DefineProcessor)]

Где первый параметр представляет собой отдельное имя, описывая цель этого процессора, а второе имя — реализация делегата, которая будет обрабатывать изменения. 

Примером делегата может быть:


[!code-csharp[Main](~/samples-cosmosdb-dotnet-change-feed-processor/src/Program.cs?name=Delegate)]

Наконец, вы определяете имя `WithInstanceName` для этого экземпляра процессора `WithLeaseContainer`с и который является контейнером для поддержания состояния аренды с .

Вызов `Build` даст вам экземпляр процессора, который `StartAsync`вы можете начать, позвонив.

## <a name="processing-life-cycle"></a>Обработка жизненного цикла

Нормальный жизненный цикл экземпляра хоста:

1. Прочитайте ленту изменений.
1. Если изменений нет, спите в течение предопределенного `WithPollInterval` количества времени (настраиваемый с в Builder) и перейдите к #1.
1. Если есть изменения, отправьте их **делегату.**
1. Когда делегат **успешно**завершит обработку изменений, обновите магазин аренды с последними обработанными моментами времени и перейдите к #1.

## <a name="error-handling"></a>Обработка ошибок

Процессор подачи изменений устойчив к ошибкам пользовательского кода. Это означает, что если в реализации делегата есть необработанное исключение (шаг #4), обработка потоков этой конкретной партии изменений будет остановлена и будет создан новый поток. Новый поток проверит, что было последним моментом времени, которое имеет магазин аренды для этого диапазона ключевых значений раздела, и перезапустит оттуда, фактически отправив ту же партию изменений делегату. Такое поведение будет продолжаться до тех пор, пока ваш делегат не обработает изменения правильно, и именно по этой причине процессор подачи изменений имеет гарантию "по крайней мере один раз", потому что если код делегата бросает, он будет повторно пытаться эту партию.

## <a name="dynamic-scaling"></a>Динамическое масштабирование

Как уже упоминалось во время введения, процессор подачи изменений может автоматически распределять вычисления по нескольким экземплярам. Вы можете развернуть несколько экземпляров приложения с помощью процессора подачи изменений и воспользоваться им, единственными ключевыми требованиями являются:

1. Все экземпляры должны иметь одинаковую конфигурацию контейнера аренды.
1. Все экземпляры должны иметь одно и то же имя рабочего процесса.
1. Каждый экземпляр должен иметь другое имя экземпляра ().`WithInstanceName`

Если эти три условия применяются, то процессор подачи изменений будет, используя алгоритм равного распределения, распределять все лизинговые договоры в контейнере аренды по всем беговым экземплярам и параллелизировать вычисления. Одна аренда может принадлежать только одному экземпляру в данный момент времени, поэтому максимальное количество экземпляров равно количеству договоров аренды.

Количество экземпляров может увеличиваться и уменьшаться, а процессор подачи изменений динамически корректирует нагрузку, соответственно перераспределяя.

Кроме того, процессор подачи изменений может динамически адаптироваться к масштабу контейнеров из-за увеличения пропускной связи или хранения. Когда ваш контейнер растет, процессор подачи изменений прозрачно обрабатывает эти сценарии, динамично увеличивая аренду и распределяя новые лизинга между существующими экземплярами.

## <a name="change-feed-and-provisioned-throughput"></a>Канал изменений и подготовленная пропускная способность

Вы оплачиваете единицы запросов, так как при перемещении данных в контейнеры Cosmos и из них всегда используются единицы запросов. Плата выставляется за число потребляемых ЕЗ контейнером аренды.

## <a name="additional-resources"></a>Дополнительные ресурсы

* [Azure Cosmos DB](sql-api-sdk-dotnet.md)
* [Примеры использования в GitHub](https://github.com/Azure/azure-cosmos-dotnet-v3/tree/master/Microsoft.Azure.Cosmos.Samples/Usage/ChangeFeed)
* [Дополнительные примеры на GitHub](https://github.com/Azure-Samples/cosmos-dotnet-change-feed-processor)

## <a name="next-steps"></a>Дальнейшие действия

Вы можете продолжить знакомство с обработчиком канала изменений, перейдя к следующим статьям:

* [Работа с поддержкой веб-канала изменений в Azure Cosmos DB](change-feed.md)
* [Как перенести из библиотеки процессоров из меняек](how-to-migrate-from-change-feed-library.md)
* [Использование оценщика канала изменений](how-to-use-change-feed-estimator.md)
* [Время запуска обработчика канала изменений](how-to-configure-change-feed-start-time.md)
