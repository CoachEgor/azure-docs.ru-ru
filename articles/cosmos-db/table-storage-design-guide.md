---
title: Дизайн таблиц Azure Cosmos DB для масштабирования и производительности
description: 'Руководство по проектированию хранилища таблиц Azure: масштабируемые и выполняемые таблицы в хранилище Azure Cosmos DB и Azure Table'
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: conceptual
ms.date: 05/21/2019
author: sakash279
ms.author: akshanka
ms.custom: seodec18
ms.openlocfilehash: 166076d366cbbf7bef24648772beaba9b3a88253
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79246478"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Руководство по проектированию таблиц таблиц для хранения таблицла для хранения таблицы Azure: Масштабируемые и перформативные таблицы

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

При проектировании масштабируемых и производительных таблиц необходимо учитывать ряд факторов, включая затраты. Если вы ранее разрабатывали схемы для реляционных баз данных, вам будет удобнее ознакомиться с этими вопросами. Хотя между хранилищем таблиц Azure и реляционными моделями есть некоторые сходства, также есть много важных различий. Как правило, эти различия приводят к созданию разных вариантов, которые могут показаться пользователям, знакомым с реляционными базами данных, алогичными или неверными, но если разработка выполняется для хранилища NoSQL типа "ключ — значение", например хранилища таблиц, эти различия будут иметь смысл.

Таблица хранения предназначена для поддержки облачных приложений, которые могут содержать миллиарды сущностей ("строки" в терминологии реляционной базы данных) данных, или для наборов данных, которые должны поддерживать большие объемы транзакций. Поэтому необходимо по-другому думать о том, как вы храните данные, и понимать, как работает хранилище таблицы. Хорошо продуманный хранилище данных NoS'L может позволить вашему решению масштабироваться гораздо дальше (и по более низкой цене), чем решение, использующее реляционную базу данных. Данное руководство поможет решить эти задачи.  

## <a name="about-azure-table-storage"></a>О хранении таблицы Azure
В этом разделе освещаются некоторые ключевые особенности хранения таблицы, которые особенно актуальны для проектирования производительности и масштабируемости. Если вы новичок в хранении и таблице Данных Azure, см. Введение в [хранилище Microsoft Azure](../storage/common/storage-introduction.md) и [начало работы с хранилищем таблицы Azure, используя .NET,](table-storage-how-to-use-dotnet.md) прежде чем читать оставшуюся часть этой статьи. Хотя основное внимание в этом руководстве уделяется хранению таблицы, оно включает в себя некоторое обсуждение хранения очереди Azure и хранилища Azure Blob, а также способы их использования вместе с хранилищем таблицва в решении.  

Таблица хранения использует табликовый формат для хранения данных. Согласно стандартной терминологии каждая строка таблицы представляет сущность, а различные свойства этой сущности хранятся в столбцах. Каждая сущность имеет пару ключей, чтобы однозначно идентифицировать его, и столбец метки времени, который хранилище таблицы использует для отслеживания, когда объект был последний обновляемый. Поле метки времени добавляется автоматически, и вы не можете вручную перезаписать метку времени с произвольным значением. Таблица хранения использует эту последнюю модифицированную метку времени (LMT) для управления оптимистической параллелизма.  

> [!NOTE]
> Операции REST API хранения `ETag` таблицы также возвращают значение, полученное из LMT. В этом документе термины ETag и LMT используются взаимозаменяемо, поскольку они относятся к тем же базовым данным.  
> 
> 

В следующем примере показана простая схема таблицы для хранения сущностей сотрудников и отделов. Подобную структуру имеет большинство таблиц, приведенных далее в этом руководстве.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td>Маркетинг</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Маркетинг</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Июнь</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Маркетинг</td>
<td>отдел;</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Маркетинг</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


Пока эта конструкция похожа на таблицу в реляционной базе данных. Ключевыми различиями являются обязательные столбцы и возможность хранения нескольких типов сущностей в одной таблице. Кроме того, каждый из свойств, определяемых пользователем, таких как **FirstName** или **Age,** имеет тип данных, такой как целый ряд или строка, точно так же, как столбец в реляционной базе данных. Однако, в отличие от реляционной базы данных, характер хранения таблицы без схемы означает, что свойство не должно иметь одинаковый тип данных на каждой сущности. Для хранения сложных типов данных в одном свойстве необходимо использовать сериализованный формат, например JSON или XML. Для получения дополнительной [Understanding Table storage data model](https://msdn.microsoft.com/library/azure/dd179338.aspx)информации см.

Ваш выбор `PartitionKey` `RowKey` и имеет основополагающее значение для хорошего дизайна таблицы. Каждая сущность, хранящаяся `PartitionKey` `RowKey`в таблице, должна иметь уникальное сочетание и . Как и в случае с ключами в таблице реляционных баз данных, значения `PartitionKey` и `RowKey` значения индексируются для создания кластерного индекса, который позволяет быстро искать. Хранение таблиц, однако, не создает вторичных индексов, так что это только два индексированных свойства (некоторые из моделей, описанных позже, показывают, как можно обойти это очевидное ограничение).  

Таблица состоит из одного или нескольких разделов, и многие из проектных решений, которые вы делаете, будут вокруг выбора подходящего `PartitionKey` и `RowKey` оптимизации вашего решения. Решение может состоять только из одной таблицы, которая содержит все объекты, организованные в разделы, но обычно решение имеет несколько таблиц. Таблицы помогают вам логически организовать объекты и управлять доступом к данным с помощью списков управления доступом. Можно сбросить всю таблицу с помощью одной операции хранения.  

### <a name="table-partitions"></a>Разделы таблицы
Имя учетной записи, `PartitionKey` имя таблицы и совместное определение раздела в службе хранения, где хранилище таблицы хранит сущность. Помимо того, что разделы являются частью схемы адресации для юридических лиц, они определяют область действия транзакций (см. раздел позже в этой статье, [транзакции группы сущностей)](#entity-group-transactions)и составляют основу масштабов хранения таблицы. Для получения дополнительной информации о разделах [таблицы](../storage/tables/storage-performance-checklist.md)см.  

В хранилище таблицотдельный отдельный узла обслуживает один или несколько полных разделов, а сервис масштабируется динамически балансируя перегородки между узлами. Если узла находится под нагрузкой, хранилище таблицы может разделить диапазон перегородок, обслуживаемых этим узлам, на различные узлы. Когда трафик спадает, хранилище таблицы может объединить диапазоны разделов от тихих узлов обратно в один узлы.  

Для получения дополнительной информации о внутренних деталях хранения таблицы, и в частности, как он управляет разделами, см. [Microsoft Azure Storage: Высокодоступная служба облачного хранения данных с сильной согласованностью.](https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)  

### <a name="entity-group-transactions"></a>Сделки группы сущностей
В таблице хранения, транзакции группы сущностей (EGTs) являются единственным встроенным механизмом для выполнения атомных обновлений в нескольких сущностях. EGT также *называются пакетные транзакции.* EGT могут работать только на сущностях, хранящихся в одном и том же разделе (совместное использование одного и того же ключа раздела в определенной таблице), поэтому в любое время требуется атомное транзакционное поведение в нескольких сущностях, убедитесь, что эти сущности находятся в одном разделе. Это часто является причиной для сохранения нескольких типов сущностей в одной таблице (и раздела) и не использования нескольких таблиц для разных типов сущностей. Одна транзакция группы сущностей может работать с максимум 100 сущностей.  Если вы отправляете несколько одновременных EGT для обработки, важно убедиться, что эти EGT s не работают на сущностях, которые являются общими для EGTs. В противном случае вы рискуете задержать обработку.

Кроме того, применение транзакций группы сущностей приводит к необходимости сопоставить преимущества и недостатки и сделать компромиссный выбор при разработке. Использование большего количества разделов увеличивает масштабируемость приложения, поскольку Azure имеет больше возможностей для балансировки нагрузки в узлах. Но это может ограничить способность приложения выполнять атомные транзакции и поддерживать сильную согласованность данных. Кроме того, следует принять во внимание наличие определенных целевых показателей масштабируемости на уровне раздела, которые могут ограничивать ожидаемую пропускную способность для транзакций на одном узле.

Для получения дополнительной информации о целевых показателях масштабируемости для учетных записей хранения Azure см. [Целевые показатели масштабируемости для стандартных учетных записей хранения.](../storage/common/scalability-targets-standard-account.md) Для получения дополнительной информации о целевых показателях масштабируемости для хранения [таблицы](../storage/tables/scalability-targets.md)см. В последующих разделах данного руководства рассматриваются различные стратегии разработки, упрощающие управление подобными компромиссными решениями, а также описываются оптимальные варианты выбора ключа раздела с учетом конкретных требований клиентского приложения.  

### <a name="capacity-considerations"></a>Рекомендации по емкости
В следующей таблице приведены некоторые ключевые значения, о которых следует знать при проектировании решения для хранения таблицы:  

| Общая емкость учетной записи хранения Azure | 500 TБ |
| --- | --- |
| Количество таблиц в учетной записи хранения Azure |Ограничено только емкостью учетной записи хранилища. |
| Количество разделов в таблице |Ограничено только емкостью учетной записи хранилища. |
| Количество сущностей в разделе |Ограничено только емкостью учетной записи хранилища. |
| Размер отдельной сущности |До 1 МБ, с максимум 255 `PartitionKey`свойствами `RowKey` `Timestamp`(включая, и). |
| Размер`PartitionKey` |Строка размером до 1 КБ. |
| Размер`RowKey` |Строка размером до 1 КБ. |
| Размер транзакции группы сущности |Транзакция может включать не более 100 сущностей, а полезная нагрузка должна быть меньше 4 МБ в размерах. Транзакция группы сущностей может обновлять сущность только один раз. |

Для получения дополнительной информации [см.](https://msdn.microsoft.com/library/azure/dd179338.aspx)  

### <a name="cost-considerations"></a>Рекомендации по стоимости
Хранение таблиц является относительно недорогим, но следует включить смету затрат как для использования емкости, так и количество транзакций в рамках оценки любого решения, использующем хранилище таблицы. Во многих сценариях, однако, хранение денормализации или дублировать данные для того, чтобы повысить производительность или масштабируемость вашего решения является действительным подходом принять. Дополнительные сведения о ценах см. на [странице цен на службу хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).  

## <a name="guidelines-for-table-design"></a>Рекомендации по разработке таблиц
Эти списки обобщают некоторые ключевые принципы, которые следует иметь в виду при проектировании таблиц. Это руководство рассматривает их все более подробно позже. Эти руководящие принципы отличаются от руководящих принципов, которые обычно следуют для реляционной конструкции базы данных.  

Проектирование хранилища таблицы для эффективного *чтения:*

* **Разрабатывайте решения с учетом выполнения запросов в приложениях с большим количеством операций чтения.** При проектировании таблиц подумайте о запросах (особенно чувствительных к задержкам), которые вы запустите, прежде чем думать о том, как обновить объекты. Это позволит создать эффективное и высокопроизводительное решение.  
* **Укажите `PartitionKey` `RowKey` как, так и в запросах.** *Такие точечные запросы* являются наиболее эффективными запросами на хранение таблиц.  
* **Рассмотрите возможность хранения повторяющихся копий сущностей.** Хранение таблиц ы дешевое, поэтому рассмотрите возможность хранения одной и той же сущности несколько раз (с разными ключами), чтобы обеспечить более эффективные запросы.  
* **Рассмотрите возможность денормализации данных.** Таблица хранения дешево, так что рассмотреть вопрос о денормализации ваших данных. Например, храните сущности сводки, чтобы запросы к объединенным данным обращались только к одной сущности.  
* **Используйте значения составного ключа.** Единственные ключи вы `PartitionKey` `RowKey`имеете и . Например, значения составного ключа можно использовать для включения альтернативных путей доступа с ключами к сущностям.  
* **Используйте проекции в запросах.**  С помощью запросов, выбирающих только необходимые поля, можно сократить объем данных, передаваемых по сети.  

Проектирование хранилища таблицы для *эффективной записи:*  

* **Не создавайте горячие перегородки.**  Выбирайте ключи, которые позволяют распределять запросы по нескольким разделам в любой момент времени.  
* **Избегайте пиковых нагрузок по трафику.** Распределите трафик в течение разумного периода времени и избегайте скачков трафика.
* **Не обязательно создавать отдельную таблицу для каждого типа сущности.**  Чтобы выполнять атомарные транзакции с типами сущностей, эти несколько типов сущностей можно хранить в одном разделе одной таблицы.
* **Рассмотрите требуемую максимальную пропускную способность.** Вы должны знать о целевых показателях масштабируемости для хранения таблицы и убедиться, что ваш дизайн не приведет к их превышению.  

Позже в этом руководстве вы увидите примеры, которые претвинули все эти принципы на практике.  

## <a name="design-for-querying"></a>Разработка для запросов
Таблица хранения можно читать интенсивно, писать интенсивно, или сочетание этих двух. В этом разделе рассматривается проектирование для эффективной поддержки считывания. Как правило, схема, поддерживающая операции чтения, также эффективна для операций записи. Тем не менее, есть дополнительные соображения при проектировании для поддержки операций записи. Они обсуждаются в следующем разделе, [Дизайн для изменения данных](#design-for-data-modification).

Хорошей отправной точкой для эффективного чтения данных является вопрос: «Какие запросы потребуется моему приложению для получения необходимых данных?»  

> [!NOTE]
> При хранении таблицы важно, чтобы получить дизайн правильно вперед, потому что это трудно и дорого изменить его позже. Например, в реляционной базе данных часто можно решить проблемы производительности, просто добавив индексы в существующую базу данных. Это не вариант с таблицей хранения.  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>Как ваш `PartitionKey` выбор `RowKey` и влияет на производительность запроса
Следующие примеры предполагают, что хранилище таблицы является хранение сущностей сотрудников со следующей структурой (в большинстве примеров опускаем свойство `Timestamp` для ясности):  

| Имя столбца | Тип данных |
| --- | --- |
| `PartitionKey`(Название департамента) |Строка |
| `RowKey`(Идентификатор сотрудника) |Строка |
| `FirstName` |Строка |
| `LastName` |Строка |
| `Age` |Целое число |
| `EmailAddress` |Строка |

Ниже приведены некоторые общие рекомендации по разработке запросов на хранение таблиц. Синтаксис фильтра, используемый в следующих примерах, — это API хранения данных таблицы. Для получения дополнительной [информации см.](https://msdn.microsoft.com/library/azure/dd179421.aspx)  

* Наиболее эффективным поиском является *точечный запрос,* который рекомендуется для больших объемов поиска или поиска, требующих самой низкой задержки. Такой запрос может использовать индексы для эффективного определения как значения, так `PartitionKey` и `RowKey` значений. Например: `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')`.  
* Вторым лучшим является *диапазон запроса*. Он `PartitionKey`использует, и фильтры на `RowKey` диапазоне значений, чтобы вернуть более чем одного объекта. Значение `PartitionKey` определяет определенный раздел, а `RowKey` значения определяют подмножество сущностей в этом разделе. Например: `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'`.  
* Третьим лучшим является *сканирование перегородки.* Он использует `PartitionKey`, и фильтры на другом неключевом свойстве и может вернуть более одного объекта. Значение `PartitionKey` определяет определенный раздел и значения свойств, выбранное для подмноза сущностей в этом разделе. Например: `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'`.  
* Сканирование *таблицы* не включает `PartitionKey`в себя и является неэффективным, поскольку оно выполняет все разделы, которые составляют таблицу для любых соответствующих сущностей. Он выполняет сканирование таблицы независимо от того, `RowKey`использует ли ваш фильтр . Например: `$filter=LastName eq 'Jones'`.  
* Запросы хранения таблицы Azure, возвращающие несколько сущностей, сортируют их `PartitionKey` и `RowKey` забираются. Чтобы избежать обращения к сущностям `RowKey` в клиенте, выберите наиболее распространенный порядок сортировки. Результаты запроса, возвращенные API таблицы Azure в Azure Cosmos DB, не сортируются по ключу раздела или ключу строки. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от хранилища таблиц Azure?](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior).

Использование **"или"** для указания фильтра, основанного на `RowKey` значениях, приводит к сканированию раздела и не рассматривается как запрос диапазона. Поэтому избегайте запросов, которые используют `$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')`фильтры, такие как: .  

Примеры кода на стороне клиента, использующем библиотеку клиентов хранения для выполнения эффективных запросов, см.:  

* [Выполнить точечный запрос с помощью библиотеки клиентов хранения](#run-a-point-query-by-using-the-storage-client-library)
* [Извлекать несколько сущностей с помощью LIN](#retrieve-multiple-entities-by-using-linq)
* [Проекция на стороне сервера](#server-side-projection)  

Примеры кода на стороне клиента, который может обрабатывать несколько типов сущностей, хранящихся в одной таблице, см. в следующем разделе:  

* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>Выберите подходящий`PartitionKey`
Ваш выбор `PartitionKey` должен сбалансировать необходимость обеспечения использования ЭГТ (для обеспечения согласованности) с требованием распределить объекты по нескольким разделам (для обеспечения масштабируемого решения).  

С одной стороны, вы можете хранить все объекты в одном разделе. Но это может ограничить масштабируемость решения и не позволит хранилищу таблицы загружать балансзапросы. С другой стороны, можно хранить одну сущность на раздел. Это очень масштабируемо и позволяет таблице хранения для загрузки баланса запросов, но предотвращает использование транзакций группы сущностей.  

Идеал `PartitionKey` позволяет использовать эффективные запросы и имеет достаточные разделы, чтобы гарантировать масштабируемое решение. Как правило, вы обнаружите, что ваши сущности будут иметь подходящее свойство, которое распределяет ваши сущности по достаточным разделам.

> [!NOTE]
> Например, в системе, которая хранит информацию о пользователях или сотрудниках, `UserID` может быть хорошим `PartitionKey`. Возможно, у вас есть `UserID` несколько сущностей, которые используют определенный элемент в качестве ключа раздела. Каждая сущность, которая хранит данные о пользователе, сгруппирована в единую раздел. Эти сущности доступны через ЭГТ, в то же время будучи высоко масштабируемыми.
> 
> 

В выборе есть дополнительные `PartitionKey` соображения, связанные с тем, как вставлять, обновлять и удалять объекты. Для получения дополнительной информации, см [Дизайн для изменения данных](#design-for-data-modification) позже в этой статье.  

### <a name="optimize-queries-for-table-storage"></a>Оптимизация запросов для хранения таблиц
Таблица хранения автоматически индексирует `PartitionKey` ваши `RowKey` сущности, используя и значения в одном кластерном индексе. Это является причиной того, что точечные запросы являются наиболее эффективными в использовании. Тем не менее, нет никаких индексов, кроме `PartitionKey` `RowKey`индекса на кластерном индексе на и .

Многие разработки должны соответствовать требованиям по включению поиска сущностей на основании нескольких условий. Например, поиск сущностей сотрудников на основе электронной почты, идентификатора сотрудника или фамилии. Следующие шаблоны в [шаблонах проектирования таблицы](#table-design-patterns) раздела таблицы касаются этих типов требований. Шаблоны также описывают способы работы над тем, что хранилище таблицы не предоставляет вторичных индексов.  

* [Шаблон вторичного индекса внутри раздела:](#intra-partition-secondary-index-pattern)Храните несколько `RowKey` копий каждой сущности с помощью различных значений (в одном и том же разделе). Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.  
* [Шаблон межраздельного вторичного индекса:](#inter-partition-secondary-index-pattern)Храните несколько `RowKey` копий каждой сущности, используя различные значения в отдельных разделах или в отдельных таблицах. Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.  
* [Шаблон сущностей индекса](#index-entities-pattern): Поддержание сущностей индекса для обеспечения эффективного поиска, возвращающие списки сущностей.  

### <a name="sort-data-in-table-storage"></a>Сортировка данных в таблице хранения

Таблица хранения возвращает результаты запроса отсортированы в порядке возрастания, на `PartitionKey` основе, а затем `RowKey`.

> [!NOTE]
> Результаты запроса, возвращенные API таблицы Azure в Azure Cosmos DB, не сортируются по ключу раздела или ключу строки. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от хранилища таблиц Azure?](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior).

Ключи в хранилище таблицы являются значениями строк. Чтобы обеспечить правильную сортировку числовых значений, следует преобразовать их в фиксированную длину и наложить на них нуля. Например, если значение идентификатора сотрудника, используемее в качестве `RowKey` значения целых, следует преобразовать идентификатор сотрудника **123** до **00000123.** 

Многие приложения предъявляют требования к использованию данных, отсортированных в разных порядках. Например, сотрудники могут быть отсортированы по имена или по дате присоединения. Следующие шаблоны в [шаблонах проектирования таблицы](#table-design-patterns) раздела рассматривают способ ы чередуйте заказы сортировки для сущностей:  

* [Шаблон вторичного индекса внутри раздела:](#intra-partition-secondary-index-pattern)Храните несколько `RowKey` копий каждой сущности с помощью различных значений (в одном и том же разделе). Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.  
* [Шаблон межраздельного вторичного индекса:](#inter-partition-secondary-index-pattern)Храните несколько `RowKey` копий каждой сущности, используя различные значения в отдельных разделах в отдельных таблицах. Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.
* [Шаблон хвоста входа](#log-tail-pattern): Извлекать *n* сущности совсем `RowKey` недавно добавленных в раздел, с помощью значения, которое сортирует в обратном порядке даты и времени.  

## <a name="design-for-data-modification"></a>Разработка для изменения данных
В этом разделе рассматриваются вопросы разработки для оптимизации операций вставки, обновления и удаления. В некоторых случаях необходимо оценить компромисс между проектами, которые оптимизируют для запросов против конструкций, которые оптимизируют для изменения данных. Эта оценка аналогична тому, что вы делаете в проектах реляционных баз данных (хотя методы управления дизайном компромиссов отличаются в реляционной базе данных). Шаблоны [проектирования раздела Таблица](#table-design-patterns) описывает некоторые подробные шаблоны проектирования для хранения таблицы и освещают некоторые из этих компромиссов. На практике вы обнаружите, что многие проекты, оптимизированные для объектов запросов, также хорошо работают для изменения сущностей.  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>Оптимизация производительности операций вставки, обновления и удаления
Чтобы обновить или удалить объект, вы должны быть `PartitionKey` в `RowKey` состоянии идентифицировать его с помощью и значения. В этом отношении `PartitionKey` ваш `RowKey` выбор и для изменения сущностей должны следовать аналогичным критериям, чтобы ваш выбор для поддержки точечных запросов. Необходимо максимально эффективно идентифицировать объекты. Вы не хотите использовать неэффективный раздел или сканирование таблицы, чтобы найти `PartitionKey` `RowKey` объект, чтобы обнаружить и значения, необходимые для обновления или удаления.  

Следующие шаблоны в [шаблонах проектирования таблицы](#table-design-patterns) раздела «Таблица» направлены на оптимизацию производительности операций вставки, обновления и удаления:  

* [Рисунок удаления большого объема:](#high-volume-delete-pattern)Включить удаление большого объема сущностей путем хранения всех сущностей для одновременного удаления в своей отдельной таблице. Вы удаляете объекты, удаляя таблицу.  
* [Шаблон серии данных:](#data-series-pattern)Храните полные ряды данных в одном объекте, чтобы свести к минимуму количество запросов, которые вы делаете.  
* [Широкий шаблон сущностей](#wide-entities-pattern): Используйте несколько физических сущностей для хранения логических сущностей с более чем 252 свойствами.  
* [Рисунок больших сущностей:](#large-entities-pattern)Используйте хранилище каплей для хранения больших значений свойств.  

### <a name="ensure-consistency-in-your-stored-entities"></a>Обеспечение согласованности хранимых сущностей
Другим фактором, который влияет на выбор ключей для оптимизации изменения данных, является обеспечение согласованности с помощью атомарных операций. Транзакции группы сущностей можно использовать только для работы с сущностями, хранящимися в одном разделе.  

Следующие шаблоны в [шаблонах проектирования таблицы](#table-design-patterns) раздела таблицы касаются управления согласованностью:  

* [Шаблон вторичного индекса внутри раздела:](#intra-partition-secondary-index-pattern)Храните несколько `RowKey` копий каждой сущности с помощью различных значений (в одном и том же разделе). Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.  
* [Шаблон межраздельного вторичного индекса:](#inter-partition-secondary-index-pattern)Храните несколько `RowKey` копий каждой сущности, используя различные значения в отдельных разделах или в отдельных таблицах. Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.  
* [В конечном итоге согласованный шаблон транзакций:](#eventually-consistent-transactions-pattern)Включить последовательное поведение через границы раздела или границы системы хранения, используя очереди Azure.
* [Шаблон сущностей индекса](#index-entities-pattern): Поддержание сущностей индекса для обеспечения эффективного поиска, возвращающие списки сущностей.  
* [Шаблон денормализации:](#denormalization-pattern)Объедините связанные данные в одну сущность, чтобы вы могли получить все данные, необходимые с помощью одного точечного запроса.  
* [Шаблон серии данных:](#data-series-pattern)Храните полные ряды данных в одной сущности, чтобы свести к минимуму количество запросов, которые вы делаете.  

Для получения дополнительной информации [в](#entity-group-transactions) этой статье см.  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>Использование эффективных запросов в разработке для эффективных изменений
Во многих случаях разработка эффективных запросов способствует эффективным изменениям. Однако в каждом конкретном случае всегда следует проверять, так ли это. Некоторые шаблоны в [шаблонах проектирования таблицы](#table-design-patterns) раздела четко оценивают компромиссы между запросами и изменением сущностей, и всегда следует учитывать количество каждого типа операций.  

Следующие шаблоны в [шаблонах проектирования таблицы раздела «Таблица»](#table-design-patterns) касаются компромиссов между проектированием эффективных запросов и проектированием для эффективной модификации данных:  

* [Соединение шаблона:](#compound-key-pattern) `RowKey` Используйте значения соединения, чтобы клиент мог искать связанные данные с помощью одного точечного запроса.  
* [Шаблон хвоста входа](#log-tail-pattern): Извлекать *n* сущности совсем `RowKey` недавно добавленных в раздел, с помощью значения, которое сортирует в обратном порядке даты и времени.  

## <a name="encrypt-table-data"></a>Шифрование данных таблиц
Клиентская библиотека .NET Azure Storage поддерживает шифрование свойств сущности строки для вставки и замены операций. Зашифрованные строки хранятся в службе как двоичные свойства, и они преобразуются обратно в строки после расшифровки.    

Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Либо укажите `EncryptProperty` атрибут (для объектов `TableEntity`POCO, которые вытекают из), или укажите разрешитель шифрования в вариантах запроса. Разрешитель шифрования — это делегат, который берет ключ раздела, ключ строки и имя свойства и возвращает Boolean, указывающий, следует ли шифровать это свойство. Во время шифрования библиотека клиента использует эту информацию, чтобы решить, следует ли шифровать свойство при записи в провод. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если X, а затем шифровать свойства A; в противном случае шифровать свойства A и B.) Нет необходимости предоставлять эту информацию при чтении или запросе сущностей.

Слияние в настоящее время не поддерживается. Поскольку подмножество свойств могло быть зашифровано ранее с помощью другого ключа, простое слияние новых свойств и обновление метаданных приведет к потере данных. Слияние либо требует принятия дополнительных вызовов службы для чтения уже существующей сущности из службы, или с помощью нового ключа на свойство. Ни один из них не подходит по причинам производительности.     

Для получения информации о шифровании данных таблицы см. [шифрование на стороне клиента и хранилище ключей Azure для Microsoft Azure Storage.](../storage/common/storage-client-side-encryption.md)  

## <a name="model-relationships"></a>Модельные отношения
Построение модели предметной области является одним из ключевых этапов при разработке комплексных систем. Как правило, процесс моделирования используется для определения сущностей и взаимосвязей между ними, как способ понять область бизнеса и проинформировать дизайн вашей системы. В этом разделе основное внимание уделяется тому, как можно перевести некоторые из общих типов отношений, найденных в моделях доменов, в проекты для хранения таблицы. Процесс отображения от логической модели данных к физической модели данных на основе НоСЗЛ отличается от той, которая используется при проектировании реляционной базы данных. Дизайн реляционных баз данных обычно предполагает процесс нормализации данных, оптимизированный для минимизации избыточности. Такая конструкция также предполагает декларативную возможность запроса, которая абстрагирует реализацию работы базы данных.  

### <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения "один-ко-многим" между бизнес-объектами являются распространенными. Например, в одном отделе работает много сотрудников. Существует несколько способов реализации взаимосвязей «один к много» в хранилище таблиц, каждый из которых имеет плюсы и минусы, которые могут иметь отношение к конкретному сценарию.  

Рассмотрим пример крупной многонациональной корпорации с десятками тысяч отделов и сотрудников. Каждый отдел имеет много сотрудников, и каждый сотрудник связан с одним конкретным отделом. Один из подходов заключается в хранении отдельных отделов и организаций, таких как:  

![Графика, показывающая сущность отдела и сущность сотрудника][1]

Этот пример показывает неявную связь между типами `PartitionKey` между типами, основанную на значении. В каждом отделе может работать много сотрудников.  

В этом примере также показана сущность отдела и связанные сущности сотрудников в одном разделе. Можно использовать различные разделы, таблицы или даже учетные записи хранения для различных типов сущностей.  

Альтернативный подход заключается в денормализации ваших данных и хранении только сотрудников с денормализации данных отдела, как показано в следующем примере. В данном конкретном сценарии этот денормализованный подход может оказаться не лучшим, если у вас есть требование изменить детали руководителя отдела. Для этого необходимо обновить каждого сотрудника отдела.  

![Графика сущности сотрудника][2]

Дополнительные сведения см. в разделе [Шаблон денормализации](#denormalization-pattern).  

В следующей таблице кратко излагаются плюсы и минусы каждого из подходов к хранению сотрудников и отделов, которые имеют отношения между собой один к многим. Вы также должны рассмотреть, как часто вы ожидаете выполнять различные операции. Может быть приемлемым иметь конструкцию, которая включает в себя дорогостоящую операцию, если эта операция происходит нечасто.  

<table>
<tr>
<th>Подход</th>
<th>Плюсы</th>
<th>Минусы</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Если требуется изменять сущность отдела при каждом обновлении, вставке или удалении сущности сотрудника, в целях обеспечения согласованности можно использовать транзакции группы сущностей. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Возможно, вам потребуется получить как сотрудника, так и подразделение отдела для некоторых действий клиента.</li>
<li>Операции хранения выполняются в одном разделе. При больших объемах транзакций это может привести к посеву доступа.</li>
<li>Вы не можете перевести сотрудника в новый отдел с помощью EGT.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы или учетные записи хранения</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>При больших объемах транзакций это может помочь распределить нагрузку по большему объему разделов.</li>
</ul>
</td>
<td>
<ul>
<li>Возможно, вам потребуется получить как сотрудника, так и подразделение отдела для некоторых действий клиента.</li>
<li>Вы не можете использовать EGT для поддержания согласованности при обновлении/вставке/удалении сотрудника и обновлении отдела. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Вы не можете перевести сотрудника в новый отдел с помощью EGT.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Все необходимые данные можно извлечь с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Это может быть дорого, чтобы поддерживать согласованность, если вам нужно обновить информацию отдела (это потребует обновления всех сотрудников в отделе).</li>
</ul>
</td>
</tr>
</table>

Как вы выбираете среди этих вариантов, и какие из плюсов и минусов являются наиболее значительными, зависит от ваших конкретных сценариев приложения. Например, как часто вы изменяете сущности отделов? Нужны ли все запросы сотрудников дополнительной ведомственной информации? Насколько вы близки к ограничениям масштабируемости в ваших разделах или учетной записи хранилища?  

### <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
Модели доменов могут включать отношения один на один между сущностями. Если вам необходимо реализовать отношения один на один в хранилище таблицы, необходимо также выбрать, как связать две связанные сущности, когда вам нужно получить их обоих. Эта ссылка может быть либо неявной, основанной на конвенции в ключевых значениях, либо явной, путем хранения ссылки в виде `PartitionKey` и `RowKey` значений в каждой сущности с связанной с ней сущностью. Сведения о необходимости хранения связанных сущностей в одном разделе см. в разделе [Отношения "один-ко-многим"](#one-to-many-relationships).  

Существуют также соображения реализации, которые могут привести вас к реализации отношений один на один в таблице хранения:  

* Обработка крупных сущностей (для получения дополнительной информации см. [шаблон Больших сущностей).](#large-entities-pattern)  
* Реализация элементов управления доступом (для получения дополнительной информации [см. Контроль ный доступ с общими подписями доступа).](#control-access-with-shared-access-signatures)  

### <a name="join-in-the-client"></a>Присоединение клиента
Хотя существуют способы моделирования взаимосвязей в хранилище таблицы, не забывайте, что двумя основными причинами использования хранилища таблиц являются масштабируемость и производительность. Если вы обнаружите, что моделируете множество взаимосвязей, которые ставят под угрозу производительность и масштабируемость вашего решения, вы должны спросить себя, нужно ли встраивать все отношения данных в дизайн таблицы. Возможно, вы сможете упростить дизайн и повысить масштабируемость и производительность решения, если позволите клиенту выполнять любые необходимые соединения.  

Например, если у вас есть небольшие таблицы, содержащие данные, которые не часто меняются, можно получить эти данные один раз и кэшировать их на клиенте. Это позволит избежать повторяющихся циклические операций по извлечению одних и тех же данных. В приведенных в этом руководстве примерах набор отделов в небольшой организации, скорее всего, будет небольшим и изменяется нечасто. Это делает его хорошим кандидатом для данных, которые клиентское приложение может загрузить один раз и кэш в качестве данных поиска.  

### <a name="inheritance-relationships"></a>Отношения наследования
Если приложение клиента использует набор классов, которые являются частью отношений наследования, чтобы представлять бизнес-сущности, вы можете легко сохранить эти сущности в таблице хранения. Например, в клиентском приложении может быть определен `Person` следующий набор классов, где находится абстрактный класс.

![Диаграмма отношений наследования][3]

Можно сохранить экземпляры двух конкретных классов в таблице `Person` хранения с помощью одной таблицы. Используйте сущности, которые выглядят следующим образом:  

![Графика, показывающая сущность клиента и сущность сотрудника][4]

Более подробную информацию о работе с несколькими типами сущностей в одной и той же таблице в коде клиента можно узнать позже в этом руководстве по -рула [Work with неоднородные типы сущности.](#work-with-heterogeneous-entity-types) Там приводятся примеры определения типа сущности в клиентском коде.  

## <a name="table-design-patterns"></a>Шаблоны для разработки таблиц
В предыдущих разделах вы узнали, как оптимизировать дизайн таблицы как для извлечения данных сущности с помощью запросов, так и для вставки, обновления и удаляния данных сущности. В этом разделе описаны некоторые шаблоны, подходящие для использования в таблице хранения. Кроме того, вы увидите, как вы можете практически решить некоторые вопросы и компромиссы, поднятые ранее в этом руководстве. На следующей диаграмме кратко излагаются взаимосвязи между различными шаблонами:  

![Диаграмма шаблонов проектирования таблиц][5]

Карта шаблонов выделяет некоторые связи между шаблонами (синими) и антишаблонами (оранжевыми), которые описаны в данном руководстве. Безусловно, существует множество других стоящих внимания шаблонов. Например, одним из ключевых сценариев хранения таблиц является использование [материализованного шаблона представления](https://msdn.microsoft.com/library/azure/dn589782.aspx) из шаблона [сегрегации ответственности запроса командного запроса.](https://msdn.microsoft.com/library/azure/jj554200.aspx)  

### <a name="intra-partition-secondary-index-pattern"></a>Шаблон вторичного индекса внутри раздела
Храните несколько копий каждой сущности с помощью различных `RowKey` значений (в одном и том же разделе). Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений. Обновления между копиями могут быть согласованы с помощью EGT.  

#### <a name="context-and-problem"></a>Контекст и проблема
Таблица хранения автоматически индексирует `PartitionKey` `RowKey` сущности с помощью и значения. Это позволяет клиенту приложения эффективно извлекать объект, используя эти значения. Например, используя следующую структуру таблицы, клиентское приложение может использовать точечный запрос для получения `PartitionKey` отдельной организации сотрудника, используя имя отдела и идентификатор сотрудника (и значения). `RowKey` Клиент также может извлекать сущности, отсортированные по идентификатору сотрудника в каждом отделе.

![Графика сущности сотрудника][6]

Если вы также хотите найти сущность сотрудника на основе стоимости другого свойства, например адреса электронной почты, необходимо использовать менее эффективное сканирование раздела, чтобы найти совпадение. Это связано с тем, что хранилище таблицы не предоставляет вторичных индексов. Кроме того, нет возможности запросить список сотрудников, отсортированных в другом порядке, чем `RowKey` заказ.  

#### <a name="solution"></a>Решение
Чтобы обойти отсутствие вторичных индексов, можно хранить несколько копий каждой `RowKey` сущности, при этом каждая копия используется с разным значением. При хранении сущности со следующими структурами можно эффективно получать сущности сотрудников на основе адреса электронной почты или идентификатора сотрудника. Префикс значения `RowKey`для, `empid_` `email_` и позволяют запросить для одного сотрудника, или ряд сотрудников, используя ряд адресов электронной почты или идентификаторов сотрудников.  

![Графическое отображение сущности сотрудника с различными значениями RowKey][7]

Следующие два критерия фильтра (один из них, идентификатор сотрудника, и один по адресу электронной почты) указывают на точечные запросы:  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

При запросе для целого ряда организаций сотрудников можно указать диапазон, отсортированный в порядке идентификатора сотрудника, или диапазон, отсортированный в заказе адреса электронной почты. Запрос для сущностей с соответствующей `RowKey`приставкой в .  

* Чтобы найти всех сотрудников отдела продаж с идентификатором сотрудника в диапазоне 000100 до 000199, используйте: $filter (PartitionKey eq 'Sales') и (RowKey ge 'empid_000100') и (RowKey le 'empid_000199')  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, начиная с буквы "а", используйте: $filter "(PartitionKey eq 'Sales') и (RowKey ge 'email_a') и (RowKey lt 'email_b')  
  
Синтаксис фильтра, используемый в предыдущих примерах, — это API хранения данных таблицы. Для получения дополнительной [информации см.](https://msdn.microsoft.com/library/azure/dd179421.aspx)  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Хранение таблиц является относительно дешевым в использовании, поэтому затраты на хранение дубликатов данных не должны быть серьезной проблемой. Тем не менее, вы всегда должны оценивать стоимость вашего проектирования на основе ожидаемых требований к хранению, и только добавить дубликаты для поддержки запросов клиентского приложения будет работать.  
* Поскольку объекты вторичного индекса хранятся в том же разделении, что и исходные объекты, убедитесь, что вы не превысите целевые показатели масштабируемости для отдельного раздела.  
* Чтобы обеспечить согласованность повторяющихся сущностей, можно воспользоваться транзакциями группы сущностей (EGT) для автоматического обновления двух копий сущности. Это означает, что все копии сущности необходимо хранить в одном разделе. Для получения дополнительной информации [см.](#entity-group-transactions)  
* Значение, используемое `RowKey` для объекта, должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Закладка численных значений в `RowKey` (например, идентификатор сотрудника 000223) позволяет правильно сортировать и фильтровать на основе верхних и нижних границ.  
* Вам не обязательно дублировать все свойства вашей сущности. Например, если запросы, которые ищут объекты, используя `RowKey` адрес электронной почты в возрасте сотрудника, никогда не нужны, эти сущности могут иметь следующую структуру:

  ![Графика сущности сотрудника][8]

* Как правило, лучше хранить дубликаты данных и гарантировать, что вы можете получить все данные, необходимые с помощью одного запроса, чем использовать один запрос для поиска сущности, а другой для поиска необходимых данных.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон в следующих случаях:

- Клиентское приложение должно извлекать объекты с помощью различных ключей.
- Клиенту необходимо извлекать объекты в различных заказах.
- Вы можете определить каждую сущность, используя различные уникальные значения.

Однако убедитесь, что при выполнении поиска сущности с помощью различных `RowKey` значений вы не превысите пределы масштабируемости разделов.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон вторичного индекса в разных разделах;](#inter-partition-secondary-index-pattern)
* [Шаблон составного ключа;](#compound-key-pattern)
* [Сделки группы сущностей](#entity-group-transactions)
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>Шаблон вторичного индекса в разных разделах
Храните несколько копий каждой сущности, используя различные `RowKey` значения в отдельных разделах или в отдельных таблицах. Это позволяет быстро и эффективно искать и чередовать `RowKey` заказы сортировки с помощью различных значений.  

#### <a name="context-and-problem"></a>Контекст и проблема
Таблица хранения автоматически индексирует `PartitionKey` `RowKey` сущности с помощью и значения. Это позволяет клиенту приложения эффективно извлекать объект, используя эти значения. Например, используя следующую структуру таблицы, клиентское приложение может использовать точечный запрос для получения `PartitionKey` отдельной организации сотрудника, используя имя отдела и идентификатор сотрудника (и значения). `RowKey` Клиент также может извлекать сущности, отсортированные по идентификатору сотрудника в каждом отделе.  

![Графика сущности сотрудника][9]

Чтобы найти сущность сотрудника на основе другого свойства (например, адрес электронной почты), необходимо использовать менее эффективную функцию просмотра раздела. Это связано с тем, что хранилище таблицы не предоставляет вторичных индексов. Кроме того, нет возможности запросить список сотрудников, отсортированных в другом порядке, чем `RowKey` заказ.  

Вы ожидаете большой объем транзакций против этих сущностей и хотите свести к минимуму риск того, что скорость хранения таблицы ограничит ваш клиент.  

#### <a name="solution"></a>Решение
Чтобы обойти отсутствие вторичных индексов, можно хранить несколько копий каждой `PartitionKey` `RowKey` сущности, каждая из которых используется с использованием различных значений и значений. При хранении сущности со следующими структурами можно эффективно получать сущности сотрудников на основе адреса электронной почты или идентификатора сотрудника. Значения префикса `PartitionKey` `empid_`для `email_` и позволяют определить, какой индекс вы хотите использовать для запроса.  

![Графическое отображение сущности сотрудника с первичным индексом и сущностью сотрудника со вторичным индексом][10]

Следующие два критерия фильтра (один из них, идентификатор сотрудника, и один по адресу электронной почты) указывают на точечные запросы:  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

При запросе для целого ряда организаций сотрудников можно указать диапазон, отсортированный в порядке идентификатора сотрудника, или диапазон, отсортированный в заказе адреса электронной почты. Запрос для сущностей с соответствующей `RowKey`приставкой в .  

* Чтобы найти всех сотрудников отдела продаж с идентификатором сотрудника в диапазоне **000100** до **000199**, отсортированных в заказе идентификатора сотрудника, использовать: $filter (PartitionKey eq 'empid_Sales') и (RowKey ge '000100') и (RowKey le '000199')  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, который начинается с "а", отсортированы в заказе адреса электронной почты, используйте: $filter "(PartitionKey eq'email_Sales") и (RowKey ge 'a') и (RowKey lt 'b')  

Обратите внимание, что синтаксис фильтра, используемый в предыдущих примерах, из API REST хранилища таблицы. Для получения дополнительной [информации см.](https://msdn.microsoft.com/library/azure/dd179421.aspx)  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить согласованность копий сущностей, можно использовать [шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) для сущностей основного и вторичного индексов.  
* Хранение таблиц является относительно дешевым в использовании, поэтому накладные расходы на хранение дублирующих данных не должны вызывать серьезной озабоченности. Однако всегда оценивайте стоимость проектирования на основе ожидаемых требований к хранению и только добавляйте дубликаты для поддержки запросов, которые будет работать клиентское приложение.  
* Значение, используемое `RowKey` для объекта, должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Закладка численных значений в `RowKey` (например, идентификатор сотрудника 000223) позволяет правильно сортировать и фильтровать на основе верхних и нижних границ.  
* Вам не обязательно дублировать все свойства вашей сущности. Например, если запросы, которые ищут объекты, используя `RowKey` адрес электронной почты в возрасте сотрудника, никогда не нужны, эти сущности могут иметь следующую структуру:
  
  ![Графика, показывающая сущность сотрудника со вторичным индексом][11]
* Как правило, лучше хранить дубликаты данных и гарантировать, что вы можете получить все данные, необходимые с помощью одного запроса, чем использовать один запрос, чтобы найти объект с помощью вторичного индекса, а другой, чтобы найти необходимые данные в первичном индексе.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон в следующих случаях:

- Клиентское приложение должно извлекать объекты с помощью различных ключей.
- Клиенту необходимо извлекать объекты в различных заказах.
- Вы можете определить каждую сущность, используя различные уникальные значения.

Используйте этот шаблон, если вы хотите избежать превышения пределов масштабируемости разделов при `RowKey` выполнении поиска сущности, используя различные значения.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern)  
* [Шаблон вторичного индекса внутри раздела;](#intra-partition-secondary-index-pattern)  
* [Шаблон составного ключа;](#compound-key-pattern)  
* [Сделки группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>Шаблон для согласованных транзакций
Обеспечьте согласованное поведение в рамках границ раздела или границ системы хранения с помощью запросов Azure.  

#### <a name="context-and-problem"></a>Контекст и проблема
Транзакции группы сущностей приводят к выполнению атомарных транзакций в нескольких сущностях, использующих один общий ключ раздела. По причинам производительности и масштабируемости можно принять решение хранить объекты, которые имеют требования к согласованности в отдельных разделах или в отдельной системе хранения. В таком случае нельзя использовать EGT для поддержания согласованности. Например, может существовать требование к обеспечению согласованности между следующими элементами.  

* Сущности, хранящиеся в двух разных секциях одной таблицы, в разных таблицах или в разных учетных записях хранения.  
* Сущность, хранящаяся в таблице хранения и капли, хранящиеся в хранилище Blob.  
* Сущность, хранящаяся в хранилище таблицы, и файл в файловой системе.  
* Сущность, хранящаяся в таблице хранения, но индексируется с помощью Azure Cognitive Search.  

#### <a name="solution"></a>Решение
Используя очереди Azure, можно реализовать решение, обеспечивающее согласованность между двумя и более разделами или системами хранения.

Чтобы проиллюстрировать этот подход, предположим, что у вас есть требование, чтобы иметь возможность архивировать бывшие подразделения сотрудников. Бывшие подразделения сотрудников редко запрашиваются и должны быть исключены из любых действий, касающихся текущих сотрудников. Для выполнения этого требования вы храните активных сотрудников в **текущей** таблице и бывших сотрудников в таблице **Архива.** Архивирование сотрудника требует удаления сущности из **текущей** таблицы и добавления сущности в таблицу **Архива.**

Но вы не можете использовать EGT для выполнения этих двух операций. Чтобы избежать риска отображения сущности в обеих таблицах или ни в одной из них в случае сбоя, операция архивации должна быть согласованной. Этапы этой операции приведены на следующей схеме.  

![Схема решения для итоговой согласованности][12]

Клиент инициирует операцию архива, размещая сообщение в очереди Azure (в этом примере в архив сотрудника #456). Рабочая роль опрашивает очередь на наличие новых сообщений. При обнаружении такого сообщения она читает сообщение и оставляет в очереди скрытую копию. Затем рабочая роль извлекает копию сущности из таблицы **Current**, вставляет копию в таблицу **Archive** и после этого удаляет исходную сущность из таблицы **Current**. Если предыдущие действия выполнены без ошибок, рабочая роль удаляет скрытое сообщения из очереди.  

В этом примере шаг 4 диаграммы вставляет сотрудника в таблицу **Архива.** Он может добавить сотрудника в каплю в хранилище Blob или файл в файловой системе.  

#### <a name="recover-from-failures"></a>Восстановление после сбоев
Важно, чтобы операции в шагах 4-5 на диаграмме были *идемпотентными* в случае, если роль работника должна перезапустить операцию архива. Если вы используете хранилище таблицы, для шага 4 вы должны использовать операцию "вставить или заменить"; для шага 5 в библиотеке клиента, которая используется, следует использовать операцию "удалить, если она существует". Если вы используете другую систему хранения данных, необходимо использовать соответствующую идемпотентную операцию.  

Если роль работника никогда не завершает шаг 6 на диаграмме, то после тайм-аута сообщение появляется в очереди, готовой к тому, что роль работника попытается переработать. Роль работника может проверить, сколько раз было прочитано сообщение в очереди, и, при необходимости, пометить его как "яд" сообщение для исследования, отправив его в отдельную очередь. Для получения дополнительной информации о чтении сообщений очереди и проверке количества dequeue, [см.](https://msdn.microsoft.com/library/azure/dd179474.aspx)  

Некоторые ошибки из хранилища таблицы и хранения очередей являются временными ошибками, и клиентское приложение должно включать подходящую логику повтора для их обработки.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Это решение не предусматривает изоляцию транзакций. Например, клиент может прочитать таблицы **"Текущий** и **Архив",** когда роль работника находится между шагами 4-5 на диаграмме, и увидеть несогласованное представление данных. В конечном счете данные будут согласованы.  
* Вы должны быть уверены, что шаги 4-5 являются идемпотентными для того, чтобы обеспечить окончательную последовательность.  
* Для масштабирования решения можно использовать несколько очередей и экземпляров рабочих ролей.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, чтобы обеспечить согласованность между сущностями, которые существуют в различных разделах или таблицах. Этот шаблон можно расширить, чтобы обеспечить окончательную согласованность операций в таблице хранения и хранения Blob, а также других не-Azure Storage источников данных, таких как база данных или файловая система.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Сделки группы сущностей](#entity-group-transactions)  
* [Объединение или замена.](#merge-or-replace)  

> [!NOTE]
> Если изоляция транзакций важна для вашего решения, подумайте о реорганизации таблиц, чтобы вы могли использовать EGT.  
> 
> 

### <a name="index-entities-pattern"></a>Шаблон сущностей индекса
Поддерживайте сущности индексов для выполнения эффективных операций поиска, возвращающих списки сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Таблица хранения автоматически индексирует `PartitionKey` `RowKey` сущности с помощью и значения. Это позволяет клиенту приложения эффективно извлекать объект с помощью точечного запроса. Например, используя следующую структуру таблицы, клиентское приложение может эффективно получить отдельный объект `PartitionKey` сотрудника, используя имя отдела и идентификатор сотрудника (идентификатор а). `RowKey`  

![Графика сущности сотрудника][13]

Если вы также хотите иметь возможность получить список сущностей сотрудников на основе значения другого неуникального свойства, например фамилии, необходимо использовать менее эффективное сканирование раздела. Это сканирование находит совпадения, а не с помощью индекса, чтобы посмотреть их непосредственно. Это связано с тем, что хранилище таблицы не предоставляет вторичных индексов.  

#### <a name="solution"></a>Решение
Для включения поиска по фамилии с предыдущей структурой сущности необходимо вести списки ипотированных сотрудников. Если вы хотите получить сущности с определенной фамилией, например Jones, необходимо сначала найти список идентификаций сотрудников с Джонсом в качестве фамилии, а затем получить эти сущности. Существует три основных варианта хранения списков итогов сотрудников:  

* Используйте хранилище Blob.  
* Создание сущностей индексов в одном разделе с сущностями сотрудников.  
* Создание сущностей индексов в отдельном разделе или таблице.  

Вариант 1: Используйте хранилище Blob  

Создайте каплю для каждой уникальной фамилии, и `PartitionKey` в каждом `RowKey` магазине blob список (отдел) и (идентификатор сотрудника) значения для сотрудников, которые имеют эту фамилию. При добавлении или удалении сотрудника убедитесь, что содержимое соответствующего капли в конечном итоге согласуется с сущностями сотрудника.  

Вариант 2: Создание сущностей индекса в одном и том же разделе  

Используйте сущности индекса, которые хранят следующие данные:  

![Графическое отображение сущности сотрудника со строкой, содержащей список идов сотрудника с той же фамилией][14]

Свойство `EmployeeIDs` содержит список идовинов сотрудников для сотрудников с фамилией, хранящейся в `RowKey`.  

Следующие шаги наметить процесс, который вы должны следовать при добавлении нового сотрудника. В этом примере мы добавляем сотрудника с ID 000152 и фамилией Джонс в отделе продаж:  

1. Извлеките сущность `PartitionKey` индекса со значением `RowKey` "Продажи" и значением "Jones". Сохраните ETag это сущности для использования на шаге 2.  
2. Создайте транзакцию группы сущностей (т.е. пакетную`PartitionKey` операцию), которая `RowKey` вставляет новую сущность сотрудника (стоимость`PartitionKey` "Продажи" `RowKey` и значение "000152"), а также обновляет сущность индекса (значение "Продажи" и значение "Jones"). EGT делает это, добавляя новый идентификатор сотрудника в список в поле EmployeeIDs. Для получения дополнительной информации о [транзакциях группы организаций](#entity-group-transactions)см.  
3. Если EGT терпит неудачу из-за оптимистичной ошибки параллелизма (т.е. кто-то другой изменил сущность индекса), то вам нужно начать все сначала на шаг 1.  

Вы можете использовать аналогичный подход для удаление сотрудника, если вы используете второй вариант. Изменение фамилии сотрудника немного сложнее, поскольку необходимо запустить EGT, который обновляет три сущности: сущность сотрудника, сущность индекса для старой фамилии и сущность индекса для новой фамилии. Необходимо получить каждую сущность, прежде чем вносить какие-либо изменения, чтобы получить значения ETag, которые затем можно использовать для выполнения обновлений, используя оптимистический параллелизм.  

Следующие шаги наметить процесс, который вы должны следовать, когда вам нужно искать всех сотрудников с конкретной фамилией в отделе. В этом примере мы ищем всех сотрудников с фамилией Джонс в отделе продаж:  

1. Извлеките сущность `PartitionKey` индекса со значением `RowKey` "Продажи" и значением "Jones".  
2. Разобрать список идов сотрудников `EmployeeIDs` в полевых условиях.  
3. Если вам нужна дополнительная информация о каждом из этих сотрудников (например, адреса электронной почты), извлекать каждый из сотрудников с помощью `PartitionKey` значения "Продажи" и `RowKey` значения из списка сотрудников, которые вы получили в шаге 2.  

Вариант 3: Создание сущностей индекса в отдельной таблице или таблице  

Для этого параметра используйте сущности индекса, которые хранят следующие данные:  

![Графическое отображение сущности сотрудника со строкой, содержащей список идов сотрудника с той же фамилией][15]

Свойство `EmployeeIDs` содержит список идовинов сотрудников для сотрудников с фамилией, хранящейся в `RowKey`.  

Вы не можете использовать EGT для поддержания согласованности, поскольку сущности индекса находятся в отдельном разделении от сущностей сотрудника. Убедитесь, что сущности индекса в конечном итоге согласуются с сущностями сотрудников.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Это решение требует по крайней мере двух запросов для извлечения соответствующих `RowKey` сущностей: одного для запроса сущностей индекса для получения списка значений, а затем запросов для извлечения каждой сущности в списке.  
* Поскольку отдельный объект имеет максимальный размер 1 МБ, вариант 2 и вариант 3 в решении предполагают, что список идентиматеров сотрудников для какой-либо конкретной фамилии никогда не более 1 МБ. Если размер идентификаций сотрудников может составить более 1 МБ, используйте опцию 1 и храните данные индекса в хранилище Blob.  
* Если вы используете опцию 2 (с помощью EGT для обработки работы с сотрудниками по добавлению и удалением и изменения фамилии сотрудника), необходимо оценить, приближается ли объем транзакций к ограничениям масштабируемости в определенном разделе. В этом случае следует рассмотреть окончательно согласованное решение (вариант 1 или вариант 3). Для обработки запросов обновлений используются очереди и позволяют хранить сущности индекса в отдельном разделе от сущностей сотрудника.  
* Вариант 2 в этом решении предполагает, что вы хотите посмотреть по фамилии в отделе. Например, необходимо получить список сотрудников с фамилией Джонс в отделе продаж. Если вы хотите иметь возможность искать всех сотрудников с фамилией Джонс по всей организации, используйте либо вариант 1 или вариант 3.
* Можно реализовать решение, основанное на очередях, которое обеспечивает окончательную согласованность. Для получения более [подробной](#eventually-consistent-transactions-pattern)информации см.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, когда требуется найти набор сущностей, которые имеют общую ценность свойства, например, всех сотрудников с фамилией Джонс.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern)  
* [Сделки группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>Шаблон денормализации
Объедините связанные данных в одной сущности для извлечения необходимых данных с помощью одного запроса точки.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных обычно нормализуют данные для удаления дублирования, которое происходит при извлечении данных из нескольких таблиц. Если нормализация данных осуществляется в таблицах Azure, для извлечения связанных данных требуется сделать несколько переходов от клиента к серверу и обратно. Например, со следующей структурой таблицы, вам нужно две поездки туда и обратно, чтобы получить детали для отдела. Одна поездка приносит сущность отдела, которая включает идентификатор менеджера, а вторая поездка получает данные менеджера в сущности сотрудника.  

![Графика сущности отдела и сотрудника][16]

#### <a name="solution"></a>Решение
Вместо хранения данных в двух отдельных сущностях денормализуйте данные и сохраните копию со сведениями о руководителе в сущности отдела. Пример:  

![Графика денормализованной и комбинированной сущности отдела][17]

С помощью сущностей отдела, хранящихся с этими свойствами, теперь можно получить все необходимые сведения о отделе с помощью точечного запроса.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Двойное хранение некоторых данных связано с определенными издержками. Преимущество производительности, полученное из-за меньшего количества запросов на хранение таблицы, обычно перевешивает незначительное увеличение затрат на хранение. Кроме того, эта стоимость частично компенсируется сокращением количества транзакций, необходимых для получения подробной информации о отделе.  
* Необходимо поддерживать согласованность двух сущностей, в которых хранятся сведения о руководителях. Вы можете справиться с проблемой согласованности, используя EGT для обновления нескольких сущностей в одной атомной транзакции. В этом случае сущность отдела и сущность сотрудника для менеджера отдела хранятся в одной и той же раздельном.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимость поиска связанных данных возникает довольно часто. Этот шаблон уменьшает количество запросов, которые необходимо выполнить клиенту для извлечения требуемых данных.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Сделки группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>Шаблон составного ключа
Используйте `RowKey` сложные значения, чтобы клиент мог искать связанные данные с помощью одного точечного запроса.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных естественно использовать соединения в запросах для возврата связанных частей данных клиенту в одном запросе. Например, с помощью идентификатора сотрудника можно выполнить поиск списка связанных сущностей, которые содержат данные о производительности этого сотрудника.  

Предположим, что вы храхотите сущности сотрудников в таблице хранения с помощью следующей структуры:  

![Графика сущности сотрудника][18]

Вы также должны хранить исторические данные, касающиеся обзоров и производительности за каждый год сотрудник работал для вашей организации, и вы должны иметь доступ к этой информации в год. Одним из вариантов является создание другой таблицы, в которой хранятся сущности со следующей структурой.  

![Графика сущности проверки сотрудников][19]

При таком подходе можно принять решение дублировать некоторую информацию (например, имя и фамилию) в новой сущности, чтобы можно было получить данные с помощью одного запроса. Тем не менее, вы не можете поддерживать сильную согласованность, потому что вы не можете использовать EGT для обновления двух сущностей атомарно.  

#### <a name="solution"></a>Решение
Храните новый тип сущности в исходной таблице, используя сущности со следующей структурой:  

![Графика сущности сотрудника со сложным ключом][20]

Обратите внимание, как в `RowKey` настоящее время соединение ключ, состоящий из идентификатора сотрудника и год обзора данных. Это позволяет получить данные о производительности сотрудника и просмотреть с помощью одного запроса для одной сущности.  

В следующем примере показан процесс извлечения всех отчетных данных по конкретному сотруднику (например, сотрудник 000123 из отдела продаж).  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Вы должны использовать подходящий символ сепаратора, который `RowKey` позволяет легко разобрать значение: например, **000123-2012**.  
* Вы также храним эту сущность в том же разделе, что и другие сущности, содержащие связанные данные для того же сотрудника. Это означает, что вы можете использовать EGT для поддержания сильной согласованности.
* Следует подумать о том, как часто вы будете задаваемые данные, чтобы определить, является ли этот шаблон подходящим. Например, если вы редко получаете доступ к данным обзора и часто основным данным сотрудников, их следует сохранить в качестве отдельных сущностей.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо сохранить одну или несколько связанных часто запрашиваемых сущностей.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Сделки группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>Шаблон для заключительного фрагмента журнала
Изыскните *n* сущности, добавленные `RowKey` в раздел, используя значение, которое сортируется в обратном порядке даты и времени.  

> [!NOTE]
> Результаты запроса, возвращенные API таблицы Azure в Azure Cosmos DB, не сортируются по ключу раздела или ключу строки. Таким образом, хотя этот шаблон подходит для хранения таблицы, он не подходит для Azure Cosmos DB. Для получения подробного списка [differences between Table API in Azure Cosmos DB and Azure Table Storage](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)различий в функциях см.

#### <a name="context-and-problem"></a>Контекст и проблема
Общее требование заключается в необходимости иметь возможность извлекать последние созданные сущности. Например, десять последних заявок на возмещение сотрудникам. Таблицы поддерживают `$top` операцию запроса для возврата *первых* n сущностей из набора. Нет эквивалентной операции запроса для возврата последних *n* сущностей в наборе.  

#### <a name="solution"></a>Решение
Храните сущности, `RowKey` используя, что, естественно, сортирует в обратном порядке даты / времени, так что последняя запись всегда первый в таблице.  

Например, чтобы извлечь десять самых последних заявок на возмещение расходов, отправленных сотрудниками, можно использовать обратное значение тика, являющееся производным от текущей даты и времени. В следующем примере кода СЗ показан один из способов создания `RowKey` подходящего значения «перевернутых тиков» для сортировки от самых последних до самых старых:  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

Вы можете вернуться к значению даты/времени, используя следующий код:  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

Табличный запрос выглядит следующим образом.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Необходимо проложить обратное значение тика с ведущими нулями, чтобы обеспечить сортзначения значения строки, как ожидалось.  
* Необходимо соблюдать целевые показатели масштабирования на уровне раздела. Будьте осторожны, чтобы не создавать разделы горячих точек.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, когда вам необходимо получить доступ к объектам в обратном порядке даты/времени, или когда вам нужно получить доступ к последним добавленным объектам.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Анти-шаблон, предусматривающий добавление в начало или конец;](#prepend-append-anti-pattern)  
* [Объекты извлечения](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>Шаблон для удаления больших объемов сущностей
Включите удаление большого объема сущностей путем хранения всех сущностей для одновременного удаления в их собственной отдельной таблице. Вы удаляете объекты, удаляя таблицу.  

#### <a name="context-and-problem"></a>Контекст и проблема
Многие приложения удаляют старые данные, которые больше не требуются для клиентского приложения. Кроме того, данные могут удаляться при архивации приложения на другой носитель. Обычно такие данные идентифицируется по дате. Например, у вас есть требование удалить записи всех запросов на вспять, которым более 60 дней.  

Одним из возможных дизайнов является использование даты и `RowKey`времени запроса на входе в систему в:  

![Графика сущности попытки входа][21]

Такой подход позволяет избежать точек доступа раздела, поскольку приложение может вставлять и удалять объекты ввода для каждого пользователя в отдельный раздел. Однако этот подход может быть дорогостоящим и отнимающим много времени, если у вас есть большое количество сущностей. Во-первых, необходимо выполнить сканирование таблицы, чтобы определить все объекты для удаления, а затем удалить каждую старую сущность. Количество переходов к серверу, необходимых для удаления старых сущностей, можно сократить путем пакетной вставки нескольких запросов на удаление в EGT.  

#### <a name="solution"></a>Решение
Используйте отдельную таблицу для каждого дня, когда предпринимаются попытки входа в систему. Предыдущую конструкцию сущности можно использовать, чтобы избежать точек доступа при вставке сущностей. Удалять старые сущности теперь просто вопрос удалять одну таблицу каждый день (одна операция хранения), вместо того, чтобы находить и удалять сотни и тысячи отдельных объектов, всходивных в систему каждый день.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Поддерживает ли ваш дизайн другие способы использования данных приложением, например поиск конкретных сущностей, связь с другими данными или генерация агрегированной информации?  
* Ваш проект предотвращает формирование активных областей в случае вставки новых сущностей?  
* Повторное использование того же имени таблицы после его удаления связано с определенной задержкой. Рекомендуется всегда использовать уникальные имена таблиц.  
* Ожидайте некоторого ограничения скорости при первом использовании новой таблицы, в то время как хранилище таблицы изучает шаблоны доступа и распределяет разделы по узтам. Рекомендуется определить периодичность создания новых таблиц.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон при наличии большого количества сущностей для одновременного удаления.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Сделки группы сущностей](#entity-group-transactions)
* [изменение сущностей.](#modify-entities)  

### <a name="data-series-pattern"></a>Шаблон для рядов данных
Чтобы сократить количество выполняемых запросов, храните ряды данных в одной сущности.  

#### <a name="context-and-problem"></a>Контекст и проблема
Возьмем распространенный сценарий, когда приложение сохраняет ряды данных, которые требуется извлечь все сразу. Например, приложение может записывать количество сообщений, ежечасно отправляемых каждым сотрудником, а затем использовать эти сведения для отображения количества сообщений, отправленных каждым пользователем за предыдущие 24 часа. Для хранения 24 сущностей для каждого сотрудника можно разработать одну структуру.  

![Рисунок сущности статистики сообщений][22]

В ней можно без труда находить и обновлять сущности для каждого сотрудника каждый раз, когда приложению требуется обновить значение количества сообщений. Однако чтобы извлечь данные для построения графика активности за предыдущие 24 часа, потребуется извлечь 24 сущности.  

#### <a name="solution"></a>Решение
Используйте следующий дизайн с отдельным свойством для хранения количества сообщений в течение каждого часа:  

![Графический отображение статистики сообщений с разделенными свойствами][23]

В этом случае вы сможете обновлять количество сообщений по сотруднику за определенный час с помощью операции объединения. Теперь вы можете получить всю информацию, необходимую для составления диаграммы, используя запрос для одной сущности.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Если ваша полная серия данных не вписывается в одну сущность (сущность может иметь до 252 свойств), используйте альтернативный хранилище данных, например, каплю.  
* Если у вас есть несколько клиентов, обновляющих сущность одновременно, используйте **ETag** для реализации оптимистичной параллелизма. Если у вас много клиентов, вы можете испытывать высокие разногласия.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо обновить и получить ряды данных, связанных с отдельной сущностью.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для сущностей больших размеров](#large-entities-pattern)  
* [Объединение или замена.](#merge-or-replace)  
* [В конечном итоге последовательная схема транзакций](#eventually-consistent-transactions-pattern) (если вы хралюбите серию данных в каплей)  

### <a name="wide-entities-pattern"></a>Шаблон для масштабных сущностей
Чтобы сохранить сущности, имеющие более 252 свойств, используйте несколько физических сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельная организация может иметь не более 252 свойств (за исключением обязательных системных свойств) и не может хранить в общей сложности более 1 МБ данных. В реляционной базе данных обычно можно обойти любые ограничения по размеру строки, добавив новую таблицу и закрепив между собой отношения 1 к 1.  

#### <a name="solution"></a>Решение
Используя хранилище таблицы, можно хранить несколько сущностей для представления одного крупного бизнес-объекта с более чем 252 свойствами. Например, если вы хотите сохранить количество сообщений, отправленных каждым сотрудником за последние 365 дней, можно использовать следующий дизайн, в который используются две сущности с различными схемами:  

![Графический отображение сообщения статистика лица с Rowkey 01 и сообщение статистика лица с Rowkey 02][24]

Если необходимо внести изменение, требующее обновления обеих сущностей для обеспечения их синхронизации, воспользуйтесь транзакциями группы сущностей. В противном случае можно выполнить одну операцию объединения, которая позволит обновить количество сообщений за определенный день. Чтобы получить все данные для отдельного сотрудника, необходимо получить оба объекта. Это можно сделать с помощью `PartitionKey` двух `RowKey` эффективных запросов, которые используют как значение, так и значение.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
Рассмотрим следующий момент при принятии решения о том, как реализовать этот шаблон:  

* Извлечение логической сущности целиком связано с выполнением как минимум двух операций с хранилищем: одна для извлечения каждой физической сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, когда необходимо хранить объекты, размер или количество свойств которых превышает пределы для отдельной сущности в таблице хранения.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Сделки группы сущностей](#entity-group-transactions)
* [Объединение или замена.](#merge-or-replace)

### <a name="large-entities-pattern"></a>Шаблон для сущностей больших размеров
Используйте хранилище Blob для хранения больших значений свойств.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельное предприятие не может хранить в общей сложности более 1 МБ данных. Если один или несколько свойств хранят значения, которые приводят к тому, что общий размер объекта превышает это значение, нельзя хранить всю сущность в таблице хранения.  

#### <a name="solution"></a>Решение
Если размер объекта превышает 1 Мб, поскольку один или несколько свойств содержат большой объем данных, можно хранить данные в хранилище Blob, а затем хранить адрес капли в свойстве объекта. Например, вы можете хранить фотографию сотрудника в хранилище Blob и хранить `Photo` ссылку на фотографию в собственности организации:  

![Графическое отображение сущности сотрудника со строкой для Фото, указывающей на хранилище Blob][25]

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Для поддержания возможной согласованности между сущностью в хранилище таблицы и данными в хранилище Blob используйте [согласованный шаблон транзакций в конечном итоге](#eventually-consistent-transactions-pattern) для поддержания сущностей.
* Для извлечения полной сущности требуется как минимум две транзакции хранилища: одна для извлечения сущности и одна для извлечения данных большого двоичного объекта.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, когда необходимо хранить объекты, размер которых превышает пределы для отдельной сущности в таблице хранения.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern)  
* [Шаблон для масштабных сущностей.](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>Анти-шаблон, предусматривающий добавление в начало или конец
Если у вас большой объем вставок, увеличьте масштабируемость, распространяя вставки по нескольким перегородким.  

#### <a name="context-and-problem"></a>Контекст и проблема
Как правило, добавление сущностей в начало или конец хранящихся сущностей приводит к тому, что приложение будет добавлять новые сущности к первому или последнему разделу в последовательности разделов. В этом случае все вставки в любое время происходят в одном и том же разделе, создавая точку доступа. Это предотвращает балансирование вставок таблицы в нескольких узлов и, возможно, приводит к тому, что приложение попадает в целевые показатели масштабируемости для раздела. Например, рассмотрим случай приложения, которое регистрирует доступ сотрудников к сети и ресурсам. Структура сущности, такая как следующая, может привести к тому, что раздел текущего часа станет точкой доступа, если объем транзакций достигает целевого показателя масштабируемости для отдельного раздела:  

![Графика сущности сотрудника][26]

#### <a name="solution"></a>Решение
Следующая альтернативная структура сущности избегает точки доступа на какой-либо конкретной разделе, так как приложение регистрирует события:  

![Графическое изображение сущности сотрудника с RowKey, усугубляющим год, месяц, день, час и идентификатор событий][27]

Обратите внимание на этот `PartitionKey` `RowKey` пример, как и соединения ключей. Используется `PartitionKey` как отдел, так и идентификатор сотрудника для распределения журналов по нескольким разделам.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Альтернативная структура ключа, которая предотвращает создание разделов с высокой нагрузкой во время выполнения операций вставки, поддерживает запросы, выполняемые клиентским приложением?  
* Означает ли ожидаемый объем транзакций, что вы, вероятно, достигнете целевых показателей масштабируемости для отдельного раздела и будете задушены хранилищем таблицы?  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Избегайте антишаблона prepend/append, когда объем транзакций может привести к ограничению скорости хранением таблицы при доступе к горячему разделу.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для заключительного фрагмента журнала;](#log-tail-pattern)  
* [изменение сущностей.](#modify-entities)  

### <a name="log-data-anti-pattern"></a>Анти-шаблон для данных журнала
Как правило, для хранения данных журнала следует использовать хранилище Blob вместо хранения таблицы.  

#### <a name="context-and-problem"></a>Контекст и проблема
Общим примером использования данных журнала является получение выбора записей журнала для определенной даты/временной дальности. Например, необходимо найти все ошибки и критические сообщения, которые приложение зарегистрировало в период с 15:04 до 15:06 в определенную дату. Вы не хотите использовать дату и время сообщения журнала для определения раздела, к который вы сохраняете объекты журнала. Это приводит к горячему разделу, потому что в любой `PartitionKey` конкретный момент времени все объекты журнала будут разделять одно и то же значение (см. [антишаблон Prepend/append).](#prepend-append-anti-pattern) Например, следующая схема сущности для сообщения журнала приводит к горячему разделу, поскольку приложение записывает все сообщения журнала в раздел для текущей даты и часа:  

![Графика сущности сообщения журнала][28]

В этом примере `RowKey` включается дата и время сообщения журнала, чтобы гарантировать, что сообщения журнала сортируются в порядке даты/времени. Также `RowKey` включает идентификатор сообщения, в случае, если несколько сообщений журнала имеют одну и ту же дату и время.  

Другой подход заключается `PartitionKey` в использовании a, который гарантирует, что приложение записывает сообщения по ряду разделов. Например, если источник сообщения журнала предоставляет способ распространения сообщений по многим разделам, можно использовать следующую схему сущности:  

![Графика сущности сообщения журнала][29]

Однако проблема этой схемы заключается в том, что для получения всех сообщений журнала для определенного промежутка времени необходимо высматривать каждый раздел в таблице.

#### <a name="solution"></a>Решение
В предыдущем разделе была подчеркнута проблема использования хранилища таблицы для хранения записей журналов и предложены два неудовлетворительных проекта. Одно из решений привело к горячему разделу с риском плохой производительности написания журналов сообщений. Другое решение привело к низкой производительности запроса из-за необходимости сканировать каждый раздел в таблице для получения сообщений журнала для определенного промежутка времени. Хранилище Blob предлагает лучшее решение для этого типа сценариев, и именно так аналитика Azure Storage хранит данные журнала, которые он собирает.  

В этом разделе описывается, как аналитика хранения хранит данные в хранилище Blob, как иллюстрация такого подхода к хранению данных, которые обычно замечают по диапазону.  

Аналитика хранения хранит журнал сообщения в разграниченном формате в нескольких капли. Формат с разделителями упрощает анализ данных в сообщениях журнала.  

Аналитика хранения использует конвенцию именования для капли, которая позволяет найти капли (или капли), которые содержат сообщения журнала, для которых вы ищете. Например, капля с именем "очередь/2014/07/31/1800/000001.log" содержит сообщения журнала, которые относятся к службе очереди за час, начинающимся в 18:00 31 июля 2014 года. «000001» означает первый файл журнала за этот период. Аналитика хранения также записывает временные метки первого и последнего сообщений журнала, хранящихся в файле, как часть метаданных капли. API для хранения Blob позволяет находить капли в контейнере на основе приставки с именем. Чтобы найти все капли, содержащие данные журнала очереди за час, начинающимся в 18:00, можно использовать приставку "очередь/2014/07/31/1800".  

Буферы аналитики хранения регистрирует сообщения внутри, а затем периодически обновляет соответствующую каплю или создает новую с последней партией записей журнала. Это уменьшает количество записок, которые он должен выполнять для хранения Blob.  

Если вы внедряете аналогичное решение в собственном приложении, подумайте, как управлять компромиссом между надежностью и стоимостью и масштабируемостью. Другими словами, оцените эффект от записи каждой записи журнала в хранилище Blob по мере того, как это происходит, по сравнению с обновлениями буферизации в вашем приложении и написанием их в хранилище Blob пакетами.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При выборе способа хранения данных журнала, необходимо учитывать следующие моменты.  

* При создании конструкции таблицы, которая позволяет избежать потенциальных горячих разделов, вы можете обнаружить, что вы не можете получить доступ к данным журнала эффективно.  
* Для обработки данные журнала клиенту часто требуется загружать много записей.  
* Хотя данные журнала часто структурированы, хранение Blob может быть лучшим решением.  

### <a name="implementation-considerations"></a>Рекомендации по реализации
В этом разделе рассматриваются некоторые вопросы, которые необходимо иметь в виду при реализации моделей, описанных в предыдущих разделах. В большей части этого раздела приводятся примеры на языке C#, в которых используется клиентская библиотека хранилища(версия 4.3.0 на момент написания данного руководства).  

### <a name="retrieve-entities"></a>Объекты извлечения
Как упоминалось в разделе [Разработка для запросов](#design-for-querying), самый эффективный запрос — точечный. Однако в некоторых сценариях может потребоваться извлечение нескольких сущностей. В этом разделе описаны некоторые общие подходы к извлечению сущностей с помощью библиотеки клиентов хранения.  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>Выполнить точечный запрос с помощью библиотеки клиентов хранения
Самый простой способ выполнения точечного запроса — использовать операцию таблицы **Retrieve.** Как показано в следующем фрагменте кода Си-Ква, `PartitionKey` эта операция извлекает `RowKey` сущность с ценностью "Продажи" и значение "212":  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

Обратите внимание, как этот пример ожидает, `EmployeeEntity`что объект, который он извлекает, будет типа.  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>Извлекать несколько сущностей с помощью LIN
Вы можете получить несколько сущностей, используя LIN's с библиотекой клиентов хранения и указав запрос с оговоркой **where.** Чтобы избежать сканирования таблицы, необходимо `PartitionKey` всегда включать значение в пункте, где, и, если возможно, `RowKey` значение, чтобы избежать сканирования таблицы и раздела. Таблица хранения поддерживает ограниченный набор операторов сравнения (больше, чем, больше или равны, меньше, чем, меньше, чем или равны, равны, и не равны) для использования в том, где оговорка. Следующий фрагмент кода C's находит всех сотрудников, фамилия которых `RowKey` начинается с "B" (при `PartitionKey` условии, что хранит фамилию) в отделе продаж (при условии, что магазины название отдела):  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

Обратите внимание, как запрос определяет `RowKey` как `PartitionKey` a, так и a для обеспечения лучшей производительности.  

Следующий пример кода показывает эквивалентную функциональность с помощью свободного API (для получения дополнительной информации о свободно множественном API в целом, [см. Лучшие практики для разработки свободного API):](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> Образец гнездится несколько `CombineFilters` методов, чтобы включить три условия фильтра.  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>Извлечение большого количества сущностей из запроса
Оптимальный запрос возвращает отдельную `PartitionKey` сущность `RowKey` на основе значения и значения. Однако в некоторых сценариях может возникнуть требование вернуть многие сущности из одного и того же раздела или даже из многих разделов. В таких случаях следует полностью протестировать производительность приложения.  

Запрос в отношении хранилища таблицы может вернуть максимум 1000 сущностей одновременно и работать не более пяти секунд. Хранилище таблиц возвращает токен продолжения, чтобы клиентское приложение запросило следующий набор сущностей, если какой-либо из следующих данных соответствует действительности:

- Набор результатов содержит более 1000 сущностей.
- Запрос не был завершен в течение пяти секунд.
- Запрос пересекает границу раздела. 

Для получения дополнительной информации о том, как работают токены продолжения, [см.](https://msdn.microsoft.com/library/azure/dd135718.aspx)  

Если вы используете библиотеку клиентов хранения, она может автоматически обрабатывать маркеры продолжения для вас, когда она возвращает сущности из хранилища таблицы. Например, следующий образец кода СЗ автоматически обрабатывает маркеры продолжения, если хранилище таблицы возвращает их в ответ:  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

Следующий код C# обрабатывает маркеры продолжения явным образом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

Явное использование маркеров продолжения позволяет управлять извлечением следующего сегмента данных. Например, если клиентское приложение позволяет пользователям просматривать объекты, хранящиеся в таблице, пользователь может принять решение не просматривать страницы во всех объектах, извлеченных в запросе. Приложение будет использовать токен продолжения только для получения следующего сегмента, когда пользователь закончил прокладку по всем объектам в текущем сегменте. Такой подход имеет несколько преимуществ.  

* Можно ограничить объем данных для извлечения из хранилища таблицы и перемещение по сети.  
* Вы можете выполнять асинхронные ввод/у в .NET.  
* Можно выставить токен продолжения на постоянное хранилище, так что можно продолжить работу в случае сбоя приложения.  

> [!NOTE]
> Продолжение токена обычно возвращает сегмент, содержащий 1000 сущностей, хотя может содержать меньше. Это также имеет место, если вы ограничиваете количество записей, которые возвращает запрос, используя **Take,** чтобы вернуть первые n сущности, которые соответствуют вашим критериям поиска. Хранилище таблиц может вернуть сегмент, содержащий меньше n сущностей, а также токен продолжения, чтобы вы могли получить оставшиеся сущности.  
> 
> 

Следующий код C# демонстрирует процесс изменения количества возвращаемых сущностей в сегменте.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>Проекция на стороне сервера
Одна сущность может иметь до 255 свойств и быть размером не более 1 МБ. При запросе таблицы и извлечении сущностей могут потребоваться не все свойства, и можно избежать излишней передачи данных (чтобы уменьшить задержку и стоимость). Проекции на стороне сервера можно использовать для передачи только необходимых свойств. Следующий пример получает `Email` только свойство `PartitionKey` `RowKey`(наряду с , `Timestamp`, и `ETag`) из сущностей, выбранных запросом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

Обратите внимание, `RowKey` как значение доступно, даже если оно не включено в список свойств для извлечения.  

### <a name="modify-entities"></a>изменение сущностей.
Библиотека клиентов хранения позволяет изменять объекты, хранящиеся в таблице хранения путем вставки, удаляния и обновления объектов. Вы можете использовать EGT для совместной партии нескольких вставок, обновления и удаления операций, чтобы уменьшить количество необходимых поездок в обход и повысить производительность решения.  

Исключения, внесенные при запуске EGT библиотеки хранения, обычно включают индекс сущности, вызвавший сбой пакета. Это может оказаться полезным при отладке кода, использующего транзакции группы сущностей.  

Следует также учитывать влияние разработки на то, каким образом клиентское приложение обрабатывает операций параллелизма и обновления.  

#### <a name="managing-concurrency"></a>Управление параллелизмом
По умолчанию хранилище таблицы реализует оптимистичные проверки параллелизма на уровне отдельных сущностей для вставки, слияния и удаления операций, хотя клиент может заставить хранилище таблицы обойти эти проверки. Для получения дополнительной информации [см. Управление параллелизмом в Microsoft Azure Storage](../storage/common/storage-concurrency.md).  

#### <a name="merge-or-replace"></a>Объединение или замена.
Метод `Replace` `TableOperation` класса всегда заменяет полную сущность в таблице хранения. Если вы не включили свойство в запрос, когда это свойство существует в сохраненной сущности, запрос удаляет это свойство из сохраненного объекта. Каждое свойство требуется в включать в запрос до тех пор, пока оно явным образом не будет удалено из хранимой сущности.  

Метод `TableOperation` класса `Merge` можно использовать для уменьшения объема данных, отправляемых в хранилище таблицы, при необходимом обновлении сущности. Метод `Merge` заменяет любые свойства в сохраненной сущности значениями свойств от сущности, включенной в запрос. Этот метод оставляет нетронутыми любые свойства в сохраненном объекте, которые не включены в запрос. Это полезно, если у вас есть большие сущности, и только необходимо обновить небольшое количество свойств в запросе.  

> [!NOTE]
> `*Replace` Методы `Merge` и методы терпят неудачу, если сущность не существует. В качестве альтернативы можно `InsertOrReplace` использовать `InsertOrMerge` методы и методы, создающие новую сущность, если она не существует.  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>Работа с разными типами сущностей
Таблица хранения является *схема менее* таблицы магазина. Это означает, что одна таблица может хранить сущности нескольких типов, обеспечивая большую гибкость в дизайне. В следующем примере показана таблица, в которой хранятся сущности сотрудников и отделов.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Каждая сущность `PartitionKey` `RowKey`должна `Timestamp` иметь и значения, но может иметь любой набор свойств. Кроме того, нет ничего, чтобы указать тип сущности, если вы не решите хранить эту информацию где-то. Существует два варианта определения типа сущности.  

* Подготовите тип сущности к `RowKey` (или, возможно, к). `PartitionKey` Например, `EMPLOYEE_000123` `DEPARTMENT_SALES` или `RowKey` как ценности.  
* Используйте отдельное свойство для записи типа сущности, как показано в следующей таблице.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>отдел;</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Первый вариант, предпосыла `RowKey`тип сущности к , полезен, если есть возможность того, что два сущности разных типов могут иметь одно и то же ключевое значение. Кроме того, он позволяет объединять сущности одного типа в раздел.  

Методы, обсуждаемые в этом разделе, особенно актуальны для обсуждения[отношений наследования.](#inheritance-relationships)  

> [!NOTE]
> Рассмотрите возможность включения номера версии в значение типа сущности, чтобы клиентские приложения могли развивать объекты POCO и работать с различными версиями.  
> 
> 

В оставшейся части этого раздела описываются некоторые функции клиентской библиотеки хранилища, которые упрощают работу с несколькими типами сущностей в одной таблице.  

#### <a name="retrieve-heterogeneous-entity-types"></a>Извлечение неоднородных типов сущностей
Если вы используете библиотеку клиентов хранения, у вас есть три варианта для работы с несколькими типами сущностей.  

Если вы знаете тип сущности, `RowKey` `PartitionKey` хранящейся со конкретными значениями, то можно указать тип сущности при извлечении сущности. Вы видели это в двух предыдущих примерах, которые извлекают сущности типа: `EmployeeEntity` [Выполнить точечный запрос с помощью библиотеки хранения клиентов](#run-a-point-query-by-using-the-storage-client-library) и получить [несколько сущностей с помощью LIN '](#retrieve-multiple-entities-by-using-linq)  

Второй вариант заключается `DynamicTableEntity` в использовании типа (мешок свойства), а не конкретный тип сущности POCO. Этот параметр может также повысить производительность, поскольку нет необходимости сериализировать и десериализировать сущность до типов .NET. Следующий код C's потенциально извлекает из таблицы несколько сущностей различных типов, но возвращает все сущности в виде `DynamicTableEntity` экземпляров. Затем он `EntityType` использует свойство для определения типа каждой сущности:  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

Чтобы получить другие свойства, `TryGetValue` необходимо использовать `Properties` метод `DynamicTableEntity` на свойстве класса.  

Третий вариант заключается `DynamicTableEntity` в объединении с использованием типа и экземпляра. `EntityResolver` Он позволяет выполнять разрешение в несколько типов POCO в рамках одного запроса. В этом примере `EntityResolver` делегат `EntityType` использует свойство для разграничения двух типов сущности, которые возвращает запрос. Метод `Resolve` использует `resolver` делегата `DynamicTableEntity` для разослать экземпляры в `TableEntity` экземпляры.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>Изменение неоднородных типов сущностей
Вам не нужно знать тип сущности, чтобы удалить его, и вы всегда знаете тип сущности при вставке. Тем не менее, `DynamicTableEntity` этот тип можно использовать для обновления сущности, не зная ее типа и не используя класс сущности POCO. Следующий образец кода извлекает одну сущность и проверяет наличие `EmployeeCount` свойства перед обновлением.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>Управление доступом с помощью общих подписей доступа
Можно использовать маркеры общей подписи доступа (SAS), чтобы клиентские приложения могли изменять (и заготавлив) объекты таблицы напрямую, без необходимости непосредственной аутентификации с помощью хранилища таблицы. Существует три основных преимущества использования SAS в приложении.  

* Вам не нужно распространять ключ учетной записи хранилища на небезопасную платформу (например, мобильное устройство), чтобы позволить этому устройству получить доступ и изменить сущности в таблице хранения.  
* Можно разгрузить часть работы, выполняемых веб-и рабочими ролями при управлении объектами. Вы можете разгрузиться на клиентские устройства, такие как компьютеры конечных пользователей и мобильные устройства.  
* Клиенту можно назначить ограниченному и ограниченному по времени набору разрешений (например, разрешить доступ только для чтения к определенным ресурсам).  

Для получения дополнительной информации об использовании токенов SAS с хранилищем таблицы [см.](../storage/common/storage-dotnet-shared-access-signature-part-1.md)  

Однако необходимо создать токены SAS, которые предоставляют клиентское приложение объектам в хранилище таблицы. Делайте это в среде, которая имеет безопасный доступ к ключам учетной записи хранилища. Как правило, для создания маркеров SAS их доставки в клиентские приложения, которым требуется доступ к сущностям, используются веб-роли или рабочие роли. Поскольку процесс создания маркеров SAS и их доставки клиентов по-прежнему связан с издержками, рекомендуется рассмотреть оптимальные варианты сокращения расходов в сценариях с большим количеством операций.  

Можно создать токен SAS, который предоставляет доступ к подмноженому набору сущностей в таблице. По умолчанию вы создаете токен SAS для всей таблицы. Но также можно указать, что токен SAS предоставляет доступ `PartitionKey` либо к диапазону `PartitionKey` `RowKey` значений, либо к диапазону значений. Вы можете выбрать для создания токенов SAS для отдельных пользователей вашей системы, так что токен SAS каждого пользователя позволяет им получить доступ только к своим собственным объектам в таблице хранения.  

### <a name="asynchronous-and-parallel-operations"></a>Асинхронные и параллельные операции
Чтобы улучшить производительность и время отклика клиента в случае распределения запросов по нескольким разделам, рекомендуется обратить внимание на асинхронные и параллельные запросы.
Например, в вашем распоряжении может быть два или несколько экземпляров рабочих ролей с параллельным доступом к таблицам. Можно иметь отдельные роли рабочего, ответственные за определенные наборы разделов, или просто иметь несколько экземпляров роли работника, каждый из которых может получить доступ ко всем разделам в таблице.  

В экземпляре клиента можно улучшить пропускную связь, асинхронно выполнить операции по хранению. Клиентская библиотека хранилища упрощает написание асинхронных запросов и изменений. Например, можно начать с синхронного метода, который извлекает все сущности в разделите, как показано в следующем коде C:  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

Вы можете легко изменить этот код так, чтобы запрос запускаться асинхронно, следующим образом:  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Подпись метода теперь включает модификатор `async` и возвращает `Task` экземпляр.  
* Вместо вызова `ExecuteSegmented` метода для получения результатов метод `ExecuteSegmentedAsync` теперь вызывает метод. Метод использует `await` модификатор для получения результатов асинхронно.  

Клиентское приложение может вызвать этот метод несколько `department` раз, с различными значениями для параметра. Каждый запрос выполняется на отдельном потоке.  

В `Execute` `TableQuery` классе нет асинхронной версии метода, так как `IEnumerable` интерфейс не поддерживает асинхронный перечисление.  

Можно вставлять, обновлять и удалять сущности в асинхронном режиме. В следующем примере кода C# показан простой синхронный метод вставки или замены сущности сотрудника.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

Вы можете легко изменить этот код так, чтобы обновление работает асинхронно, следующим образом:  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Подпись метода теперь включает модификатор `async` и возвращает `Task` экземпляр.  
* Вместо вызова `Execute` метода обновления сущности метод теперь вызывает `ExecuteAsync` метод. Метод использует `await` модификатор для получения результатов асинхронно.  

Клиентское приложение может вызывать несколько асинхронных методов, подобных этому, и каждый метод вызова выполняется на отдельном потоке.  


[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

