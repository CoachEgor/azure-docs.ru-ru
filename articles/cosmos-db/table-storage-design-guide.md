---
title: Проектирование Azure Cosmos DB таблиц для масштабирования и производительности
description: Руководство по проектированию хранилища таблиц Azure. масштабируемые и высокопроизводительные таблицы в Azure Cosmos DB и хранилище таблиц Azure
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: conceptual
ms.date: 05/21/2019
author: sakash279
ms.author: akshanka
ms.custom: seodec18
ms.openlocfilehash: 166076d366cbbf7bef24648772beaba9b3a88253
ms.sourcegitcommit: 509b39e73b5cbf670c8d231b4af1e6cfafa82e5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2020
ms.locfileid: "78395654"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Руководство по проектированию таблиц хранилища таблиц Azure. масштабируемые и высокопроизводительные таблицы

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

При проектировании масштабируемых и производительных таблиц необходимо учитывать ряд факторов, включая затраты. Если вы ранее разрабатывали схемы для реляционных баз данных, вам будет удобнее ознакомиться с этими вопросами. Хотя между хранилищем таблиц Azure и реляционными моделями есть некоторые сходства, также есть много важных различий. Как правило, эти различия приводят к созданию разных вариантов, которые могут показаться пользователям, знакомым с реляционными базами данных, алогичными или неверными, но если разработка выполняется для хранилища NoSQL типа "ключ — значение", например хранилища таблиц, эти различия будут иметь смысл.

Хранилище таблиц предназначено для поддержки облачных приложений, которые могут содержать миллиарды сущностей ("строки" в терминологии реляционных баз данных) или для наборов данных, которые должны поддерживать большие объемы транзакций. Поэтому необходимо по-разному подумать о том, как хранятся данные, и понять, как работает хранилище таблиц. Хорошо спроектированное хранилище данных NoSQL может обеспечить более подробное масштабирование решения (и с меньшими затратами), чем решение, использующее реляционную базу данных. Данное руководство поможет решить эти задачи.  

## <a name="about-azure-table-storage"></a>Сведения о хранилище таблиц Azure
В этом разделе описываются некоторые основные функции хранилища таблиц, которые особенно важны для разработки с целью повышения производительности и масштабируемости. Если вы еще не знакомы с хранилищем Azure и хранилищем таблиц, ознакомьтесь со статьей [Введение в Служба хранилища Microsoft Azure](../storage/common/storage-introduction.md) и приступайте к [работе с хранилищем таблиц Azure с помощью .NET](table-storage-how-to-use-dotnet.md) , прежде чем читать оставшуюся часть этой статьи. Хотя основное внимание уделяется использованию хранилища таблиц, оно включает в себя некоторые сведения о хранилище очередей Azure и хранилище BLOB-объектов Azure, а также о способах их использования вместе с хранилищем таблиц в решении.  

Хранилище таблиц использует табличный формат для хранения данных. Согласно стандартной терминологии каждая строка таблицы представляет сущность, а различные свойства этой сущности хранятся в столбцах. Каждая сущность имеет пару ключей для уникальной идентификации, а столбец отметок времени, используемый хранилищем таблиц для наблюдения за моментом последнего обновления сущности. Поле метки времени добавляется автоматически, и вы не можете вручную перезаписать метку времени произвольным значением. Хранилище таблиц использует эту отметку времени последнего изменения (LMT) для управления оптимистичным параллелизмом.  

> [!NOTE]
> Операции хранилища таблиц REST API также возвращают `ETag` значение, которое оно является производным от LMT. В этом документе термины ETag и LMT используются взаимозаменяемыми, так как они ссылаются на одни и те же базовые данные.  
> 
> 

В следующем примере показана простая схема таблицы для хранения сущностей сотрудников и отделов. Подобную структуру имеет большинство таблиц, приведенных далее в этом руководстве.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td>Маркетинг</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Маркетинг</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td>Июнь</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Маркетинг</td>
<td>отдел;</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Маркетинг</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Продажи</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


До сих пор эта схема выглядит примерно так же, как таблица в реляционной базе данных. Ключевые отличия являются обязательными столбцами и возможностью хранения нескольких типов сущностей в одной таблице. Кроме того, каждое определяемое пользователем свойство, такое как **FirstName** или **Age**, имеет тип данных, например Integer или String, как и столбец в реляционной базе данных. В отличие от реляционной базы данных, схема хранения таблиц без схемы означает, что свойство не должно иметь одинаковых типов данных для каждой сущности. Для хранения сложных типов данных в одном свойстве необходимо использовать сериализованный формат, например JSON или XML. Дополнительные сведения см. в разделе [понятие о модели данных хранилища таблиц](https://msdn.microsoft.com/library/azure/dd179338.aspx).

`PartitionKey` и `RowKey` являются фундаментальными для хорошего проектирования таблиц. Каждая сущность, хранящаяся в таблице, должна иметь уникальное сочетание `PartitionKey` и `RowKey`. Как и в случае с ключами в таблице реляционной базы данных, значения `PartitionKey` и `RowKey` индексируются для создания кластеризованного индекса, который обеспечивает быстрый поиск. Однако хранилище таблиц не создает вторичных индексов, поэтому это единственное два индексированных свойства (некоторые закономерности, описанные ниже, показывают, как можно обойти это очевидное ограничение).  

Таблица состоит из одной или нескольких секций, и многие из решений по проектированию будут выбирать подходящие `PartitionKey` и `RowKey` для оптимизации решения. Решение может состоять только из одной таблицы, содержащей все сущности, упорядоченные по секциям, но обычно решение имеет несколько таблиц. Таблицы помогают логически упорядочивать сущности, а также помогают управлять доступом к данным с помощью списков управления доступом. Можно удалить всю таблицу с помощью одной операции хранилища.  

### <a name="table-partitions"></a>Разделы таблицы
Имя учетной записи, имя таблицы и `PartitionKey` вместе указывают секцию в службе хранилища, в которой хранилище таблиц хранит сущность. Кроме того, что входит в схему адресации для сущностей, секции определяют область для транзакций (см. раздел далее в этой статье, [транзакции группы сущностей](#entity-group-transactions)) и формируют, как масштабируется хранилище таблиц. Дополнительные сведения о секциях таблиц см. в разделе [Контрольный список производительности и масштабируемости для хранилища таблиц](../storage/tables/storage-performance-checklist.md).  

В хранилище таблиц отдельный узел служб выполняет одну или несколько полных секций, а служба масштабируется путем динамической балансировки нагрузки секций между узлами. Если узел находится под нагрузкой, хранилище таблиц может разделить диапазон секций, обслуживаемых этим узлом, на разные узлы. При отправной стороне трафика хранилище таблиц может объединить диапазоны секций из бесшумных узлов обратно в один узел.  

Дополнительные сведения о внутренних деталях хранилища таблиц и о том, как она управляет секциями, см. в разделе [Служба хранилища Microsoft Azure: высокодоступная служба облачного хранилища со строгой согласованностью](https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).  

### <a name="entity-group-transactions"></a>Транзакции группы сущностей
В табличном хранилище транзакции групп сущностей (EGT) являются единственным встроенным механизмом для выполнения атомарных обновлений в нескольких сущностях. EGT также называются *пакетными транзакциями*. EGT может применяться только к сущностям, хранящимся в том же разделе (совместно с одним и тем же ключом секции в определенной таблице), поэтому в любое время, когда требуется атомарное поведение транзакций для нескольких сущностей, убедитесь, что эти сущности находятся в одной секции. Часто это является причиной хранения нескольких типов сущностей в одной и той же таблице (и секции) и не использовать несколько таблиц для различных типов сущностей. Одна транзакция группы сущностей может работать с максимум 100 сущностей.  При отправке нескольких одновременных EGT для обработки важно убедиться, что эти EGT не работают с сущностями, которые являются общими для EGT. В противном случае вы рискуете обработать задержку.

Кроме того, применение транзакций группы сущностей приводит к необходимости сопоставить преимущества и недостатки и сделать компромиссный выбор при разработке. Использование большего количества секций повышает масштабируемость приложения, поскольку в Azure есть больше возможностей для запросов балансировки нагрузки на узлах. Но это может ограничить возможность приложения выполнять атомарные транзакции и поддерживать строгую согласованность данных. Кроме того, следует принять во внимание наличие определенных целевых показателей масштабируемости на уровне раздела, которые могут ограничивать ожидаемую пропускную способность для транзакций на одном узле.

Дополнительные сведения о целевых показателях масштабируемости для учетных записей хранения Azure см. в статье [целевые показатели масштабируемости для стандартных учетных записей хранения](../storage/common/scalability-targets-standard-account.md). Дополнительные сведения о целевых показателях масштабируемости для хранилища таблиц см. в разделе [целевые показатели масштабируемости и производительности для хранилища таблиц](../storage/tables/scalability-targets.md). В последующих разделах данного руководства рассматриваются различные стратегии разработки, упрощающие управление подобными компромиссными решениями, а также описываются оптимальные варианты выбора ключа раздела с учетом конкретных требований клиентского приложения.  

### <a name="capacity-considerations"></a>Рекомендации по емкости
В следующей таблице приведены некоторые ключевые значения, которые следует учитывать при проектировании решения для хранения таблиц.  

| Общая емкость учетной записи хранения Azure | 500 TБ |
| --- | --- |
| Количество таблиц в учетной записи хранения Azure |Ограничивается только емкостью учетной записи хранения. |
| Количество разделов в таблице |Ограничивается только емкостью учетной записи хранения. |
| Количество сущностей в разделе |Ограничивается только емкостью учетной записи хранения. |
| Размер отдельной сущности |До 1 МБ и максимум 255 свойств (включая `PartitionKey`, `RowKey`и `Timestamp`). |
| Размер `PartitionKey` |Строка размером до 1 КБ. |
| Размер `RowKey` |Строка размером до 1 КБ. |
| Размер транзакции группы сущностей |Транзакция может включать не более 100 сущностей, а полезная нагрузка должна иметь размер менее 4 МБ. Транзакция группы сущностей может обновлять сущность только один раз. |

Дополнительные сведения см. [в разделе Основные сведения о модели данных службы таблиц](https://msdn.microsoft.com/library/azure/dd179338.aspx).  

### <a name="cost-considerations"></a>Рекомендации по стоимости
Хранилище таблиц является относительно недорогим, но при оценке любого решения, использующего табличное хранилище, следует учитывать затраты на использование емкости и количество транзакций. Однако во многих случаях хранение денормализованных или дублирующихся данных для повышения производительности или масштабируемости решения является допустимым подходом. Дополнительные сведения о ценах см. на [странице цен на службу хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).  

## <a name="guidelines-for-table-design"></a>Рекомендации по разработке таблиц
В этих списках приведены некоторые ключевые рекомендации, которые следует учитывать при проектировании таблиц. В этом пошаговом руководством эти сведения рассматриваются более подробно. Эти рекомендации отличаются от рекомендаций по проектированию реляционной базы данных.  

Проектирование хранилища таблиц для эффективного *чтения* :

* **Разрабатывайте решения с учетом выполнения запросов в приложениях с большим количеством операций чтения.** При проектировании таблиц подумайте о запросах (особенно с учетом задержек), которые будут выполняться перед тем, как вы думаете, как обновлять сущности. Это позволит создать эффективное и высокопроизводительное решение.  
* **Укажите в запросах как `PartitionKey`, так и `RowKey`.** *Запросы на указание* , такие как, являются наиболее эффективными запросами к хранилищу таблиц.  
* **Рассмотрите возможность хранения повторяющихся копий сущностей.** Хранилище таблиц является недорогым, поэтому рекомендуется хранить одну и ту же сущность несколько раз (с разными ключами), чтобы обеспечить более эффективные запросы.  
* **Рассмотрите возможность денормализации данных.** Хранилище таблиц является недорогым, поэтому рассмотрите возможность денормализации данных. Например, храните сущности сводки, чтобы запросы к объединенным данным обращались только к одной сущности.  
* **Используйте значения составного ключа.** `PartitionKey` и `RowKey`только ключи. Например, значения составного ключа можно использовать для включения альтернативных путей доступа с ключами к сущностям.  
* **Используйте проекции в запросах.** С помощью запросов, выбирающих только необходимые поля, можно сократить объем данных, передаваемых по сети.  

Проектирование хранилища таблиц для эффективной *записи* :  

* **Не создавайте горячие секции.** Выбирайте ключи, которые позволяют распределять запросы по нескольким разделам в любой момент времени.  
* **Избегайте пиковых нагрузок по трафику.** Распределите трафик по разумному периоду времени и избегайте пиковых нагрузок трафика.
* **Для каждого типа сущности не требуется создавать отдельную таблицу.** Чтобы выполнять атомарные транзакции с типами сущностей, эти несколько типов сущностей можно хранить в одном разделе одной таблицы.
* **Рассмотрите требуемую максимальную пропускную способность.** Необходимо знать целевые показатели масштабируемости для хранилища таблиц и убедиться, что ваша структура не приведет к превышению их.  

Далее в этом пошаговом окне вы увидите примеры, которые посвящены всем этим принципам.  

## <a name="design-for-querying"></a>Разработка для запросов
Хранилище таблиц может быть интенсивно Прочитано, интенсивно записываться или сочетаться с ними. В этом разделе рассматривается разработка для эффективной поддержки операций чтения. Как правило, схема, поддерживающая операции чтения, также эффективна для операций записи. Однако при проектировании для поддержки операций записи необходимо учитывать дополнительные моменты. Эти сведения обсуждаются в следующем разделе: [Разработка для изменения данных](#design-for-data-modification).

Хорошей отправной точкой для эффективного чтения данных является вопрос: «какие запросы нужно запускать приложению для получения необходимых данных?».  

> [!NOTE]
> При использовании табличного хранилища очень важно, чтобы проект заменялся заранее, так как это труднее и дорого изменить его позже. Например, в реляционной базе данных часто можно решить проблемы с производительностью, просто добавив индексы в существующую базу данных. Это не является вариантом с хранилищем таблиц.  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>Влияние выбора `PartitionKey` и `RowKey` на производительность запросов
В следующих примерах предполагается, что хранилище таблиц хранит сущности сотрудников со следующей структурой (в большинстве примеров опущено свойство `Timestamp` для ясности):  

| Имя столбца | Тип данных |
| --- | --- |
| `PartitionKey` (название отдела) |String |
| `RowKey` (идентификатор сотрудника) |String |
| `FirstName` |String |
| `LastName` |String |
| `Age` |Целое число |
| `EmailAddress` |String |

Ниже приведены некоторые общие рекомендации по проектированию запросов к хранилищу таблиц. Синтаксис фильтра, используемый в следующих примерах, взят из REST API хранилища таблиц. Дополнительные сведения см. в разделе [сущности запросов](https://msdn.microsoft.com/library/azure/dd179421.aspx).  

* *Запрос к точке* является наиболее эффективным поиском, и его рекомендуется использовать для операций поиска большого объема или уточняющих запросов, для которых требуется наименьшая задержка. Такой запрос может использовать индексы для эффективного поиска отдельной сущности путем указания значений `PartitionKey` и `RowKey`. Например: `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')`.  
* Второй лучший вариант — *запрос Range*. Он использует `PartitionKey`и фильтрует диапазон значений `RowKey`, чтобы вернуть более одной сущности. Значение `PartitionKey` определяет конкретную секцию, а `RowKey` значения определяют подмножество сущностей в этой секции. Например: `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'`.  
* Третье лучше — *Просмотр секций*. Он использует `PartitionKey`и фильтрует еще одно свойство, не являющееся ключевым, и может возвращать несколько сущностей. Значение `PartitionKey` определяет конкретную секцию, а значения свойств выбираются для подмножества сущностей в этой секции. Например: `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'`.  
* *Просмотр таблицы* не включает `PartitionKey`и неэффективно, поскольку он выполняет поиск всех секций, составляющих таблицу, для любых совпадающих сущностей. Он выполняет просмотр таблицы независимо от того, использует ли фильтр `RowKey`. Например: `$filter=LastName eq 'Jones'`.  
* Запросы хранилища таблиц Azure, возвращающие несколько сущностей, сортируются в `PartitionKey` и `RowKey` порядке. Чтобы избежать применения сущностей в клиенте, выберите `RowKey`, определяющий наиболее распространенный порядок сортировки. Результаты запроса, возвращенные API таблиц Azure в Azure Cosmos DB, не сортируются по ключу секции или ключу строки. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от хранилища таблиц Azure?](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior).

Использование "**или**" для указания фильтра, основанного на значениях `RowKey`, приводит к просмотру секции и не рассматривается как запрос диапазона. Поэтому избегайте запросов, использующих такие фильтры, как: `$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')`.  

Примеры кода на стороне клиента, которые используют клиентскую библиотеку хранилища для выполнения эффективных запросов, см. в следующих статьях:  

* [Выполнение запроса к точке с помощью клиентской библиотеки хранилища](#run-a-point-query-by-using-the-storage-client-library)
* [Получение нескольких сущностей с помощью LINQ](#retrieve-multiple-entities-by-using-linq)
* [Проекция на стороне сервера](#server-side-projection)  

Примеры кода на стороне клиента, который может обрабатывать несколько типов сущностей, хранящихся в одной таблице, см. в следующем разделе:  

* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>Выберите подходящий `PartitionKey`
Выбранный `PartitionKey` должен сбалансировать необходимость использования EGT (для обеспечения согласованности) с требованием распределения сущностей по нескольким секциям (для обеспечения масштабируемого решения).  

С одной стороны, все сущности можно хранить в одном разделе. Но это может ограничить масштабируемость вашего решения и не позволит табличному хранилищу получать запросы на балансировку нагрузки. В другой крайней части можно хранить одну сущность на секцию. Это очень масштабируемое и позволяет табличному хранилищу выполнять запросы балансировки нагрузки, но не позволяет использовать транзакции группы сущностей.  

Идеальный `PartitionKey` позволяет использовать эффективные запросы и имеет достаточно секций, чтобы обеспечить масштабируемость решения. Как правило, вы обнаружите, что сущности будут иметь подходящее свойство, которое распределяет сущности по достаточному количеству секций.

> [!NOTE]
> Например, в системе, в которой хранятся сведения о пользователях или сотрудниках, `UserID` может быть хорошим `PartitionKey`. У вас может быть несколько сущностей, использующих определенный `UserID` в качестве ключа секции. Каждая сущность, хранящая данные о пользователе, сгруппирована в одну секцию. Доступ к этим сущностям можно получить с помощью EGT, сохраняя при этом высокую масштабируемость.
> 
> 

При выборе `PartitionKey`, связанных с вставкой, обновлением и удалением сущностей, необходимо учитывать дополнительные соображения. Дополнительные сведения см. в разделе [Разработка для изменения данных](#design-for-data-modification) далее в этой статье.  

### <a name="optimize-queries-for-table-storage"></a>Оптимизация запросов к хранилищу таблиц
Хранилище таблиц автоматически индексирует сущности с помощью `PartitionKey` и `RowKey` значений в одном кластеризованном индексе. Именно по этой причине запросы к точкам являются наиболее эффективными для использования. Однако в кластеризованном индексе на `PartitionKey` и `RowKey`отсутствуют индексы, отличные от этого.

Многие разработки должны соответствовать требованиям по включению поиска сущностей на основании нескольких условий. Например, Поиск сущностей сотрудников на основе адреса электронной почты, идентификатора сотрудника или фамилии. Приведенные ниже шаблоны в разделе [шаблоны проектирования таблиц](#table-design-patterns) удовлетворяют этим типам требований. Шаблоны также описывают способы работы с тем, что хранилище таблиц не предоставляет вторичные индексы.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с помощью разных значений `RowKey` (в одной секции). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.  
* [Шаблон вторичного индекса](#inter-partition-secondary-index-pattern)в разных разделах. Хранение нескольких копий каждой сущности с помощью различных `RowKey` значений в отдельных секциях или в отдельных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.  
* [Шаблон сущностей индекса](#index-entities-pattern): ведение сущностей индекса для обеспечения эффективного поиска, возвращающего списки сущностей.  

### <a name="sort-data-in-table-storage"></a>Сортировка данных в табличном хранилище

Табличное хранилище возвращает результаты запроса, отсортированные в возрастающем порядке, на основе `PartitionKey`, а затем по `RowKey`.

> [!NOTE]
> Результаты запроса, возвращенные API таблиц Azure в Azure Cosmos DB, не сортируются по ключу секции или ключу строки. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от хранилища таблиц Azure?](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior).

Ключи в хранилище таблиц — это строковые значения. Чтобы обеспечить правильную сортировку числовых значений, необходимо преобразовать их в фиксированную длину и заполнить их нулями. Например, если значение идентификатора сотрудника, используемое в качестве `RowKey`, является целочисленным значением, необходимо преобразовать идентификатор сотрудника **123** в **00000123**. 

Многие приложения предъявляют требования к использованию данных, отсортированных в разных порядках. Например, сотрудники могут быть отсортированы по имена или по дате присоединения. Следующие шаблоны в разделе [шаблоны проектирования таблиц](#table-design-patterns) позволяют решать альтернативные порядки сортировки для сущностей.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с помощью разных значений `RowKey` (в одной секции). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.  
* [Шаблон вторичного индекса в разных секциях](#inter-partition-secondary-index-pattern). Храните несколько копий каждой сущности, используя разные значения `RowKey` в отдельных секциях в отдельных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.
* [Шаблон заключительного фрагмента журнала](#log-tail-pattern): получение *n* сущностей, недавно добавленных в секцию, с использованием `RowKey` значения, которое сортируется в обратную дату и время.  

## <a name="design-for-data-modification"></a>Разработка для изменения данных
В этом разделе рассматриваются вопросы разработки для оптимизации операций вставки, обновления и удаления. В некоторых случаях необходимо оценить компромисс между проектами, оптимизированными для выполнения запросов к проектам, которые оптимизируют изменение данных. Эта оценка похожа на то, что делается в разработке для реляционных баз данных (хотя методы управления компромиссами при проектировании различаются в реляционной базе данных). В разделе [шаблоны проектирования таблиц](#table-design-patterns) описаны некоторые подробные шаблоны проектирования для хранилища таблиц и приведены некоторые из этих компромиссов. На практике вы обнаружите, что многие разработки, оптимизированные для запросов сущностей, также хорошо подходят для изменения сущностей.  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>Оптимизация производительности операций вставки, обновления и удаления
Чтобы обновить или удалить сущность, ее необходимо распознать с помощью значений `PartitionKey` и `RowKey`. В этом отношении выбор `PartitionKey` и `RowKey` для изменения сущностей должен соответствовать выбранным критериям для поддержки запросов точек. Необходимо, чтобы сущности определялись как можно эффективнее. Вы не хотите использовать неэффективное сканирование секций или таблиц для поиска сущности, чтобы обнаружить `PartitionKey` и `RowKey` значения, которые необходимо обновить или удалить.  

Следующие шаблоны в разделе [шаблоны проектирования таблиц](#table-design-patterns) устраняют производительность операций вставки, обновления и удаления:  

* [Шаблон удаления большого объема](#high-volume-delete-pattern). Включите удаление большого объема сущностей, сохранив все сущности для одновременного удаления в отдельной таблице. Сущности удаляются путем удаления таблицы.  
* [Шаблон ряда данных](#data-series-pattern). Храните ряды данных в одной сущности, чтобы максимально сокращать количество запросов.  
* [Шаблон широких сущностей](#wide-entities-pattern): использование нескольких физических сущностей для хранения логических сущностей с более чем 252 свойствами.  
* [Шаблон крупных сущностей](#large-entities-pattern). Используйте хранилище BLOB-объектов для хранения больших значений свойств.  

### <a name="ensure-consistency-in-your-stored-entities"></a>Обеспечение согласованности хранимых сущностей
Другим фактором, который влияет на выбор ключей для оптимизации изменения данных, является обеспечение согласованности с помощью атомарных операций. Транзакции группы сущностей можно использовать только для работы с сущностями, хранящимися в одном разделе.  

Следующие шаблоны в разделе [шаблоны проектирования таблиц](#table-design-patterns) устраняют согласованность:  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с помощью разных значений `RowKey` (в одной секции). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.  
* [Шаблон вторичного индекса](#inter-partition-secondary-index-pattern)в разных разделах. Хранение нескольких копий каждой сущности с помощью различных `RowKey` значений в отдельных секциях или в отдельных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.  
* [Шаблон согласованных транзакций](#eventually-consistent-transactions-pattern). позволяет в конечном итоге повлиять на границы секций или границы системы хранения с помощью очередей Azure.
* [Шаблон сущностей индекса](#index-entities-pattern): ведение сущностей индекса для обеспечения эффективного поиска, возвращающего списки сущностей.  
* [Шаблон денормализации](#denormalization-pattern). Объедините связанные данные вместе в одной сущности, чтобы получить все необходимые данные с помощью одноточечного запроса.  
* [Шаблон ряда данных](#data-series-pattern): Храните все ряды данных в одной сущности, чтобы максимально сокращать количество запросов.  

Дополнительные сведения см. в разделе [транзакции группы сущностей](#entity-group-transactions) далее в этой статье.  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>Использование эффективных запросов в разработке для эффективных изменений
Во многих случаях разработка эффективных запросов способствует эффективным изменениям. Однако в каждом конкретном случае всегда следует проверять, так ли это. Некоторые закономерности в разделе [шаблоны проектирования таблиц](#table-design-patterns) позволяют явно оценивать компромиссы между запросами и изменением сущностей, при этом всегда следует учитывать количество операций каждого типа.  

Следующие шаблоны в разделе [шаблоны проектирования таблиц](#table-design-patterns) задают компромиссы между проектированием для эффективных запросов и проектированием эффективного изменения данных.  

* [Шаблон составного ключа](#compound-key-pattern). Используйте составные значения `RowKey`, чтобы разрешить клиенту выполнять поиск связанных данных с помощью одноточечного запроса.  
* [Шаблон заключительного фрагмента журнала](#log-tail-pattern): получение *n* сущностей, недавно добавленных в секцию, с использованием `RowKey` значения, которое сортируется в обратную дату и время.  

## <a name="encrypt-table-data"></a>Шифрование данных таблиц
Клиентская библиотека хранилища Azure .NET поддерживает шифрование свойств строковых сущностей для операций вставки и замены. Зашифрованные строки хранятся в службе как двоичные свойства и преобразуются обратно в строки после расшифровки.    

Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Либо укажите атрибут `EncryptProperty` (для сущностей POCO, производных от `TableEntity`), либо укажите сопоставитель шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который принимает ключ секции, ключ строки и имя свойства и возвращает логическое значение, указывающее, должно ли это свойство быть зашифровано. Во время шифрования клиентская библиотека использует эти сведения, чтобы решить, следует ли шифровать свойство при записи в канал. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если X, то зашифруйте свойство A; в противном случае зашифруйте свойства A и B.) Нет необходимости предоставлять эти сведения при чтении или запросе сущностей.

Слияние сейчас не поддерживается. Так как подмножество свойств может быть зашифровано ранее с помощью другого ключа, простое объединение новых свойств и обновление метаданных приведут к потери данных. При слиянии необходимо сделать лишние вызовы служб для считывания уже существующей сущности из службы или использовать новый ключ для каждого свойства. Ни один из них не подходит для повышения производительности.     

Сведения о шифровании данных таблицы см. в разделе [Шифрование на стороне клиента и Azure Key Vault для Служба хранилища Microsoft Azure](../storage/common/storage-client-side-encryption.md).  

## <a name="model-relationships"></a>Связи модели
Построение модели предметной области является одним из ключевых этапов при разработке комплексных систем. Как правило, процесс моделирования используется для определения сущностей и связей между ними в качестве способа понимания бизнес-домена и информирования разработчика системы. В этом разделе основное внимание уделяется тому, как можно преобразовать некоторые общие типы отношений, находящиеся в моделях предметной области, для проектирования хранилища таблиц. Процесс сопоставления логической модели данных с физической моделью данных на основе NoSQL отличается от процесса, используемого при проектировании реляционной базы данных. Структура реляционных баз данных обычно предполагает процесс нормализации данных, оптимизированный для минимизации избыточности. Такой подход также предполагает возможность декларативного запроса, который абстрагирует реализацию работы базы данных.  

### <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения "один-ко-многим" между бизнес-объектами являются распространенными. Например, в одном отделе работает много сотрудников. Существует несколько способов реализации связей "один ко многим" в хранилище таблиц, каждая с плюсами и минусами, которые могут быть важны для конкретного сценария.  

Рассмотрим пример крупной многонациональной корпорации с десятками тысяч отделов и сущностей сотрудников. Каждый отдел имеет много сотрудников, и каждый сотрудник связан с одним конкретным подразделением. Один из подходов состоит в хранении отдельных сущностей отдела и сотрудников, таких как следующие:  

![График, показывающий сущность отдела и сущность Employee][1]

В этом примере показана неявная связь "один ко многим" между типами на основе значения `PartitionKey`. В каждом отделе может работать много сотрудников.  

В этом примере также показана сущность отдела и связанные сущности сотрудников в одном разделе. Можно выбрать использование различных секций, таблиц или даже учетных записей хранения для различных типов сущностей.  

Альтернативный подход заключается в денормализации данных и хранении только сущностей сотрудников с денормализованными данными Отдела, как показано в следующем примере. В этом конкретном сценарии Денормализованный подход может быть не лучшим, если у вас есть требование изменить сведения о менеджере отдела. Для этого необходимо обновить всех сотрудников отдела.  

![Изображение сущности Employee][2]

Дополнительные сведения см. в разделе [Шаблон денормализации](#denormalization-pattern).  

В следующей таблице перечислены преимущества и недостатки каждого из подходов к хранению сущностей Employee и Department, имеющих связь «один ко многим». Следует также учитывать частоту выполнения различных операций. Может оказаться приемлемым наличие проекта, который включает дорогостоящую операцию, если эта операция происходит редко.  

<table>
<tr>
<th>Подход</th>
<th>Плюсы</th>
<th>Минусы</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Если требуется изменять сущность отдела при каждом обновлении, вставке или удалении сущности сотрудника, в целях обеспечения согласованности можно использовать транзакции группы сущностей. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий клиента может потребоваться получить сущность "сотрудник" и "Отдел".</li>
<li>Операции хранения выполняются в одном разделе. При больших объемах транзакций это может привести к появлению точки доступа.</li>
<li>Вы не можете переместить сотрудника в новый отдел с помощью транзакции группы СУЩНОСТЕЙ.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы или учетные записи хранения</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>При больших объемах транзакций это может способствовать распределению нагрузки между несколькими секциями.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий клиента может потребоваться получить сущность "сотрудник" и "Отдел".</li>
<li>EGT нельзя использовать для поддержания согласованности при обновлении, вставке или удалении сотрудника и обновлении отдела. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Вы не можете переместить сотрудника в новый отдел с помощью транзакции группы СУЩНОСТЕЙ.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Все необходимые данные можно извлечь с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Поддержание согласованности может быть дорогостоящим, если необходимо обновить сведения о отделе (для этого потребуется обновить всех сотрудников в отделе).</li>
</ul>
</td>
</tr>
</table>

Выбор между этими вариантами и наиболее значимых достоинств и недостатков зависит от конкретных сценариев приложений. Например, как часто изменяется сущность отдела? Требуются ли для всех запросов сотрудников дополнительные сведения о отделе? Насколько близко к ограничениям масштабируемости в секциях или вашей учетной записи хранения?  

### <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
Модели предметной области могут включать связи "один к одному" между сущностями. Если необходимо реализовать связь «один к одному» в хранилище таблиц, необходимо также выбрать способ связывания двух связанных сущностей, когда необходимо их извлечь. Эта ссылка может быть либо неявной, основанной на соглашении в ключевых значениях, либо явной, путем сохранения ссылки в форме `PartitionKey` и `RowKey` значений в каждой сущности в связанную с ней сущность. Сведения о необходимости хранения связанных сущностей в одном разделе см. в разделе [Отношения "один-ко-многим"](#one-to-many-relationships).  

Существуют также рекомендации по реализации, которые могут привести к реализации связей "один к одному" в хранилище таблиц:  

* Обработка больших сущностей (Дополнительные сведения см. в разделе [шаблон крупных сущностей](#large-entities-pattern)).  
* Реализация элементов управления доступом (Дополнительные сведения см. в разделе [Управление доступом с помощью подписанного](#control-access-with-shared-access-signatures)URL-доступа).  

### <a name="join-in-the-client"></a>Присоединение клиента
Хотя существуют способы моделирования связей в хранилище таблиц, не забывайте, что две простые причины для использования табличного хранилища — это масштабируемость и производительность. Если вы намерены моделировать много связей, которые нарушают производительность и масштабируемость вашего решения, следует попросить себя, если нужно создать все связи данных в структуре таблицы. Вы можете упростить разработку и повысить масштабируемость и производительность вашего решения, если позволить клиентскому приложению выполнять все необходимые объединения.  

Например, если имеются небольшие таблицы, содержащие данные, которые не меняются часто, можно получить эти данные один раз и кэшировать их на клиенте. Это позволит избежать повторяющихся циклические операций по извлечению одних и тех же данных. В примерах, которые мы рассматривали в этом разделе, набор отделов небольшой организации, скорее всего, будет небольшим и редко изменяться. Это позволяет получить хороший кандидат на данные, которые клиентское приложение может скачать один раз и кэшировать как уточняющие данные.  

### <a name="inheritance-relationships"></a>Отношения наследования
Если клиентское приложение использует набор классов, образующих часть отношения наследования для представления бизнес-сущностей, можно легко сохранить эти сущности в хранилище таблиц. Например, в клиентском приложении может быть определен следующий набор классов, где `Person` является абстрактным классом.

![Схема отношений наследования][3]

Экземпляры двух конкретных классов в хранилище таблиц можно сохранять с помощью одной `Person` таблицы. Используйте сущности, которые выглядят следующим образом:  

![График, отображающий сущность клиента и сущность Employee][4]

Дополнительные сведения о работе с несколькими типами сущностей в одной таблице в клиентском коде см. в разделе [Работа с разнородными типами сущностей](#work-with-heterogeneous-entity-types) далее в этом пошаговом окне. Там приводятся примеры определения типа сущности в клиентском коде.  

## <a name="table-design-patterns"></a>Шаблоны для разработки таблиц
В предыдущих разделах вы узнали, как оптимизировать структуру таблицы для получения данных сущности с помощью запросов, а также для вставки, обновления и удаления данных сущности. В этом разделе описываются некоторые шаблоны, подходящие для использования с хранилищем таблиц. Кроме того, вы увидите, как можно решить некоторые проблемы и компромиссы, которые были вызваны ранее в этом руководство. На следующей схеме показаны связи между различными шаблонами.  

![Схема шаблонов проектирования таблиц][5]

В схеме шаблона показаны некоторые связи между шаблонами (синим цветом) и антишаблонами (оранжевый), которые описаны в этом документе. Безусловно, существует множество других стоящих внимания шаблонов. Например, одним из ключевых сценариев для хранилища таблиц является использование [шаблона материализованных представлений](https://msdn.microsoft.com/library/azure/dn589782.aspx) из шаблона [разделения обязанностей для командных запросов](https://msdn.microsoft.com/library/azure/jj554200.aspx) .  

### <a name="intra-partition-secondary-index-pattern"></a>Шаблон вторичного индекса внутри раздела
Храните несколько копий каждой сущности, используя разные значения `RowKey` (в одной секции). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`. Обновления между копиями можно хранить согласованно с помощью EGT.  

#### <a name="context-and-problem"></a>Контекст и проблема
Табличное хранилище автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey`. Это позволяет клиентскому приложению эффективно извлекать сущность с помощью этих значений. Например, с помощью следующей табличной структуры клиентское приложение может использовать запрос к точке для получения отдельной сущности Employee, используя название отдела и идентификатор сотрудника (значения `PartitionKey` и `RowKey`). Клиент также может извлекать сущности, отсортированные по идентификатору сотрудника в каждом отделе.

![Изображение сущности Employee][6]

Если вы также хотите найти сущность Employee на основе значения другого свойства, например адреса электронной почты, необходимо использовать менее эффективное сканирование секций для поиска совпадения. Это связано с тем, что хранилище таблиц не предоставляет вторичные индексы. Кроме того, нет возможности запрашивать список сотрудников, отсортированных в порядке, отличном от порядка `RowKey`.  

#### <a name="solution"></a>Решение
Чтобы обойти недостаток вторичных индексов, можно сохранить несколько копий каждой сущности, при этом каждая копия будет использовать другое значение `RowKey`. При хранении сущности со следующими структурами можно эффективно получать сущности сотрудников на основе адреса электронной почты или идентификатора сотрудника. Значения префикса для `RowKey`, `empid_`и `email_` позволяют запрашивать одного сотрудника или диапазона сотрудников, используя диапазон адресов электронной почты или идентификаторов сотрудников.  

![График, отображающий сущность Employee с различными значениями RowKey][7]

Следующие два критерия фильтра (один поиск по ИДЕНТИФИКАТОРу сотрудника и один поиск по адресу электронной почты) указывают запросы точек:  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

При запросе диапазона сущностей Employee можно указать диапазон, отсортированный в порядке ИДЕНТИФИКАТОРов сотрудников, или диапазон, отсортированный в порядке адресов электронной почты. Запрос сущностей с соответствующим префиксом в `RowKey`.  

* Чтобы найти всех сотрудников отдела продаж с ИДЕНТИФИКАТОРом сотрудника в диапазоне от 000100 до 000199, используйте: $filter = (PartitionKey EQ ' Sales ') и (RowKey GE ' empid_000100 ') и (RowKey Le ' empid_000199 ').  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, начинающимся с буквы "a", используйте: $filter = (PartitionKey EQ "Sales") и (RowKey GE "email_a") и (RowKey lt "email_b")  
  
Синтаксис фильтра, используемый в предыдущих примерах, взят из REST API хранилища таблиц. Дополнительные сведения см. в разделе [сущности запросов](https://msdn.microsoft.com/library/azure/dd179421.aspx).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Табличное хранилище относительно недорого, поэтому издержки на хранение повторяющихся данных не должны быть существенными. Тем не менее следует всегда оценивать стоимость проекта на основе ожидаемых требований к хранилищу и добавлять только дублирующиеся сущности для поддержки запросов, которые будут выполняться клиентским приложением.  
* Поскольку сущности вторичного индекса хранятся в том же разделе, что и исходные сущности, убедитесь, что не превышены целевые показатели масштабируемости для отдельной секции.  
* Чтобы обеспечить согласованность повторяющихся сущностей, можно воспользоваться транзакциями группы сущностей (EGT) для автоматического обновления двух копий сущности. Это означает, что все копии сущности необходимо хранить в одном разделе. Дополнительные сведения см. в разделе [Использование транзакций группы сущностей](#entity-group-transactions).  
* Значение, используемое для `RowKey`, должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовых значений в `RowKey` (например, идентификатор сотрудника 000223) обеспечивает правильную сортировку и фильтрацию на основе верхней и нижней границ.  
* Вам не обязательно дублировать все свойства сущности. Например, если запросы, которые ищут сущности, используют адрес электронной почты в `RowKey` никогда не нуждаются в возрасте сотрудника, эти сущности могут иметь следующую структуру:

  ![Изображение сущности Employee][8]

* Как правило, лучше хранить дублирующиеся данные и обеспечить возможность извлечения всех необходимых данных с помощью одного запроса, чем использовать один запрос для поиска сущности, а другой — для поиска необходимых данных.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон в следующих случаях:

- Клиентское приложение должно получать сущности с помощью различных ключей.
- Клиент должен получить сущности в различных порядках сортировки.
- Каждую сущность можно найти с помощью различных уникальных значений.

Однако не превышайте ограничения масштабируемости секций при выполнении поиска сущностей с использованием разных значений `RowKey`.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон вторичного индекса в разных разделах;](#inter-partition-secondary-index-pattern)
* [Шаблон составного ключа;](#compound-key-pattern)
* [Транзакции группы сущностей](#entity-group-transactions)
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>Шаблон вторичного индекса в разных разделах
Храните несколько копий каждой сущности, используя разные значения `RowKey` в отдельных секциях или в отдельных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки, используя разные значения `RowKey`.  

#### <a name="context-and-problem"></a>Контекст и проблема
Табличное хранилище автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey`. Это позволяет клиентскому приложению эффективно извлекать сущность с помощью этих значений. Например, с помощью следующей табличной структуры клиентское приложение может использовать запрос к точке для получения отдельной сущности Employee, используя название отдела и идентификатор сотрудника (значения `PartitionKey` и `RowKey`). Клиент также может извлекать сущности, отсортированные по идентификатору сотрудника в каждом отделе.  

![Изображение сущности Employee][9]

Чтобы найти сущность сотрудника на основе другого свойства (например, адрес электронной почты), необходимо использовать менее эффективную функцию просмотра раздела. Это связано с тем, что хранилище таблиц не предоставляет вторичные индексы. Кроме того, нет возможности запрашивать список сотрудников, отсортированных в порядке, отличном от порядка `RowKey`.  

Вы ожидаете большой объем транзакций для этих сущностей и хотите снизить риск частоты хранения таблиц, ограничивающих ваш клиент.  

#### <a name="solution"></a>Решение
Чтобы обойти недостаток вторичных индексов, можно хранить несколько копий каждой сущности, каждый из которых использует разные `PartitionKey` и `RowKey` значения. При хранении сущности со следующими структурами можно эффективно получать сущности сотрудников на основе адреса электронной почты или идентификатора сотрудника. Префиксные значения для `PartitionKey`, `empid_`и `email_` позволяют выбрать индекс, который будет использоваться для запроса.  

![График, отображающий сущность Employee с первичным индексом и сущностью Employee с вторичным индексом][10]

Следующие два критерия фильтра (один поиск по ИДЕНТИФИКАТОРу сотрудника и один поиск по адресу электронной почты) указывают запросы точек:  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

При запросе диапазона сущностей Employee можно указать диапазон, отсортированный в порядке ИДЕНТИФИКАТОРов сотрудников, или диапазон, отсортированный в порядке адресов электронной почты. Запрос сущностей с соответствующим префиксом в `RowKey`.  

* Чтобы найти всех сотрудников отдела продаж с ИДЕНТИФИКАТОРом сотрудника в диапазоне от **000100** до **000199**, ОТСОРТИРОВАНного в порядке идентификаторов сотрудников, используйте: $Filter = (PartitionKey EQ "empid_Sales") и (RowKey GE "000100") и (RowKey Le "000199").  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, начинающимся с "a", отсортированного в порядке адресов электронной почты, используйте: $filter = (PartitionKey EQ "email_Sales") и (RowKey GE "a") и (RowKey lt "b").  

Обратите внимание, что синтаксис фильтра, используемый в предыдущих примерах, взят из REST API хранилища таблиц. Дополнительные сведения см. в разделе [сущности запросов](https://msdn.microsoft.com/library/azure/dd179421.aspx).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить согласованность копий сущностей, можно использовать [шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) для сущностей основного и вторичного индексов.  
* Табличное хранилище относительно недорого, поэтому издержки на хранение повторяющихся данных не должны быть существенными. Тем не менее следует всегда оценивать стоимость проекта на основе ожидаемых требований к хранилищу и добавлять только дубликаты сущностей для поддержки запросов, которые будут выполняться клиентским приложением.  
* Значение, используемое для `RowKey`, должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовых значений в `RowKey` (например, идентификатор сотрудника 000223) обеспечивает правильную сортировку и фильтрацию на основе верхней и нижней границ.  
* Вам не обязательно дублировать все свойства сущности. Например, если запросы, которые ищут сущности, используют адрес электронной почты в `RowKey` никогда не нуждаются в возрасте сотрудника, эти сущности могут иметь следующую структуру:
  
  ![График, отображающий сущность Employee с вторичным индексом][11]
* Как правило, лучше хранить дублирующиеся данные и обеспечить возможность извлечения всех необходимых данных с помощью одного запроса, а не использовать один запрос для поиска сущности с использованием вторичного индекса, а другой — для поиска необходимых данных в первичном индексе.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон в следующих случаях:

- Клиентское приложение должно получать сущности с помощью различных ключей.
- Клиент должен получить сущности в различных порядках сортировки.
- Каждую сущность можно найти с помощью различных уникальных значений.

Используйте этот шаблон, если вы хотите избежать превышения ограничений масштабируемости секций при выполнении поиска сущностей с использованием разных значений `RowKey`.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон вторичного индекса внутри раздела;](#intra-partition-secondary-index-pattern)  
* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>Шаблон для согласованных транзакций
Обеспечьте согласованное поведение в рамках границ раздела или границ системы хранения с помощью запросов Azure.  

#### <a name="context-and-problem"></a>Контекст и проблема
Транзакции группы сущностей приводят к выполнению атомарных транзакций в нескольких сущностях, использующих один общий ключ раздела. В целях повышения производительности и масштабируемости можно сохранить сущности с требованиями к согласованности в отдельных секциях или в отдельной системе хранения. В таком сценарии нельзя использовать EGT для поддержания согласованности. Например, может существовать требование к обеспечению согласованности между следующими элементами.  

* Сущности, хранящиеся в двух разных секциях одной таблицы, в разных таблицах или в разных учетных записях хранения.  
* Сущность, хранящаяся в хранилище таблиц, и большой двоичный объект, хранящийся в хранилище BLOB-объектов.  
* Сущность, хранящаяся в хранилище таблиц, и файл в файловой системе.  
* Сущность, хранящаяся в хранилище таблиц, но индексируемая с помощью Когнитивный поиск Azure.  

#### <a name="solution"></a>Решение
Используя очереди Azure, можно реализовать решение, обеспечивающее согласованность между двумя и более разделами или системами хранения.

Чтобы продемонстрировать этот подход, предположим, что у вас есть требование иметь возможность архивировать бывшие сущности сотрудников. Бывшие сущности сотрудников редко запрашиваются, и их следует исключить из любых действий, связанных с текущими сотрудниками. Для реализации этого требования вы храните активных сотрудников в **текущей** таблице и бывших сотрудниках в **архивной** таблице. Для архивации сотрудника необходимо удалить сущность из **текущей** таблицы и добавить сущность в **архивную** таблицу.

Но вы не можете использовать транзакции группы СУЩНОСТЕЙ для выполнения этих двух операций. Чтобы избежать риска отображения сущности в обеих таблицах или ни в одной из них в случае сбоя, операция архивации должна быть согласованной. Этапы этой операции приведены на следующей схеме.  

![Схема решения для итоговой согласованности][12]

Клиент инициирует операцию архивации, помещая сообщение в очередь Azure (в этом примере — в архив Employee #456). Рабочая роль опрашивает очередь на наличие новых сообщений. При обнаружении такого сообщения она читает сообщение и оставляет в очереди скрытую копию. Затем рабочая роль извлекает копию сущности из таблицы **Current**, вставляет копию в таблицу **Archive** и после этого удаляет исходную сущность из таблицы **Current**. Если предыдущие действия выполнены без ошибок, рабочая роль удаляет скрытое сообщения из очереди.  

В этом примере шаг 4 на схеме вставляет сотрудника в **архивную** таблицу. Он может добавить сотрудника в большой двоичный объект в хранилище BLOB-объектов или в файл в файловой системе.  

#### <a name="recover-from-failures"></a>Восстановление после сбоев
Важно, чтобы операции в шагах 4-5 на схеме *идемпотентными* в случае, если рабочей роли необходимо перезапустить операцию архивации. Если вы используете хранилище таблиц, для шага 4 следует использовать операцию вставки или замены. для шага 5 необходимо использовать операцию "удалить, если существует" в клиентской библиотеке, которую вы используете. Если вы используете другую систему хранения данных, необходимо использовать соответствующую операцию идемпотентными.  

Если Рабочая роль не завершает шаг 6 на схеме, то после истечения времени ожидания сообщение снова появится в очереди, готовой рабочей роли для ее повторной обработки. Рабочая роль может проверять, сколько раз прочитано сообщение в очереди, и при необходимости помечать его как «подозрительные» сообщения для расследования путем отправки в отдельную очередь. Дополнительные сведения о чтении сообщений очереди и проверке числа выводов из очереди см. в разделе [Получение сообщений](https://msdn.microsoft.com/library/azure/dd179474.aspx).  

Некоторые ошибки из хранилища таблиц и хранилища очередей являются временными ошибками, и клиентское приложение должно включать в себя подходящую логику повторных попыток для их обработки.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Это решение не обеспечивает изоляцию транзакций. Например, клиент может считывать **текущие** и **Архивные** таблицы, когда Рабочая роль находилась между шагами 4-5 на схеме и видеть несогласованное представление данных. В конечном счете данные будут согласованы.  
* Чтобы обеспечить окончательную согласованность, необходимо убедиться, что шаги 4-5 идемпотентными.  
* Для масштабирования решения можно использовать несколько очередей и экземпляров рабочих ролей.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, чтобы обеспечить согласованность между сущностями, которые существуют в различных разделах или таблицах. Этот шаблон можно расширить, чтобы обеспечить окончательную согласованность операций в хранилище таблиц и хранилище BLOB-объектов, а также в других источниках данных, не связанных с хранилищем Azure, таких как база данных или файловая система.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)  
* [Объединение или замена.](#merge-or-replace)  

> [!NOTE]
> Если для вашего решения важна изоляция транзакций, рассмотрите возможность перепроектирования таблиц для использования EGT.  
> 
> 

### <a name="index-entities-pattern"></a>Шаблон сущностей индекса
Поддерживайте сущности индексов для выполнения эффективных операций поиска, возвращающих списки сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Табличное хранилище автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey`. Это позволяет клиентскому приложению эффективно извлекать сущность с помощью запроса к точке. Например, с помощью следующей табличной структуры клиентское приложение может эффективно извлекать отдельные сущности сотрудников с помощью имени отдела и идентификатора сотрудника (`PartitionKey` и `RowKey`).  

![Изображение сущности Employee][13]

Если также требуется получить список сущностей сотрудников на основе значения другого свойства, не являющегося уникальным, например фамилии, необходимо использовать менее эффективное сканирование секций. Эта проверка находит совпадения, вместо того чтобы использовать индекс для непосредственного поиска. Это связано с тем, что хранилище таблиц не предоставляет вторичные индексы.  

#### <a name="solution"></a>Решение
Чтобы включить поиск по фамилии с помощью предыдущей структуры сущностей, необходимо сохранить списки идентификаторов сотрудников. Если вы хотите получить сущности сотрудников с определенным фамилией, например Jones, сначала необходимо найти список идентификаторов сотрудников для сотрудников с именем Jones в качестве фамилии, а затем извлечь эти сущности сотрудников. Существует три основных варианта хранения списков идентификаторов сотрудников:  

* Используйте хранилище BLOB-объектов.  
* Создание сущностей индексов в одном разделе с сущностями сотрудников.  
* Создание сущностей индексов в отдельном разделе или таблице.  

Вариант 1. Использование хранилища BLOB-объектов  

Создайте большой двоичный объект для каждого уникального фамилии, а в каждом BLOB-объекте — список значений `PartitionKey` (отдел) и `RowKey` (идентификатор сотрудника) для сотрудников с фамилией. При добавлении или удалении сотрудника убедитесь, что содержимое соответствующего большого двоичного объекта в конечном итоге согласуется с сущностями Employee.  

Вариант 2. Создание сущностей индекса в одной секции  

Используйте сущности индекса, которые хранят следующие данные:  

![Рисунок, показывающий сущность Employee, со строкой, содержащей список идентификаторов сотрудников с одинаковым фамилией][14]

Свойство `EmployeeIDs` содержит список идентификаторов сотрудников для сотрудников с последним именем, хранящимся в `RowKey`.  

Следующие шаги описывают процесс, который следует выполнить при добавлении нового сотрудника. В этом примере мы добавляем сотрудник с ИДЕНТИФИКАТОРом 000152 и фамилией Jones в отдел продаж:  

1. Получите сущность индекса со значением `PartitionKey` "Sales" и значением `RowKey` "Jones". Сохраните ETag это сущности для использования на шаге 2.  
2. Создайте транзакцию группы сущностей (то есть пакетную операцию), которая вставляет новую сущность Employee (`PartitionKey` значение "продажи" и `RowKey` значение "000152") и обновляет сущность индекса (`PartitionKey` значение "продажи" и `RowKey` значение "Jones"). ТРАНЗАКЦИИ группы СУЩНОСТЕЙ делает это, добавляя новый идентификатор сотрудника в список в поле EmployeeID. Дополнительные сведения о EGT см. в разделе [транзакции группы сущностей](#entity-group-transactions).  
3. Если транзакции группы СУЩНОСТЕЙ завершается сбоем из-за ошибки оптимистичного параллелизма (то есть кто-то другой изменил сущность index), необходимо начать с шага 1.  

Аналогичный подход можно использовать для удаления сотрудника, если используется второй вариант. Изменение фамилии сотрудника немного сложнее, так как вам нужно запустить транзакции группы СУЩНОСТЕЙ, обновляющий три сущности: сущность Employee, индекс сущности для старого фамилии и сущность индекса для нового фамилии. Необходимо извлечь каждую сущность перед внесением изменений, чтобы получить значения ETag, которые затем можно использовать для выполнения обновлений с помощью оптимистичного параллелизма.  

Следующие шаги описывают процесс, который следует выполнить, когда необходимо найти всех сотрудников с определенным фамилией в отделе. В этом примере мы ищем всех сотрудников с фамилией Jones в отделе продаж:  

1. Получите сущность индекса со значением `PartitionKey` "Sales" и значением `RowKey` "Jones".  
2. Проанализируйте список идентификаторов сотрудников в поле `EmployeeIDs`.  
3. Если вам нужны дополнительные сведения о каждом из этих сотрудников (например, их адреса электронной почты), извлеките каждую сущность сотрудников, используя `PartitionKey` значение "продажи", и `RowKey` значения из списка сотрудников, полученных на шаге 2.  

Вариант 3. Создание сущностей индекса в отдельной секции или таблице  

Для этого параметра используйте индексные сущности, в которых хранятся следующие данные:  

![Рисунок, показывающий сущность Employee, со строкой, содержащей список идентификаторов сотрудников с одинаковым фамилией][15]

Свойство `EmployeeIDs` содержит список идентификаторов сотрудников для сотрудников с последним именем, хранящимся в `RowKey`.  

EGT нельзя использовать для поддержания согласованности, поскольку сущности индекса находятся в отдельной секции из сущностей Employee. Убедитесь, что сущности индекса в конечном итоге согласуются с сущностями Employee.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Для этого решения требуется по крайней мере два запроса для получения совпадающих сущностей: один для запроса сущностей индекса для получения списка значений `RowKey`, а затем запросы для получения каждой сущности в списке.  
* Так как размер отдельной сущности не должен превышать 1 МБ, вариант 2 и вариант 3 в решении предполагают, что список идентификаторов сотрудников для каждого конкретного фамилии не превышает 1 МБ. Если список идентификаторов сотрудников, скорее всего, будет иметь размер более 1 МБ, используйте вариант 1 и храните данные индекса в хранилище BLOB-объектов.  
* Если вы используете вариант 2 (с помощью EGT для управления добавлением и удалением сотрудников и изменением фамилии сотрудника), необходимо оценить, будут ли объемы транзакций подходить к ограничениям масштабируемости в определенной секции. В этом случае следует рассмотреть однородное решение (вариант 1 или вариант 3). Они используют очереди для обработки запросов на обновление и позволяют хранить сущности индекса в отдельной секции из сущностей Employee.  
* Вариант 2 в этом решении предполагает, что вы хотите выполнить поиск по фамилии в отделе. Например, вы хотите получить список сотрудников с фамилией Jones в отделе продаж. Если требуется возможность поиска всех сотрудников с фамилией Jones в пределах всей Организации, используйте вариант 1 или 3.
* Можно реализовать решение на основе очереди, которое обеспечивает окончательную согласованность. Дополнительные сведения см. в статье [шаблон последовательного соответствия транзакций](#eventually-consistent-transactions-pattern).  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если нужно найти набор сущностей, которые имеют общее значение свойства, например все сотрудники с фамилией Jones.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>Шаблон денормализации
Объедините связанные данных в одной сущности для извлечения необходимых данных с помощью одного запроса точки.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных обычно выполняется нормализация данных для удаления дубликатов, происходящих, когда запросы получают данные из нескольких таблиц. Если нормализация данных осуществляется в таблицах Azure, для извлечения связанных данных требуется сделать несколько переходов от клиента к серверу и обратно. Например, в следующей таблице необходимо два круговых обращения для получения сведений о отделе. Один прием извлекает сущность «отдел», включающую идентификатор руководителя, а вторая поездка извлекает сведения об менеджере в сущности «Сотрудник».  

![Рисунок сущности отделов и сущностей сотрудников][16]

#### <a name="solution"></a>Решение
Вместо хранения данных в двух отдельных сущностях денормализуйте данные и сохраните копию со сведениями о руководителе в сущности отдела. Например:  

![Рисунок денормализованной и Объединенной сущности отдела][17]

С сущностями отдела, сохраненными с этими свойствами, теперь можно получить все необходимые сведения о отделе с помощью запроса к точке.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Двойное хранение некоторых данных связано с определенными издержками. Преимущество производительности, возникающее в результате меньшего количества запросов к хранилищу таблиц, обычно приводит к увеличению затрат на хранение. Кроме того, эта стоимость частично смещается на сокращение числа транзакций, которые требуются для получения сведений о подразделении.  
* Необходимо поддерживать согласованность двух сущностей, в которых хранятся сведения о руководителях. Можно справиться с проблемой согласованности, используя EGT для обновления нескольких сущностей в одной атомарной транзакции. В этом случае сущность «отдел» и сущность «сотрудник» для диспетчера отделов хранятся в одной секции.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимость поиска связанных данных возникает довольно часто. Этот шаблон уменьшает количество запросов, которые необходимо выполнить клиенту для извлечения требуемых данных.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>Шаблон составного ключа
Используйте составные значения `RowKey`, чтобы разрешить клиенту выполнять поиск связанных данных с помощью одноточечного запроса.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных естественно использовать объединения в запросах для возвращения связанных частей данных клиенту в одном запросе. Например, с помощью идентификатора сотрудника можно выполнить поиск списка связанных сущностей, которые содержат данные о производительности этого сотрудника.  

Предположим, что вы храните сущности сотрудников в хранилище таблиц, используя следующую структуру:  

![Изображение сущности Employee][18]

Кроме того, необходимо хранить исторические данные, касающиеся проверок и производительности за каждый год, когда сотрудник работал в вашей организации, и вам потребуется получить доступ к этим сведениям по годам. Одним из вариантов является создание другой таблицы, в которой хранятся сущности со следующей структурой.  

![Рисунок сущности проверки сотрудника][19]

При таком подходе может быть решено дублировать некоторые сведения (например, имя и фамилию) в новой сущности, чтобы вы могли получать данные с помощью одного запроса. Однако невозможно обеспечить строгую согласованность, поскольку нельзя использовать транзакции группы СУЩНОСТЕЙ для одновременного обновления двух сущностей.  

#### <a name="solution"></a>Решение
Сохраните новый тип сущности в исходной таблице с помощью сущностей со следующей структурой:  

![Рисунок сущности Employee с составным ключом][20]

Обратите внимание, что `RowKey` теперь является составным ключом, состоящие из идентификатора сотрудника и года данных проверки. Это позволяет получить данные о производительности и проверке данных сотрудника с помощью одного запроса для одной сущности.  

В следующем примере показан процесс извлечения всех отчетных данных по конкретному сотруднику (например, сотрудник 000123 из отдела продаж).  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Следует использовать подходящий символ-разделитель, который упрощает анализ `RowKey`ого значения: например, **000123_2012**.  
* Эта сущность также сохраняется в том же разделе, что и другие сущности, которые содержат связанные данные для одного и того же сотрудника. Это означает, что вы можете использовать EGT для обеспечения строгой согласованности.
* Следует учитывать частоту запросов данных, чтобы определить, подходит ли этот шаблон. Например, при нечастом доступе к данным проверки и основных данных о сотрудниках их следует размещать как отдельные сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо сохранить одну или несколько связанных часто запрашиваемых сущностей.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>Шаблон для заключительного фрагмента журнала
Извлечение *n* сущностей, недавно добавленных в секцию, с помощью `RowKey` значения, которое сортируется в обратную дату и время.  

> [!NOTE]
> Результаты запроса, возвращенные API таблиц Azure в Azure Cosmos DB, не сортируются по ключу секции или ключу строки. Таким же подходом, хотя этот шаблон подходит для хранилища таблиц, он не подходит для Azure Cosmos DB. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от Хранилища таблиц Azure?](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior).

#### <a name="context-and-problem"></a>Контекст и проблема
Общее требование заключается в необходимости иметь возможность извлекать последние созданные сущности. Например, десять последних заявок на возмещение сотрудникам. Запросы таблиц поддерживают `$top` операцию запроса для возврата первых *n* сущностей из набора. Нет эквивалентной операции запроса для возврата последних *n* сущностей в наборе.  

#### <a name="solution"></a>Решение
Храните сущности с помощью `RowKey`, который естественным образом сортирует в обратную сортировку по дате и времени, поэтому самая последняя запись всегда является первой в таблице.  

Например, чтобы извлечь десять самых последних заявок на возмещение расходов, отправленных сотрудниками, можно использовать обратное значение тика, являющееся производным от текущей даты и времени. В следующем C# примере кода показан один из способов создания подходящего значения "Инвертированные такты" для `RowKey`, которая сортирует от самой последней до самой старой:  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

Вы можете вернуться к значению даты и времени, используя следующий код:  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

Табличный запрос выглядит следующим образом.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Необходимо запустить обратную шкалу с начальными нулями, чтобы значение строки было упорядочено так, как ожидалось.  
* Необходимо соблюдать целевые показатели масштабирования на уровне раздела. Будьте внимательны, чтобы не создавать секции с активной точки.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо получить доступ к сущностям в обратную сортировку по дате и времени или когда необходимо получить доступ к последним добавленным сущностям.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Анти-шаблон, предусматривающий добавление в начало или конец;](#prepend-append-anti-pattern)  
* [Получение сущностей](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>Шаблон для удаления больших объемов сущностей
Включите удаление большого объема сущностей, сохранив все сущности для одновременного удаления в отдельной таблице. Сущности удаляются путем удаления таблицы.  

#### <a name="context-and-problem"></a>Контекст и проблема
Многие приложения удаляют старые данные, которые больше не требуются для клиентского приложения. Кроме того, данные могут удаляться при архивации приложения на другой носитель. Как правило, эти данные определяются по датам. Например, имеется требование удалять записи всех запросов на вход, которые устарели более 60 дней.  

Одна из возможных структур — использовать дату и время запроса на вход в `RowKey`:  

![Рисунок сущности попытки входа][21]

Такой подход позволяет избежать точек доступа к секциям, так как приложение может вставлять и удалять сущности входа для каждого пользователя в отдельной секции. Однако при наличии большого количества сущностей такой подход может быть дорогостоящим и длительным. Во-первых, необходимо выполнить просмотр таблицы, чтобы найти все удаляемые сущности, а затем удалить каждую старую сущность. Количество переходов к серверу, необходимых для удаления старых сущностей, можно сократить путем пакетной вставки нескольких запросов на удаление в EGT.  

#### <a name="solution"></a>Решение
Используйте отдельную таблицу для каждого дня, когда предпринимаются попытки входа в систему. Вы можете использовать предыдущий проект сущности, чтобы избежать гиперобъектов при вставке сущностей. Удаление старых сущностей теперь представляет собой вопрос об удалении одной таблицы каждый день (операция с одной операцией хранения) вместо поиска и удаления сотен и тысяч отдельных сущностей входа каждый день.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Поддерживает ли ваш проект другие способы использования данных приложением, например поиск конкретных сущностей, связывание с другими данными или создание статистических данных?  
* Ваш проект предотвращает формирование активных областей в случае вставки новых сущностей?  
* Повторное использование того же имени таблицы после его удаления связано с определенной задержкой. Рекомендуется всегда использовать уникальные имена таблиц.  
* При первом использовании новой таблицы требуется ограничение скорости, а в хранилище таблиц — шаблоны доступа и распределение секций между узлами. Рекомендуется определить периодичность создания новых таблиц.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон при наличии большого количества сущностей для одновременного удаления.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)
* [Изменение сущностей](#modify-entities)  

### <a name="data-series-pattern"></a>Шаблон для рядов данных
Чтобы сократить количество выполняемых запросов, храните ряды данных в одной сущности.  

#### <a name="context-and-problem"></a>Контекст и проблема
Возьмем распространенный сценарий, когда приложение сохраняет ряды данных, которые требуется извлечь все сразу. Например, приложение может записывать количество сообщений, ежечасно отправляемых каждым сотрудником, а затем использовать эти сведения для отображения количества сообщений, отправленных каждым пользователем за предыдущие 24 часа. Для хранения 24 сущностей для каждого сотрудника можно разработать одну структуру.  

![Изображение сущности «Статистика сообщений»][22]

В ней можно без труда находить и обновлять сущности для каждого сотрудника каждый раз, когда приложению требуется обновить значение количества сообщений. Однако чтобы извлечь данные для построения графика активности за предыдущие 24 часа, потребуется извлечь 24 сущности.  

#### <a name="solution"></a>Решение
Используйте следующую конструкцию с отдельным свойством для хранения числа сообщений за каждый час:  

![Рисунок с сущностью статистики сообщений с разделенными свойствами][23]

В этом случае вы сможете обновлять количество сообщений по сотруднику за определенный час с помощью операции объединения. Теперь можно получить всю информацию, необходимую для построения диаграммы, с помощью запроса для одной сущности.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Если весь ряд данных не умещается в одну сущность (сущность может иметь до 252 свойств), используйте альтернативное хранилище данных, например BLOB-объект.  
* Если несколько клиентов одновременно обновляют сущность, используйте **ETag** для реализации оптимистичного параллелизма. При наличии большого числа клиентов может возникнуть высокая конкуренция.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо обновить и получить ряды данных, связанных с отдельной сущностью.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для сущностей больших размеров](#large-entities-pattern)  
* [Объединение или замена.](#merge-or-replace)  
* [Шаблон непротиворечивой транзакции](#eventually-consistent-transactions-pattern) (если вы храните ряды данных в большом двоичном объекте)  

### <a name="wide-entities-pattern"></a>Шаблон для масштабных сущностей
Чтобы сохранить сущности, имеющие более 252 свойств, используйте несколько физических сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельная сущность может иметь не более 252 свойств (исключая обязательные системные свойства) и не может хранить более 1 МБ данных в целом. В реляционной базе данных обычно используются любые ограничения на размер строки путем добавления новой таблицы и реализации связи «один к одному» между ними.  

#### <a name="solution"></a>Решение
С помощью хранилища таблиц можно хранить несколько сущностей, представляющих один большой бизнес-объект с более чем 252 свойствами. Например, если необходимо хранить количество сообщений IM, отправленных каждым сотрудником за последние 365 дней, можно использовать следующую конструкцию, использующую две сущности с разными схемами:  

![Рисунок с сущностью статистики сообщений с RowKey 01 и сущностью статистики сообщений с RowKey 02][24]

Если необходимо внести изменение, требующее обновления обеих сущностей для обеспечения их синхронизации, воспользуйтесь транзакциями группы сущностей. В противном случае можно выполнить одну операцию объединения, которая позволит обновить количество сообщений за определенный день. Чтобы получить все данные для отдельного сотрудника, необходимо получить обе сущности. Это можно сделать с помощью двух эффективных запросов, которые используют как `PartitionKey`, так и значение `RowKey`.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о том, как реализовать этот шаблон, рассмотрим следующий момент:  

* Извлечение логической сущности целиком связано с выполнением как минимум двух операций с хранилищем: одна для извлечения каждой физической сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо хранить сущности, размер или количество свойств которых превышает ограничения для отдельной сущности в хранилище таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)
* [Объединение или замена.](#merge-or-replace)

### <a name="large-entities-pattern"></a>Шаблон для сущностей больших размеров
Используйте хранилище BLOB-объектов для хранения больших значений свойств.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельная сущность не может хранить более 1 МБ данных в целом. Если одно или несколько свойств хранят значения, которые приводят к тому, что общий размер сущности превысит это значение, вы не сможете хранить всю сущность в хранилище таблиц.  

#### <a name="solution"></a>Решение
Если размер сущности превышает 1 МБ, так как одно или несколько свойств содержат большой объем данных, вы можете хранить данные в хранилище BLOB-объектов, а затем хранить адрес большого двоичного объекта в свойстве сущности. Например, вы можете сохранить фотографию сотрудника в хранилище BLOB-объектов и сохранить ссылку на фотографию в свойстве `Photo` сущности Employee:  

![Рисунок, показывающий сущность Employee со строкой для фотографии, указывающей на хранилище BLOB-объектов][25]

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы сохранить окончательную согласованность между сущностью в хранилище таблиц и данными в хранилище BLOB-объектов, используйте [шаблон согласованных транзакций](#eventually-consistent-transactions-pattern) для обслуживания сущностей.
* Для извлечения полной сущности требуется как минимум две транзакции хранилища: одна для извлечения сущности и одна для извлечения данных большого двоичного объекта.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо хранить сущности, размер которых превышает ограничения для отдельной сущности в хранилище таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон для масштабных сущностей.](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>Анти-шаблон, предусматривающий добавление в начало или конец
При наличии большого объема операций вставки увеличьте масштабируемость путем распределения вставок по нескольким секциям.  

#### <a name="context-and-problem"></a>Контекст и проблема
Как правило, добавление сущностей в начало или конец хранящихся сущностей приводит к тому, что приложение будет добавлять новые сущности к первому или последнему разделу в последовательности разделов. В этом случае все операции вставки в определенный момент времени выполняются в одной секции, создавая активную область. Это позволяет не добиваться хранения таблиц с балансировки нагрузки на несколько узлов и, возможно, привести к тому, что приложение достигнет целевых показателей масштабируемости для секции. Например, рассмотрим случай приложения, которое регистрирует доступ к сети и ресурсам для сотрудников. Структура сущности, подобная приведенной ниже, может привести к тому, что Секция текущего часа станет активной областью, если объем транзакций достигает целевой цели масштабируемости для отдельной секции:  

![Изображение сущности Employee][26]

#### <a name="solution"></a>Решение
Следующая альтернативная структура сущностей позволяет избежать точки доступа к какой-либо конкретной секции, так как приложение регистрирует события:  

![Рисунок, показывающий сущность Employee с RowKeyом года, месяца, дня, часа и идентификатора события][27]

Обратите внимание на этот пример того, как `PartitionKey` и `RowKey` являются составными ключами. `PartitionKey` использует как отдел, так и идентификатор сотрудника для распределения журнала по нескольким секциям.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Альтернативная структура ключа, которая предотвращает создание разделов с высокой нагрузкой во время выполнения операций вставки, поддерживает запросы, выполняемые клиентским приложением?  
* Означает ли ожидаемый объем транзакций, то, что вы, вероятно, достигли целевых показателей масштабируемости для отдельных секций и регулируете хранилищем таблиц?  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Не рекомендуется использовать относительный шаблон в начале или в конце, если объем транзакций, скорее всего, приведет к ограничению скорости хранилища таблиц при доступе к горячей секции.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для заключительного фрагмента журнала;](#log-tail-pattern)  
* [Изменение сущностей](#modify-entities)  

### <a name="log-data-anti-pattern"></a>Анти-шаблон для данных журнала
Как правило, для хранения данных журнала следует использовать хранилище BLOB-объектов вместо хранилища таблиц.  

#### <a name="context-and-problem"></a>Контекст и проблема
Распространенным вариантом использования данных журнала является получение выбранных записей журнала для определенного диапазона дат и времени. Например, необходимо найти все ошибки и критические сообщения, которые приложение зарегистрировало между 15:04 и 15:06, на определенную дату. Вы не хотите использовать дату и время сообщения журнала, чтобы определить секцию, в которой сохраняются сущности журнала. Это приводит к тому, что в любой момент времени все сущности журнала будут совместно использовать одно и то же значение `PartitionKey` (см. [отпечаток в начале или в конце](#prepend-append-anti-pattern)). Например, следующая схема сущности для сообщения журнала приводит к постановке в горячую секцию, так как приложение записывает все сообщения журнала в секцию для текущей даты и часа:  

![Рисунок объекта сообщения журнала][28]

В этом примере `RowKey` содержит дату и время сообщения журнала, чтобы сообщения журнала были отсортированы в порядке даты и времени. `RowKey` также содержит идентификатор сообщения, в случае, если несколько сообщений журнала имеют одинаковую дату и время.  

Другой подход заключается в использовании `PartitionKey`, который гарантирует, что приложение записывает сообщения в диапазон секций. Например, если источник сообщения журнала предоставляет способ распределения сообщений по нескольким секциям, можно использовать следующую схему сущности:  

![Рисунок объекта сообщения журнала][29]

Однако проблема, связанная с этой схемой, заключается в том, что для извлечения всех сообщений журнала за указанный промежуток времени необходимо выполнить поиск в каждой секции в таблице.

#### <a name="solution"></a>Решение
В предыдущем разделе была выделена проблема использования хранилища таблиц для хранения записей журнала и предлагаются два неудовлетворительных проекта. Одно решение привело к горячей секции с риском низкой производительности при написании сообщений журнала. Другое решение привело к ухудшению производительности запросов из-за необходимости сканировать каждую секцию в таблице для получения сообщений журнала за указанный промежуток времени. Хранилище BLOB-объектов предлагает лучшее решение для этого типа сценария, и именно в нем хранятся собираемые данные журналов в Azure Storage Analytics.  

В этом разделе описано, как аналитика хранилища хранит данные журнала в хранилище BLOB-объектов, как показано в этом подходе к хранению данных, которые обычно запрашиваются по диапазону.  

Аналитика хранилища хранит сообщения журнала в формате с разделителями в нескольких больших двоичных объектах. Формат с разделителями упрощает анализ данных в сообщениях журнала.  

Аналитика хранилища использует соглашение об именовании для больших двоичных объектов, которое позволяет найти большой двоичный объект (или большие двоичные объекты), содержащий сообщения журнала, для которых выполняется поиск. Например, большой двоичный объект с именем "Queue/2014/07/31/1800/000001. log" содержит сообщения журнала, относящиеся к службе очередей в течение часа, начиная с 18:00 31 июля 2014 г. «000001» означает первый файл журнала за этот период. Аналитика хранилища также записывает метки времени первого и последнего сообщений журнала, хранящихся в файле, в составе метаданных большого двоичного объекта. API для хранилища BLOB-объектов позволяет размещать большие двоичные объекты в контейнере на основе префикса имени. Чтобы разместить все большие двоичные объекты, содержащие данные журнала очереди за час, начиная с 18:00, можно использовать префикс "Queue/2014/07/31/1800".  

Storage Analytics помещает сообщения в журнал внутренним образом, а затем периодически обновляет соответствующий большой двоичный объект или создает новый, используя последний пакет записей журнала. Это сокращает число операций записи, которые он должен выполнять в хранилище BLOB-объектов.  

Если вы реализуете аналогичное решение в своем приложении, подумайте, как управлять компромиссом между надежностью и затратами и масштабируемостью. Иными словами, оцените результат записи всех записей журнала в хранилище BLOB-объектов по сравнению с буферизацией обновлений в приложении и их записи в хранилище BLOB-объектов в пакетах.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При выборе способа хранения данных журнала, необходимо учитывать следующие моменты.  

* Если вы создаете структуру таблицы, которая позволяет избежать возможных активных секций, может оказаться, что вы не сможете эффективно обращаться к данным журнала.  
* Для обработки данные журнала клиенту часто требуется загружать много записей.  
* Несмотря на то что данные журнала часто структурированы, хранилище BLOB-объектов может быть лучшим решением.  

### <a name="implementation-considerations"></a>Рекомендации по реализации
В этом разделе рассматриваются некоторые вопросы, которые необходимо иметь в виду при реализации моделей, описанных в предыдущих разделах. В большей части этого раздела приводятся примеры на языке C#, в которых используется клиентская библиотека хранилища(версия 4.3.0 на момент написания данного руководства).  

### <a name="retrieve-entities"></a>Получение сущностей
Как упоминалось в разделе [Разработка для запросов](#design-for-querying), самый эффективный запрос — точечный. Однако в некоторых сценариях может потребоваться получить несколько сущностей. В этом разделе описываются некоторые распространенные подходы к извлечению сущностей с помощью клиентской библиотеки хранилища.  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>Выполнение запроса к точке с помощью клиентской библиотеки хранилища
Самый простой способ выполнить запрос к точке — использовать операцию **извлечения** таблицы. Как показано в следующем C# фрагменте кода, эта операция извлекает сущность с `PartitionKey` значением "Sales", а `RowKey` значение "212":  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

Обратите внимание, что в этом примере сущность, которую он извлекает, имеет тип `EmployeeEntity`.  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>Получение нескольких сущностей с помощью LINQ
Вы можете получить несколько сущностей с помощью LINQ с клиентской библиотекой хранилища и указать запрос с предложением **WHERE** . Чтобы избежать просмотра таблицы, следует всегда включать значение `PartitionKey` в предложение WHERE и, если возможно, `RowKey` значение, чтобы избежать просмотра таблиц и секций. Хранилище таблиц поддерживает ограниченный набор операторов сравнения (больше, больше или равно, меньше, меньше или равно, равно и не равно) для использования в предложении WHERE. В следующем C# фрагменте кода выполняется поиск всех сотрудников, фамилия которых начинается с "B" (при условии, что `RowKey` сохраняет фамилию) в отделе продаж (при условии, что `PartitionKey` сохраняет название отдела):  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

Обратите внимание, что запрос указывает как `RowKey`, так и `PartitionKey`, чтобы обеспечить лучшую производительность.  

В следующем примере кода показана эквивалентная функциональность с помощью API-интерфейса Fluent (Дополнительные сведения о интерфейсах API Fluent см. в разделе [рекомендации по проектированию API Fluent](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> В примере вложены несколько методов `CombineFilters` для включения трех условий фильтра.  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>Получение большого количества сущностей из запроса
Оптимальный запрос возвращает отдельную сущность на основе значения `PartitionKey` и значения `RowKey`. Однако в некоторых сценариях может потребоваться возврат множества сущностей из одной и той же секции или даже из нескольких секций. В таких случаях следует полностью протестировать производительность приложения.  

Запрос к хранилищу таблиц может возвращать не более 1 000 сущностей за один раз и выполняться не более пяти секунд. Табличное хранилище Возвращает токен продолжения, чтобы клиентское приложение запрашивало следующий набор сущностей, если выполняется одно из следующих условий.

- Результирующий набор содержит более 1 000 сущностей.
- Запрос не завершился в течение пяти секунд.
- Запрос пересекает границу секции. 

Дополнительные сведения о том, как работают маркеры продолжения, см. в разделе [время ожидания запроса и разбивка на страницы](https://msdn.microsoft.com/library/azure/dd135718.aspx).  

Если вы используете клиентскую библиотеку хранилища, она может автоматически выполнять маркеры продолжения, так как она возвращает сущности из хранилища таблиц. Например, следующий C# пример кода автоматически обрабатывает маркеры продолжения, если хранилище таблиц возвращает их в ответе:  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

Следующий код C# обрабатывает маркеры продолжения явным образом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

Явное использование маркеров продолжения позволяет управлять извлечением следующего сегмента данных. Например, если клиентское приложение позволяет пользователям пролистывать сущности, хранящиеся в таблице, пользователь может принять решение не пролистывать все сущности, полученные запросом. Приложение будет использовать токен продолжения только для получения следующего сегмента, когда пользователь завершил разбиение по страницам всех сущностей в текущем сегменте. Такой подход имеет несколько преимуществ.  

* Можно ограничить объем данных, получаемых из хранилища таблиц и перемещаемых по сети.  
* В .NET можно выполнять асинхронный ввод-вывод.  
* Токен продолжения можно сериализовать в постоянное хранилище, чтобы можно было продолжать работу в случае сбоя приложения.  

> [!NOTE]
> Маркер продолжения обычно возвращает сегмент, содержащий 1 000 сущностей, хотя он может содержать меньшее значение. Это также происходит, если ограничить количество записей, возвращаемых запросом, с помощью инструкции **Take** для возврата первых n сущностей, соответствующих условиям поиска. Хранилище таблиц может возвращать сегмент, содержащий менее n сущностей, а также токен продолжения, позволяющий получить оставшиеся сущности.  
> 
> 

Следующий код C# демонстрирует процесс изменения количества возвращаемых сущностей в сегменте.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>Проекция на стороне сервера
Одна сущность может иметь до 255 свойств и быть размером не более 1 МБ. При запросе таблицы и извлечении сущностей могут потребоваться не все свойства, и можно избежать передачи данных без необходимости (чтобы сократить задержку и стоимость). Проекции на стороне сервера можно использовать для передачи только необходимых свойств. В следующем примере извлекается только свойство `Email` (вместе с `PartitionKey`, `RowKey`, `Timestamp`и `ETag`) из сущностей, выбранных запросом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

Обратите внимание, что значение `RowKey` доступно, даже если оно не включено в список извлекаемых свойств.  

### <a name="modify-entities"></a>изменение сущностей.
Клиентская библиотека хранилища позволяет изменять сущности, хранящиеся в хранилище таблиц, путем вставки, удаления и обновления сущностей. EGT можно использовать для пакетной обработки нескольких операций вставки, обновления и удаления, чтобы уменьшить количество требуемых круговых путей и повысить производительность решения.  

Исключения, создаваемые при запуске клиентской библиотеки хранилища транзакции группы СУЩНОСТЕЙ, обычно включают в себя индекс сущности, вызвавшей сбой пакета. Это может оказаться полезным при отладке кода, использующего транзакции группы сущностей.  

Следует также учитывать влияние разработки на то, каким образом клиентское приложение обрабатывает операций параллелизма и обновления.  

#### <a name="managing-concurrency"></a>Управление параллелизмом
По умолчанию хранилище таблиц реализует проверки оптимистического параллелизма на уровне отдельных сущностей для операций вставки, слияния и удаления, хотя клиент может принудительно использовать табличное хранилище для обхода этих проверок. Дополнительные сведения см. [в разделе Управление параллелизмом в Служба хранилища Microsoft Azure](../storage/common/storage-concurrency.md).  

#### <a name="merge-or-replace"></a>Объединение или замена.
Метод `Replace` класса `TableOperation` всегда заменяет полную сущность в хранилище таблиц. Если не включить в запрос свойство, если оно существует в хранимой сущности, запрос удаляет это свойство из хранимой сущности. Каждое свойство требуется в включать в запрос до тех пор, пока оно явным образом не будет удалено из хранимой сущности.  

Можно использовать метод `Merge` класса `TableOperation`, чтобы уменьшить объем данных, отправляемых в хранилище таблиц, когда требуется обновить сущность. Метод `Merge` заменяет все свойства в хранимой сущности значениями свойств из сущности, входящей в запрос. Этот метод оставляет без изменений все свойства в хранимой сущности, которые не включаются в запрос. Это полезно, если у вас есть крупные сущности, и требуется только обновить небольшое количество свойств в запросе.  

> [!NOTE]
> Методы `*Replace` и `Merge` завершаются ошибкой, если сущность не существует. В качестве альтернативы можно использовать методы `InsertOrReplace` и `InsertOrMerge`, которые создают новую сущность, если она не существует.  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>Работа с разнородными типами сущностей
Хранилище таблиц — это хранилище таблиц *без схемы* . Это означает, что одна таблица может хранить сущности нескольких типов, что обеспечивает большую гибкость в разработке. В следующем примере показана таблица, в которой хранятся сущности сотрудников и отделов.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Каждая сущность по-прежнему должна иметь значения `PartitionKey`, `RowKey`и `Timestamp`, но может иметь любой набор свойств. Кроме того, нет ничего указывать тип сущности, если вы не решите хранить эту информацию где-то еще. Существует два варианта определения типа сущности.  

* Добавьте в начало типа сущности `RowKey` (или, возможно, `PartitionKey`). Например, `EMPLOYEE_000123` или `DEPARTMENT_SALES` как значения `RowKey`.  
* Используйте отдельное свойство для записи типа сущности, как показано в следующей таблице.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>отдел;</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Время существования</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Первый параметр, добавляющий тип сущности к `RowKey`, полезен, если существует вероятность того, что две сущности разных типов могут иметь одинаковое значение ключа. Кроме того, он позволяет объединять сущности одного типа в раздел.  

Методики, описанные в этом разделе, особенно важны для обсуждения[отношений наследования](#inheritance-relationships).  

> [!NOTE]
> Рекомендуется включить номер версии в значение типа сущности, чтобы обеспечить клиентским приложениям возможность развивать объекты POCO и работать с различными версиями.  
> 
> 

В оставшейся части этого раздела описываются некоторые функции клиентской библиотеки хранилища, которые упрощают работу с несколькими типами сущностей в одной таблице.  

#### <a name="retrieve-heterogeneous-entity-types"></a>Извлечение разнородных типов сущностей
Если вы используете клиентскую библиотеку хранилища, у вас есть три варианта работы с несколькими типами сущностей.  

Если известно, какой тип сущности хранится с конкретными `RowKey` и `PartitionKey` значениями, то можно указать тип сущности при извлечении сущности. Вы видели это в предыдущих двух примерах, получающих сущности типа `EmployeeEntity`: [выполнение запроса точки с помощью клиентской библиотеки хранилища](#run-a-point-query-by-using-the-storage-client-library) и [Получение нескольких сущностей с помощью LINQ](#retrieve-multiple-entities-by-using-linq).  

Второй вариант — использовать тип `DynamicTableEntity` (контейнер свойств) вместо конкретного типа сущности POCO. Этот параметр также может повысить производительность, так как нет необходимости выполнять сериализацию и десериализовать сущность в типы .NET. Следующий C# код потенциально получает несколько сущностей различных типов из таблицы, но возвращает все сущности как экземпляры `DynamicTableEntity`. Затем для определения типа каждой сущности используется свойство `EntityType`.  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

Чтобы получить другие свойства, необходимо использовать метод `TryGetValue` в свойстве `Properties` класса `DynamicTableEntity`.  

Третьим вариантом является объединение с использованием типа `DynamicTableEntity` и экземпляра `EntityResolver`. Он позволяет выполнять разрешение в несколько типов POCO в рамках одного запроса. В этом примере делегат `EntityResolver` использует свойство `EntityType`, чтобы различать два типа сущности, возвращаемые запросом. Метод `Resolve` использует делегат `resolver` для разрешения экземпляров `DynamicTableEntity` в `TableEntity` экземпляры.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>Изменение разнородных типов сущностей
Вам не нужно знать тип сущности для ее удаления, и вы всегда узнаете тип сущности при его вставке. Однако можно использовать тип `DynamicTableEntity` для обновления сущности, не зная ее тип, и без использования класса сущности POCO. Следующий пример кода извлекает одну сущность и проверяет, существует ли свойство `EmployeeCount`, прежде чем обновлять его.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>Управление доступом с помощью подписанных URL
Маркеры подписанного URL-адрес (SAS) можно использовать для того, чтобы клиентские приложения могли напрямую изменять (и запрашивать) сущности таблиц, не требуя непосредственного выполнения проверки подлинности в хранилище таблиц. Существует три основных преимущества использования SAS в приложении.  

* Вам не нужно распространять ключ учетной записи хранения на небезопасную платформу (например, на мобильное устройство), чтобы разрешить этому устройству доступ к сущностям в хранилище таблиц и их изменение.  
* Вы можете разгрузить некоторую работу, которую выполняет веб-роли и рабочие задачи при управлении сущностями. Можно выполнить разгрузку на клиентские устройства, такие как компьютеры конечных пользователей и мобильные устройства.  
* Для клиента можно назначить ограниченный набор разрешений с ограничением по времени и ограниченное время, например разрешить доступ только для чтения к конкретным ресурсам.  

Дополнительные сведения об использовании токенов SAS с хранилищем таблиц см. в разделе использование подписанных URL-адресов [(SAS)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).  

Тем не менее необходимо по-прежнему создавать маркеры SAS, которые предоставляют клиентскому приложению доступ к сущностям в табличном хранилище. Это можно сделать в среде, которая имеет безопасный доступ к ключам учетной записи хранения. Как правило, для создания маркеров SAS их доставки в клиентские приложения, которым требуется доступ к сущностям, используются веб-роли или рабочие роли. Поскольку процесс создания маркеров SAS и их доставки клиентов по-прежнему связан с издержками, рекомендуется рассмотреть оптимальные варианты сокращения расходов в сценариях с большим количеством операций.  

Можно создать маркер SAS, который предоставляет доступ к подмножеству сущностей в таблице. По умолчанию создается маркер SAS для всей таблицы. Но можно также указать, чтобы маркер SAS предоставил доступ либо к диапазону значений `PartitionKey`, либо к диапазону `PartitionKey` и `RowKey` значений. Вы можете создать маркеры SAS для отдельных пользователей системы, чтобы маркер SAS каждого пользователя допускает доступ только к собственным сущностям в хранилище таблиц.  

### <a name="asynchronous-and-parallel-operations"></a>Асинхронные и параллельные операции
Чтобы улучшить производительность и время отклика клиента в случае распределения запросов по нескольким разделам, рекомендуется обратить внимание на асинхронные и параллельные запросы.
Например, в вашем распоряжении может быть два или несколько экземпляров рабочих ролей с параллельным доступом к таблицам. Можно иметь отдельные рабочие роли, ответственные за определенные наборы секций, или просто иметь несколько экземпляров рабочей роли, каждый из которых может получить доступ ко всем секциям в таблице.  

В экземпляре клиента можно повысить пропускную способность, выполняя операции хранилища асинхронно. Клиентская библиотека хранилища упрощает написание асинхронных запросов и изменений. Например, вы можете начать с синхронного метода, который получает все сущности в секции, как показано в следующем C# коде:  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

Этот код можно легко изменить, чтобы запрос выполнялся асинхронно, как показано ниже.  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Сигнатура метода теперь включает модификатор `async` и возвращает экземпляр `Task`.  
* Вместо вызова метода `ExecuteSegmented` для получения результатов метод теперь вызывает метод `ExecuteSegmentedAsync`. Метод использует модификатор `await` для асинхронного получения результатов.  

Клиентское приложение может вызывать этот метод несколько раз с разными значениями параметра `department`. Каждый запрос выполняется в отдельном потоке.  

В классе `TableQuery` нет асинхронной версии метода `Execute`, так как интерфейс `IEnumerable` не поддерживает асинхронное перечисление.  

Можно вставлять, обновлять и удалять сущности в асинхронном режиме. В следующем примере кода C# показан простой синхронный метод вставки или замены сущности сотрудника.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

Этот код можно легко изменить, чтобы обновление выполнялось асинхронно, как показано ниже.  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Сигнатура метода теперь включает модификатор `async` и возвращает экземпляр `Task`.  
* Вместо вызова метода `Execute` для обновления сущности метод теперь вызывает метод `ExecuteAsync`. Метод использует модификатор `await` для асинхронного получения результатов.  

Клиентское приложение может вызывать несколько асинхронных методов, таких как этот, и каждый вызов метода выполняется в отдельном потоке.  


[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

