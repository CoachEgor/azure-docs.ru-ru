---
title: Секционирование данных в API Gremlin для Azure Cosmos DB | Документация Майкрософт
description: Узнайте, как в Azure Cosmos DB можно использовать секционированный граф. В этой статье также описываются требования и рекомендации для секционированного графа.
author: luisbosquez
ms.author: lbosq
ms.service: cosmos-db
ms.subservice: cosmosdb-graph
ms.topic: conceptual
ms.date: 06/24/2019
ms.custom: seodec18
ms.openlocfilehash: 4c8761d82c8a735ac9c4bff2e5ac0107b2a57fe0
ms.sourcegitcommit: 084630bb22ae4cf037794923a1ef602d84831c57
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/03/2019
ms.locfileid: "67537533"
---
# <a name="using-a-partitioned-graph-in-azure-cosmos-db"></a>Использование секционированного графа в Azure Cosmos DB

Одной из ключевых функций API Gremlin в Azure Cosmos DB является способность обрабатывать крупномасштабные графы с помощью горизонтального масштабирования. С точки зрения хранилища и пропускной способности контейнеры можно масштабировать независимо друг от друга. В Azure Cosmos DB можно создавать контейнеры, которые можно автоматически масштабировать, чтобы хранить данные графа. Данные автоматически балансируются на основе указанного **ключа секции**.

**Секционирование необходимо**, если контейнер будет хранить больше чем 10 ГБ или если необходимо выделить более чем 10 000 единиц запросов в секунду (ЕЗ). Те же общие принципы из [механизм секционирования в Azure Cosmos DB](partition-data.md) распространяются, имеющие несколько реализаций определенных graph, описанных ниже.

![Секционирование данных Graph.](./media/graph-partitioning/graph-partitioning.png)

## <a name="graph-partitioning-mechanism"></a>Граф, механизм секционирования

Следующие рекомендации показывают, как работает стратегию секционирования в Azure Cosmos DB:

- **Вершины и ребра хранятся в виде документов JSON**.

- **Для вершин требуется ключ секции**. Этот ключ определяет, в какой секции будет храниться вершина, с использованием алгоритма хэширования. Имя свойства ключа секции определяется при создании нового контейнера, и он имеет формат: `/partitioning-key-name`.

- **Ребра будут храниться вместе с их исходной вершиной**. Другими словами, для каждой вершины ключ секции определяет их место хранения вместе с ее исходящими ребрами. Эта оптимизация делается во избежание межсекционных запросов при использовании `out()` количества элементов в запросах графа.

- **Границы содержат ссылки на вершины, они указывают**. Все ребра хранятся с помощью ключей разделов и идентификаторы вершин, которые они указывают. Это вычисление делает все `out()` направление запросов всегда быть областью действия секционированного запроса и не людей с нарушениями зрения запрос между секциями. 

- **В запросах графа необходимо задавать ключ секции**. Чтобы воспользоваться всеми преимуществами горизонтального секционирования в Azure Cosmos DB, ключ секции необходимо по возможности указывать всякий раз, когда выбирается одна вершина. Ниже приведены запросы для выбора одной или нескольких вершин в секционированном графе:

    - `/id` и `/label` не поддерживаются в качестве ключей секции для контейнера в API Gremlin.


    - Выбор вершины по идентификатору, затем **использование шага `.has()` для указания свойства ключа секции**: 
    
        ```java
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - Выбор вершины путем **указания кортежа, включая значение ключа секции и идентификатор**: 
    
        ```java
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - Указание **массива кортежей значений ключей секций и идентификаторов**:
    
        ```java
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - Выбор набора вершин и их идентификаторы и **определения списка значений ключа раздела**: 
    
        ```java
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

    - С помощью **стратегии секционирования** в начале запроса и указания секции в рамках оставшейся части запроса Gremlin: 
    
        ```java
        g.withStrategies(PartitionStrategy.build().partitionKey('partitionKey').readPartitions('partitionKey_value').create()).V()
        ```

## <a name="best-practices-when-using-a-partitioned-graph"></a>Рекомендации при использовании секционированного графа

Следуйте приведенным ниже рекомендациям, чтобы обеспечить производительность и масштабируемость при использовании секционированных графов с контейнерами с неограниченным хранилищем.

- **Всегда указывайте значение ключа секции при запросе вершины**. Чтобы получить возможность повысить производительность, получите вершины из известной секции. Все последующие смежных операции всегда попадает в секцию краев включают ссылку идентификатор и ключ секции для их вершинами целевой объект.

- **По возможности используйте исходящее направление при запросе ребер**. Как упоминалось выше, ребра хранятся с их исходными вершинами в исходящем направлении. Поэтому, вероятность повторной сортировки межсекционных запросов сведена к минимуму, когда данные и запросы разработаны с ориентацией на этот шаблон. Напротив `in()` запрос всегда будет дорогостоящим развертываемый запрос.

- **Выберите ключ секции, который равномерно распределяет данные по секциям**. Это решение сильно зависит от модели данных решения. Дополнительные сведения о создании соответствующего ключа секции см. в статье [Секционирование и масштабирование в Azure Cosmos DB](partition-data.md).

- **Оптимизируйте запросы для получения данных в пределах секции**. Оптимальной стратегией секционирования является согласование с шаблонами запросов. Запросы для получения данных из одной секции обеспечивают наилучшую производительность.

## <a name="next-steps"></a>Дальнейшие действия

Затем можно ознакомиться со следующими статьями:

* Дополнительные сведения о [секционировании и масштабировании в Azure Cosmos DB](partition-data.md).
* Дополнительные сведения о [поддержке Gremlin в API Gremlin](gremlin-support.md).
* [Общие сведения об API Gremlin](graph-introduction.md).
