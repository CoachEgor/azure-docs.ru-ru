---
title: Секционирование данных в API Gremlin для Azure Cosmos DB | Документация Майкрософт
description: Узнайте, как в Azure Cosmos DB можно использовать секционированный граф. В этой статье также описываются требования и рекомендации для секционированного графа.
author: luisbosquez
ms.author: lbosq
ms.service: cosmos-db
ms.subservice: cosmosdb-graph
ms.topic: how-to
ms.date: 06/24/2019
ms.custom: seodec18
ms.openlocfilehash: 78c15da1ea9fe5f6307ce388e4d64d372e9eb8c8
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2020
ms.locfileid: "85261772"
---
# <a name="using-a-partitioned-graph-in-azure-cosmos-db"></a>Использование секционированного графа в Azure Cosmos DB

Одной из ключевых функций API Gremlin в Azure Cosmos DB является способность обрабатывать крупномасштабные графы с помощью горизонтального масштабирования. С точки зрения хранилища и пропускной способности контейнеры можно масштабировать независимо друг от друга. В Azure Cosmos DB можно создавать контейнеры, которые можно автоматически масштабировать, чтобы хранить данные графа. Данные автоматически балансируются на основе указанного **ключа секции**.

**Секционирование требуется** , если предполагается, что контейнер хранит более 20 ГБ памяти, или если требуется выделить более 10 000 единиц запросов в секунду (RUs). Те же общие принципы использования [механизма секционирования Azure Cosmos DB](partition-data.md) применяются с помощью нескольких оптимизаций, связанных с графиком, описанных ниже.

:::image type="content" source="./media/graph-partitioning/graph-partitioning.png" alt-text="Секционирование графа." border="false":::

## <a name="graph-partitioning-mechanism"></a>Механизм секционирования графа

Следующие рекомендации описывают, как действует стратегия секционирования в Azure Cosmos DB.

- **Вершины и ребра хранятся в виде документов JSON**.

- **Для вершин требуется ключ секции**. Этот ключ определяет, в какой секции будет храниться вершина, с использованием алгоритма хэширования. Имя свойства ключа секции определяется при создании нового контейнера и имеет формат: `/partitioning-key-name` .

- **Ребра будут храниться вместе с их исходной вершиной**. Другими словами, для каждой вершины ключ секции определяет их место хранения вместе с ее исходящими ребрами. Эта оптимизация выполняется во избежание межсекционных запросов при использовании `out()` количества элементов в запросах Graph.

- **Края содержат ссылки на вершины, на которые они указывают**. Все грани хранятся с ключами секций и идентификаторами вершин, на которые они указывают. Это вычисление делает все `out()` запросы направления всегда выделяться секционированным запросом с областью, а не с помощью скрытого межсекционного запроса. 

- **В запросах графа необходимо задавать ключ секции**. Чтобы воспользоваться всеми преимуществами горизонтального секционирования в Azure Cosmos DB, ключ секции необходимо по возможности указывать всякий раз, когда выбирается одна вершина. Ниже приведены запросы для выбора одной или нескольких вершин в секционированном графе:

    - `/id` и `/label` не поддерживаются в качестве ключей секции для контейнера в API Gremlin.


    - Выбор вершины по идентификатору, затем **использование шага `.has()` для указания свойства ключа секции**: 
    
        ```java
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - Выбор вершины путем **указания кортежа, включая значение ключа секции и идентификатор**: 
    
        ```java
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - Указание **массива кортежей значений ключей секций и идентификаторов**:
    
        ```java
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - Выбор набора вершин с их идентификаторами и **Указание списка значений ключа секции**: 
    
        ```java
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

    - Использование **стратегии секционирования** в начале запроса и указание секции для области остальной части запроса Gremlin: 
    
        ```java
        g.withStrategies(PartitionStrategy.build().partitionKey('partitionKey').readPartitions('partitionKey_value').create()).V()
        ```

## <a name="best-practices-when-using-a-partitioned-graph"></a>Рекомендации при использовании секционированного графа

Следуйте приведенным ниже рекомендациям, чтобы обеспечить производительность и масштабируемость при использовании секционированных графов с контейнерами с неограниченным хранилищем.

- **Всегда указывайте значение ключа секции при запросе вершины**. Чтобы получить возможность повысить производительность, получите вершины из известной секции. Все последующие операции с соседями будут всегда находиться в области видимости секции, поскольку границы содержат идентификатор ссылки и ключ секции для целевых вершин.

- **По возможности используйте исходящее направление при запросе ребер**. Как упоминалось выше, ребра хранятся с их исходными вершинами в исходящем направлении. Поэтому, вероятность повторной сортировки межсекционных запросов сведена к минимуму, когда данные и запросы разработаны с ориентацией на этот шаблон. В противоположность этому, `in()` запрос всегда будет дорогостоящим.

- **Выберите ключ секции, который будет равномерно распределять данные по секциям**. Это решение сильно зависит от модели данных решения. Дополнительные сведения о создании соответствующего ключа секции см. в статье [Секционирование и масштабирование в Azure Cosmos DB](partition-data.md).

- **Оптимизируйте запросы для получения данных в пределах секции**. Оптимальной стратегией секционирования является согласование с шаблонами запросов. Запросы для получения данных из одной секции обеспечивают наилучшую производительность.

## <a name="next-steps"></a>Дальнейшие шаги

Затем можно ознакомиться со следующими статьями:

* Дополнительные сведения о [секционировании и масштабировании в Azure Cosmos DB](partition-data.md).
* Дополнительные сведения о [поддержке Gremlin в API Gremlin](gremlin-support.md).
* [Общие сведения об API Gremlin](graph-introduction.md).
