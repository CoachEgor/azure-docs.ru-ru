---
title: Секционирование данных в API Gremlin для Azure Cosmos DB | Документация Майкрософт
description: Узнайте, как в Azure Cosmos DB можно использовать секционированный граф. В этой статье также описываются требования и рекомендации для секционированного графа.
author: luisbosquez
ms.author: lbosq
ms.service: cosmos-db
ms.subservice: cosmosdb-graph
ms.topic: conceptual
ms.date: 06/24/2019
ms.custom: seodec18
ms.openlocfilehash: 44d3b7c2b9e23b90f696162747d9728b18fb7d3f
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "77623376"
---
# <a name="using-a-partitioned-graph-in-azure-cosmos-db"></a>Использование секционированного графа в Azure Cosmos DB

Одной из ключевых функций API Gremlin в Azure Cosmos DB является способность обрабатывать крупномасштабные графы с помощью горизонтального масштабирования. С точки зрения хранилища и пропускной способности контейнеры можно масштабировать независимо друг от друга. В Azure Cosmos DB можно создавать контейнеры, которые можно автоматически масштабировать, чтобы хранить данные графа. Данные автоматически балансируются на основе указанного **ключа секции**.

**Раздел требуется,** если контейнер, как ожидается, хранить более 20 ГБ в размере или если вы хотите выделить более 10000 единиц запроса в секунду (RUs). Те же общие принципы из [механизма раздела Azure Cosmos DB](partition-data.md) применяются с несколькими графическими оптимизациями, описанными ниже.

![Графная перегородка.](./media/graph-partitioning/graph-partitioning.png)

## <a name="graph-partitioning-mechanism"></a>Механизм расставания графика

Ниже приведены рекомендации, описывающие, как работает стратегия раздела в Azure Cosmos DB:

- **Вершины и ребра хранятся в виде документов JSON**.

- **Для вершин требуется ключ секции**. Этот ключ определяет, в какой секции будет храниться вершина, с использованием алгоритма хэширования. Имя ключа раздела определяется при создании нового контейнера и `/partitioning-key-name`имеет формат: .

- **Ребра будут храниться вместе с их исходной вершиной**. Другими словами, для каждой вершины ключ секции определяет их место хранения вместе с ее исходящими ребрами. Эта оптимизация выполняется для предотвращения запросов перекрестного раздела при использовании `out()` кардинальности в запросах графика.

- **Края содержат ссылки на вершины, на которые они указывают.** Все края хранятся с ключами перегородки и идентизациями вертики, на которые они указывают. Эта вычисления `out()` всегда делает все запросы направления масштабированным разделенным запросом, а не слепым запросом перекрестного раздела. 

- **В запросах графа необходимо задавать ключ секции**. Чтобы воспользоваться всеми преимуществами горизонтального секционирования в Azure Cosmos DB, ключ секции необходимо по возможности указывать всякий раз, когда выбирается одна вершина. Ниже приведены запросы для выбора одной или нескольких вершин в секционированном графе:

    - `/id` и `/label` не поддерживаются в качестве ключей секции для контейнера в API Gremlin.


    - Выбор вершины по идентификатору, затем **использование шага `.has()` для указания свойства ключа секции**: 
    
        ```java
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - Выбор вершины путем **указания кортежа, включая значение ключа секции и идентификатор**: 
    
        ```java
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - Указание **массива кортежей значений ключей секций и идентификаторов**:
    
        ```java
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - Выбор набора головоретов с их идентизацией и **указание списка ключевых значений раздела:** 
    
        ```java
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

    - Использование **стратегии раздела** в начале запроса и указание раздела для сферы остальной части запроса Gremlin: 
    
        ```java
        g.withStrategies(PartitionStrategy.build().partitionKey('partitionKey').readPartitions('partitionKey_value').create()).V()
        ```

## <a name="best-practices-when-using-a-partitioned-graph"></a>Рекомендации при использовании секционированного графа

Следуйте приведенным ниже рекомендациям, чтобы обеспечить производительность и масштабируемость при использовании секционированных графов с контейнерами с неограниченным хранилищем.

- **Всегда указывайте значение ключа секции при запросе вершины**. Чтобы получить возможность повысить производительность, получите вершины из известной секции. Все последующие операции adjacency всегда будут присваиваться разделу, так как edges содержат идентификатор ссылки и ключ раздела к их целевым вершинам.

- **По возможности используйте исходящее направление при запросе ребер**. Как упоминалось выше, ребра хранятся с их исходными вершинами в исходящем направлении. Поэтому, вероятность повторной сортировки межсекционных запросов сведена к минимуму, когда данные и запросы разработаны с ориентацией на этот шаблон. Напротив, `in()` запрос всегда будет дорогим запросом вентилятора.

- **Выберите ключ раздела, который равномерно распределит данные по разделам.** Это решение сильно зависит от модели данных решения. Дополнительные сведения о создании соответствующего ключа секции см. в статье [Секционирование и масштабирование в Azure Cosmos DB](partition-data.md).

- **Оптимизируйте запросы для получения данных в пределах секции**. Оптимальной стратегией секционирования является согласование с шаблонами запросов. Запросы для получения данных из одной секции обеспечивают наилучшую производительность.

## <a name="next-steps"></a>Дальнейшие действия

Затем можно ознакомиться со следующими статьями:

* Дополнительные сведения о [секционировании и масштабировании в Azure Cosmos DB](partition-data.md).
* Дополнительные сведения о [поддержке Gremlin в API Gremlin](gremlin-support.md).
* [Общие сведения об API Gremlin](graph-introduction.md).
