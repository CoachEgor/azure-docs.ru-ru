---
title: Управление параллелизмом
titleSuffix: Azure Storage
description: Узнайте, как управлять параллелизмом в службе хранилища Azure для служб BLOB-объектов, очередей, таблиц и файлов. Ознакомьтесь с тремя основными используемыми стратегиями параллелизма данных.
services: storage
author: tamram
ms.service: storage
ms.devlang: dotnet
ms.topic: conceptual
ms.date: 12/20/2019
ms.author: tamram
ms.subservice: common
ms.custom: devx-track-csharp
ms.openlocfilehash: b83a8bfbc79af344c4d158ee65134034db714e9c
ms.sourcegitcommit: 400f473e8aa6301539179d4b320ffbe7dfae42fe
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/28/2020
ms.locfileid: "92783969"
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a>Управление параллелизмом в службе хранилища Microsoft Azure

В современных интернет-приложениях данные обычно могут одновременно просматриваться и обновляться несколькими пользователями. Разработчикам приложений необходимо тщательно подумать о предоставлении предсказуемого взаимодействия с пользователем, особенно в тех случаях, когда несколько пользователей могут обновлять одни и те же данные. Обычно разработчики рассматривают три следующие основные стратегии конфликтов данных:

1. Оптимистическая блокировка — приложение, которое выполняет обновление, в рамках обновления проверяет, изменились ли данные с момента последнего считывания этих данных приложением. Например, если два пользователя, просматривающие вики-страницу, обновляют одну и ту же страницу, то платформа вики-страниц должна гарантировать, что второе обновление не перезапишет первое обновление — и что оба пользователя понимают, было ли обновление успешным. Стратегия наиболее часто применяется в веб-приложениях.
2. Пессимистическая блокировка — приложение, которое ищет обновление, заблокирует объект, предотвращая обновление данных другими пользователями до тех пор, пока блокировка не будет снята.
3. Последний модуль записи WINS — подход, позволяющий продолжать любые операции обновления, не проверяя, обновлялись ли данные другими приложениями, так как приложение сначала считывает данные. Эта стратегия часто используется при секционировании данных, поэтому не существует вероятность того, что несколько пользователей получат доступ к одним и тем же данным. Она также применяется при обработке кратковременных потоков данных.

В этой статье приводятся общие сведения о том, как служба хранилища Azure упрощает разработку за счет поддержки всех трех этих стратегий параллелизма.

## <a name="azure-storage-simplifies-cloud-development"></a>Служба хранилища Azure упрощает облачную разработку

Служба хранилища Azure поддерживает все три стратегии, хотя она позволяет обеспечить полную поддержку оптимистичного и пессимистического параллелизма. Служба хранилища Azure разработана так, чтобы обеспечить надежную модель согласованности, гарантируя, что при фиксации операции вставки или обновления данных все последующие обращения к этим данным будут видеть Последнее обновление. На платформах хранения, использующих окончательную модель согласованности, возникает задержка между выполнением записи одним пользователем и тем, когда новые пользователи могут видеть обновленные данные.

Разработчики также должны иметь в виду, как платформа хранения изолирует изменения, в особенности изменения одного и того же объекта для транзакций. Служба хранилища Azure использует изоляцию моментального снимка, чтобы разрешить выполнение операций чтения параллельно с операциями записи в пределах одной секции. В отличие от других уровней изоляции, изоляция моментального снимка гарантирует видимость операциям чтения только согласованных моментальных снимков данных даже при их обновлении, возвращая, по сути, в процессе обновления последние фиксированные значения.

## <a name="managing-concurrency-in-blob-storage"></a>Управление параллелизмом в хранилище BLOB-объектов

Вы можете выбрать модель оптимистического или пессимистичного параллелизма для управления доступа к BLOB-объектам и контейнерам службы BLOB-объектов. Если стратегия не указана явным образом, по умолчанию используется последняя запись WINS.

### <a name="optimistic-concurrency-for-blobs-and-containers"></a>Оптимистичный параллелизм для BLOB-объектов и контейнеров

Служба хранилища присваивает идентификатор каждому сохраненному объекту. Этот идентификатор обновляется каждый раз, когда операция обновления выполняется над объектом. Идентификатор возвращается клиенту в качестве ответа HTTP GET с помощью заголовка ETag (тег объекта), определенного в протоколе HTTP. Пользователь, выполняющий обновление такого объекта, может отправить в исходной ETag вместе с условным заголовком, чтобы гарантировать, что обновление будет происходить только при выполнении определенного условия. в данном случае условие является заголовком "If-Match", который требует, чтобы служба хранилища сохранила значение ETag, указанное в запросе на обновление, так же, как оно хранится в службе хранилища.

Для этой команды используется следующая структура:

1. Извлеките BLOB-объект из службы хранилища, ответ содержит значение заголовка HTTP ETag, указывающее текущую версию объекта в службе хранилища.
2. При обновлении BLOB-объекта включите полученное после выполнения шага 1 значение ETag в условный заголовок **If-Match** запроса, отправляемого вами в службу.
3. Служба сравнивает значение ETag запроса с текущим значением ETag BLOB-объекта.
4. Если текущее значение ETag BLOB-объекта отличается от ETag в условном заголовке запроса **If-Match** , служба возвращает клиенту ошибку 412. Эта ошибка указывает клиенту, что другой процесс обновил большой двоичный объект с момента его получения клиентом.
5. Если текущее значение ETag BLOB-объекта совпадает со значением ETag в условном заголовке запроса **If-Match** , служба выполняет запрошенную операцию и обновляет текущее значение ETag BLOB-объекта, указывая тем самым на создание новой версии.

Следующий фрагмент C#-кода (с использованием клиентской библиотеки хранилища версии 4.2.0) является простым примером того, как построить **If-Match AccessCondition** , основанное на значении ETag, доступном из свойств извлеченного или вставленного до этого BLOB-объекта. Затем он использует объект **AccessCondition** при обновлении большого двоичного объекта: объект **AccessCondition** добавляет заголовок **If-Match** к запросу. Если произошло обновление BLOB-объекта другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено). Полный пример доступен на [этой странице](https://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage Blob service which returns the ETag in response.
string originalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No ETag provided so original blob is overwritten (thus generating a new ETag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the original ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using original ETag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(originalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's original ETag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}
```

Служба хранилища Azure также включает поддержку условных заголовков, таких как **If-Modified-, с** , если-без **изменений, с** , **Если-None-Match** , и комбинации этих заголовков. Дополнительные сведения см. в статье [Указание условных заголовков для операций службы BLOB-объектов](/rest/api/storageservices/Specifying-Conditional-Headers-for-Blob-Service-Operations).

В таблице содержится свод операций с контейнером, принимающих в запросе такие условные заголовки, как **If-Match** и возвращающих в ответе значение ETag.

| Операция | Возврат значения ETag для контейнера | Принятие дополнительных заголовков |
|:--- |:--- |:--- |
| Create Container (Создание контейнера) |Да |нет |
| Get Container Properties (Получение свойств контейнера) |Да |нет |
| Get Container Metadata (Получение метаданных контейнера) |Да |нет |
| Set Container Metadata (Определение метаданных контейнера) |Да |Да |
| Get Container ACL (Получение списка управления доступом для контейнера) |Да |нет |
| Set Container ACL (Задание списка управления доступом для контейнера) |Да |Да (*) |
| Delete Container (Удаление контейнера) |нет |Да |
| Lease Container (Аренда контейнера) |Да |Да |
| List Blobs (Отображение списка BLOB-объектов) |нет |Нет |

(*) Разрешения, определенные в SetContainerACL, кэшируются, и обновления этих разрешений выполняются через 30 секунд, в течение которых обновления периода не гарантированно согласованы.

В таблице содержится свод операций с BLOB-объектами, принимающих в запросе такие условные заголовки, как **If-Match** и возвращающих в ответе значение ETag.

| Операция | Returns ETag value (Возврат значения ETag) | Принятие дополнительных заголовков |
|:--- |:--- |:--- |
| Put BLOB (Вставка BLOB-объекта) |Да |Да |
| Get BLOB (Получение BLOB-объекта) |Да |Да |
| Get BLOB Properties (Получение свойств BLOB-объекта) |Да |Да |
| Set BLOB Properties (Задание свойств службы BLOB-объекта) |Да |Да |
| Get BLOB Metadata (Получение метаданных BLOB-объекта) |Да |Да |
| Set BLOB Metadata (Задание метаданных BLOB-объекта) |Да |Да |
| Lease Blob (Аренда BLOB-объекта) (*) |Да |Да |
| Создание моментального снимка большого двоичного объекта |Да |Да |
| Копирование BLOB-объекта |Да |Да (для исходного и целевого большого двоичного объекта) |
| Прерывание копирования большого двоичного объекта |нет |нет |
| Delete BLOB (Удаление BLOB-объекта) |нет |Да |
| Put Block (Вставка блокировки) |нет |нет |
| Put Block List (Вставка списка блокировки) |Да |Да |
| Get Block List (Получение списка блокировки) |Да |нет |
| Put Page (Вставка страницы) |Да |Да |
| Get Page Ranges (Получение диапазона страницы) |Да |Да |

(*) BLOB-объект аренды не изменяет ETag в большом двоичном объекте.

### <a name="pessimistic-concurrency-for-blobs"></a>Пессимистичный параллелизм для BLOB-объектов

Чтобы заблокировать большой двоичный объект для монопольного использования, получите [аренду](/rest/api/storageservices/Lease-Blob) на него. При получении аренды необходимо указать период времени для аренды. Период времени в диапазоне от 15 до 60 секунд или бесконечности, который составляет монопольную блокировку. Продлите конечную аренду, чтобы продлить ее. Освободите аренду, когда завершите работу с ней. Хранилище BLOB-объектов автоматически освобождает конечные аренды по истечении срока их действия.

Аренда позволяет поддерживать различные стратегии синхронизации. К таким стратегиям относятся *Монопольная запись, чтение* , *монопольная* запись и *монопольное чтение.* Если Аренда существует, служба хранилища Azure принудительно применяет монопольные операции записи (вставки, установки и удаления), но при этом исключительные права для операций чтения требует от разработчика гарантировать, что все клиентские приложения используют идентификатор аренды и что только один клиент в каждый момент времени имеет действительный идентификатор аренды. Операции чтения, которые не включают идентификатор аренды, приводят к общим операциям чтения.

Следующий фрагмент C#-кода является примером получения на 30 секунд монопольной аренды на BLOB-объект, обновления содержимого BLOB-объекта и освобождения от аренды. Если при попытке получить новую аренду в большом двоичном объекте уже есть действительная Аренда, Служба BLOB-объектов возвращает результат состояния "HTTP (409) конфликт". Следующий фрагмент кода использует объект **AccessCondition** , чтобы инкапсулировать данные аренды, когда он выполняет запрос на обновление большого двоичного объекта в службе хранилища.  Полный пример доступен на [этой странице](https://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}
```

Если вы пытаетесь совершить операцию записи на арендованном BLOB-объекте, не идентифицировав аренду, неудавшийся запрос возвращается с ошибкой 412. Если срок действия аренды истекает до вызова метода **UploadText** , но вы по-прежнему передаете идентификатор аренды, запрос также завершается ошибкой **412** . Дополнительные сведения об управлении сроком аренды и идентификаторами аренды см. в статье, посвященной операции [Lease Blob](/rest/api/storageservices/Lease-Blob), в документации REST.

Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с BLOB-объектами:

* Put BLOB (Вставка BLOB-объекта)
* Get BLOB (Получение BLOB-объекта)
* Get BLOB Properties (Получение свойств BLOB-объекта)
* Set BLOB Properties (Задание свойств службы BLOB-объекта)
* Get BLOB Metadata (Получение метаданных BLOB-объекта)
* Set BLOB Metadata (Задание метаданных BLOB-объекта)
* Delete BLOB (Удаление BLOB-объекта)
* Put Block (Вставка блокировки)
* Put Block List (Вставка списка блокировки)
* Get Block List (Получение списка блокировки)
* Put Page (Вставка страницы)
* Get Page Ranges (Получение диапазона страницы)
* Snapshot Blob (Моментальные снимки BLOB-объектов) — идентификатор аренды не обязателен, если есть аренда
* Copy Blob (Копирование BLOB-объекта) — необходим идентификатор аренды, если есть аренда на целевой BLOB-объект
* Abort Copy Blob (Прерывание копирования BLOB-объекта) — необходим идентификатор аренды, если есть неограниченная аренда на целевой BLOB-объект
* Lease Blob (Аренда BLOB-объекта)

### <a name="pessimistic-concurrency-for-containers"></a>Пессимистичный параллелизм для контейнеров

Аренда в контейнерах обеспечивает поддержку тех же стратегий синхронизации, что и для больших двоичных объектов ( *Монопольная запись, чтение* , *Монопольная запись* и монопольное чтение, а также *Совместное чтение/монопольное считывание* ), но в отличие от больших двоичных объектов Служба хранилища принудительно применяет исключительные права только для операций удаления. Для удаления контейнера с активной арендой клиент наряду с запросом на удаление должен ввести активный идентификатор аренды. Остальные операции по контейнерам выполняются без введения идентификатора аренды, являясь общими операциями. Если требуется монополия на операции обновления (put или set) или чтения, разработчик должен обеспечить всех клиентов возможностью использования идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента.

Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с контейнерами:

* Delete Container (Удаление контейнера)
* Get Container Properties (Получение свойств контейнера)
* Get Container Metadata (Получение метаданных контейнера)
* Set Container Metadata (Определение метаданных контейнера)
* Get Container ACL (Получение списка управления доступом для контейнера)
* Set Container ACL (Задание списка управления доступом для контейнера)
* Lease Container (Аренда контейнера)

Дополнительные сведения см. в разделе:

* [Указание условных заголовков для операций службы BLOB-объектов](/rest/api/storageservices/Specifying-Conditional-Headers-for-Blob-Service-Operations)
* [Аренда контейнера](/rest/api/storageservices/Lease-Container)
* [Аренда BLOB-объекта](/rest/api/storageservices/Lease-Blob)

## <a name="managing-concurrency-in-table-storage"></a>Управление параллелизмом в хранилище таблиц

Служба таблиц использует проверки оптимистического параллелизма в качестве поведения по умолчанию при работе с сущностями, в отличие от службы BLOB-объектов, в которой необходимо явно выбрать проверку оптимистического параллелизма. Другое различие между службами таблиц и больших двоичных объектов заключается в том, что вы можете управлять поведением параллелизма только сущностей, но с помощью службы BLOB-объектов можно управлять параллелизмом контейнеров и больших двоичных объектов.

Чтобы использовать оптимистичный параллелизм и проверить, модифицировал ли какой-либо процесс сущность с момента его извлечения из службы табличного хранилища, вы можете использовать значение ETag, которое вы получите при возвращении службой таблиц сущности. Для этой команды используется следующая структура:

1. Извлеките сущность из службы табличного хранилища. Ответ включает значение ETag, определяющее текущий идентификатор, ассоциирующийся с этой сущностью в службе хранилища.
2. При обновлении сущности включите полученное после выполнения шага 1 значение ETag в обязательный заголовок **If-Match** запроса, отправляемого вами в службу.
3. Служба сравнивает значение ETag запроса с текущим значением ETag сущности.
4. Если текущее значение ETag сущности отличается от ETag в обязательном заголовке запроса **If-Match** , служба возвращает клиенту ошибку 412. Это указывает клиенту на то, что после извлечения клиентом сущности он был обновлен другим процессом.
5. Если текущее значение ETag сущности совпадает с ETag в обязательном заголовке **If-Match** в запросе или заголовок **If-Match** содержит подстановочный знак (*), служба выполняет запрошенную операцию и обновляет текущее значение ETag сущности, чтобы оно было обновлено.

Служба таблиц требует, чтобы клиент включал заголовок **If-Match** в запросы на обновление. Однако можно принудительно применить безусловное обновление (стратегия "Сохраняются изменения, внесенные последними") и избежать проверки параллелизма, если клиент устанавливает в заголовке **If-Match** подстановочный знак (*), когда делает запрос.

Следующий фрагмент C#-кода показывает пользователю сущность, предварительно созданную или извлеченную, с обновленным электронным адресом. Начальная операция по вводу или извлечению сохраняет значение ETag в объекте пользователя, а так как образец использует тот же экземпляр при операции замены, он автоматически отправляет значение ETag назад в службу таблиц, вызывая проверку на нарушение параллелизма. Если произошло обновление сущности в службе хранилища другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено).  Полный пример доступен на [этой странице](https://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}
```

Для явного отключения проверки на параллелизм вам следует задать характеристику **ETag** объекта **employee** в виде "*", прежде чем выполнить операцию замены.

```csharp
customer.ETag = "*";
```

Таблица показывает, как операции сущности в таблице используют значения ETag:

| Операция | Returns ETag value (Возврат значения ETag) | Requires If-Match request header (Требует заголовок запроса If-Match) |
|:--- |:--- |:--- |
| Query Entities (Сущности запроса) |Да |нет |
| Insert Entity (Вставка сущности ) |Да |нет |
| Update Entity (Обновление сущности) |Да |Да |
| Merge Entity (Слияние сущностей) |Да |Да |
| Delete Entity (Удаление сущности) |нет |Да |
| Insert or Replace Entity (Вставка или замена сущности) |Да |нет |
| Insert or Merge Entity (Вставка или слияние сущностей) |Да |Нет |

Обратите внимание, что операции **вставки или замены сущности** , **вставки или слияния** *не* выполняют проверок параллелизма, так как они не отправляют значение ETag в службу таблиц.

Как правило, разработчики, использующие таблицы, должны полагаться на оптимистичный параллелизм. Если требуется Пессимистическая блокировка при доступе к таблицам, назначьте выбранный большой двоичный объект для каждой таблицы и попытайтесь получить аренду для большого двоичного объекта перед тем, как работать с таблицей. При таком подходе приложение должно гарантировать, что все пути доступа к данным получат аренду перед тем, как будет работать в таблице. Следует также отметить, что минимальное время аренды составляет 15 секунд, что требует тщательного рассмотрения в отношении масштабируемости.

Дополнительные сведения см. в разделе:

* [Операции с сущностями](/rest/api/storageservices/Operations-on-Entities)

## <a name="managing-concurrency-in-the-queue-service"></a>Управление параллелизмом в службе очередей

Одним из сценариев, в котором параллелизм является проблемой, является служба очередей, в которой из очереди получают сообщения несколько клиентов. Когда сообщение извлекается из очереди, ответ включает в себя сообщение и значение подтверждения получения, необходимое для удаления очереди. Сообщение не удаляется из очереди автоматически, но после получения оно не отображается для других клиентов в течение интервала времени, заданного параметром времени ожидания видимости. Ожидается, что клиент, извлекающий сообщение, удаляет сообщение после его обработки и до времени, указанного элементом Тименекствисибле ответа, который вычисляется на основе значения параметра времени ожидания видимости. Значение времени ожидания видимости добавляется ко времени получения сообщения, чтобы определить значение Тименекствисибле.

Служба очередей не поддерживает оптимистичный или пессимистичный параллелизм, поэтому клиенты, обрабатывающие сообщения, получаемые из очереди, должны убедиться, что сообщения обрабатываются идемпотентными способом. Стратегия последнего модуля записи WINS используется для операций обновления, таких как Сеткуеуесервицепропертиес, SetQueueMetaData, SetQueueACL и UpdateMessage.

Дополнительные сведения см. в разделе:

* [REST API службы очередей](/rest/api/storageservices/Queue-Service-REST-API)
* [Получение сообщений](/rest/api/storageservices/Get-Messages)

## <a name="managing-concurrency-in-azure-files"></a>Управление параллелизмом в Файлах Azure

Доступ к файловой службе можно получить с помощью двух протоколов конечной точки — SMB и REST. Служба RESTFUL не поддерживает оптимистичную блокировку или пессимистическую блокировку, и все обновления будут следовать стратегии последнего модуля записи в службу WINS. Клиенты SMB, которые подключаются к файловым ресурсам, могут использовать механизмы блокировки файловой системы для управления доступом к общим файлам, включая возможность выполнения пессимистической блокировки. При открытии файла клиентом SMB он определяет как доступ к файлам, так и режим общего доступа. Параметры доступа к файлам "Write" или "Read/Write" ("Для записи" или "Для чтения и записи"), а также режима совместного использования файлам "None" ("Ни один") приводят к блокировке файла клиентом SMB до закрытия файла. Если попытаться осуществить операцию REST на файле, заблокированном клиентом, SMB служба REST вернет код состояния 409 (конфликт) с кодом ошибки SharingViolation.

При открытии клиентом SMB файла для удаления она отмечает файл как "ожидающий удаления" до тех пор, пока все остальные клиенты SMB, открывшие дескрипторы на файл, закроются. Пока файл отмечен как "ожидающий удаления", любая операция REST на этом файле вернется кодом состояния 409 (конфликт) и с кодом ошибки SMBDeletePending. Код состояния 404 (не найден) не возвращается, так как клиент SMB может удалить флаг ожидания удаления перед закрытием файла. Иными словами, получение кода состояния 404 (не найден) возможно только после удаления файла. Заметьте, что пока файл находится в состоянии ожидания удаления SMB, он не будет включен в результаты операции "Список файлов". Обратите также внимание, что операции REST Delete File (Удалить файлы) и REST Delete Directory (Удалить каталог) выполняются атомарным образом и не ведут к состоянию ожидания удаления.

Дополнительные сведения см. в разделе:

* [Управление блокировкой файлов](/rest/api/storageservices/Managing-File-Locks)

## <a name="next-steps"></a>Дальнейшие действия

Полный образец приложения, упомянутый в блоге:

* [Управление параллелизмом с помощью службы хранилища Azure: пример приложения](https://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)

Дополнительные сведения о службе хранилища Azure см. в следующих статьях:

* [Домашняя страница службы хранилища Microsoft Azure](https://azure.microsoft.com/services/storage/)
* [Введение в хранилище Azure](storage-introduction.md)
* Приступая к работе с хранилищем: [большой двоичный объект](../blobs/storage-quickstart-blobs-dotnet.md), [таблица](../../cosmos-db/tutorial-develop-table-dotnet.md), [очереди](../queues/storage-dotnet-how-to-use-queues.md) и [файлы](../files/storage-dotnet-how-to-use-files.md).
* Архитектура службы хранилища — [Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](/archive/blogs/windowsazurestorage/sosp-paper-windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency) (Служба хранилища Azure: высокодоступная служба облачного хранения со строгой согласованностью).