---
title: Ссылка на ускорение запросов s'L (предварительный просмотр)
titleSuffix: Azure Storage
description: Узнайте, как использовать синтаксис ускорения запроса sql.
services: storage
author: normesta
ms.service: storage
ms.topic: conceptual
ms.date: 04/21/2020
ms.author: normesta
ms.subservice: data-lake-storage-gen2
ms.reviewer: ereilebr
ms.openlocfilehash: cea5fb507225f063e2d48c56fae254e123a8f72b
ms.sourcegitcommit: d57d2be09e67d7afed4b7565f9e3effdcc4a55bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81772123"
---
# <a name="query-acceleration-sql-language-reference-preview"></a>Ссылка на ускорение запросов s'L (предварительный просмотр)

Ускорение запросов поддерживает язык, похожий на ANSI S'L, для выражения запросов по содержимому капли.  Диалект ускорения запроса s'L представляет собой подмножество ANSI S'L, с ограниченным набором поддерживаемых типов данных, операторов и т.д., но он также расширяется на ANSI S'L для поддержки запросов по иерархическим полуструктурированным форматам данных, таким как JSON. 

> [!NOTE]
> Функция ускорения запроса находится в открытом доступе и доступна в центральных регионах Канады и Франции. Для проверки ограничений смотрите статью [«Известные проблемы».](data-lake-storage-known-issues.md) Чтобы зарегистрироваться в предварительном просмотре, [см.](https://aka.ms/adls/qa-preview-signup) 

## <a name="select-syntax"></a>SELECT Syntax

Единственным заявлением, поддерживаемым ускорением запроса, является заявление SELECT. Этот пример возвращает каждую строку, для которой выражение возвращается верно.

```sql
SELECT * FROM table [WHERE expression] [LIMIT limit]
```

Для данных формата CSV `BlobStorage` *таблица* должна быть .  Это означает, что запрос будет работать в отношении того, какой капли был указан в вызове REST.
Для данных, форматируемых JSON, *таблица* представляет собой "столовый дескриптор".   Смотрите раздел [«Оскрипторы таблиц»](#table-descriptors) в этой статье.

В следующем примере для каждой строки, для которой *выражение* WHERE возвращается верно, это утверждение возвращает новую строку, сделанную из оценки каждого из выражений проекции.


```sql
SELECT expression [, expression …] FROM table [WHERE expression] [LIMIT limit]
```

Следующий пример возвращает совокупный вычисление (например: среднее значение определенного столбца) по каждой из строк, для которых *выражение* возвращается верно. 

```sql
SELECT aggregate_expression FROM table [WHERE expression] [LIMIT limit]
```

Следующий пример возвращает подходящие смещения для разделения CSV-форматной капли.  Смотрите раздел [Sys.Split](#sys-split) этой статьи.

```sql
SELECT sys.split(split_size)FROM BlobStorage
```

<a id="data-types" />

## <a name="data-types"></a>Типы данных

|Тип данных|Описание|
|---------|-------------------------------------------|
|INT      |64-разрядное целое число со знаком.                     |
|FLOAT    |64-битная ("двойная точность") плавающая точка.|
|STRING   |Строка Unicode с переменной длиной.            |
|timestamp|Точка времени.                           |
|BOOLEAN  |Значение true или false.                             |

При чтении значений из данных csV-форматированных значений все значения считываются как строки.  Значения строки могут быть преобразованы в другие типы с помощью выражений CAST.  Значения могут быть неявно отлиты в другие типы в зависимости от контекста. для получения дополнительной [Data type precedence (Transact-SQL)](https://docs.microsoft.com/sql/t-sql/data-types/data-type-precedence-transact-sql?view=sql-server-2017)информации см.

## <a name="expressions"></a>Выражения

### <a name="referencing-fields"></a>Поле ссылки

Для данных формата JSON или CSV-форматированных данных с заголовком строки поля могут быть отсылёнпокпо по имени.  Имена полей могут быть процитированы или не котируются. Указанные названия полей заключены в символы с двойной цитатой (), могут содержать пробелы и чувствительны к случаям.  Нецитируемые имена полей нечувствительны к случаям и не могут содержать специальных символов.

В данных csV-форматированных поля также могут быть отсылкой по ординатору, прикрепляемым с подчеркивателем (я) характером.  Например, первое поле может быть отосвещено как No1, или одиннадцатое поле может быть отосвещено как No11.  Ссылки на поля по ординатору полезны для данных форматирования CSV, которые не содержат строку заголовка, и в этом случае единственным способом ссылки на конкретное поле является или ими.

### <a name="operators"></a>Операторы

Поддерживаются следующие стандартные операторы S'L:

``=``, ``!=``, ``<>``, ``<``, ``<=``, ``>``, ``>=``, ``+``, ``-``, ``/``, ``*``, ``%``, ``AND``, ``OR``, ``NOT``, ``CAST``, ``BETWEEN``, ``IN``, ``NULLIF``, ``COALESCE``

Если типы данных слева и справа от оператора отличаются, то автоматическое преобразование будет осуществляться в соответствии с правилами, указанными здесь: [приоритет типа данных (Transact-S'L).](https://docs.microsoft.com/sql/t-sql/data-types/data-type-precedence-transact-sql?view=sql-server-2017)

Язык ускорения запроса S'L поддерживает только очень небольшое подмножество типов данных, обсуждаемых в этой статье.  Смотрите раздел [Типы данных](#data-types) в этой статье.

### <a name="casts"></a>Приведения

Язык ускорения запроса S'L поддерживает оператора CAST, в соответствии с правилами здесь: [преобразование типа данных (Database Engine)](https://docs.microsoft.com/sql/t-sql/data-types/data-type-conversion-database-engine?view=sql-server-2017).  

Язык ускорения запроса S'L поддерживает лишь крошечный подмножество типов данных, обсуждаемых в этой статье.  Смотрите раздел [Типы данных](#data-types) в этой статье.

### <a name="string-functions"></a>Строковые функции

Язык ускорения запроса S'L поддерживает следующие стандартные функции строки S'L:

``LIKE``, ``CHAR_LENGTH``, ``CHARACTER_LENGTH``, ``LOWER``, ``UPPER``, ``SUBSTRING``, ``TRIM``, ``LEADING``, ``TRAILING``.

Вот несколько примеров:

|Функция|Пример|Результат|
|---|---|---|
|CHARACTER_LENGTH|``SELECT CHARACTER_LENGTH('abcdefg') from BlobStorage`` |``7``|
|CHAR_LENGTH|``SELECT CHAR_LENGTH(_1) from BlobStorage``|``1``|
|LOWER|``SELECT LOWER('AbCdEfG') from BlobStorage``|``abcdefg``|
|UPPER|``SELECT UPPER('AbCdEfG') from BlobStorage``|``ABCDEFG``|
|SUBSTRING|``SUBSTRING('123456789', 1, 5)``|``23456``|
|TRIM|``TRIM(BOTH '123' FROM '1112211Microsoft22211122')``|``Microsoft``|

Функция [LIKE](https://docs.microsoft.com/sql/t-sql/language-elements/like-transact-sql?view=sql-server-ver15) помогает искать шаблон. Вот несколько примеров, [LIKE](https://docs.microsoft.com/sql/t-sql/language-elements/like-transact-sql?view=sql-server-ver15) которые используют функцию ``abc,abd,cd\ntest,test2,test3\na_bc,xc%d^e,gh[i ``LIKE для поиска строки данных.

|Запрос|Пример|
|--|--|
|``SELECT _1, _2, _3 from BlobStorage where _2 LIKE 'a%'``|``abc,abd,cd\n``|
|``SELECT * from BlobStorage where _1 LIKE 'a[bcd]c``|``abc,abd,cd\n``|
|``SELECT _1 from BlobStorage where _2 LIKE '[^xyz]%'``|``abc\ntest\n``|
|``SELECT * from BlobStorage where _1 LIKE 'a_``|``abc,abd,cd\n``|
|``SELECT _2,_3 from BlobStorage where _3 LIKE '[g-h]_![[a-j]' Escape '!'``|``xc%d^e,gh[i\n``|

### <a name="date-functions"></a>Функции данных

Поддерживаются следующие стандартные функции даты S'L:

``DATE_ADD``, ``DATE_DIFF``, ``EXTRACT``, ``TO_STRING``, ``TO_TIMESTAMP``.

В настоящее время мы конвертируем все [форматы даты стандартного IS08601](https://www.w3.org/TR/NOTE-datetime). 

#### <a name="date_add-function"></a>функция DATE_ADD

Язык ускорения запроса S'L поддерживает год, месяц, день, ``DATE_ADD`` час, минуту, второе место для функции.

Примеры:

```sql
DATE_ADD(datepart, quantity, timestamp)
DATE_ADD('minute', 1, CAST('2017-01-02T03:04:05.006Z' AS TIMESTAMP)
```

#### <a name="date_diff-function"></a>DATE_DIFF функция

Язык ускорения запроса S'L поддерживает год, месяц, день, ``DATE_DIFF`` час, минуту, второе место для функции.

```sql
DATE_DIFF(datepart, timestamp, timestamp)
DATE_DIFF('hour','2018-11-09T00:00+05:30','2018-11-09T01:00:23-08:00') 
```

#### <a name="extract-function"></a>Функция EXTRACT

Для EXTRACT, помимо детали, поддерживаемой для ``DATE_ADD`` функции, язык ускорения запроса s'L поддерживает timezone_hour и timezone_minute как часть даты.

Примеры:

```sql
EXTRACT(datepart FROM timestampstring)
EXTRACT(YEAR FROM '2010-01-01T')
```

#### <a name="to_string-function"></a>функция TO_STRING

Примеры:

```sql
TO_STRING(TimeStamp , format)
TO_STRING(CAST('1969-07-20T20:18Z' AS TIMESTAMP),  'MMMM d, y')
```

В этой таблице описаны строки, которые можно ``TO_STRING`` использовать для указания формата вывода функции.

|Строка форматирования    |Выходные данные                               |
|-----------------|-------------------------------------|
|yy               |Год в формате 2 цифры - 1999 как '99'|
|y                |Год в формате 4 цифры               |
|гггг             |Год в формате 4 цифры               |
|M                |Месяц года - 1                    |
|ММ               |Нулевой мягкий месяц - 01               |
|MMM              |Аббр. месяц года -JAN            |
|ММММ:             |Полный месяц - май                      |
|d                |День месяца (1-31)                  |
|дд               |Нулевой мягкий день месяца (01-31)     |
|а                |AM или PM                             |
|h                |Час дня (1-12)                   |
|hh               |Нулевой мягкий часы od день (01-12)     |
|H                |Час дня (0-23)                   |
|ЧЧ               |Нулевой проложенный час дня (00-23)      |
|m                |Минута часа (0-59)                |
|ММ               |Нулевая проложенная минута (00-59)           |
|s                |Второй минут (0-59)             |
|сс               |Нулевые проложенные секунды (00-59)          |
|S                |Фракция секунд (0.1-0.9)        |
|SS               |Фракция секунд (0.01-0.99)      |
|Sss              |Фракция секунд (0.001-0.999)    |
|X                |Смещение в часах                      |
|XX или XXXX       |Смещение в часах и минутах (0430)  |
|XXX или XXXXX     |Смещение в часах и минутах (-07:00) |
|x                |Смещение в часах (7)                  |
|хх или xxxx       |Смещение в час и минуту (0530)    |
|Xxx или xxxxx     |Смещение в час и минуту (05:30)   |

#### <a name="to_timestamp-function"></a>функция TO_TIMESTAMP

Поддерживаются только форматы IS08601.

Примеры:

```sql
TO_TIMESTAMP(string)
TO_TIMESTAMP('2007T')
```

> [!NOTE]
> Вы также можете ``UTCNOW`` использовать функцию, чтобы получить системное время.


## <a name="aggregate-expressions"></a>Совокупные выражения

Заявление SELECT может содержать одно или несколько проекционных выражений или одно совокупное выражение.  Поддерживаются следующие совокупные выражения:

|Выражение|Описание|
|--|--|
|[СЧЕТ\*()](https://docs.microsoft.com/sql/t-sql/functions/count-transact-sql?view=sql-server-ver15)    |Возвращает количество записей, соответствующих выражению предиката.|
|[COUNT (выражение)](https://docs.microsoft.com/sql/t-sql/functions/count-transact-sql?view=sql-server-ver15)    |Возвращает количество записей, для которых выражение не является нулевым.|
|[AVERAGE (выражение)](https://docs.microsoft.com/sql/t-sql/functions/avg-transact-sql?view=sql-server-ver15)    |Возвращает среднее значение выражения без нулевых.|
|[MIN (выражение)](https://docs.microsoft.com/sql/t-sql/functions/min-transact-sql?view=sql-server-ver15)    |Возвращает минимальное ненулевое значение выражения.|
|[MAX (выражение)](https://docs.microsoft.com/sql/t-sql/functions/max-transact-sql?view=sql-server-ver15)    |Возвращает максимальное ненулевое значение выражения.|
|[SUM (выражение)](https://docs.microsoft.com/sql/t-sql/functions/sum-transact-sql?view=sql-server-ver15)    |Возвращает сумму всех ненулевых значений выражения.|

### <a name="missing"></a>Отсутствует

Оператор ``IS MISSING`` является единственным нестандартным, что ускорение запроса язык S'L поддерживает.  Для данных JSON, если поле отсутствует в определенной ``IS MISSING`` записи ввода, поле выражения будет оцениваться на истинное значение Boolean.

<a id="table-descriptors" />

## <a name="table-descriptors"></a>Дескрипторы таблиц

Для данных CSV имя `BlobStorage`таблицы всегда .  Пример:

```sql
SELECT * FROM BlobStorage
```

Для данных JSON доступны дополнительные опции:

```sql
SELECT * FROM BlobStorage[*].path
```

Это позволяет запрашивать подмножества данных JSON.

Для запросов JSON можно упомянуть путь в части положения FROM. Эти пути помогут разобрать подмножество данных JSON. Эти пути могут ссылаться на значения JSON Array и Object.

Давайте возьмем пример, чтобы понять это более подробно.

Это наши выборочные данные:

```json
{
  "id": 1,
  "name": "mouse",
  "price": 12.5,
  "tags": [
    "wireless",
    "accessory"
  ],
  "dimensions": {
    "length": 3,
    "width": 2,
    "height": 2
  },
  "weight": 0.2,
  "warehouses": [
    {
      "latitude": 41.8,
      "longitude": -87.6
    }
  ]
}
```

Из приведенных выше `warehouses` данных вас может заинтересовать только объект JSON. Объект `warehouses` является типом массива JSON, поэтому вы можете упомянуть об этом в пункте FROM. Ваш пример запроса может выглядеть примерно так.

```sql
SELECT latitude FROM BlobStorage[*].warehouses[*]
```

Запрос получает все поля, но выбирает только широту.

Если вы хотите получить `dimensions` доступ только к значению объекта JSON, можно использовать ссылку на этот объект в запросе. Пример:

```sql
SELECT length FROM BlobStorage[*].dimensions
```

Это также ограничивает доступ к `dimensions` членам объекта. Если вы хотите получить доступ к другим членам полей JSON и внутренним значениям объектов JSON, то можно использовать запросы, такие как показано в следующем примере:

```sql
SELECT weight,warehouses[0].longitude,id,tags[1] FROM BlobStorage[*]
```

> [!NOTE]
> BlobStorage и BlobStorage оба\*относятся ко всему объекту. Однако, если у вас есть путь в пункте FROM, то\*вам нужно будет использовать BlobStorage.

<a id="sys-split" />

## <a name="syssplit"></a>Sys.Split

Это специальная форма заявления SELECT, которая доступна только для данных csV-формата.

```sql
SELECT sys.split(split_size)FROM BlobStorage
```

Используйте это утверждение в тех случаях, когда вы хотите загрузить, а затем обрабатывать записи данных CSV пакетами. Таким образом, вы можете обрабатывать записи параллельно, вместо того, чтобы загружать все записи за один раз. Это заявление не возвращает записи из файла CSV. Вместо этого он возвращает коллекцию пакетных размеров. Затем можно использовать каждый размер пакета для получения пакета записей данных. 

Используйте *split_size* параметр, чтобы указать количество байтов, которые вы хотите, чтобы каждая партия содержала. Например, если вы хотите обрабатывать только 10 МБ данных за один `SELECT sys.split(10485760)FROM BlobStorage` раз, выписка будет выглядеть следующим образом: потому что 10 МБ равен 10 485 760 байт. Каждая партия будет содержать столько записей, сколько может вписаться в эти 10 МБ. 

В большинстве случаев размер каждой партии будет немного выше, чем число, указанное. Это потому, что пакет не может содержать частичную запись. Если последняя запись в пакете начинается до конца порога, пакет будет больше, так что она может содержать полную запись. Размер последней партии, скорее всего, будет меньше, чем указанный размер.

>[!NOTE]
> Split_size должно быть не менее 10 МБ (10485760).

## <a name="see-also"></a>См. также раздел

- [Ускорение запроса на хранение данных Azure Data Lake (предварительный просмотр)](data-lake-storage-query-acceleration.md)
- [Фильтруя данные с помощью ускорения запроса на хранение данных Azure Data Lake (предварительный просмотр)](data-lake-storage-query-acceleration-how-to.md)

