---
title: Контрольный список производительности и масштабируемости для хранения Blob - Azure Storage
description: Контрольный список проверенных практик для использования с хранилищем Blob при разработке высокопроизводительных приложений.
services: storage
author: tamram
ms.service: storage
ms.topic: conceptual
ms.date: 10/10/2019
ms.author: tamram
ms.subservice: blobs
ms.openlocfilehash: e4103f8360f6fa80470b0f8002a61f8ac903bd8b
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79255435"
---
# <a name="performance-and-scalability-checklist-for-blob-storage"></a>Контрольный список для обеспечения масштабируемости и производительности для Хранилища таблиц

Корпорация Майкрософт разработала ряд проверенных методов разработки высокопроизводительных приложений с помощью хранилища Blob. Этот контрольный список определяет основные методики, которые помогут разработчикам оптимизировать производительность. Учитывайте эти рекомендации при проектировании приложения и на протяжении всего процесса разработки.

Служба хранилища Azure имеет целевые показатели по масштабируемости и производительности, выраженные в объемах, скорости транзакций и пропускной способности. Для получения дополнительной информации о целевых показателях масштабируемости хранилища Azure [см.](../common/scalability-targets-standard-account.md?toc=%2fazure%2fstorage%2fblobs%2ftoc.json) [Scalability and performance targets for Blob storage](scalability-targets.md)

## <a name="checklist"></a>Контрольный список

Эта статья организует проверенные практики для производительности в контрольный список, который вы можете следовать при разработке приложения для хранения Blob.

| Готово | Категория | Рекомендации по проектированию |
| --- | --- | --- |
| &nbsp; |Целевые показатели масштабируемости |[Можно ли спроектировать приложение так, чтобы количество используемых учетных записей хранения не превышало максимальное значение?](#maximum-number-of-storage-accounts) |
| &nbsp; |Целевые показатели масштабируемости |[Удастся ли вам избежать приближения к предельным значениям емкости и количеству транзакций?](#capacity-and-transaction-targets) |
| &nbsp; |Целевые показатели масштабируемости |[Много ли клиенты одновременно получают доступ к одной капли?](#multiple-clients-accessing-a-single-blob-concurrently) |
| &nbsp; |Целевые показатели масштабируемости |[Остается ли ваше приложение в пределах целевых показателей масштабируемости для одной капли?](#bandwidth-and-operations-per-blob) |
| &nbsp; |Секционирование |[Помогает ли ваше соглашения об именовании улучшить распределение нагрузки?](#partitioning) |
| &nbsp; |Сеть |[Имеют ли клиентские устройства достаточно высокую пропускную способность и достаточно низкую задержку для достижения необходимой производительности?](#throughput) |
| &nbsp; |Сети |[Имеют ли клиентские устройства достаточно высокое качество связи?](#link-quality) |
| &nbsp; |Сети |[Размещено ли клиентское приложение в том же регионе, что и учетная запись хранения?](#location) |
| &nbsp; |Прямой клиентский доступ |[Используются ли подписанные URL-адреса (SAS) и общий доступ к ресурсам независимо от источника (CORS) для организации прямого доступа к службе хранилища Azure?](#sas-and-cors) |
| &nbsp; |Caching |[Данные кэширования приложений, которые часто доступны и редко изменяются?](#reading-data) |
| &nbsp; |Caching |[Является ли ваше приложение пакетных обновлений путем кэширования их на клиента, а затем загружать их в больших наборов?](#uploading-data-in-batches) |
| &nbsp; |Конфигурация .NET |[Используется ли .NET Core 2.1 или более поздней версии, чтобы обеспечить оптимальную производительность?](#use-net-core) |
| &nbsp; |Конфигурация .NET |[Вы настроили свой клиент на использование достаточного количества одновременных подключений?](#increase-default-connection-limit) |
| &nbsp; |Конфигурация .NET |[Настроено ли для приложений .NET использование достаточного количества потоков?](#increase-minimum-number-of-threads) |
| &nbsp; |Parallelism |[Ограничен ли параллелизм достаточным образом, чтобы нагрузка не превышала возможности клиента и не приближалась к целевым показателям масштабируемости?](#unbounded-parallelism) |
| &nbsp; |Инструменты |[Используются ли последние версии клиентских библиотек и инструментов, предоставленных корпорацией Майкрософт?](#client-libraries-and-tools) |
| &nbsp; |Повторы |[Используется ли политика повтора с экспоненциальной задержкой для ошибок регулирования и превышения времени ожидания?](#timeout-and-server-busy-errors) |
| &nbsp; |Повторы |[Ваше приложение избегает повторов неповторяемых ошибок?](#non-retryable-errors) |
| &nbsp; |Копирование капли |[Вы копируете капли наиболее эффективным образом?](#blob-copy-apis) |
| &nbsp; |Копирование капли |[Используете ли вы последнюю версию AzCopy для операций с объемными копиями?](#use-azcopy) |
| &nbsp; |Копирование капли |[Используете ли вы семейство Данных Azure Box для импорта больших объемов данных?](#use-azure-data-box) |
| &nbsp; |Распространение содержимого |[Используете ли вы CDN для распределения содержимого?](#content-distribution) |
| &nbsp; |Использование метаданных |[Вы храните часто используемые метаданные, касающиеся BLOB-объектов, в их метаданных?](#use-metadata) |
| &nbsp; |Быстрая загрузка |[При попытке быстро отправить один BLOB-объект вы осуществляете параллельную отправку блоков?](#upload-one-large-blob-quickly) |
| &nbsp; |Быстрая загрузка |[При попытке быстро отправить множество BLOB-объектов вы отправляете BLOB-объекты параллельно?](#upload-many-blobs-quickly) |
| &nbsp; |Тип большого двоичного объекта |[Используете ли вы при необходимости страничные BLOB-объекты или блочные BLOB-объекты?](#choose-the-correct-type-of-blob) |

## <a name="scalability-targets"></a>Целевые показатели масштабируемости

Если приложение достигает одного из целевых показателей масштабируемости или превышает его, оно может столкнуться с увеличением задержки транзакций или запуском механизма регулировки количества запросов. Когда служба хранилища Azure применяет регулирование для приложения, она начинает возвращать коды ошибки 503 — Server busy (сервер занят) или 500 — Operation timeout (время ожидания операции истекло). Этих ошибок можно избежать, строго соблюдая ограничения для целевых показателей масштабируемости. Это важная часть стратегии по повышению производительности приложения.

См. сведения о [целевых показателях масштабируемости службы хранилища Azure для Службы очередей](/azure/storage/queues/scalability-targets#scale-targets-for-queue-storage).

### <a name="maximum-number-of-storage-accounts"></a>Максимальное количество учетных записей хранения

Если вы приближаетесь к максимальному количеству учетных записей хранилища, разрешенных для конкретной комбинации подписки/региона, оцените сценарий и определите, применяется ли какое-либо из следующих условий:

- Используете ли вы учетные записи хранения неуправляемых дисков и добавление этих дисков в виртуальные машины (VMs)? Для этого сценария корпорация Майкрософт рекомендует использовать управляемые диски. Масштаб управляемых дисков для вас автоматически и без необходимости создавать и управлять отдельными учетными записями хранения данных. Для получения дополнительной информации [см.](../../virtual-machines/windows/managed-disks-overview.md)
- Используете ли вы одну учетную запись хранения на одного клиента для изоляции данных? Для этого сценария корпорация Майкрософт рекомендует использовать контейнер с каплями для каждого клиента, а не всю учетную запись хранилища. Теперь Azure Storage позволяет назначать роли управления доступом (RBAC) на основе ролей управления доступом (RBAC) на основе одного контейнера. Дополнительные сведения см. в статье о [предоставлении доступа к данным больших двоичных объектов и очереди с помощью ролей RBAC на портале Azure](../common/storage-auth-aad-rbac-portal.md).
- Используете ли вы несколько учетных записей хранения для увеличения входа, выхода, операций ввоза/всекунды (IOPS) или емкости? Для такой ситуации корпорация Майкрософт рекомендует увеличить ограничения по учетным записям хранения, если это возможно, чтобы сократить количество учетных записей хранения для рабочей нагрузки. Запрос на увеличение ограничений на количество учетных записей хранения следует направлять в [службу поддержки Azure](https://azure.microsoft.com/support/options/). Дополнительные сведения см. в [объявлении об учетных записях хранения большего размера и большего масштаба](https://azure.microsoft.com/blog/announcing-larger-higher-scale-storage-accounts/).

### <a name="capacity-and-transaction-targets"></a>Целевые показатели емкости и транзакций

Если приложение достигает целевых показателей масштабируемости, когда речь идет об одной учетной записи хранения, рассмотрите вопрос об использовании одного из следующих подходов:  

- Если приложение попадает в цель транзакции, рассмотрите возможность использования учетных записей хранения блоков blob, которые оптимизированы для высоких ставок транзакций и низкой и последовательной задержки. Дополнительные сведения см. в статье [Общие сведения об учетной записи хранения Azure](../common/storage-account-overview.md).
- Пересмотрите рабочую нагрузку, которая приводит к достижению приложением целевого показателя масштабируемости или его превышению. Вы можете спроектировать его по-другому, чтобы использовать меньшую полосу пропускания или производительность, или меньшее количество транзакций?
- Если приложение должно превышать какой-то из целевых показателей масштабируемости, создайте несколько учетных записей хранения и сегментируйте между ними данные приложения. При использовании этого подхода необходимо разработать приложение таким образом, чтобы в будущем для балансировки нагрузки в него можно было добавлять другие учетные записи хранения. Плата взимается только за потребление, то есть объем хранимых и передаваемых данных и совершенные транзакции, но не за сами учетные записи хранения.
- Если приложение приближается к целевым показателям пропускной способности, попробуйте применить сжатие данных на стороне клиента, чтобы снизить пропускную способность, требуемую для отправки данных в службу хранилища Azure.
    Этот способ снижает нагрузку на пропускную способность и повышает производительность сети, но может ухудшать общую производительность. Оцените, как дополнительная работа по сжатию и распаковке данных на стороне клиента влияет на производительность. Не забывайте также, что хранение данных в сжатом виде может усложнить устранение неполадок, так как затрудняет просмотр данных с помощью стандартных инструментов.
- Если приложение достигает целевых показателей масштабируемости, обязательно примените экспоненциальную задержку для повторов. Лучше всего сделать так, чтобы приложение не приближалось к целевым показателям масштабируемости. Для этого примените описанные в этой статье рекомендации. Если же потребуется выполнить регулирование, экспоненциальная задержка позволит избежать слишком частых повторов, которые только ухудшают ситуацию. Дополнительные сведения см. в разделе о [превышении времени ожидания и ошибках занятости сервера](#timeout-and-server-busy-errors).

### <a name="multiple-clients-accessing-a-single-blob-concurrently"></a>Несколько клиентов, имеющих одновременное доступ к одной капли

Если у вас есть большое количество клиентов, имеющих доступ к одной капли одновременно, вам нужно будет учитывать как на капля и на цели масштабируемости учетной записи хранения. Точное число клиентов, которые могут получить доступ к одной капли будет варьироваться в зависимости от таких факторов, как количество клиентов, запрашивающих капля одновременно, размер капли, и сетевые условия.

Если капля может быть распространена через CDN, такие как изображения или видео, подаваемые с веб-сайта, то вы можете использовать CDN. Для получения дополнительной информации смотрите раздел под названием [Распределение контента](#content-distribution).

В других сценариях, таких как научное моделирование, где данные конфиденциальны, у вас есть два варианта. Во-первых, чтобы ошеломить доступ вашей рабочей нагрузки таким образом, что капля доступна в течение определенного периода времени против одновременного доступа. Кроме того, можно временно скопировать blob на несколько учетных записей хранения, чтобы увеличить общую сумму IOPS на капля и через учетные записи. Результаты будут варьироваться в зависимости от поведения приложения, поэтому не забудьте протестировать модели параллелизма во время проектирования.

### <a name="bandwidth-and-operations-per-blob"></a>Пропускная способность и операции на капля

Одна капля поддерживает до 500 запросов в секунду. Если у вас есть несколько клиентов, которые должны читать ту же каплю, и вы можете превысить этот предел, а затем рассмотреть вопрос об использовании блока капли хранения счета. Учетная запись хранения block blob обеспечивает более высокую скорость запроса, или операции ввоза/в секунду (IOPS).

Вы также можете использовать сеть доставки контента (CDN), такую как Azure CDN, для распространения операций на blob. Для получения дополнительной информации о Azure CDN смотрите [обзор Azure CDN](../../cdn/cdn-overview.md).  

## <a name="partitioning"></a>Секционирование

Понимание того, как данные Azure Storage являются полезными для повышения производительности. Хранилище Azure может обслуживать данные в одном разделе быстрее, чем данные, охватывающие несколько разделов. Называя ваши капли надлежащим образом, вы можете повысить эффективность чтения запросов.

Blob storage использует схему расставания на основе диапазона для масштабирования и балансировки нагрузки. Каждая капля имеет ключ раздела, состоящий из полного имени капли (account-container-blob). Ключ раздела используется для раздела данных капли в диапазоны. Диапазоны затем сбалансированы нагрузкой через хранилище Blob.

Диапазон основе раздела означает, что именования конвенций, которые используют лексический заказ (например, *mypayroll*, *myperformance*, *myemployees*и т.д.) или временные метки *(log20160101*, *log20160102*, и т.д.), скорее всего, приведет к разделов в сотрудничестве на том же сервере раздела. *log20160102* , до тех пор, пока повышенная нагрузка не требует, чтобы они были разделены на меньшие диапазоны. Совместное размещение капли на том же сервере раздела повышает производительность, поэтому важная часть повышения производительности включает в себя именование капли таким образом, что организует их наиболее эффективно.

Например, все BLOB-объекты в контейнере могут обрабатываться одним и тем же сервером, пока нагрузка на эти BLOB-объекты не потребует дополнительного перераспределения диапазонов секций. Аналогичным образом, группа легко загруженных учетных записей с их именами, расположенными в лексическом порядке, может обслуживаться одним сервером до тех пор, пока нагрузка на одну или все эти учетные записи не потребует, чтобы они были разделены на несколько серверов разделов.

Каждая операция балансировки нагрузки может вызывать задержку вызовов хранилища во время ее выполнения. Способность службы обрабатывать внезапный всплеск трафика на раздел ограничивается масштабируемостью одного сервера разделов до тех пор, пока операция балансировки нагрузки не начнет сяплет и не уравновесит диапазон ключа раздела.

Частоту выполнения таких операций можно уменьшить.  

- Если это возможно, используйте blob или блок размеров больше, чем 4 MiB для стандартных счетов хранения и больше, чем 256 КиБ для премиум-аккаунтов хранения. Большие размеры капли или блока автоматически активируют капли блока с высокой пропускной прикладом. Высокопроизводительные блобы блока обеспечивают высокую производительность глотать, что не зависит от именования разделов.
- Изучите конвенцию именования, используемую для учетных записей, контейнеров, капли, таблицы и очереди. Рассмотрим предификачирование учетной записи, контейнера или имен капли с трехзначным хэшом, используя функцию хэширования, которая наилучшим образом соответствует вашим потребностям.
- Если вы организуете свои данные с помощью меток времени или численных идентификаторов, убедитесь, что вы не используете шаблон трафика только для приложений (или только для подготовки). Эти шаблоны не подходят для системы раздела на основе диапазона. Эти закономерности могут привести к тому, что весь трафик будет переходить к одной разделу и ограничит систему от эффективного балансировки нагрузки.

    Например, если у вас есть ежедневные операции, которые используют капли с меткой времени, таких как *yyyymmdd*, то весь трафик для этой ежедневной операции направляется на одну каплю, которая обслуживается одним сервером перегородки. Подумайте, отвечают ли ваши потребности лимиты на каждый blob и на один раздел, и при необходимости рассмотрите возможность разбиения этой операции на несколько капли. Аналогичным образом, при хранении данных временных рядов в таблицах весь трафик может быть направлен в последнюю часть ключевого пространства имен. Если вы используете числовые идентификаторы, префикс идентификатор с трехзначным хэшом. Если вы используете метки времени, префикс метки времени с значением секунд, например, *ssyyyymmdd*. Если приложение регулярно выполняет операции по перечислению и запросу, выберите функцию хэширования, которая ограничит количество запросов. В некоторых случаях может быть достаточно случайной приставки.
  
- Для получения дополнительной информации о схеме раздела, [Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](https://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf)используемой в хранилище Azure, см.

## <a name="networking"></a>Сети

Физические ограничения сети, в которой работает приложение, оказывают существенное влияние на производительность. В следующих разделах описаны некоторые ограничения, с которыми могут столкнуться пользователи.  

### <a name="client-network-capability"></a>Возможности клиентской сети

Пропускная способность и качество сетевого подключения являются важными факторами, влияющими на производительность приложения, как описано в следующих разделах.

#### <a name="throughput"></a>Пропускная способность

Что касается полосы пропускания, частой проблемой являются возможности клиента. Очень крупные экземпляры Azure имеют сетевые карты, обладающие большими возможностями, поэтому если необходимы более высокие сетевые ограничения от одной машины, следует рассмотреть возможность использования более крупного экземпляра или большего количества виртуальных машин. Если локальное приложение будет обращаться к службе хранилища Azure, примените ту же стратегию. Оцените сетевые возможности клиентского устройства и подключения к расположению службы хранилища Azure, а затем увеличьте их до необходимого уровня или учтите эти ограничения при проектировании приложения.

#### <a name="link-quality"></a>Качество связи

Помните, что состояние любой используемой сети, приводящее к ошибкам и потере пакетов, снижает эффективную пропускную способность.  Использование инструмента WireShark или NetMon может помочь в диагностике этой проблемы.  

### <a name="location"></a>Расположение

В любой распределенной среде наилучшее быстродействие достигается при нахождении клиента рядом с сервером. Для доступа к хранилищу Azure с наименьшей задержкой лучшим местом для клиента будет его нахождение в том же регионе Azure. Например, если ваше веб-приложение Azure использует службу хранилища Azure, обе службы лучше разместить в пределах одного региона (западная часть США, Юго-Восточная Азия и т. д.). Совместное размещение ресурсов уменьшает задержку и снижает стоимость, так как трафик в пределах одного региона остается бесплатным.  

Если же клиентские приложения, которые используют службу хранилища Azure, не размещены в Azure (например, приложения для мобильных устройств или локальные корпоративные службы), учетную запись хранения следует разместить в регионе, максимально приближенном к этим клиентам, так как это может снизить задержку. Если клиенты разбросаны по всему миру (например, часть в Северной Америке, а остальные в Европе), обдумайте вариант с несколькими учетными записями хранения, по одной в каждом регионе. Такой подход легче реализовать, если данные, которые хранят приложения, предназначены для отдельных пользователей, и не требуют репликации между учетными записями хранения.

Для широкого распространения контента капли используйте сеть доставки контента, такого как Azure CDN. Для получения дополнительной информации о сети Azure CDN см. статью [Сеть кэширующих серверов](../../cdn/cdn-overview.md).  

## <a name="sas-and-cors"></a>SAS и CORS

Предположим, что вам нужно создать код JavaScript, который выполняется в веб-браузере пользователя или приложении на мобильном телефоне и обращается к данным в службе хранилища Azure. Один из вариантов — создать приложение-службу, которое выполнит роль прокси-сервера. Устройство пользователя проходит проверку подлинности в этой службе, которая, в свою очередь, предоставляет доступ к ресурсам службы хранилища Azure. Таким образом, на небезопасных устройствах можно не сообщать ключи своей учетной записи хранения. Но такой подход создает значительную нагрузку на приложение-службу, через которое проходят все данные, передаваемые между пользовательским устройством и службой хранилища Azure.

Вы можете обойтись без приложения-службы прокси-сервера, обращаясь к службе хранилища Azure с использованием подписанных URL-адресов (SAS). С технологией SAS вы можете разрешить пользовательскому устройству напрямую обращаться к службе хранилища Azure с маркером ограниченного доступа. Например, если пользователь хочет отправить фотографию в приложение, приложение-служба создаст SAS и отправит его на устройство пользователя. Маркер SAS может предоставлять разрешение на запись в ресурс службы хранилища Azure в течение указанного интервала времени. По истечении этого времени маркер SAS становится недействительным. Дополнительные сведения о подписанных URL-адресах см. в статье об [использование подписанных URL-адресов SAS в службе хранилища Azure](../common/storage-sas-overview.md).  

Обычно браузер не разрешает выполнять в коде JavaScript некоторые операции, например запись данных, в домене, отличном от домена размещения страницы с этим кодом. Эта политика использования одного источника не позволяет вредоносному коду с любой веб-страницы получить доступ к данным, размещенным на другой странице. Но при создании облачного решения политика использования одного источника становится неудобным ограничением. Реализуемая на уровне браузера технология CORS (общий доступ к ресурсам независимо от источника) позволяет целевому домену сообщать браузеру, что он доверяет запросам, поступающим из определенных исходных доменов.

Предположим, что выполняемое в Azure веб-приложение обращается к ресурсу в учетной записи хранения Azure. В этом сценарии веб-приложение выполняет роль исходного домена, а учетная запись хранения является целевым доменом. Вы можете настроить CORS для любой из служб хранилища Azure, чтобы она сообщала веб-браузеру о том, что служба хранилища Azure доверяет запросам, поступающим из исходного домена. Дополнительные сведения о технологии CORS см. в статье [Cross-Origin Resource Sharing (CORS) support for Azure Storage](/rest/api/storageservices/Cross-Origin-Resource-Sharing--CORS--Support-for-the-Azure-Storage-Services) (Поддержка общего доступа к ресурсам независимо от источника (CORS) для службы хранилища Azure).  
  
Технологии SAS и CORS помогают избавиться от лишней нагрузки на веб-приложения.  

## <a name="caching"></a>Caching

Кэшинг играет важную роль в производительности. В следующих разделах обсуждаются рекомендации по кэшингу.

### <a name="reading-data"></a>Чтение данных

В общем, чтение данных один раз предпочтительнее чтения его дважды. Рассмотрим пример веб-приложения, которое получило 50 miB капли из хранилища Azure, чтобы служить в качестве содержимого для пользователя. В идеале приложение кэширует каплю локально на диск, а затем извлекает кэшированную версию для последующих запросов пользователей.

Один из способов избежать извлечения капли, если она не была изменена, так как она была кэширована, чтобы квалифицировать операцию GET с условным заголовком для изменения времени. Если последнее измененное время происходит после момента кэша капли, то капля извлекается и повторно кэшируется. В противном случае кэшированные капли извлекаются для оптимальной производительности.

Вы также можете решить спроектировать приложение, чтобы предположить, что капля остается неизменной в течение короткого периода после его получения. В этом случае приложению не нужно проверять, был ли капля изменена в течение этого интервала.

Данные конфигурации, данные поиска и другие данные, часто используемые приложением, являются хорошими кандидатами для кэширования.  

Для получения дополнительной информации об [использовании](/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations)условных заголовков см.  

### <a name="uploading-data-in-batches"></a>Загрузка данных пакетами

В некоторых сценариях можно агрегировать данные локально, а затем периодически загружать их в пакет вместо того, чтобы немедленно загружать каждую часть данных. Например, предположим, что веб-приложение хранит файл действий. Приложение может либо загружать детали каждого действия, как это происходит со таблицей (которая требует многих операций хранения), или он может сохранить сведения о деятельности в локальный файл журнала, а затем периодически загружать все сведения о деятельности в качестве файла делегированного кабы. Если каждый вход в журнал имеет размер 1 КБ, вы можете загрузить тысячи записей за одну транзакцию. Одна транзакция поддерживает загрузку капли размером до 64 МБ. Разработчик приложения должен спроектировать возможность клиентского устройства или сбоев загрузки. Если данные о действиях необходимо загрузить на промежуток времени, а не для одного действия, то рекомендуется использовать хранилище Blob через хранилище таблицы.

## <a name="net-configuration"></a>Конфигурация .NET

В данном разделе перечислены несколько быстрых параметров конфигурации, которые можно использовать для значительного повышения производительности при использовании платформы .NET Framework.  При использовании других языков проверьте, применяются ли в выбранном языке подобные концепции.  

### <a name="use-net-core"></a>Использование .NET Core

Для разработки приложений, взаимодействующих со службой хранилища Azure, используйте .NET Core 2.1 или более поздних версий, в которых реализованы некоторые улучшения производительности. Мы рекомендуем использовать .NET Core 3.x всегда, когда это возможно.

Дополнительные сведения о повышении производительности в .NET Core вы можете получить в следующих записях блога:

- [о повышении производительности в .NET Core 3.0](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/);
- [о повышении производительности в .NET Core 2.1](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/).

### <a name="increase-default-connection-limit"></a>Увеличение стандартного ограничения на количество подключений

В .NET следующий код увеличивает лимит соединения по умолчанию (который обычно составляет два в клиентской среде или десять в среде сервера) до 100. В обычном случае следует установить значение, приблизительно соответствующее количеству потоков, используемых приложением. Ограничение количества подключений должно быть установлено до открытия каких-либо подключений.

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

Для других языков программирования ознакомьтесь с документацией, чтобы определить, как установить предел соединения.  

Для получения дополнительной информации смотрите [веб-службы в блоге: Concurrent Connections](https://blogs.msdn.microsoft.com/darrenj/2005/03/07/web-services-concurrent-connections/).  

### <a name="increase-minimum-number-of-threads"></a>Увеличение минимального количества потоков

Если вы используете синхронные вызовы с асинхронными задачами, есть смысл увеличить количество потоков в пуле потоков:

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

См. описание метода [ThreadPool.SetMinThreads](/dotnet/api/system.threading.threadpool.setminthreads).  

## <a name="unbounded-parallelism"></a>Неограниченный параллелизм

Параллелизм часто очень полезен для повышения производительности, но следует с настороженностью относиться к неограниченному параллелизму, то есть к отсутствию ограничений на количество потоков или параллельных запросов. Обязательно ограничьте количество параллельных запросов на отправку или скачивание данных, на доступ к нескольким секциям в одной учетной записи хранения и на доступ к нескольким элементам в одной секции. При неограниченном параллелизме приложение сможет превысить возможности клиентского устройства или целевые показатели масштабируемости для учетных записей хранения, что приведет к увеличению задержек и применению регулирования.  

## <a name="client-libraries-and-tools"></a>Клиентские библиотеки и средства

Для повышения производительности всегда используйте самые последние версии клиентских библиотек и средств, предоставляемых корпорацией Майкрософт. Клиентские библиотеки службы хранилища Azure доступны для многих языков. Обозреватель службы хранилища также поддерживает PowerShell и Azure CLI. Корпорация Майкрософт активно развивает эти клиентские библиотеки и средства, оптимизируя их производительность, поддерживая их согласованность с последними версиями служб и реализуя внутреннюю поддержку для многих проверенных методов повышения производительности. Дополнительные сведения см. в [документации по службе хранилища Azure](/azure/storage/#reference).

## <a name="handle-service-errors"></a>Обработка ошибок службы

Служба хранилища Azure возвращает ошибку, если ей не удается обработать запрос. Понимание ошибок, которые возвращает служба хранилища Azure, и соответствующих сценариев, помогает оптимизировать производительность.

### <a name="timeout-and-server-busy-errors"></a>Ошибки времени ожидания и занятости сервера

Служба хранилища Azure может применять регулирование к приложению, когда его загрузка приближается к ограничениям масштабируемости. В некоторых случаях служба хранилища Azure не может обработать запрос из-за некоторого временного состояния. В обоих случаях служба может вернуть ошибку 503 — Server Busy (сервер занят) или 500 — Timeout (время ожидания истекло). Эти же ошибки могут возникать, когда служба перераспределяет сегменты данных для повышения пропускной способности. В большинстве случаев при получении таких ошибок приложению следует повторить операцию, которая их вызвала. Но если служба хранилища Azure применяет к приложению регулирование из-за превышения целевых показателей масштабируемости или по другим причинам, долго не позволяющим службе обработать запрос, агрессивная стратегия повторов только усугубит проблему. Мы рекомендуем использовать экспоненциальную задержку для политики повтора. Во всех клиентских библиотеках именно такое поведение является вариантом по умолчанию. Например, приложение может повторить действие через 2 секунды, затем через 4 секунды, затем через 10 секунд, затем через 30 секунд, а затем полностью отказаться от повторения. Это позволяет приложению значительно снизить нагрузку на службу и не усугублять проблемы, связанные с регулированием.  

Ошибки подключения могут вызывать немедленные повторы, так как они не являются результатом регулирования количества запросов и, как ожидается, будут временными.  

### <a name="non-retryable-errors"></a>Ошибки без возможности повтора

Клиентские библиотеки обрабатывают повторы с учетом того, допускает ли ошибка возможность повтора. Но если вы напрямую обращаетесь к REST API службы хранилища Azure, учитывайте ограничение на повтор для некоторых ошибок. Например, ошибка 400 — Bad Request (ошибка запроса) означает, что отправленный клиентским приложением запрос имеет неправильный формат и его невозможно обработать. Повторная отправка такого запроса каждый раз будет возвращать тот же ответ, и в таком повторе нет смысла. Если вы напрямую вызываете REST API службы хранилища Azure, учитывайте возможные варианты ошибок и применимость повторов для них.

Дополнительные сведения о кодах ошибок в службе хранилища Azure вы найдете в статье [Status and Error Codes](/rest/api/storageservices/status-and-error-codes2) (Коды ошибок и состояний).

## <a name="copying-and-moving-blobs"></a>Копирование и перемещение капли

Azure Storage предоставляет ряд решений для копирования и перемещения капли внутри учетной записи хранения, между учетными записями хранения, а также между камерами и облаком. В этом разделе описаны некоторые из этих вариантов с точки зрения их влияния на производительность. Для получения информации об эффективной передаче данных в хранилище Blob или из нее [см.](../common/storage-choose-data-transfer-solution.md?toc=%2fazure%2fstorage%2fblobs%2ftoc.json)

### <a name="blob-copy-apis"></a>Blob копировать AIS

Для копирования капли через учетные записи хранения, используйте [Put Block От операции URL.](/rest/api/storageservices/put-block-from-url) Эта операция синхронно копирует данные из любого источника URL в блок капли. Использование `Put Block from URL` операции может значительно снизить требуемую пропускную способность при миграции данных через учетные записи хранения данных. Поскольку операция копирования происходит на стороне службы, вам не нужно загружать и перегружать данные.

Для копирования данных в одной учетной записи хранилища используйте операцию [Copy Blob.](/rest/api/storageservices/Copy-Blob) Копирование данных в одной и той же учетной записи хранилища обычно завершается быстро.  

### <a name="use-azcopy"></a>Использование AzCopy

Утилита командной строки AzCopy является простой и эффективной опцией для массовой передачи капли в, из и через счета хранения. AzCopy оптимизирован для этого сценария и может достичь высоких скоростей передачи. Версия 10 AzCopy `Put Block From URL` использует операцию для копирования данных по учетным записям. Для получения дополнительной информации [см. Copy или move data to Azure Storage с помощью AzCopy v10.](/azure/storage/common/storage-use-azcopy-v10)  

### <a name="use-azure-data-box"></a>Используйте ящик данных Azure

Для импорта больших объемов данных в хранилище Blob рассмотрите возможность использования семейства Данных Azure Box для перевода в автономном режиме. Устройства, предоставленные корпорацией Майкрософт, являются хорошим выбором для перемещения больших объемов данных в Azure, когда вы ограничены по времени, доступности сети или затратам. Для получения дополнительной [Azure DataBox Documentation](/azure/databox/)информации см.

## <a name="content-distribution"></a>Распространение содержимого

Иногда приложение должно обслуживать один и тот же контент для многих пользователей (например, демо-видео продукта, используемого на главной странице веб-сайта), расположенного в одних и тех же или нескольких регионах. В этом сценарии используйте сеть доставки контента (CDN), такую как Azure CDN, для географического распространения контента. В отличие от учетной записи хранилища Azure, которая существует в одном регионе и которая не может распространять содержимое с минимальной задержкой в другие регионы, сеть Azure CDN использует серверы, расположенные в нескольких центрах обработки данных по всему миру. Кроме того, сеть CDN обычно поддерживает гораздо более высокие ограничения на выходе, чем одна учетная запись хранения.  

Для получения дополнительной информации о сети Azure CDN см. статью [Сеть кэширующих серверов](../../cdn/cdn-overview.md).

## <a name="use-metadata"></a>Использование метаданных

Служба Blob поддерживает запросы HEAD, которые могут включать свойства капли или метаданные. Например, если вашему приложению нужны данные Exif (формат изображения) с фотографии, оно может получить фотографию и извлечь ее. Чтобы сохранить пропускную способность и повысить производительность, приложение может хранить данные Exif в метаданных капли, когда приложение загружает фотографию. Затем можно получить данные Exif в метаданных, используя только запрос HEAD. Извлечение только метаданных, а не полного содержимого капли, экономит значительную пропускную способность и сокращает время обработки, необходимое для извлечения данных Exif. Имейте в виду, что 8 КИБ метаданных могут храниться на каплю.  

## <a name="upload-blobs-quickly"></a>Загрузка капли быстро

Чтобы загрузить капли быстро, сначала определить, будете ли вы загружать одну каплю или много. Чтобы правильно выбрать метод работы, используйте сведения из приведенного ниже руководства.  

### <a name="upload-one-large-blob-quickly"></a>Загрузите одну большую каплю быстро

Чтобы быстро загрузить одну большую каплю, клиентское приложение может загружать свои блоки или страницы параллельно, памятуя о целевых показателях масштабируемости для отдельных капли и учетной записи хранилища в целом. Библиотеки клиентов Azure Storage поддерживают загрузку параллельно. Например, можно использовать следующие свойства для указания количества одновременных запросов, разрешенных в .NET или Java. Библиотеки клиентов для других поддерживаемых языков предоставляют аналогичные опции.

- Для .NET установите свойство [BlobRequestOptions.ParallelOperationThreadCount.](/dotnet/api/microsoft.azure.storage.blob.blobrequestoptions.paralleloperationthreadcount)
- Для Java/Android позвоните по методу [BlobRequestOptions.setConcurrentRequestCount (окончательный integer concurrentRequestCount).](/java/api/com.microsoft.azure.storage.blob._blob_request_options.setconcurrentrequestcount)

### <a name="upload-many-blobs-quickly"></a>Загрузите много капли быстро

Чтобы быстро отправить множество BLOB-объектов, отправьте их параллельно. Загрузка параллельно происходит быстрее, чем загрузка одной капли одновременно с параллельными загрузками блоков, поскольку она распределяет загрузку по нескольким разделам службы хранения. AzCopy выполняет параллельную отправку по умолчанию, как и рекомендуется для данного случая. Для получения дополнительной информации [см.](../common/storage-use-azcopy-v10.md)  

## <a name="choose-the-correct-type-of-blob"></a>Выберите правильный тип капли

Azure Storage поддерживает блок капли, капли приложений и капли страниц. В данном случае использования выбор типа BLOB-объекта будет влиять на производительность и масштабируемость решения.

Блок капли подходят, когда вы хотите, чтобы загрузить большие объемы данных эффективно. Например, клиентское приложение, которое загружает фотографии или видео в хранилище Blob, будет нацелено на блокировку капли.

Аппен капли похожи на блок капли в том, что они состоят из блоков. При изменении капли приложения блоки добавляются только к концу капли. Капли приложения полезны для таких сценариев, как журналирование, когда приложению необходимо добавить данные в существующий капля.

Капли страницы являются подходящими, если приложение должно выполнять случайные записи на данных. Например, виртуальные машинные диски Azure хранятся как капли страниц. Для получения дополнительной информации, см [Понимание блок капли, приложение капли, и страницы капли](/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs).  

## <a name="next-steps"></a>Дальнейшие действия

- [Целевые показатели масштабируемости и производительности для хранилища BLOB-объектов](scalability-targets.md)
- [Целевые показатели масштабируемости и производительности для учетных записей хранения ценовой категории "Стандартный"](../common/scalability-targets-standard-account.md?toc=%2fazure%2fstorage%2fblobs%2ftoc.json)
- [Коды состояний и ошибок](/rest/api/storageservices/Status-and-Error-Codes2)
