---
title: Настраиваемые модели
titleSuffix: Azure Digital Twins
description: Узнайте, как в Azure Digital двойников используются пользовательские модели для описания сущностей в среде.
author: baanders
ms.author: baanders
ms.date: 3/12/2020
ms.topic: conceptual
ms.service: digital-twins
ms.openlocfilehash: 2d062ea4f38742129d44be0e2b7ff51fe3ad8dd1
ms.sourcegitcommit: 97a0d868b9d36072ec5e872b3c77fa33b9ce7194
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87562435"
---
# <a name="understand-twin-models-in-azure-digital-twins"></a>Общие сведения о моделях двойника в Azure Digital двойников

Ключевой характеристикой Azure Digital двойников является возможность определения собственного словаря и создания графа двойника в самостоятельно определенных условиях вашего бизнеса. Эта возможность предоставляется с помощью пользовательских **моделей**. Модели можно рассматривать как существительные в описании мира. 

Модель похожа на **класс** в объектно-ориентированном языке программирования, определяя фигуру данных для одной конкретной концепции в реальной рабочей среде. Модели имеют имена (например, *комнаты* или *датчик температуры*) и содержат элементы, такие как свойства, данные телеметрии и события, и команды, которые описывают, что может делать сущность этого типа в вашей среде. Позже эти модели будут использоваться для создания [**цифровых двойников**](concepts-twins-graph.md) , представляющих определенные сущности, которые соответствуют этому описанию типа.

Модели пишутся с помощью **языка определения цифровых двойника**на основе JSON-LD (дтдл).  

## <a name="digital-twin-definition-language-dtdl-for-writing-models"></a>Язык определения цифровых двойника (ДТДЛ) для создания моделей

Модели для Azure Digital двойников определяются с помощью языка определения цифровых двойников (ДТДЛ). ДТДЛ основан на JSON-LD и не зависит от языка программирования. ДТДЛ не является эксклюзивным для Azure Digital двойников, но также используется для представления данных устройства в других службах IoT, таких как [iot Plug and Play](../iot-pnp/overview-iot-plug-and-play.md). 

В Azure Digital двойников используется **дтдл _версии 2_**. Дополнительные сведения об этой версии ДТДЛ см. в документации по спецификациям на сайте GitHub: [*Digital двойников Definition Language (дтдл) — версия 2*](https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md). Использование ДТДЛ _версии 1_ с Azure Digital двойников теперь устарело.

> [!TIP] 
> Не все службы, использующие ДТДЛ, реализуют одни и те же функции ДТДЛ. Например, IoT Plug and Play не использует функции ДТДЛ, предназначенные для графов, в то время как Azure Digital двойников в настоящее время не реализует команды ДТДЛ. Дополнительные сведения о функциях ДТДЛ, относящихся к Azure Digital двойников, см. в подразделе далее в этой статье, посвященной [особенностям реализации Azure Digital ДВОЙНИКОВ дтдл](#azure-digital-twins-dtdl-implementation-specifics).

## <a name="elements-of-a-model"></a>Элементы модели

В определении модели элемент кода верхнего уровня является **интерфейсом**. Это инкапсулирует всю модель, а остальная часть модели определяется в интерфейсе. 

Интерфейс модели ДТДЛ может содержать ноль, одно или несколько из следующих полей:
* Свойства **Свойства** — это поля данных, которые представляют состояние сущности (например, свойства во многих языках объектно-ориентированного программирования). В отличие от данных телеметрии, которые являются событиями с данными, связанными с временем, свойства имеют резервное хранилище и могут быть считаны в любое время.
* **Телеметрии** — поля телеметрии представляют измерения или события, и часто используются для описания считывания датчика устройства. Данные телеметрии не хранятся в цифровом двойника; Это более похоже на поток событий данных, готовых к отправке в любое место. 
* **Компонент Components** -Components позволяет при необходимости построить интерфейс модели как сборку других интерфейсов. Примером компонента является интерфейс *фронткамера* (и другая интерфейсная *Камера*), который используется при определении модели для *телефона*. Необходимо сначала определить интерфейс для *фронткамера* , как если бы он был собственной моделью, а затем ссылаться на него при определении *телефона*.

    Используйте компонент для описания того, что является неотъемлемой частью решения, но не требует отдельного удостоверения, и его не нужно создавать, удалять или переупорядочивать в графе двойника независимо друг от друга. Если требуется, чтобы сущности имели независимые существования на графе двойника, они представляют их как отдельные цифровые двойников различных моделей, Соединенные *связями* (см. следующий маркер).
    
    >[!TIP] 
    >Компоненты также можно использовать для Организации, чтобы сгруппировать наборы связанных свойств в интерфейсе модели. В этом случае каждый компонент можно считать пространством имен или папкой внутри интерфейса.
* Отношения « **связь-отношение** » позволяют представить, как цифровые двойника могут быть вовлечены в другие цифровые двойников. Отношения могут представлять различные семантические значения, например *Contains* ("этаж содержит комнату"), *выисбилледто* *("* охлаждение"), "(" для пользователя "и т. д.") и т. д. Связи позволяют решению предоставлять граф взаимосвязанных сущностей.

> [!NOTE]
> Спецификация ДТДЛ также определяет **команды**, которые являются методами, которые могут быть выполнены в цифровом двойника (например, команда Reset) или команда для переключения вентилятора. Однако *команды в настоящее время не поддерживаются в Azure Digital двойников.*

### <a name="azure-digital-twins-dtdl-implementation-specifics"></a>Особенности реализации ДТДЛ в Azure Digital двойников

Чтобы модель ДТДЛ была совместима с Azure Digital двойников, она должна соответствовать этим требованиям.

* Все элементы ДТДЛ верхнего уровня в модели должны иметь тип *Interface*. Это обусловлено тем, что интерфейсы API модели Digital двойников могут получить объекты JSON, представляющие интерфейс или массив интерфейсов. В результате на верхнем уровне не допускаются другие типы элементов ДТДЛ.
* ДТДЛ для Azure Digital двойников не должен определять какие бы то ни было *команды*.
* Azure Digital двойников допускает только один уровень вложенности компонентов. Это означает, что интерфейс, используемый в качестве компонента, не может иметь самих компонентов. 
* Интерфейсы не могут быть определены встроенными в других интерфейсах ДТДЛ; они должны быть определены как отдельные сущности верхнего уровня с собственными идентификаторами. Затем, когда другой интерфейс хочет включить этот интерфейс как компонент или через наследование, он может ссылаться на его идентификатор.

## <a name="example-model-code"></a>Пример кода модели

Модели типов двойника могут быть написаны в любом текстовом редакторе. Язык ДТДЛ соответствует синтаксису JSON, поэтому необходимо хранить модели с расширением *. JSON*. Использование расширения JSON позволит многим текстовым редакторам программирования обеспечить базовую проверку синтаксиса и выделение для документов ДТДЛ. Существует также [расширение дтдл](https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.vscode-dtdl) , доступное для [Visual Studio Code](https://code.visualstudio.com/).

В этом разделе содержится пример типичной модели, написанной как интерфейс ДТДЛ. Модель описывает **планеты**, каждый из которых имеет имя, масса и температуру.
 
Учтите, что планеты также могут взаимодействовать с **лунами** , которые являются их вспомогательными, и могут содержать **кратерс**. В приведенном ниже примере `Planet` модель выражает соединения с другими сущностями, ссылаясь на две внешние модели — `Moon` и `Crater` . Эти модели также определяются в приведенном ниже примере кода, но хранятся очень просто, поэтому не следует полагаться на основной `Planet` пример.

```json
[
  {
    "@id": "dtmi:com:contoso:Planet;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Planet",
    "contents": [
      {
        "@type": "Property",
        "name": "name",
        "schema": "string"
      },
      {
        "@type": "Property",
        "name": "mass",
        "schema": "double"
      },
      {
        "@type": "Telemetry",
        "name": "Temperature",
        "schema": "double"
      },
      {
        "@type": "Relationship",
        "name": "satellites",
        "target": "dtmi:com:contoso:Moon;1"
      },
      {
        "@type": "Component",
        "name": "deepestCrater",
        "schema": "dtmi:com:contoso:Crater;1"
      }
    ]
  },
  {
    "@id": "dtmi:com:contoso:Crater;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
  },
  {
    "@id": "dtmi:com:contoso:Moon;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
  }
]
```

Поля модели:

| Поле | Описание |
| --- | --- |
| `@id` | Идентификатор модели. Значение должно быть в формате `dtmi:<domain>:<unique model identifier>;<model version number>` . |
| `@type` | Определяет тип описываемой информации. Для интерфейса используется тип *Interface*. |
| `@context` | Задает [контекст](https://niem.github.io/json/reference/json-ld/context/) для документа JSON. Модели должны использовать `dtmi:dtdl:context;2` . |
| `displayName` | используемых Позволяет при необходимости присвоить модели понятное имя. |
| `contents` | Все остальные данные интерфейса помещаются здесь в виде массива определений атрибутов. Каждый атрибут должен предоставлять `@type` (*свойство*, *телеметрию*, *команду*, *связь*или *компонент*) для определения того, какую информацию о интерфейсе он описывает, а затем набор свойств, определяющих фактический атрибут (например, `name` и `schema` для определения *Свойства*). |

> [!NOTE]
> Обратите внимание, что интерфейс компонента (*кратер* в этом примере) определен в том же массиве, что и интерфейс, который его использует (*Планета*). Компоненты должны быть определены таким образом в вызовах API, чтобы был найден интерфейс.

### <a name="possible-schemas"></a>Возможные схемы

Как и для дтдл, схема для атрибутов *свойств* и *телеметрии* может иметь стандартные примитивные типы — `integer` , `double` , `string` и, `Boolean` и другие типы, такие как `DateTime` и `Duration` . 

Помимо типов-примитивов, поля *свойств* и *телеметрии* могут иметь следующие сложные типы:
* `Object`
* `Map`
* `Enum`

Поля *телеметрии* также поддерживают `Array` .

### <a name="model-inheritance"></a>Наследование модели

Иногда может потребоваться дальнейшее специализацию модели. Например, может быть полезно иметь универсальное *пространство*модели, а также специализированные варианты *конференцерум* и *ГИМ*. Чтобы выразить специализацию, ДТДЛ поддерживает наследование: интерфейсы могут наследовать от одного или нескольких других интерфейсов. 

В следующем примере демонстрируется повторная модель *планеты* из предыдущего примера дтдл в качестве подтипа более крупной модели *целестиалбоди* . Сначала определяется "родительская" модель, а затем "дочерняя" модель строится на ней с помощью поля `extends` .

```json
[
  {
    "@id": "dtmi:com:contoso:CelestialBody;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Celestial body",
    "contents": [
      {
        "@type": "Property",
        "name": "name",
        "schema": "string"
      },
      {
        "@type": "Property",
        "name": "mass",
        "schema": "double"
      },
      {
        "@type": "Telemetry",
        "name": "temperature",
        "schema": "double"
      }
    ]
  },
  {
    "@id": "dtmi:com:contoso:Planet;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2",
    "displayName": "Planet",
    "extends": "dtmi:com:contoso:CelestialBody;1",
    "contents": [
      {
        "@type": "Relationship",
        "name": "satellites",
        "target": "dtmi:com:contoso:Moon;1"
      },
      {
        "@type": "Component",
        "name": "deepestCrater",
        "schema": "dtmi:com:contoso:Crater;1"
      }
    ]
  },
  {
    "@id": "dtmi:com:contoso:Crater;1",
    "@type": "Interface",
    "@context": "dtmi:dtdl:context;2"
  }
]
```

В этом примере *целестиалбоди* вносит имя, масса и температуру в *планеты*. `extends`Раздел представляет собой имя интерфейса или массив имен интерфейсов (что позволяет расширять интерфейс наследовать от нескольких родительских моделей при необходимости).

После применения наследования расширяющий интерфейс предоставляет все свойства из всей цепочки наследования.

Расширяющий интерфейс не может изменять любые определения родительских интерфейсов; Он может добавлять только к ним. Он также не может переопределить возможность, уже определенную в любом из ее родительских интерфейсов (даже если возможности определены как одинаковые). Например, если родительский интерфейс определяет `double` свойство *массы*, то расширяющий интерфейс не может содержать объявление *массы*, даже если это также `double` .

## <a name="validating-models"></a>Проверка моделей

> [!TIP]
> Перед отправкой в свой экземпляр Azure Digital двойников рекомендуется проверить свои модели в автономном режиме.

Существует независимый от языка пример, доступный для проверки документов модели, чтобы убедиться в правильности ДТДЛ. Он расположен здесь: [**Пример проверяющего элемента управления дтдл**](https://docs.microsoft.com/samples/azure-samples/dtdl-validator/dtdl-validator).

Пример проверяющего элемента управления ДТДЛ основан на библиотеке средства синтаксического анализа .NET ДТДЛ, которая доступна в NuGet в качестве клиентской библиотеки: [**Microsoft. Azure. дигиталтвинс. Parser**](https://nuget.org/packages/Microsoft.Azure.DigitalTwins.Parser/). Библиотеку можно также использовать непосредственно для разработки собственного решения проверки. При использовании библиотеки средства синтаксического анализа обязательно используйте версию, совместимую с версией, которая работает в Azure Digital двойников. На этапе предварительной версии это *3.7.0*версии.

Дополнительные сведения о библиотеке анализатора, включая примеры использования, см. в статье [*инструкции. анализ и проверка моделей*](how-to-use-parser.md).

## <a name="next-steps"></a>Дальнейшие действия

См. раздел Управление моделями с помощью API-интерфейсов Дигиталтвинсмоделс:
* [*Практическое руководство. Управление настраиваемыми моделями*](how-to-manage-model.md).

Или Узнайте, как создаются цифровые двойников на основе моделей:
* [*Основные понятия: Цифровые двойников и двойника Graph*](concepts-twins-graph.md)

