---
title: Профилирование приложений в рабочей среде Azure с помощью Application Insights Profiler | Документация Майкрософт
description: Определите критический путь в коде веб-сервера с помощью профилировщика небольшого размера.
services: application-insights
documentationcenter: ''
author: cweining
manager: carmonm
ms.service: application-insights
ms.workload: tbd
ms.tgt_pltfrm: ibiza
ms.topic: conceptual
ms.reviewer: mbullwin
ms.date: 08/06/2018
ms.author: cweining
ms.openlocfilehash: c07b325f3de6cd2cf3aaa436736786d2cdc42881
ms.sourcegitcommit: 41ca82b5f95d2e07b0c7f9025b912daf0ab21909
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "60306331"
---
# <a name="profile-production-applications-in-azure-with-application-insights"></a>Профилирование приложений в рабочей среде Azure с помощью Application Insights Profiler
## <a name="enable-application-insights-profiler-for-your-application"></a>Включение Application Insights Profiler для приложений

Azure Application Insights Profiler предоставляет трассировки производительности приложений, выполняющихся в рабочей среде Azure. Профилировщик автоматически выполняет сбор данных в большом масштабе, не осложняя работу пользователей. Профилировщик помогает найти критический путь кода, выполнение которого занимает больше всего времени при обработке отдельных веб-запросов. 

Профилировщик работает с приложениями .NET, развернутыми в следующих службах Azure. Конкретные инструкции по включению Profiler для службы каждого типа вы найдете по приведенным ниже ссылкам.

* [службе приложений Azure](profiler.md?toc=/azure/azure-monitor/toc.json)
* [Облачные службы Azure](profiler-cloudservice.md?toc=/azure/azure-monitor/toc.json)
* [Azure Service Fabric](profiler-servicefabric.md?toc=/azure/azure-monitor/toc.json)
* [Профилирование веб-приложений, работающих на виртуальной машине Azure или в масштабируемом наборе виртуальных машин, с помощью Application Insights Profiler](profiler-vm.md?toc=/azure/azure-monitor/toc.json)
* [**Предварительная версия** ASP.NET Core Linux веб-приложений Azure](profiler-aspnetcore-linux.md?toc=/azure/azure-monitor/toc.json) 

Если вы уже включили Profiler, но трассировки не отображаются, проверьте [руководство по устранению неполадок](profiler-troubleshooting.md?toc=/azure/azure-monitor/toc.json).

## <a name="view-profiler-data"></a>Просмотр данных Profiler

Чтобы Profiler смог отправлять трассировки, приложение должно активно обрабатывать запросы. Для эксперимента запросы к веб-приложению можно создать [в рамках тестирования производительности Application Insights](https://docs.microsoft.com/vsts/load-test/app-service-web-app-performance-test). Если вы только что включили Profiler, запустите короткий нагрузочный тест. Во время выполнения нагрузочного теста нажмите кнопку **Профилировать** в области [**параметров профилировщика**](profiler-settings.md#profiler-settings-pane). При выполнении Profiler случайным образом выбирает время для сбора данных, примерно по две минуты один раз в час. Если приложение обрабатывает устойчивый поток запросов, Profiler отправляет трассировки каждый час.

После того как приложение получит некоторый объем трафика, а Profiler — достаточное время для передачи трассировок, вы получите возможность их просмотреть. Этот процесс может занять от 5 до 10 минут. Чтобы просмотреть трассировки, на панели **Производительность** выберите **Take Actions** (Предпринять действия), а затем нажмите кнопку **Profiler Traces** (Трассировки Profiler).

![Кнопка Profiler traces (Трассировки Profiler) в области Preview Performance (Производительность предварительной версии) Application Insights][performance-blade]

Выберите пример, чтобы отобразить классификацию на уровне кода по времени, затраченному на выполнение запроса.

![Обозреватель трассировки Application Insights][trace-explorer]

Обозреватель трассировки отображает следующие сведения:

* **Показать критический путь** — открывает основной листовой узел или похожий конечный объект. В большинстве случаев этот узел находится рядом с узким местом производительности.
* **Метка** — имя функции или события. В дереве отображается сочетание кода и возникающих событий (например, события SQL и HTTP). Основное событие предоставляет общую длительность запроса.
* **Прошло** — интервал времени между началом и завершением операции.
* **Когда** — время запуска функции или события по отношению к другим функциям.

## <a name="how-to-read-performance-data"></a>Чтение данных о производительности

Профилировщик службы Майкрософт использует метод выборки в сочетании с инструментированием для анализа производительности приложения. Во время подробной сборки профилировщик службы каждую миллисекунду проводит выборку указателя инструкций для всех ЦП компьютера. Каждый пример записывает полный стек вызовов выполняющегося потока. Он предоставляет подробные сведения об этом потоке на высоком и низком уровне абстракции. Профилировщик службы также собирает сведения о других событиях, включая события переключения контекста, библиотеки параллельных задач (TPL) и пула потоков, для отслеживания корреляции действий и причинно-следственных связей.

Стек вызовов, отображаемый в представлении временной шкалы, является результатом выборки и инструментирования. Так как каждый пример записывает полный стек вызовов потока, он содержит код из Microsoft .NET Framework, а также из других указанных вами платформ.

### <a id="jitnewobj"></a>Выделение объектов (clr!JIT\_New или clr!JIT\_Newarr1)

**clr!JIT\_New** и **clr!JIT\_Newarr1** — это вспомогательные функции в .NET Framework, выделяющие память из управляемой кучи. **clr!JIT\_New** вызывается при выделении объекта. **clr!JIT\_Newarr1** вызывается при выделении массива объектов. Обычно эти две функции выполняются быстро за относительно небольшое время. Если функции **clr!JIT\_New** или **clr!JIT\_Newarr1** занимают довольно много времени во временной шкале, код, возможно, выделяет много объектов и потребляет значительный объем памяти.

### <a id="theprestub"></a>Код загрузки (clr!ThePreStub)

**clr!ThePreStub** — это вспомогательная функция в .NET Framework, подготавливающая код к первому выполнению. Это выполнение обычно включает в себя JIT-компиляцию, но не ограничивается ею. Для каждого метода C# **clr!ThePreStub** должна вызываться только один раз в течение процесса.

Если выполнение **clr!ThePreStub** при запросе занимает много времени, значит этот метод выполняется впервые. На загрузку первого метода требуется значительное время работы среды выполнения .NET Framework. Вы можете использовать процесс прогрева, выполняющий эту часть кода до предоставления к нему доступа пользователям, или запустить генератор образа в машинном коде (ngen.exe) в сборках.

### <a id="lockcontention"></a>Конфликт блокировки (clr!JITutil\_MonContention или clr!JITutil\_MonEnterWorker)

**clr!JITutil\_MonContention** или **clr!JITutil\_MonEnterWorker** указывает, что текущий поток ожидает снятия блокировки. Этот текст обычно отображается при выполнении команды **LOCK** языка C# путем вызова метода **Monitor.Enter** или метода с атрибутом **MethodImplOptions.Synchronized**. Конфликт блокировки обычно происходит при получении блокировки потоком _A_, а также при попытке получить ту же блокировку потоком _Б_ до ее снятия потоком _A_.

### <a id="ngencold"></a>Код загрузки ([COLD])

Если имя метода содержит **[COLD]** , например **mscorlib.ni![COLD]System.Reflection.CustomAttribute.IsDefined**, это значит, что в среде выполнения .NET Framework впервые выполняется код, который не был оптимизирован с помощью [профильной оптимизации](/cpp/build/profile-guided-optimizations). Для каждого метода он должен отображаться только один раз в течение процесса.

Если коду загрузки требуется значительное время на запрос, значит запрос впервые выполняет неоптимизированную часть метода. Вы можете использовать процесс прогрева, который выполняет эту часть кода до предоставления к нему доступа пользователям.

### <a id="httpclientsend"></a>Отправка HTTP-запроса

Методы, такие как **HttpClient.Send**, указывают на то, что код ожидает завершения HTTP-запроса.

### <a id="sqlcommand"></a>Операция с базой данных

Методы, такие как **SqlCommand.Execute**, указывают на то, что код ожидает завершения операции с базой данных.

### <a id="await"></a>Ожидание (AWAIT\_TIME)

**AWAIT\_TIME** указывает на то, что код ожидает завершения другой задачи. Задержка обычно осуществляется с помощью инструкции **AWAIT** языка C#. Когда код выполняет команду C# **AWAIT**, поток освобождается и возвращает управление пулу потоков, то есть ни один поток не блокируется в ожидании завершения **AWAIT**. Однако если рассуждать логически, то поток, который выполнил команду **AWAIT**, "заблокирован" и ожидает завершения операции. Команда **AWAIT\_TIME** указывает время блокировки в ожидании завершения задачи.

### <a id="block"></a>Время блокировки

**BLOCKED_TIME** указывает на то, что код ожидает, пока другой ресурс станет доступным. Например, он может ожидать объект синхронизации, или когда поток станет доступным, или когда завершится запрос.

### <a name="unmanaged-async"></a>Неуправляемые Async

.NET framework генерирует события ETW и передает коды операций между потоками, что можно отслеживать асинхронные вызовы между потоками. Неуправляемый код (машинный код) и некоторые более старые стили асинхронного кода отсутствуют эти события и коды операций, поэтому профилировщик не может определить, какой поток и какие функции выполняются в потоке. Это называется «Неуправляемых Async» в стеке вызовов. Если вы загрузите файл трассировки событий Windows, можно использовать [PerfView](https://github.com/Microsoft/perfview/blob/master/documentation/Downloading.md) Чтобы получить дополнительные сведения о том, что происходит.

### <a id="cpu"></a>Время ЦП

ЦП занят выполнением инструкций.

### <a id="disk"></a>Время работы диска

Приложение выполняет операции с диском.

### <a id="network"></a>Сетевое время

Приложение выполняет сетевые операции.

### <a id="when"></a>Столбец "Время"

Столбец **Когда** — это визуальное представление того, как со временем изменяются выборки INCLUSIVE, собранные для узла. Общий диапазон запроса состоит из 32 временных периодов. В них накапливаются включающие выборки для данного узла. Каждый период представляется в виде полосы. Высота полосы обозначает масштабированное значение. Для узлов, помеченных как **CPU_TIME** или **BLOCKED_TIME**, или когда существует очевидная связь с потреблением ресурсов (например, ЦП, диск или поток), в полосе представлено использование одного из этих ресурсов в контейнере. Для этих метрик можно получить значение, превышающее 100 процентов, за счет потребления нескольких ресурсов. Например, если в среднем за определенный интервал времени используется два процессора, то показатель достигнет 200 процентов.

## <a name="limitations"></a>Ограничения

Срок хранения данных по умолчанию — пять дней. Максимальный объем ежедневно обрабатываемых данных — 10 ГБ.

За использование службы профилировщика плата не взимается. Чтобы вы могли использовать ее, веб-приложение должно быть размещено по крайней мере на уровне "Базовый" функции веб-приложения Службы приложений Azure.

## <a name="overhead-and-sampling-algorithm"></a>Дополнительная нагрузка и алгоритм выборки

Раз в час профилировщик запускается случайным образом на две минуты на каждой виртуальной машине, где размещено приложение, для сбора трассировок которого настроен профилировщик. При запуске Profiler увеличивает нагрузку на ресурсы ЦП сервера на 5–15 процентов.

## <a name="next-steps"></a>Дальнейшие действия
Включение Application Insights Profiler для приложения Azure. См. также:
* [Службы приложений](profiler.md?toc=/azure/azure-monitor/toc.json)
* [Облачные службы Azure](profiler-cloudservice.md?toc=/azure/azure-monitor/toc.json)
* [Azure Service Fabric](profiler-servicefabric.md?toc=/azure/azure-monitor/toc.json)
* [Профилирование веб-приложений, работающих на виртуальной машине Azure или в масштабируемом наборе виртуальных машин, с помощью Application Insights Profiler](profiler-vm.md?toc=/azure/azure-monitor/toc.json)


[performance-blade]: ./media/profiler-overview/performance-blade-v2-examples.png
[trace-explorer]: ./media/profiler-overview/trace-explorer.png
