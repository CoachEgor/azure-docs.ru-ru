---
title: Оптимизация запросов журналов в Azure Monitor
description: Рекомендации по оптимизации запросов журналов в Azure Monitor.
ms.subservice: logs
ms.topic: conceptual
author: bwren
ms.author: bwren
ms.date: 02/28/2019
ms.openlocfilehash: c32731ce2de2b0f886a1e21ee8ccad3996e395eb
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79480272"
---
# <a name="optimize-log-queries-in-azure-monitor"></a>Оптимизация запросов журналов в Azure Monitor
Журналы Azure Monitor используют [Azure Data Explorer (ADX)](/azure/data-explorer/) для хранения данных журналов и выполнения запросов для анализа этих данных. Он создает, управляет и поддерживает кластеры ADX для вас и оптимизирует их для рабочей нагрузки анализа журнала. При запуске запроса он оптимизирован и направляется в соответствующий кластер ADX, который хранит данные рабочего пространства. Как журналы Azure Monitor, так и Azure Data Explorer используют множество механизмов автоматической оптимизации запросов. Хотя автоматическая оптимизация обеспечивает значительный импульс, в некоторых случаях они могут значительно улучшить производительность запроса. В этой статье объясняется соображения производительности и несколько методов, чтобы исправить их.

Большинство методов являются общими для запросов, которые работают непосредственно на Azure Data Explorer и журналы мониторинга Azure, хотя здесь обсуждается несколько уникальных соображений журналов мониторинга Azure, которые обсуждаются здесь. Дополнительные советы по оптимизации Azure Data Explorer можно узнать из [рекомендаций по оптимизации запросов.](/azure/kusto/query/best-practices)

Оптимизированные запросы будут:

- Выполнить быстрее, уменьшить общую продолжительность выполнения запроса.
- Имеют меньшие шансы быть задушенили или отклонены.

Особое внимание следует уделить запросам, которые используются для повторного и взрывного использования, таких как панели мониторинга, оповещения, логические приложения и Power BI. Влияние неэффективного запроса в этих случаях является существенным.

## <a name="query-performance-pane"></a>Панель производительности запроса
После выполнения запроса в журнале Analytics щелкните ниже стрелку ниже результатов запроса, чтобы просмотреть панель производительности запроса, которая показывает результаты нескольких индикаторов производительности для запроса. Каждый из этих показателей эффективности описан в следующем разделе.

![Панель производительности запроса](media/query-optimization/query-performance-pane.png)


## <a name="query-performance-indicators"></a>Показатели эффективности запросов

Для каждого выполненного запроса доступны следующие индикаторы производительности запроса:

- [Общий процессор:](#total-cpu)Общий вычисление, используемое для обработки запроса во всех вычислительных узлах. Он представляет собой время, используемое для вычислений, анализа и извлечения данных. 

- [Данные, используемые для обработанного запроса:](#data-used-for-processed-query)Общие данные, которые были доступны для обработки запроса. Под влиянием размера целевой таблицы, используемого промежутка времени, примененных фильтров и количества упомянутых столбцов.

- [Временной промежуток обработанного запроса](#time-span-of-the-processed-query): Разрыв между новейшими и самыми старыми данными, которые были доступны для обработки запроса. Под влиянием явного диапазона времени, указанного для запроса.

- [Возраст обработанных данных](#age-of-processed-data): Разрыв между сейчас и старейших данных, которые были доступны для обработки запроса. Это в высокой степени влияет на эффективность извлечения данных.

- [Количество рабочих областей:](#number-of-workspaces)Сколько рабочих областей было доступно во время обработки запросов из-за неявного или явного выбора.

- [Количество регионов](#number-of-regions): Сколько регионов было доступно во время обработки запросов, основанной на неявном или явном выборе рабочих областей. Многорегиональные запросы гораздо менее эффективны, а показатели эффективности имеют частичный охват.

- [Параллелизм](#parallelism): Указывает, сколько система смогла выполнить этот запрос на нескольких узлах. Относится только к запросам, которые имеют высокое потребление процессора. Под влиянием использования конкретных функций и операторов.


## <a name="total-cpu"></a>Всего процессоров
Фактический процессор вычислений, который был инвестирован для обработки этого запроса во всех узлах обработки запросов. Поскольку большинство запросов выполняется на большом количестве узлов, это обычно намного больше, чем продолжительность запроса, фактически необходимого для выполнения. 

Время обработки запросов тратится на:
- Поиск данных – поиск старых данных потребует больше времени, чем поиск последних данных.
- Обработка данных – логика и оценка данных. 

Помимо времени, затрачиваемого на узлы обработки запросов, есть дополнительное время, затрачиваемые журналами Azure Monitor, чтобы: аутентифицировать пользователя и убедиться, что ему разрешен доступ к этим данным, найти хранилище данных, разобрать запрос и выделить обработку запроса Узлов. Это время не включено в общее время процессора запроса.

### <a name="early-filtering-of-records-prior-of-using-high-cpu-functions"></a>Ранняя фильтрация записей до использования высоких функций процессора

Некоторые команды и функции запроса являются тяжелыми в потреблении процессора. Это особенно верно для команд, которые разбирают JSON и XML или извлекают сложные регулярные выражения. Такой разбор может происходить явно через [parse_json ()](/azure/kusto/query/parsejsonfunction) или [parse_xml ()](/azure/kusto/query/parse-xmlfunction) функции или неявно при общении с динамическими столбиками.

Эти функции потребляют процессор пропорционально количеству обрабатываемых строк. Наиболее эффективной оптимизацией является добавление условий на ранних стадиях запроса, которые могут отфильтровать как можно больше записей до выполнения интенсивной функции процессора.

Например, следующие запросы дают точно такой же результат, но второй на сегодняшний день является наиболее эффективным, поскольку [условие](/azure/kusto/query/whereoperator) перед разбором исключает множество записей:

```Kusto
//less efficient
SecurityEvent
| extend Details = parse_xml(EventData)
| extend FilePath = tostring(Details.UserData.RuleAndFileData.FilePath)
| extend FileHash = tostring(Details.UserData.RuleAndFileData.FileHash)
| summarize count() by FileHash, FilePath
| where FileHash != "" and FilePath !startswith "%SYSTEM32"  // Problem: irrelevant results are filtered after all processing and parsing is done
```
```Kusto
//more efficient
SecurityEvent
| where EventID == 8002 //Only this event have FileHash
| where EventData !has "%SYSTEM32" //Early removal of unwanted records
| extend Details = parse_xml(EventData)
| extend FilePath = tostring(Details.UserData.RuleAndFileData.FilePath)
| extend FileHash = tostring(Details.UserData.RuleAndFileData.FileHash)
| summarize count() by FileHash, FilePath
| where FileHash != "" // No need to filter out %SYSTEM32 here as it was removed before
```

### <a name="avoid-using-evaluated-where-clauses"></a>Избегайте использования оцененных мест, где положения

Запросы, содержащие, [где](/azure/kusto/query/whereoperator) положения на оцениваемом столбце, а не на столбцах, физически присутствующих в наборе данных, теряют эффективность. Фильтрация на оцениваемых столбцах предотвращает некоторые оптимизации системы при обработке больших наборов данных.
Например, следующие запросы дают точно такой же результат, но второй более эффективен, как и состояние, [в](/azure/kusto/query/whereoperator) котором условие относится к встроенной колонке

```Kusto
//less efficient
Heartbeat 
| extend IPRegion = iif(RemoteIPLongitude  < -94,"WestCoast","EastCoast")
| where IPRegion == "WestCoast"
| summarize count() by Computer
```
```Kusto
//more efficient
Heartbeat 
| where RemoteIPLongitude  < -94
| extend IPRegion = iif(RemoteIPLongitude  < -94,"WestCoast","EastCoast")
| summarize count() by Computer
```

### <a name="use-effective-aggregation-commands-and-dimmentions-in-summarize-and-join"></a>Используйте эффективные команды агрегирования и dimmentions в суммировании и присоединении

В то время как некоторые команды агрегирования, такие как [max()](/azure/kusto/query/max-aggfunction), [сумма(),](/azure/kusto/query/sum-aggfunction) [кол()](/azure/kusto/query/count-aggfunction)и [avg()](/azure/kusto/query/avg-aggfunction) имеют низкое влияние процессора из-за их логики, другие являются более сложными и включают эвристику и оценки, которые позволяют им быть выполнены эффективно. Например, [dcount()](/azure/kusto/query/dcount-aggfunction) использует алгоритм HyperLogLog для обеспечения близкой оценки для четкого подсчета больших наборов данных без фактического подсчета каждого значения; процентильные функции делают аналогичные приближения с помощью ближайшего ранга процентиля алгоритма. Некоторые из команд включают дополнительные параметры для уменьшения их воздействия. Например, функция [makeset()](/azure/kusto/query/makeset-aggfunction) имеет дополнительный параметр для определения максимального размера набора, что значительно влияет на процессор и память.

[Присоединение](/azure/kusto/query/joinoperator?pivots=azuremonitor) и [обобщение](/azure/kusto/query/summarizeoperator) команд может привести к высокому использованию процессора при обработке большого набора данных. Их сложность напрямую связана с числом возможных значений, называемых *кардинальностью,* столбцов, которые используются `by` в качестве обобщения или атрибутов соединения. Для объяснения и оптимизации соединения и обобщения, смотрите их статьи документации и советы по оптимизации.

Например, следующие запросы дают точно такой же результат, потому что **CounterPath** всегда один к одному отображается на **CounterName** и **ObjectName**. Второй является более эффективным, поскольку измерение агрегации меньше:

```Kusto
//less efficient
Perf
| summarize avg(CounterValue) 
by CounterName, CounterPath, ObjectName
```
```Kusto
//make the group expression more compact improve the performance
Perf
| summarize avg(CounterValue), any(CounterName), any(ObjectName) 
by CounterPath
```

Потребление процессора также может быть затронуто условиями или расширенными столбцов, требующими интенсивных вычислений. Все тривиальные сравнения строк, такие как [равные и](/azure/kusto/query/datatypes-string-operators) [startswith](/azure/kusto/query/datatypes-string-operators) имеют примерно одинаковое влияние процессора, в то время как продвинутые текстовые совпадения имеют большее влияние. В частности, [имеет](/azure/kusto/query/datatypes-string-operators) оператора является более эффективным, что [содержит](/azure/kusto/query/datatypes-string-operators) оператора. Из-за методов обработки строк, это более эффективно искать строки, которые больше, чем четыре символа, чем короткие строки.

Например, следующие запросы дают аналогичные результаты, в зависимости от политики именования компьютера, но второй является более эффективным:

```Kusto
//less efficient – due to filter based on contains
Heartbeat
| where Computer contains "Production" 
| summarize count() by ComputerIP 
```
```Kusto
//less efficient – due to filter based on extend
Heartbeat
| extend MyComputer = Computer
| where MyComputer startswith "Production" 
| summarize count() by ComputerIP 
```
```Kusto
//more efficient
Heartbeat
| where Computer startswith "Production" 
| summarize count() by ComputerIP 
```

> [!NOTE]
> Этот индикатор представляет только процессор из непосредственного кластера. В многорегионеных запросах он будет представлять только один из регионов. В запросе с несколькими рабочими пространствами он может включать не все рабочие области.


## <a name="data-used-for-processed-query"></a>Данные, используемые для обработки запроса

Критическим фактором в обработке запроса является объем данных, которые сканируются и используются для обработки запросов. Azure Data Explorer использует агрессивные оптимизации, которые значительно снижают объем данных по сравнению с другими платформами данных. Тем не менее, в запросе есть критические факторы, которые могут повлиять на объем данных, который используется.

В журналах Azure Monitor столбец **TimeGenerated** используется для индексирования данных. Ограничение значений **TimeGenerated** как можно более узким диапазоном значительно убедит производительность запроса, значительно ограничив объем данных, которые должны быть обработаны.

### <a name="avoid-unnecessary-use-of-search-and-union-operators"></a>Избегайте ненужного использования поисковых и профсоюзных операторов

Другим фактором, повысивающих процесс данных, является использование большого количества таблиц. Это обычно `search *` происходит, когда используются `union *` команды. Эти команды заставляют систему оценивать и сканировать данные из всех таблиц рабочего пространства. В некоторых случаях в рабочей области могут быть сотни таблиц. Старайтесь избегать как можно больше, используя "поиск" или любой поиск, не просматривая его в определенной таблице.

Например, следующие запросы дают точно такой же результат, но последний на сегодняшний день является наиболее эффективным:

```Kusto
// This version scans all tables though only Perf has this kind of data
search "Processor Time" 
| summarize count(), avg(CounterValue)  by Computer
```
```Kusto
// This version scans all strings in Perf tables – much more efficient
Perf
| search "Processor Time" 
| summarize count(), avg(CounterValue)  by Computer
```
```Kusto
// This is the most efficient version 
Perf 
| where CounterName == "% Processor Time"  
| summarize count(), avg(CounterValue)  by Computer
```

### <a name="add-early-filters-to-the-query"></a>Добавление ранних фильтров в запрос

Другой метод сокращения объема данных заключается в том, чтобы иметь, [где](/azure/kusto/query/whereoperator) условия в начале запроса. Платформа Azure Data Explorer включает в себя кэш, который позволяет узнать, какие разделы включают данные, которые актуальны для конкретного состояния. Например, если запрос `where EventID == 4624` содержит, то он будет распределять запрос только на узлы, обрабатывающие разделы с соответствующими событиями.

Следующие примеры запросов дают точно такой же результат, но второй является более эффективным:

```Kusto
//less efficient
SecurityEvent
| summarize LoginSessions = dcount(LogonGuid) by Account
```
```Kusto
//more efficient
SecurityEvent
| where EventID == 4624 //Logon GUID is relevant only for logon event
| summarize LoginSessions = dcount(LogonGuid) by Account
```

### <a name="reduce-the-number-of-columns-that-is-retrieved"></a>Уменьшите количество извлеченных столбцов

Поскольку Azure Data Explorer является хранилищем данных столбцов, поиск каждого столбца не зависит от других. Количество извлеченных столбцов непосредственно влияет на общий объем данных. В вывод следует включать только столбцы, необходимые для [подведения итогов](/azure/kusto/query/summarizeoperator) или [прогнозирования](/azure/kusto/query/projectoperator) определенных столбцов. Azure Data Explorer имеет несколько оптимизаций, чтобы уменьшить количество извлеченных столбцов. Если он определяет, что столбец не нужен, например, если он не упоминается в [команде суммировать,](/azure/kusto/query/summarizeoperator) он не будет получать его.

Например, второй запрос может обрабатывать в три раза больше данных, так как он должен принести не один столбец, а три:

```Kusto
//Less columns --> Less data
SecurityEvent
| summarize count() by Computer  
```
```Kusto
//More columns --> More data
SecurityEvent
| summarize count(), dcount(EventID), avg(Level) by Computer  
```

## <a name="time-span-of-the-processed-query"></a>Временной промежуток обработанного запроса

Все журналы в журналах Azure Monitor разделены в соответствии с столбцом **TimeGenerated.** Количество перегородок, которые доступны, непосредственно связаны с промежутки времени. Сокращение временной диапазона является наиболее эффективным способом обеспечения быстрого выполнения запроса.

Диапазон времени можно установить с помощью селектора временной диапазонной линии на экране log Analytics, описанного в [области запроса журнала и диапазоне времени в Azure Monitor Log Analytics.](scope.md#time-range) Это рекомендуемый метод, поскольку выбранный временной диапазон передается бэкэнду с помощью метаданных запроса. 

Альтернативный метод заключается в явном включении в запрос, [где](/azure/kusto/query/whereoperator) условие **TimeGenerated.** Этот метод следует использовать, поскольку он гарантирует, что временной промежуток иссяк, даже если запрос используется из другого интерфейса.
Необходимо убедиться, что во всех частях запроса есть фильтры **TimeGenerated.** Когда запрос имеет подзапросы, извлекающие данные из различных таблиц или одной таблицы, каждый должен включать свое [собственное](/azure/kusto/query/whereoperator) условие.

### <a name="make-sure-all-sub-queries-have-timegenerated-filter"></a>Убедитесь, что все подзапросы имеют фильтр TimeGenerated

Например, в следующем запросе, в то время как таблица **Perf** будет отсканирована только в течение последнего дня, таблица **Heartbeat** будет отсканирована на протяжении всей своей истории, которая может составить до двух лет:

```Kusto
Perf
| where TimeGenerated > ago(1d)
| summarize avg(CounterValue) by Computer, CounterName
| join kind=leftouter (
    Heartbeat
    //No time span filter in this part of the query
    | summarize IPs = makeset(ComputerIP, 10) by  Computer
) on Computer
```

Распространенный случай, когда такая ошибка происходит, когда [arg_max()](/azure/kusto/query/arg-max-aggfunction) используется, чтобы найти самое последнее явление. Пример:

```Kusto
Perf
| where TimeGenerated > ago(1d)
| summarize avg(CounterValue) by Computer, CounterName
| join kind=leftouter (
    Heartbeat
    //No time span filter in this part of the query
    | summarize arg_max(TimeGenerated, *), min(TimeGenerated)   
by Computer
) on Computer
```

Это можно легко исправить, добавив фильтр времени во внутреннем запросе:

```Kusto
Perf
| where TimeGenerated > ago(1d)
| summarize avg(CounterValue) by Computer, CounterName
| join kind=leftouter (
    Heartbeat
    | where TimeGenerated > ago(1d) //filter for this part
    | summarize arg_max(TimeGenerated, *), min(TimeGenerated)   
by Computer
) on Computer
```

Другим примером этого недостатка является выполнение фильтрации временной сферы сразу после [объединения](/azure/kusto/query/unionoperator?pivots=azuremonitor) в нескольких таблицах. При выполнении соединения каждый подзапрос должен быть добыт. Вы можете использовать [let](/azure/kusto/query/letstatement) statement для обеспечения согласованности.

Например, следующий запрос будет сканировать все данные в таблицах *Heartbeat* и *Perf,* а не только за последний 1 день:

```Kusto
Heartbeat 
| summarize arg_min(TimeGenerated,*) by Computer
| union (
    Perf 
    | summarize arg_min(TimeGenerated,*) by Computer) 
| where TimeGenerated > ago(1d)
| summarize min(TimeGenerated) by Computer
```

Этот запрос должен быть исправлен следующим образом:

```Kusto
let MinTime = ago(1d);
Heartbeat 
| where TimeGenerated > MinTime
| summarize arg_min(TimeGenerated,*) by Computer
| union (
    Perf 
    | where TimeGenerated > MinTime
    | summarize arg_min(TimeGenerated,*) by Computer) 
| summarize min(TimeGenerated) by Computer
```

### <a name="time-span-measurement-limitations"></a>Ограничения по времени измерений

Измерение всегда больше, чем фактическое указанное время. Например, если фильтр в запросе составляет 7 дней, система может сканировать 7,5 или 8,1 дня. Это связано с тем, что система делит данные на куски переменного размера. Чтобы гарантировать, что все соответствующие записи сканируются, он сканирует весь раздел, который может охватывать несколько часов и даже более чем в день.

Есть несколько случаев, когда система не может обеспечить точное измерение временной диапазон. Это происходит в большинстве случаев, когда запрос охватывает менее суток или в запросах с несколькими рабочими местами.


> [!IMPORTANT]
> Этот индикатор представляет только данные, обрабатываемые в непосредственном кластере. В многорегионеных запросах он будет представлять только один из регионов. В запросе с несколькими рабочими пространствами он может включать не все рабочие области.

## <a name="age-of-processed-data"></a>Возраст обработанных данных
Azure Data Explorer использует несколько уровней хранения данных: в памяти, локальные SSD-диски и гораздо более медленные Azure Blobs. Чем новее данные, тем выше вероятность того, что они хранятся в более выполнении уровня с меньшей задержкой, уменьшая продолжительность запроса и процессор. Помимо самих данных, система также имеет кэш для метаданных. Чем старше данные, тем меньше вероятность того, что их метаданные будут находиться в кэше.

Хотя некоторые запросы требуют использования старых данных, бывают случаи, когда старые данные используются по ошибке. Это происходит, когда запросы выполняются без предоставления временной диапазон в их мета-данных, и не все ссылки таблицы включают фильтр в столбце **TimeGenerated.** В этих случаях система будет сканировать все данные, которые хранятся в этой таблице. Когда хранение данных является длительным, оно может охватывать длительные диапазоны времени и, таким образом, данные, которые так же стары, как период хранения данных.

Такие случаи могут быть, например:

- Не устанавливая временной диапазон в журнале Analytics с подзапросом, который не ограничен. пример выше.
- Использование API без дополнительных параметров диапазона времени.
- Использование клиента, который не заставляет временной диапазон, такой как разъем Power BI.

Смотрите примеры и заметки в разделе, поскольку они также актуальны в данном случае.

## <a name="number-of-regions"></a>Количество регионов
Существует несколько ситуаций, когда один запрос может быть выполнен в разных регионах:

- Когда несколько рабочих областей явно перечислены, и они расположены в разных регионах.
- Когда ресурсоснабжающий запрос изготавливает данные и данные хранятся в нескольких рабочих областях, расположенных в разных регионах.

Выполнение кросс-региона требует от системы сериализации и передачи в бэкэнде больших кусков промежуточных данных, которые обычно намного больше конечных результатов запроса. Это также ограничивает способность системы выполнять оптимизацию, эвристику и использовать кэши.
Если нет реальных причин для сканирования всех этих регионов, следует настроить область, чтобы она охватывала меньшее число регионов. Если область ресурса сведена к минимуму, но все еще используется много регионов, это может произойти из-за неправильной настройки. Например, журналы аудита и диагностические настройки отправляются в различные рабочие области в разных регионах или имеют несколько конфигураций диагностических настроек. 

> [!IMPORTANT]
> При запуске запроса в нескольких регионах измерения процессора и данных не будут точными и будут представлять измерения только в одном из регионов.

## <a name="number-of-workspaces"></a>Количество рабочих областей
Рабочие области являются логическими контейнерами, которые используются для сегрегировать и администрировать данные журналов. Бэкэнд оптимизирует размещение рабочих мест на физических кластерах в выбранном регионе.

Использование нескольких рабочих областей может быть результатом: 

- Где несколько рабочих областей явно перечислены.
- Когда ресурсоснабжающий запрос изготавливает данные и данные хранятся в нескольких рабочих областях.
 
Кросс-регион и кросс-кластервыполнения запросов требует, чтобы система сериализировала и передавала в бэкэнд большие куски промежуточных данных, которые обычно намного больше, чем конечные результаты запроса. Это также ограничивает способность системы выполнять оптимизацию, эвристику и использование кэшов.

> [!IMPORTANT]
> В некоторых сценариях с несколькими рабочими пространствами измерения процессора и данных не будут точными и будут представлять измерения лишь для нескольких рабочих областей.

## <a name="parallelism"></a>Parallelism
Журналы Azure Monitor используют большие кластеры Azure Data Explorer для выполнения запросов, и эти кластеры различаются по масштабу, потенциально доскакнув до десятков вычислительных узлов. Система автоматически масштабирует кластеры в соответствии с логикой и емкостью рабочего пространства.

Для эффективного выполнения запроса он разделен и распределен для вычислений узлов на основе данных, необходимых для его обработки. Есть ситуации, когда система не может сделать это эффективно. Это может привести к длительной продолжительности запроса. 

Поведение запросов, которое может уменьшить параллелизм, включает:

- Использование функций сериализации и окон, таких как [оператор сериализации,](/azure/kusto/query/serializeoperator) [следующий()](/azure/kusto/query/nextfunction), [prev()](/azure/kusto/query/prevfunction)и функции [строки.](/azure/kusto/query/rowcumsumfunction) В некоторых из этих случаев можно использовать временные ряды и функции аналитики пользователей. Неэффективная сериализация может также произойти, если следующие операторы используются не в конце [запроса:](/azure/kusto/query/getschemaoperator) [диапазон,](/azure/kusto/query/rangeoperator) [сортировка,](/azure/kusto/query/sortoperator) [заказ,](/azure/kusto/query/orderoperator) [топ-хиттеров,](/azure/kusto/query/tophittersoperator)getschema . [top](/azure/kusto/query/topoperator)
-    Использование функции агрегации [очислений ()](/azure/kusto/query/dcount-aggfunction) вынуждает систему иметь центральную копию различных значений. При высокой шкале данных следует использовать дополнительные параметры функции облика с пониженной точностью.
-    Во многих случаях оператор [соединения](/azure/kusto/query/joinoperator?pivots=azuremonitor) снижает общий параллелизм. Изучите соединение перетасовки в качестве альтернативы, когда производительность проблематична.
-    В запросах области ресурсов предвыполнение проверок RBAC может задерживаться в ситуациях, когда имеется очень большое количество назначений RBAC. Это может привести к более длительным проверкам, что приведет к снижению параллелизма. Например, запрос выполняется по подписке, где есть тысячи ресурсов, и каждый ресурс имеет много ролевых заданий на уровне ресурсов, а не в группе подписки или ресурса.
-    Если запрос обрабатывает небольшие фрагменты данных, его параллелизм будет низким, так как система не будет распространять его по многим вычислительным узлам.



## <a name="next-steps"></a>Дальнейшие действия

- [Справочная документация для языка запроса Kusto](/azure/kusto/query/).
