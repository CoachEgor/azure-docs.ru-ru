---
title: Начало работы с запросами журнала в Azure Monitor | Документация Майкрософт
description: В этой статье содержится руководство по началу работы по написанию запросов журнала в Azure Monitor.
services: log-analytics
documentationcenter: ''
author: bwren
manager: carmonm
editor: ''
ms.assetid: ''
ms.service: log-analytics
ms.workload: na
ms.tgt_pltfrm: na
ms.topic: conceptual
ms.date: 05/09/2019
ms.author: bwren
ms.openlocfilehash: 6eb066e04cfa561a4fa443b8c8f9582e286a4d7b
ms.sourcegitcommit: 8ef0a2ddaece5e7b2ac678a73b605b2073b76e88
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2019
ms.locfileid: "71076762"
---
# <a name="get-started-with-log-queries-in-azure-monitor"></a>Начало работы с запросами журналов в Azure Monitor


> [!NOTE]
> Перед завершением работы с этим руководством необходимо завершить [работу с Azure Monitor log Analytics](get-started-portal.md) .

> [!NOTE]
> Это упражнение можно проработать в собственной среде, если вы собираете данные по крайней мере с одной виртуальной машины. Если это не так, используйте нашу [демонстрационную среду](https://portal.loganalytics.io/demo), включающую множество образцов данных.


В этом учебнике вы узнаете, как записывать запросы журнала в Azure Monitor. Вы научитесь:

- Общие сведения о структуре запроса
- сортировать результаты запроса;
- фильтровать результаты запроса;
- указывать диапазон времени;
- выбирать поля для включения в результаты;
- определять и использовать настраиваемые поля;
- вычислять и группировать результаты.

Руководство по использованию Log Analytics в портал Azure см. в статье [Приступая к работе с Azure Monitor log Analytics](get-started-portal.md).<br>
Дополнительные сведения о запросах журналов в Azure Monitor см. [в разделе Обзор запросов журналов в Azure Monitor](log-query-overview.md).

## <a name="writing-a-new-query"></a>Создание запроса
Запросы могут начинаться с имени таблицы или команды *search*. Начните с имени таблицы, так как это определит четкую область запроса и повысит как производительность запроса, так и релевантность результатов.

> [!NOTE]
> Azure Monitor использует язык запросов Kusto с учетом регистра. Ключевые слова языка обычно пишутся строчными буквами. При использовании имен таблиц или столбцов в запросе обязательно используйте правильный регистр, как показано в области схемы.

### <a name="table-based-queries"></a>Запросы на основе таблиц
Azure Monitor упорядочивает данные журнала в таблицы, каждая из которых состоит из нескольких столбцов. На портале Analytics в области схемы в Log Analytics отображаются все таблицы и столбцы. Определите интересующую вас таблицу, а затем взгляните на часть данных:

```Kusto
SecurityEvent
| take 10
```

Запрос, показанный выше, возвращает 10 результатов из таблицы *SecurityEvent* в произвольном порядке. Это очень распространенный способ взглянуть на таблицу и понять ее структуру и содержимое. Давайте рассмотрим структуру запроса:

* Запрос начинается с имени таблицы *SecurityEvent* — эта часть определяет область запроса.
* Символ вертикальной черты (|) разделяет команды, поэтому выходные данные первой команды содержатся во входных данных следующей команды. Можно добавить любое число элементов, разделенных этой чертой.
* За вертикальной чертой следует команда **take**, которая возвращает указанное количество произвольных записей из таблицы.

Мы фактически могли выполнить запрос даже без добавления `| take 10`. Такой запрос тоже действительный, но он может вернуть до 10 000 результатов.

### <a name="search-queries"></a>Поисковые запросы
Поисковые запросы менее структурированы и, как правило, более подходят для поиска записей, которые содержат указанное значение в любом из столбцов:

```Kusto
search in (SecurityEvent) "Cryptographic"
| take 10
```

Этот поисковый запрос выполняет в таблице *SecurityEvent* поиск записей, содержащих фразу "Cryptographic". Из этих записей будут возвращены и показаны 10. Если опустить часть `in (SecurityEvent)` и просто запустить `search "Cryptographic"`, поиск пройдет по *всем* таблицам. Это будет дольше и менее эффективно.

> [!WARNING]
> Поисковые запросы обычно выполняются медленнее, чем запросы на основе таблиц, поскольку они должны обрабатывать больше данных. 

## <a name="sort-and-top"></a>Операторы sort и top
Хотя команда **take** и полезна для получения нескольких записей, но результаты выбираются и отображаются в произвольном порядке. Чтобы получить упорядоченное представление, можно выполнить **сортировку** по предпочтительному столбцу:

```Kusto
SecurityEvent   
| sort by TimeGenerated desc
```

Такой запрос может вернуть слишком много результатов и занять некоторое время. Приведенный выше запрос сортирует *всю* таблицу SecurityEvent по столбцу TimeGenerated. Портал аналитики ограничивает отображение для вывода только 10 000 записей. Такой подход, конечно же, не оптимален.

Лучшим способом получить только последние 10 записей является использование оператора **top**, который сортирует таблицу целиком на стороне сервера, а затем возвращает первые записи:

```Kusto
SecurityEvent
| top 10 by TimeGenerated
```

Порядок сортировки по убыванию используется по умолчанию, поэтому мы обычно опускаем аргумент **desc**. Результат будет выглядеть следующим образом:

![Первые 10](media/get-started-queries/top10.png)


## <a name="where-filtering-on-a-condition"></a>Оператор where: фильтрация по условию
Фильтры, как очевидно из названия, фильтруют данные по указанному условию. Это самый распространенный способ ограничения результатов запроса для получения соответствующей информации.

Чтобы добавить фильтр к запросу, используйте оператор **where**, за которым следует одно или несколько условий. Например, следующий запрос возвращает только записи *SecurityEvent*, где _Level_ равняется _8_:

```Kusto
SecurityEvent
| where Level == 8
```

При написании условий фильтра вы можете использовать следующие выражения:

| Выражение | Описание | Пример |
|:---|:---|:---|
| == | Проверка на равенство<br>(с учетом регистра) | `Level == 8` |
| =~ | Проверка на равенство<br>(без учета регистра) | `EventSourceName =~ "microsoft-windows-security-auditing"` |
| !=, <> | Проверка на неравенство<br>(оба выражения идентичны) | `Level != 4` |
| *and*, *or* | Требуется между условиями| `Level == 16 or CommandLine != ""` |

Чтобы отфильтровать по нескольким условиям, можно использовать оператор **and**:

```Kusto
SecurityEvent
| where Level == 8 and EventID == 4672
```

Для этого также можно включить несколько элементов **where**, разделенных вертикальной чертой:

```Kusto
SecurityEvent
| where Level == 8 
| where EventID == 4672
```
    
> [!NOTE]
> Значения могут иметь разные типы, поэтому может потребоваться привести их в правильный тип для выполнения сравнения. Например, столбец *Level* таблицы SecurityEvent имеет строчный тип, поэтому необходимо привести его в числовой тип, например *int* или *long*, прежде чем вы сможете использовать его с числовыми операторами: `SecurityEvent | where toint(Level) >= 10`

## <a name="specify-a-time-range"></a>Указание диапазона времени

### <a name="time-picker"></a>Средство выбора времени
Рядом с кнопкой запуска находится элемент выбора времени, указывающий, что мы запрашиваем только записи за последние 24 часа. Этот диапазон времени по умолчанию применяется ко всем запросам. Чтобы получить только записи за последний час, выберите _последний час_ и повторно запустите запрос.

![Выбор времени](media/get-started-queries/timepicker.png)


### <a name="time-filter-in-query"></a>Фильтр времени в запросе
Вы также можете определить ваш собственный диапазон времени, добавив фильтр времени к запросу. Лучше всего поместить фильтр времени сразу после имени таблицы: 

```Kusto
SecurityEvent
| where TimeGenerated > ago(30m) 
| where toint(Level) >= 10
```

Указанный фильтр времени `ago(30m)` означает "30 минут назад", поэтому этот запрос возвращает только записи за последние 30 минут. Другие единицы времени включают в себя дни (2d), минуты (25m) и секунды (10s).


## <a name="project-and-extend-select-and-compute-columns"></a>Операторы project и extend. Выбор и вычисление столбцов
Используйте оператор **project**, чтобы выбрать конкретные столбцы, которые нужно включить в результаты:

```Kusto
SecurityEvent 
| top 10 by TimeGenerated 
| project TimeGenerated, Computer, Activity
```

Предыдущий пример создает такие выходные данные:

![Запрос результатов проекта](media/get-started-queries/project.png)

С помощью **project** также можно переименовать столбцы и определить новые. В примере ниже project используется для выполнения следующих действий:

* Выбор только исходных столбцов *Computer* и *TimeGenerated*.
* Переименование столбца *Activity* в *EventDetails*.
* Создание столбца *EventCode*. Функция **substring()** используется для получения только первых четырех символов из поля Activity.


```Kusto
SecurityEvent
| top 10 by TimeGenerated 
| project Computer, TimeGenerated, EventDetails=Activity, EventCode=substring(Activity, 0, 4)
```

**extend** отслеживает все исходные столбцы в результирующем наборе, а также определяет дополнительные. Следующий запрос использует **расширение** , чтобы добавить столбец *EventCode* . Обратите внимание, что этот столбец может не отображаться в конце таблицы, в результате чего потребуется расширить сведения о записи, чтобы просмотреть ее.

```Kusto
SecurityEvent
| top 10 by TimeGenerated
| extend EventCode=substring(Activity, 0, 4)
```

## <a name="summarize-aggregate-groups-of-rows"></a>Оператор summarize. Агрегирование групп строк
С помощью оператора **summarize** можно определить группы записей в соответствии с одним или несколькими столбцами и применить к ним статистические вычисления. Поэтому с **summarize** чаще всего применяется функция *count*, которая возвращает число результатов в каждой группе.

Следующий запрос проверяет все записи в таблице *Perf* за последний час, группирует их по столбцу *ObjectName* и подсчитывает количество записей в каждой группе: 
```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize count() by ObjectName
```

Иногда имеет смысл определить группы по нескольким измерениям. Каждое уникальное сочетание этих значений определяет отдельную группу:

```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize count() by ObjectName, CounterName
```

Другое распространенное использование — выполнять математические или статистические вычисления в каждой группе. Например, следующий фрагмент вычисляет среднее значение *CounterValue* для каждого компьютера:

```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize avg(CounterValue) by Computer
```

К сожалению, результаты этого запроса бессмысленны, так как мы смешали разные счетчики производительности. Чтобы это имело смысл, следует рассчитывать среднее значение отдельно для каждого сочетания *CounterName* и *Computer*:

```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize avg(CounterValue) by Computer, CounterName
```

### <a name="summarize-by-a-time-column"></a>Суммирование по столбцу времени
Результаты также можно группировать по столбцу времени или другому непрерывному значению. В результате простого суммирования `by TimeGenerated` будут созданы группы для каждой миллисекунды за определенный период времени, так как речь идет об уникальных значениях. 

Чтобы создать группы на основании непрерывных значений, рекомендуется разбить диапазон на управляемые единицы с помощью **bin**. Следующий запрос анализирует записи *Perf* с данными об измерении свободной памяти (*доступная память в МБ*) на указанном компьютере. Он вычисляет среднее значение за каждый час за последние семь дней:

```Kusto
Perf 
| where TimeGenerated > ago(7d)
| where Computer == "ContosoAzADDS2" 
| where CounterName == "Available MBytes" 
| summarize avg(CounterValue) by bin(TimeGenerated, 1h)
```

Чтобы сделать выходные данные более понятными, выберите отображение в виде диаграммы времени, показывающую объем доступной памяти с течением времени:

![Запрос памяти с течением времени](media/get-started-queries/chart.png)



## <a name="next-steps"></a>Следующие шаги

- [Дополнительные сведения о написании запросов поиска](search-queries.md)
