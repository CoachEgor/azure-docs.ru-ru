---
title: Улучшение производительности индекса columnstore
description: Уменьшите требования к памяти или увеличьте доступную память, чтобы максимизировать количество строк в каждой группе строк.
services: synapse-analytics
author: kevinvngo
manager: craigg
ms.service: synapse-analytics
ms.topic: conceptual
ms.subservice: ''
ms.date: 03/22/2019
ms.author: kevin
ms.reviewer: igorstan
ms.custom: azure-synapse
ms.openlocfilehash: 8e78ad26701bae1357ef6a2a0a03dff1319f0efe
ms.sourcegitcommit: d597800237783fc384875123ba47aab5671ceb88
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2020
ms.locfileid: "80633168"
---
# <a name="maximizing-rowgroup-quality-for-columnstore"></a>Максимальное повышение качества группы строк для индекса columnstore

Качество группы строк определяется количеством строк в группе строк. Увеличение доступной памяти может максимизировать количество строк, которые индекс столбцовстрия сжимает в каждую группу строк.  Эти способы можно использовать, чтобы оптимизировать степень сжатия и производительность запросов для индексов columnstore.

## <a name="why-the-rowgroup-size-matters"></a>На что влияет размер группы строк
Так как индекс columnstore обрабатывает таблицу, сканируя сегменты столбцов отдельных групп строк, увеличение максимального числа строк в каждой группе строк повышает производительность запросов. 

Если группы включают большое число строк, сжатие данных также оптимизируется, так как с диска считывается меньше данных.

Дополнительные сведения о группах строк см. в [руководстве по индексам сolumnstore](https://msdn.microsoft.com/library/gg492088.aspx).

## <a name="target-size-for-rowgroups"></a>Целевой размер для групп строк
Чтобы повысить производительность запросов, нужно максимально увеличить число строк в каждой группе строк в индексе columnstore. Группа строк может включать до 1 048 576 строк. 

При этом использовать максимальное значение необязательно. Индексы columnstore обеспечивают высокую производительность, если группы строк включают хотя бы 100 000 строк.

## <a name="rowgroups-can-get-trimmed-during-compression"></a>Группы строк при сжатии можно обрезать

Во время массовой загрузки или повторном создании индекса columnstore для сжатия всех строк, назначенных каждой группе строк, иногда не хватает доступной памяти. При нажатии давления памяти индексы columnstore обрезают размеры группы строк, поэтому сжатие в столбец может быть успешным. 

При недостаточной памяти для сжатия по крайней мере 10 000 строк в каждую группу строк, будет сгенерирована ошибка.

Дополнительные сведения о выполнении массовой загрузки см. в статье [Загрузка данных индексов ColumnStore](https://msdn.microsoft.com/library/dn935008.aspx#Bulk ).

## <a name="how-to-monitor-rowgroup-quality"></a>Мониторинг качества групп строк

DMV sys.dm_pdw_nodes_db_column_store_row_group_physical_stats[(sys.dm_db_column_store_row_group_physical_stats](https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-db-column-store-row-group-physical-stats-transact-sql) содержит определение представления, соответствующее S'L DB), которое предоставляет полезную информацию, такую как количество строк в группах строк и причину обрезки, если была обрезка. 

Вы можете создать следующее представление для удобства выполнения запросов к этому динамическому административному представлению, чтобы получить сведения об усечении групп строк.

```sql
create view dbo.vCS_rg_physical_stats
as 
with cte
as
(
select   tb.[name]                    AS [logical_table_name]
,        rg.[row_group_id]            AS [row_group_id]
,        rg.[state]                   AS [state]
,        rg.[state_desc]              AS [state_desc]
,        rg.[total_rows]              AS [total_rows]
,        rg.[trim_reason_desc]        AS trim_reason_desc
,        mp.[physical_name]           AS physical_name
FROM    sys.[schemas] sm
JOIN    sys.[tables] tb               ON  sm.[schema_id]          = tb.[schema_id]                             
JOIN    sys.[pdw_table_mappings] mp   ON  tb.[object_id]          = mp.[object_id]
JOIN    sys.[pdw_nodes_tables] nt     ON  nt.[name]               = mp.[physical_name]
JOIN    sys.[dm_pdw_nodes_db_column_store_row_group_physical_stats] rg      ON  rg.[object_id]     = nt.[object_id]
                                                                            AND rg.[pdw_node_id]   = nt.[pdw_node_id]
                                        AND rg.[distribution_id]    = nt.[distribution_id]                                              
)
select *
from cte;
```

Параметр trim_reason_desc сообщает, была ли усечена группа строк (trim_reason_desc = NO_TRIM означает, что усечения не было и качество группы строк является оптимальным). Ниже перечислены причины, указывающие на преждевременное усечение групп строк.
- BULKLOAD. Эта причина усечения используется, когда входящий пакет строк для загрузки содержит менее 1 миллиона строк. При вставке более 100 000 строк обработчик создает сжатые группы строк (в отличие от вставки в разностное хранилище), но задает причину усечения BULKLOAD. В этом сценарии рассмотрите возможность увеличения загрузки, чтобы включить больше строк. Кроме того, переоцените схему раздела, чтобы убедиться, что она не слишком детализирована, так как группы строк не могут охватывать границы разделов.
- MEMORY_LIMITATION. Для создания групп строк, содержащих 1 миллион строк, обработчику требуется определенный объем рабочей памяти. Если доступный объем памяти сеанса загрузки меньше необходимого объема рабочей памяти, то группы строк преждевременно усекаются. В следующих разделах объясняется, как оценить требуемую память и выделить больше памяти.
- DICTIONARY_SIZE. Эта причина усечения указывает на то, что усечение групп строк вызвано наличием по крайней мере одного столбца строки с широкими строками и (или) со строками, имеющими большое количество элементов. Размер словаря ограничен объемом памяти 16 МБ, поэтому когда этот предел достигается, группа строк сжимается. Если складывается такая ситуация, рекомендуется поместить проблемный столбец в отдельную таблицу.

## <a name="how-to-estimate-memory-requirements"></a>Как рассчитать требования к памяти

<!--
To view an estimate of the memory requirements to compress a rowgroup of maximum size into a columnstore index, download and run the view [dbo.vCS_mon_mem_grant](). This view shows the size of the memory grant that a rowgroup requires for compression in to the columnstore.
-->

Максимальный объем памяти, требуемый для сжатия одной группы строк, составляет приблизительно

- 72 МБ +
- \#столбцы \* \#строк \* 8 байтов
- \#строки \* \#короткие строки-колонки \* 32 байтов
- \#столбцы длинных строк \* 16 МБ для словаря сжатия

> [!NOTE]
> Короткорядные столбцы используют типы строковых данных <32 байтов, а длинные строки-столбцы используют типы строковых данных > 32 байтов.

Используемый метод сжатия длинных строк предназначен для сжатия текста. Этот метод сжатия использует *словари* для хранения текстовых шаблонов. Максимальный размер словаря составляет 16 МБ. Для каждого столбца длинной строки в группе строк используется только один словарь.

Для углубленного обсуждения требований к памяти [Synapse SQL pool scaling: configuration and guidance](https://channel9.msdn.com/Events/Ignite/2016/BRK3291)columnstore см.

## <a name="ways-to-reduce-memory-requirements"></a>Способы снижения требований к памяти

Используйте следующие методы, чтобы снизить требования к памяти для сжатия групп строк в индексах columnstore.

### <a name="use-fewer-columns"></a>Используйте меньшее число столбцов
По возможности проектируйте таблицы с меньшим числом столбцов. Когда группа строк сжимается в columnstore, индекс columnstore сжимает каждый сегмент столбца отдельно. 

Таким образом, требования к памяти для сжатия группы строк увеличиваются по мере увеличения числа столбцов.


### <a name="use-fewer-string-columns"></a>Используйте меньшее число строковых столбцов
Столбцы строковых типов данных требуют больше памяти, чем числовые типы и типы даты. Чтобы снизить требования к памяти, можно удалить строковые столбцы из таблиц фактов и поместить их в меньшие таблицы измерений.

Дополнительные требования к памяти при сжатии строк:

- для строковых типов данных до 32 символов может дополнительно потребоваться 32 байта на каждое значение;
- строковые типы данных свыше 32 символов сжимаются с помощью методов словаря,  а для каждого столбца в группе строк может дополнительно потребоваться 16 МБ для создания словаря.

### <a name="avoid-over-partitioning"></a>Избегайте избыточного секционирования

Индексы columnstore создают одну или несколько групп строк в каждой секции. Для пула S'L в Azure Synapse Analytics количество разделов быстро растет, поскольку данные распределены и каждое распределение разделено. 

Если в таблице слишком много разделов, существующих строк может не хватить для заполнения групп строк. Отсутствие строк не создает давления памяти во время сжатия. Но это приводит к группам строк, которые не достигают наилучшей производительности запроса столбцов.

Также рекомендуется избегать чрезмерного секционирования из-за перерасхода памяти при загрузке строк в индекс columnstore в секционированной таблице. 

При загрузке многие секции могут принимать входящие строки, которые хранятся в памяти, пока каждая секция не получит достаточное количество строк для сжатия. Слишком большое число секций приводит к избыточному потреблению памяти.

### <a name="simplify-the-load-query"></a>Упрощайте запросы загрузки

База данных распределяет память, выделенную для запросов, между всеми операторами запроса. Если запрос загрузки включает сложные сортировки и соединения, объем доступной для сжатия памяти снижается.

Разработайте такой запрос нагрузки, который позволит использовать ресурсы только для его загрузки. Если необходимо выполнить преобразование данных, выполните эту операцию отдельно от выполнения запроса загрузки. Например, запустите промежуточную обработку данных в таблице кучи, выполните преобразование и только потом загружайте промежуточную таблицу в индексе. 

> [!TIP]
> Можно также сначала загрузить данные, затем использовать систему MPP для преобразования данных.

### <a name="adjust-maxdop"></a>Настройка MAXDOP

В рамках каждого распределения группы строк сжимаются в columnstore параллельно, если для распределения доступно более одного ядра ЦП. 

Параллелизм потребляет дополнительную память, что может привести к ее нехватке и усечению строк.

Чтобы избежать этого, можно использовать указание запроса MAXDOP для принудительного выполнения загрузки в последовательном режиме в рамках каждого распределения.

```sql
CREATE TABLE MyFactSalesQuota
WITH (DISTRIBUTION = ROUND_ROBIN)
AS SELECT * FROM FactSalesQuota
OPTION (MAXDOP 1);
```

## <a name="ways-to-allocate-more-memory"></a>Способы выделения дополнительной памяти

Объем доступной для выполнения пользовательских запросов памяти определяется размером DWU и классом ресурсов пользователя. 

Чтобы увеличить объем выделенной для запросов загрузки памяти, можно увеличить число DWU или повысить класс ресурсов.

- Сведения об увеличении числа DWU см.в разделе [Масштабирование производительности](quickstart-scale-compute-portal.md).
- Сведения об изменении класса ресурсов для запросов см. в разделе [Пример изменения класса ресурсов пользователя](resource-classes-for-workload-management.md#change-a-users-resource-class).

## <a name="next-steps"></a>Дальнейшие действия

Чтобы найти дополнительные способы повышения производительности [Performance overview](cheat-sheet.md)для пула S'L, см.
