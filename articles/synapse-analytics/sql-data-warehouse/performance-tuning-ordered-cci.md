---
title: Performance tuning with result set caching (Настройка производительности с помощью упорядоченного кластеризованного индекса columnstore)
description: Рекомендации и соображения, которые следует знать при использовании упорядоченного кластерного индекса столбцов для повышения производительности запроса.
services: synapse-analytics
author: XiaoyuMSFT
manager: craigg
ms.service: synapse-analytics
ms.topic: conceptual
ms.subservice: ''
ms.date: 09/05/2019
ms.author: xiaoyul
ms.reviewer: nibruno; jrasnick
ms.custom: seo-lt-2019, azure-synapse
ms.openlocfilehash: a5bb048a2368f60a83e70dcd6d1ce663ce70a885
ms.sourcegitcommit: 8a9c54c82ab8f922be54fb2fcfd880815f25de77
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "80350932"
---
# <a name="performance-tuning-with-ordered-clustered-columnstore-index"></a>Performance tuning with result set caching (Настройка производительности с помощью упорядоченного кластеризованного индекса columnstore)  

Когда пользователи загоняют таблицу столбцов в S'L Analytics, оптимизатор проверяет минимальные и максимальные значения, хранящиеся в каждом сегменте.  Сегменты, выходящие за рамки предиката запроса, не считываются от диска к памяти.  Запрос может получить более высокую производительность, если количество сегментов для чтения и их общий размер невелики.   

## <a name="ordered-vs-non-ordered-clustered-columnstore-index"></a>Заказ против неупорядоченного кластерного индекса columnstore 
По умолчанию для каждой таблицы S'L Analytics, созданной без опциона индекса, внутренний компонент (индекс-строитель) создает неупорядоченный кластерный индекс столбцов (CCI).  Данные в каждом столбце сжимаются в отдельный сегмент группы строк CCI.  Есть метаданные о диапазоне значений каждого сегмента, поэтому сегменты, которые находятся за пределами предиката запроса, не считываются с диска во время выполнения запроса.  CCI предлагает самый высокий уровень сжатия данных и уменьшает размер сегментов для чтения, чтобы запросы могли работать быстрее. Однако из-за того, что индекс-строитель не сортирует данные перед сжатием их в сегменты, могут возникать сегменты с перекрывающимися диапазонами значений, в результате чего запросы должны читать больше сегментов с диска и займывать больше времени.  

При создании заказавшегося CCI движок S'L Analytics сортирует существующие данные в памяти по ключу заказа (ы) до того, как строитель индекса сжимает их в сегменты индексов.  С помощью отсортированных данных перекрытие сегмента уменьшается, позволяя запросам иметь более эффективную ликвидацию сегмента и, таким образом, более высокую производительность, поскольку количество сегментов, считывающих сяслук с диска, меньше.  Если все данные могут быть отсортированы в памяти сразу, то перекрытия сегмента можно избежать.  Учитывая большой размер данных в таблицах аналитики S'L, такой сценарий происходит не часто.  

Чтобы проверить диапазоны сегментов для столбца, запустите эту команду с именем таблицы и именем столбца:

```sql
SELECT o.name, pnp.index_id, 
cls.row_count, pnp.data_compression_desc, 
pnp.pdw_node_id, pnp.distribution_id, cls.segment_id, 
cls.column_id, 
cls.min_data_id, cls.max_data_id, 
cls.max_data_id-cls.min_data_id as difference
FROM sys.pdw_nodes_partitions AS pnp
   JOIN sys.pdw_nodes_tables AS Ntables ON pnp.object_id = NTables.object_id AND pnp.pdw_node_id = NTables.pdw_node_id
   JOIN sys.pdw_table_mappings AS Tmap  ON NTables.name = TMap.physical_name AND substring(TMap.physical_name,40, 10) = pnp.distribution_id
   JOIN sys.objects AS o ON TMap.object_id = o.object_id
   JOIN sys.pdw_nodes_column_store_segments AS cls ON pnp.partition_id = cls.partition_id AND pnp.distribution_id  = cls.distribution_id
JOIN sys.columns as cols ON o.object_id = cols.object_id AND cls.column_id = cols.column_id
WHERE o.name = '<Table Name>' and cols.name = '<Column Name>'  and TMap.physical_name  not like '%HdTable%'
ORDER BY o.name, pnp.distribution_id, cls.min_data_id 


```

> [!NOTE] 
> В упорядоченной таблице CCI новые данные, полученные в результате одной и той же партии операций загрузки DML или данных, сортируются в этой партии, глобальная сортировка по всем данным в таблице отсутствует.  Пользователи могут REBUILD заказанный CCI для сортировки всех данных в таблице.  В s'L Analytics индекс columnstore REBUILD является автономной операцией.  Для разделительной таблицы REBUILD выполняется по одной разделу за один раз.  Данные в перестроенном перечне раздела "в автономном режиме" и недоступны до завершения РАЗДЕЛа REBUILD. 

## <a name="query-performance"></a>Производительность запросов

Увеличение производительности запроса от заказанных CCI зависит от шаблонов запроса, размера данных, того, насколько хорошо отсортированы данные, физической структуры сегментов, а также выбранного для выполнения запроса класса DWU и ресурса.  Пользователи должны просмотреть все эти факторы, прежде чем выбрать колонки заказа при проектировании упорядоченной таблицы CCI.

Запросы со всеми этими шаблонами обычно работают быстрее с упорядоченным CCI.  
1. Запросы имеют равенство, неравенство или диапазон предикатов
1. Предикатные столбцы и упорядоченные столбцы CCI одинаковы.  
1. Предикатные столбцы используются в том же порядке, что и столбец, порядко упорядоченных столбцов CCI.  
 
В этом примере таблица T1 имеет кластерный индекс столбцов, упорядоченный в последовательности Col_C, Col_B и Col_A.

```sql

CREATE CLUSTERED COLUMNSTORE INDEX MyOrderedCCI ON  T1
ORDER (Col_C, Col_B, Col_A)

```

Производительность запроса 1 может извлечь большую пользу из заказанных CCI, чем остальные три запроса. 

```sql
-- Query #1: 

SELECT * FROM T1 WHERE Col_C = 'c' AND Col_B = 'b' AND Col_A = 'a';

-- Query #2

SELECT * FROM T1 WHERE Col_B = 'b' AND Col_C = 'c' AND Col_A = 'a';

-- Query #3
SELECT * FROM T1 WHERE Col_B = 'b' AND Col_A = 'a';

-- Query #4
SELECT * FROM T1 WHERE Col_A = 'a' AND Col_C = 'c';

```

## <a name="data-loading-performance"></a>Производительность загрузки данных

Производительность загрузки данных в упорядоченную таблицу CCI аналогична разделенной таблице.  Загрузка данных в упорядоченную таблицу CCI может занять больше времени, чем неупорядоченная таблица CCI из-за операции сортировки данных, однако запросы могут работать быстрее после этого с упорядоченным CCI.  

Вот пример сравнения производительности загрузки данных в таблицы с различными схемами.

![Performance_comparison_data_loading](./media/performance-tuning-ordered-cci/cci-data-loading-performance.png)


Вот пример сравнения производительности запроса между CCI и упорядоченным CCI.

![Performance_comparison_data_loading](./media/performance-tuning-ordered-cci/occi_query_performance.png)

 
## <a name="reduce-segment-overlapping"></a>Сокращение перекрытия сегмента

Количество перекрывающихся сегментов зависит от размера данных для сортировки, доступной памяти и максимальной степени парализмации (MAXDOP) при создании заказанных CCI. Ниже приведены варианты уменьшения перекрытия сегмента при создании упорядоченного CCI.

- Используйте класс ресурсов xlargerc на более высоком DWU, чтобы обеспечить больше памяти для сортировки данных, прежде чем строитель индекса сжимает данные на сегменты.  Попав в сегмент индекса, физическое местоположение данных не может быть изменено.  Нет сортировки данных в сегменте или в разных сегментах.  

- Создайте упорядоченный CCI с MAXDOP No 1.  Каждый поток, используемый для создания заказанных CCI, работает на подмножестве данных и сортирует их локально.  Глобальной сортировки данных, отсортированных по разным потокам, не существует.  Использование параллельных потоков может сократить время создания упорядоченного CCI, но будет генерировать больше перекрывающихся сегментов, чем с помощью одного потока.  В настоящее время опция MAXDOP поддерживается только при создании упорядоченной таблицы CCI с использованием команды CREATE TABLE AS SELECT.  Создание упорядоченного CCI с помощью команд CREATE INDEX или CREATE TABLE не поддерживает опцию MAXDOP. Например,

```sql
CREATE TABLE Table1 WITH (DISTRIBUTION = HASH(c1), CLUSTERED COLUMNSTORE INDEX ORDER(c1) )
AS SELECT * FROM ExampleTable
OPTION (MAXDOP 1);
```
- Предварительно сортировать данные по сортированному ключу (ы) перед их загрузкой в таблицы аналитики S'L.


Вот пример упорядоченного распределения таблиц CCI, которое имеет нулевое перекрываемое сегментное распределение вышеуказанных рекомендаций. Заказанные таблицы CCI создаются в базе данных DWU1000c через CTAS из 20-ГБ кучи таблицы с использованием MAXDOP 1 и xlargerc.  CCI заказываюсь на колонке BIGINT без дубликатов.  

![Segment_No_Overlapping](./media/performance-tuning-ordered-cci/perfect-sorting-example.png)

## <a name="create-ordered-cci-on-large-tables"></a>Создание упорядоченного CCI на больших столах
Создание упорядоченной CCI является автономной операцией.  Для таблиц без разделов данные не будут доступны пользователям до завершения заказанных процессов создания CCI.   Для разделенных таблиц, так как движок создает упорядоченную раздел CCI по разделу, пользователи все равно могут получить доступ к данным в разделах, где упорядоченное создание CCI не находится в процессе.   Эту опцию можно использовать для минимизации простоя во время заказанных создания CCI на больших таблицах: 

1.    Создание разделов на целевой большой таблице (называемые Table_A).
2.    Создайте пустую упорядоченную таблицу CCI (называемую Table_B) с той же таблицей и схемой раздела, что и таблица А.
3.    Переключите одну раздел из таблицы А в таблицу B.
4.    Выполнить ORDERED_CCI_INDEX <Ordered_CCI_Index> Ordered_CCI_Index Ordered_CCI_Index ON <Table_B> REBUILD PARTITION - <Partition_ID> на таблице B для восстановления переключенного раздела.  
5.    Повторите шаг 3 и 4 для каждого раздела в Table_A.
6.    После того, как все разделы переключаются с Table_A на Table_B и перестраиваются, Table_A и переименовывая Table_B в Table_A. 

## <a name="examples"></a>Примеры

**A. Чтобы проверить заказанные столбцы и порядковую заказ:**
```sql
SELECT object_name(c.object_id) table_name, c.name column_name, i.column_store_order_ordinal 
FROM sys.index_columns i 
JOIN sys.columns c ON i.object_id = c.object_id AND c.column_id = i.column_id
WHERE column_store_order_ordinal <>0
```

**B. Изменить столбец, добавить или удалить столбцы из списка заказов или изменить с CCI на упорядоченный CCI:**
```sql
CREATE CLUSTERED COLUMNSTORE INDEX InternetSales ON  InternetSales
ORDER (ProductKey, SalesAmount)
WITH (DROP_EXISTING = ON)
```

## <a name="next-steps"></a>Дальнейшие действия
Дополнительные советы по разработке см. в статье [Проектные решения и методики программирования для хранилища данных SQL](sql-data-warehouse-overview-develop.md).
