---
title: Общие сведения о поддержке Azure MQTT в Центре Интернета вещей | Документация Майкрософт
description: 'Руководство разработчика: поддержка устройств, подключающихся к конечной точке для устройств Центра Интернета вещей по протоколу MQTT. Содержит сведения о встроенной поддержке MQTT в пакетах SDK для устройств Azure IoT.'
author: robinsh
ms.service: iot-hub
services: iot-hub
ms.topic: conceptual
ms.date: 10/12/2018
ms.author: robinsh
ms.openlocfilehash: 9ccfaa57b8e8fdea325bed908ffe8815b09d0d15
ms.sourcegitcommit: 8dc84e8b04390f39a3c11e9b0eaf3264861fcafc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/13/2020
ms.locfileid: "81257799"
---
# <a name="communicate-with-your-iot-hub-using-the-mqtt-protocol"></a>Взаимодействие с Центром Интернета вещей с помощью протокола MQTT

Центр Интернета вещей позволяет устройствам взаимодействовать с конечными точками устройств Центра Интернета вещей с помощью:

* протокола [MQTT версии 3.1.1](https://mqtt.org/) на порту 8883;
* протокола MQTT версии 3.1.1 через WebSocket на порту 443.

Центр Интернета вещей не является полнофункциональным брокером MQTT и не поддерживает все функциональные возможности, указанные в стандарте MQTT версии 3.1.1. В этой статье описывается, как устройства могут использовать поддерживаемые MQTT поведения для связи с Центром Интернета вещей.

[!INCLUDE [iot-hub-basic](../../includes/iot-hub-basic-partial.md)]

Весь обмен данными Центра Интернета вещей с устройствами защищен с помощью протокола TLS/SSL. Таким образом, IoT Hub не поддерживает небезопасные соединения по порту 1883.

## <a name="connecting-to-iot-hub"></a>Подключение к Центру Интернета вещей

Устройство может использовать протокол МЗТТ для подключения к концентратору IoT, используя любой из следующих вариантов.

* Библиотеки в [SDK Azure IoT](https://github.com/Azure/azure-iot-sdks).
* Протокол МЗТТ напрямую.

Порт МЗТТ (8883) заблокирован во многих корпоративных и образовательных сетевых средах. Если вы не можете открыть порт 8883 в брандмауэре, мы рекомендуем использовать МЗТТ по веб-разъемам. МЗТТ по веб-разъемам общается через порт 443, который почти всегда открыт в сетевых средах. Чтобы узнать, как указать МЗТТ и МЗТТ по протоколам Web Sockets при использовании SDK Azure IoT, [см.](#using-the-device-sdks)

## <a name="using-the-device-sdks"></a>Использование пакетов SDK для устройств

Доступны [пакеты SDK для устройств](https://github.com/Azure/azure-iot-sdks), поддерживающие протокол MQTT, для Java, Node.js, C, C# и Python. Для установки подключения к Центру Интернета вещей пакеты SDK для устройств используют стандартную строку подключения к Центру Интернета вещей. Чтобы использовать протокол MQTT, параметр протокола клиента должен быть задан как **MQTT**. Вы также можете указать МЗТТ над web-разъемами в параметре протокола клиента. По умолчанию пакеты SDK для устройств подключаются к Центру Интернета вещей, если для флага **CleanSession** установлено значение **0**, и используют **качество обслуживания первого уровня** для обмена сообщениями с Центром Интернета вещей.

Когда устройство подключено к Центру Интернета вещей, пакеты SDK для устройства предоставляют методы, позволяющие устройству осуществлять обмен сообщениями с Центром Интернета вещей.

В следующей таблице содержатся ссылки на образцы кода для каждого поддерживаемого языка и указан параметр, который можно использовать для установления соединения с Концентратором IoT с помощью M'TT или Протокола МЗТТ по протоколу Web Sockets.

| Язык | Параметр протокола МЗТТ | МЗТТ над параметром протокола Web Sockets
| --- | --- | --- |
| [Node.js](https://github.com/Azure/azure-iot-sdk-node/blob/master/device/samples/simple_sample_device.js) | лазурно-йот-устройство-mqtt. Mqtt | лазурно-йот-устройство-mqtt. MqttWs |
| [Java](https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-samples/send-receive-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/SendReceive.java) |[IotHubКлиентПротокол](https://docs.microsoft.com/java/api/com.microsoft.azure.sdk.iot.device.iothubclientprotocol?view=azure-java-stable). МЗТТ | IotHubClientProtocol.MQTT_WS |
| [C](https://github.com/Azure/azure-iot-sdk-c/tree/master/iothub_client/samples/iothub_client_sample_mqtt_dm) | [MQTT_Protocol](https://docs.microsoft.com/azure/iot-hub/iot-c-sdk-ref/iothubtransportmqtt-h/mqtt-protocol) | [MQTT_WebSocket_Protocol](https://docs.microsoft.com/azure/iot-hub/iot-c-sdk-ref/iothubtransportmqtt-websockets-h/mqtt-websocket-protocol) |
| [C#](https://github.com/Azure/azure-iot-sdk-csharp/tree/master/iothub/device/samples) | [ТранспортТип](https://docs.microsoft.com/dotnet/api/microsoft.azure.devices.client.transporttype?view=azure-dotnet). Mqtt | TransportType.Mqtt возвращается к МЗТТ по веб-разъемам, если МЗТТ терпит неудачу. Чтобы указать МЗТТ только по веб-разъемам, используйте TransportType.Mqtt_WebSocket_Only |
| [Python](https://github.com/Azure/azure-iot-sdk-python/tree/master/azure-iot-device/samples) | Поддерживает МЗТТ по умолчанию | Добавление `websockets=True` вызова для создания клиента |

В следующем фрагменте показано, как указать протокол МЗТТ по веб-разъемам при использовании Azure IoT Node.js SDK:

```javascript
var Client = require('azure-iot-device').Client;
var Protocol = require('azure-iot-device-mqtt').MqttWs;
var client = Client.fromConnectionString(deviceConnectionString, Protocol);
```

Следующий фрагмент показывает, как указать протокол МЗТТ по веб-разъемам при использовании Azure IoT Python SDK:

```python
from azure.iot.device.aio import IoTHubDeviceClient
device_client = IoTHubDeviceClient.create_from_connection_string(deviceConnectionString, websockets=True)
```

### <a name="default-keep-alive-timeout"></a>По умолчанию сохранить-живой тайм-аут

Для того, чтобы клиент/ IoT Концентратор соединение остается в живых, как служба и клиент регулярно отправить *сохранить-живой* пинг друг с другом. Клиент, использующий IoT SDK, отправляет сохранение в интервале, определенном в этой таблице ниже:

|Язык  |По умолчанию держать-живой интервал  |Настраивается  |
|---------|---------|---------|
|Node.js     |   180 секунд      |     нет    |
|Java     |    230 секунд     |     нет    |
|C     | 240 секунд |  [Да](https://github.com/Azure/azure-iot-sdk-c/blob/master/doc/Iothub_sdk_options.md#mqtt-transport)   |
|C#     | 300 секунд |  [Да](https://github.com/Azure/azure-iot-sdk-csharp/blob/master/iothub/device/src/Transport/Mqtt/MqttTransportSettings.cs#L89)   |
|Python (V2)   | 60 секунд |  нет   |

После [спецификации МЗТТ,](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081)интервал ioT Hub с сохранением живого пинга в 1,5 раза превышает значение клиента keep-alive. Однако IoT Концентратор ограничивает максимальное время отображив на стороне сервера 29,45 минут (1767 секунд), поскольку все службы Azure связаны с тайм-аулером TCP- хода нагрузки Azure, который составляет 29,45 минуты. 

Например, устройство, используюееемое Java SDK, отправляет пинг-наживание, а затем теряет подключение к сети. 230 секунд спустя, устройство пропускает держать-живой пинг, потому что это в автономном режиме. Тем не менее, IoT Концентратор не `(230 * 1.5) - 230 = 115` закрывает соединение сразу - он ждет еще несколько секунд, прежде чем отключить устройство с ошибкой [404104 DeviceConnectionClosedRemotely.](iot-hub-troubleshoot-error-404104-deviceconnectionclosedremotely.md) 

Максимальное значение клиента keep-alive, `1767 / 1.5 = 1177` который вы можете установить, составляет секунды. Любой трафик сбросить сохранить-живой. Например, успешное обновление маркера SAS сбрасывает сохранение жизни.

### <a name="migrating-a-device-app-from-amqp-to-mqtt"></a>Переход от AMQP на MQTT в приложении устройства

При использовании [пакетов SDK для устройств](https://github.com/Azure/azure-iot-sdks) для перехода с протокола AMQP на MQTT требуется изменить параметр протокола в инициализации клиента, как указано выше.

При этом обязательно проверьте следующее:

* AMQP возвращает ошибки для многих условий, а MQTT завершает подключение. В результате может потребоваться изменить логику обработки исключений.

* MQTT не поддерживает операции *отклонения* при получении [сообщений из облака на устройство](iot-hub-devguide-messaging.md). Если нужно, чтобы серверная часть получала ответы от приложения для устройства, стоит использовать [прямые методы](iot-hub-devguide-direct-methods.md).

* АМЗП не поддерживается в SDK Python

## <a name="using-the-mqtt-protocol-directly-as-a-device"></a>Непосредственное использование протокола MQTT (как устройство)

Если устройство не может использовать пакеты SDK для устройств, оно может подключаться к общедоступным конечным точкам устройства по протоколу MQTT по порту 8883. В пакете **CONNECT** устройство должно использовать следующие значения:

* В поле **Идентификатор клиента** укажите значение **идентификатор устройства**.

* В поле **Username** (Имя пользователя) укажите значение `{iothubhostname}/{device_id}/?api-version=2018-06-30`, где `{iothubhostname}` — это полная запись CName Центра Интернета вещей.

    Например, если имя Центра Интернета вещей — **contoso.azure-devices.net**, а имя устройства — **MyDevice01**, то полное поле **Username** (Имя пользователя) должно содержать:

    `contoso.azure-devices.net/MyDevice01/?api-version=2018-06-30`

* В поле **Пароль** укажите маркер SAS. Формат маркера SAS аналогичен описанному для протоколов HTTPS и AMQP:

  `SharedAccessSignature sig={signature-string}&se={expiry}&sr={URL-encoded-resourceURI}`

  > [!NOTE]
  > При использовании аутентификации с помощью сертификата X.509 пароли маркеров SAS не требуются. Для получения дополнительной информации смотрите в [настройке безопасности X.509 в концентраторе Azure IoT](iot-hub-security-x509-get-started.md) и следуйте инструкциям по [коду ниже.](#tlsssl-configuration)

  Дополнительные сведения о способах создания маркеров SAS см. в соответствующем разделе статьи [Управление доступом к Центру Интернета вещей](iot-hub-devguide-security.md#use-sas-tokens-in-a-device-app).

  При тестировании можно также использовать кроссплатформенные [инструменты Azure IoT для Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.azure-iot-tools) или команду расширения CLI az [iot, генерируемую-сас-токен,](/cli/azure/ext/azure-cli-iot-ext/iot/hub?view=azure-cli-latest#ext-azure-cli-iot-ext-az-iot-hub-generate-sas-token) чтобы быстро создать токен SAS, который можно скопировать и вставить в свой собственный код:

### <a name="for-azure-iot-tools"></a>Для инструментов Azure IoT

1. Разверните вкладку **AZURE IOT HUB DEVICES** (Устройства Центра Интернета вещей Azure) в левом нижнем углу Visual Studio Code.
  
2. Щелкните устройство правой кнопкой мыши и выберите **Generate SAS Token for Device** (Создать маркер безопасности SAS для этого устройства).
  
3. Задайте **время истечения срока действия** и нажмите клавишу "ВВОД".
  
4. Маркер SAS создается и копируется в буфер обмена.

   Созданный маркер SAS имеет следующую структуру.

   `HostName={your hub name}.azure-devices.net;DeviceId=javadevice;SharedAccessSignature=SharedAccessSignature sr={your hub name}.azure-devices.net%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`

   Его часть используется в поле **Пароль** для подключения с использованием MQTT:

   `SharedAccessSignature sr={your hub name}.azure-devices.net%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`

Для пакетов подключения и отключения MQTT Центр Интернета вещей создает событие в канале **мониторинга операций**. Это событие содержит дополнительные сведения, которые помогут устранить неполадки с подключением.

Приложение устройства может указать сообщение **Will** в пакете **CONNECT**. Приложение для устройства должно использовать `devices/{device_id}/messages/events/` или `devices/{device_id}/messages/events/{property_bag}` в качестве значения параметра **Will topic name** (Будущее имя раздела) для определения **будущих сообщений**, которые будут пересылаться в качестве сообщения телеметрии. В этом случае, если сетевое соединение закрыто, но пакет **DISCONNECT** ранее не был получен с устройства, то концентратор Центр Интернета вещей отправляет сообщение **Will**, содержащееся в пакете **CONNECT**, в канал телеметрии. Канал телеметрии может быть либо конечной точкой **События** по умолчанию, либо настраиваемой конечной точкой, определяемой маршрутизацией Центра Интернета вещей. Сообщение имеет свойство **iothub-MessageType** со значением **Will**, назначенным ему.

### <a name="an-example-of-c-code-using-mqtt-without-azure-iot-c-sdk"></a>Пример C-кода с использованием МЗТТ без Azure IoT C SDK
В этом [репозитории](https://github.com/Azure-Samples/IoTMQTTSample)вы найдете несколько демо-проектов C/C,, показывающих, как отправлять телеметрические сообщения, получать события с помощью концентратора IoT без использования Azure IoT C SDK. 

Эти образцы используют библиотеку Eclipse Mosquitto для отправки сообщений брокеру МЗТТ, реализованным в концентраторе IoT.

Этот репозиторий содержит:

**Для Windows:**

* ТелеметрияМТТВИ32: содержит код для отправки телеметрического сообщения в концентратор Azure IoT, построенный и запущенный на компьютере Windows.

* SubscribeM-TTWin32: содержит код для подписки на события данного концентратора IoT на компьютере Windows.

* DeviceTwinM-TTWin32: содержит код для запроса и подписки на двойное устройство устройства в концентраторе Azure IoT на компьютере Windows.

* PnPM-TTWin32: содержит код для отправки телеметрического сообщения с ioT Plug & Play Preview Device в концентратор Azure IoT, построенный и запущенный на компьютере Windows. Подробнее о IoT Plug & Play [здесь](https://docs.microsoft.com/azure/iot-pnp/overview-iot-plug-and-play)

**Для Linux:**

* МЗТТЛинус: содержит код и сценарий сборки для запуска на Linux (WSL, Ubuntu и Raspbian были протестированы до сих пор).

* LinuxConsoleVS2019: содержит тот же код, но в проекте VS2019, ориентированном на WSL (подсистема Windows Linux). Этот проект позволяет отладить код, работающий на Linux шаг за шагом от Visual Studio.

**Для mosquitto_pub:**

Эта папка содержит две команды образцов, используемые с mosquitto_pub утилита инструмент, предоставляемый Mosquitto.org.

* Mosquitto_sendmessage: отправить простое текстовое сообщение в концентратор Azure IoT, выступающий в качестве устройства.

* Mosquitto_subscribe: увидеть события, происходящие в концентраторе Azure IoT.

## <a name="using-the-mqtt-protocol-directly-as-a-module"></a>Непосредственное использование протокола MQTT (как модуль)

Подключение к Центру Интернета вещей по протоколу MQTT с помощью удостоверения модуля аналогично подключению к устройству (описано [выше](#using-the-mqtt-protocol-directly-as-a-device)), но необходимо использовать следующее:

* Установите идентификатор клиента. `{device_id}/{module_id}`

* При аутентификации с использованием имени пользователя и пароля задайте для имени пользователя значение `<hubname>.azure-devices.net/{device_id}/{module_id}/?api-version=2018-06-30` и используйте в качестве пароля маркер SAS, связанный с удостоверением модуля.

* Используйте `devices/{device_id}/modules/{module_id}/messages/events/` в качестве раздела для публикации телеметрии.

* Используйте `devices/{device_id}/modules/{module_id}/messages/events/` как раздел WILL.

* Разделы двойников GET и PATCH идентичны для модулей и устройств.

* Раздел состояния двойников идентичны для модулей и устройств.

## <a name="tlsssl-configuration"></a>конфигурация протокола TLS/SSL

Чтобы напрямую использовать протокол MQTT, ваш клиент *должен* подключиться по протоколу TLS/SSL. Попытки пропустить этот шаг будут завершаться ошибками соединения.

Чтобы установить соединение TLS, может потребоваться скачать корневой сертификат DigiCert Baltimore и добавить ссылку на него. Этот сертификат используется в Azure для обеспечения безопасного подключения. Вы можете найти этот сертификат в репозитории [Azure-iot-sdk-c](https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c). Дополнительные сведения об этих сертификатах можно найти на [веб-сайте Digicert](https://www.digicert.com/digicert-root-certificates.htm).

Пример реализации с помощью версии библиотеки [Paho MQTT](https://pypi.python.org/pypi/paho-mqtt) фонда Eclipse для Python может выглядеть следующим образом.

Сначала установите библиотеку Paho из командной строки:

```cmd/sh
pip install paho-mqtt
```

Затем запустите клиент в сценарии Python. Замените заполнители следующим образом.

* `<local path to digicert.cer>` — путь к локальному файлу, содержащему корневой сертификат DigiCert Baltimore. Этот файл можно создать путем копирования сведений о сертификате из [certs.c](https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c) в пакете Центра Интернета вещей Azure для C. Укажите строки `-----BEGIN CERTIFICATE-----` и `-----END CERTIFICATE-----`, удалите метки `"` в начале и в конце каждой строки, а также удалите знаки `\r\n` в конце каждой строки.

* `<device id from device registry>` — идентификатор устройства, добавленного в Центр Интернета вещей.

* `<generated SAS token>` — маркер SAS для устройства, созданного как описано ранее в этой статье.

* `<iot hub name>` — имя Центра Интернета вещей.

```python
from paho.mqtt import client as mqtt
import ssl

path_to_root_cert = "<local path to digicert.cer file>"
device_id = "<device id from device registry>"
sas_token = "<generated SAS token>"
iot_hub_name = "<iot hub name>"


def on_connect(client, userdata, flags, rc):
    print("Device connected with result code: " + str(rc))


def on_disconnect(client, userdata, rc):
    print("Device disconnected with result code: " + str(rc))


def on_publish(client, userdata, mid):
    print("Device sent message")


client = mqtt.Client(client_id=device_id, protocol=mqtt.MQTTv311)

client.on_connect = on_connect
client.on_disconnect = on_disconnect
client.on_publish = on_publish

client.username_pw_set(username=iot_hub_name+".azure-devices.net/" +
                       device_id + "/?api-version=2018-06-30", password=sas_token)

client.tls_set(ca_certs=path_to_root_cert, certfile=None, keyfile=None,
               cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1_2, ciphers=None)
client.tls_insecure_set(False)

client.connect(iot_hub_name+".azure-devices.net", port=8883)

client.publish("devices/" + device_id + "/messages/events/", "{id=123}", qos=1)
client.loop_forever()
```

Чтобы проверить подлинность с помощью сертификата устройства, обновите фрагмент кода выше со следующими изменениями (см. [Как получить сертификат X.509 CA](./iot-hub-x509ca-overview.md#how-to-get-an-x509-ca-certificate) о том, как подготовиться к проверке подлинности на основе сертификата):

```python
# Create the client as before
# ...

# Set the username but not the password on your client
client.username_pw_set(username=iot_hub_name+".azure-devices.net/" +
                       device_id + "/?api-version=2018-06-30", password=None)

# Set the certificate and key paths on your client
cert_file = "<local path to your certificate file>"
key_file = "<local path to your device key file>"
client.tls_set(ca_certs=path_to_root_cert, certfile=cert_file, keyfile=key_file,
               cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1_2, ciphers=None)

# Connect as before
client.connect(iot_hub_name+".azure-devices.net", port=8883)
```

## <a name="sending-device-to-cloud-messages"></a>Отправка сообщений из устройства в облако

После успешного подключения устройство может отправлять сообщения в Центр Интернета вещей, используя `devices/{device_id}/messages/events/` или `devices/{device_id}/messages/events/{property_bag}` в качестве значения параметра **Имя раздела**. Элемент `{property_bag}` позволяет устройству отправлять сообщения с дополнительными свойствами в формате URL-адреса. Пример:

```text
RFC 2396-encoded(<PropertyName1>)=RFC 2396-encoded(<PropertyValue1>)&RFC 2396-encoded(<PropertyName2>)=RFC 2396-encoded(<PropertyValue2>)…
```

> [!NOTE]
> Этот `{property_bag}` элемент использует тот же кодирование, что и строки запроса в протоколе HTTPS.

Ниже приведен список реакций на события, характерных для реализации Центра Интернета вещей:

* Центр Интернета вещей не поддерживает сообщения со вторым уровнем качества обслуживания. Если приложение для устройства публикует сообщение со **вторым уровнем качества обслуживания**, то Центр Интернета вещей закрывает сетевое подключение.

* Центр Интернета вещей не сохраняет сообщения retain. Если устройство отправляет сообщение с флагом **RETAIN**, имеющим значение 1, то Центр Интернета вещей добавляет в сообщение свойство приложения **x-opt-retain**. В этом случае Центр Интернета вещей не хранит сообщение retain, а передает его во внутреннее приложение.

* Центр Интернета вещей поддерживает только одно активное подключение MQTT на устройство. Любое новое подключение MQTT от имени того же идентификатора устройства приводит к тому, что Центр Интернета вещей разрывает существующее подключение.

Дополнительные сведения см. в статье [Отправка и получение сообщений в Центре Интернета вещей](iot-hub-devguide-messaging.md).

## <a name="receiving-cloud-to-device-messages"></a>Получение сообщений из облака на устройство

Для получения сообщений от Концентратора IoT устройство должно подписаться, используя `devices/{device_id}/messages/devicebound/#` в качестве **фильтра темы.** Многоуровневый подстановочный знак `#` в параметре Topic Filter (Фильтр разделов) используется только для того, чтобы разрешить устройству получать дополнительные свойства в имени раздела. В Центре Интернета вещей запрещено использовать подстановочные знаки `#` или `?` для фильтрации подразделов. Так как Центр Интернета вещей не является универсальным брокером службы сообщений на основе шаблона "издатель-подписчик", то он поддерживает только задокументированные имена и фильтры разделов.

Устройство не будет получать сообщения из Центра Интернета вещей, пока не будет успешно подписано на соответствующую конечную точку устройства, представленную фильтром разделов `devices/{device_id}/messages/devicebound/#`. Когда подписка выполнена, устройство получает сообщения, переданные из облака на устройство, только с момента подписки. Если устройство подключается с флагом **CleanSession**, имеющим значение **0**, то подписка будет сохраняться в разных сеансах. В этом случае при следующем подключении с флагом **CleanSession 0** устройство получает ожидающие сообщения, отправленные на него, пока оно было отключено. Если устройство использует флаг **CleanSession** со значением **1**, то оно не будет получать сообщения из Центра Интернета вещей, пока не будет подписано на конечную точку устройства.

Центр Интернета вещей передает сообщения с **именем раздела** `devices/{device_id}/messages/devicebound/` или `devices/{device_id}/messages/devicebound/{property_bag}` при наличии свойств сообщения. `{property_bag}` содержит закодированные в формате URL-адреса пары "ключ-значение" свойств сообщения. В контейнер свойств входят только свойства приложений и задаваемые пользователем системные свойства (такие как **messageId** или **correlationId**). Имена свойств системы **$** имеют префикс, свойства приложения используют исходное имя свойства без префикса.

Если приложение для устройства подписывается на раздел со **вторым уровнем качества обслуживания**, то Центр Интернета вещей присваивает пакету **SUBACK** уровень качества обслуживания не выше первого. После этого Центр Интернета вещей доставляет сообщения на устройство, используя первый уровень качества обслуживания.

## <a name="retrieving-a-device-twins-properties"></a>Получение свойств двойника устройства

Сначала устройство подписывается на `$iothub/twin/res/#`, чтобы получать ответы операций. Затем он отправляет пустое сообщение `$iothub/twin/GET/?$rid={request id}`в тему с заполненным значением для **идентификатора запроса.** Затем служба отправляет ответное сообщение, содержащее данные с двумя данными устройства по теме, `$iothub/twin/res/{status}/?$rid={request id}`используя тот же **идентификатор запроса,** что и запрос.

Идентификатор запроса может быть допустимым значением для стоимости свойств сообщения, в том что касается [руководства разработчика обмена сообщениями IoT Hub,](iot-hub-devguide-messaging.md)и статус проверяется как целый ряд.

Текст ответа содержит раздел properties двойника устройства, как показано в следующем примере ответа:

```json
{
    "desired": {
        "telemetrySendFrequency": "5m",
        "$version": 12
    },
    "reported": {
        "telemetrySendFrequency": "5m",
        "batteryLevel": 55,
        "$version": 123
    }
}
```

Возможны следующие коды состояний:

|Состояние | Описание |
| ----- | ----------- |
| 200 | Успешно |
| 429 | Слишком много запросов (регулирование), как указано в статье [Reference - quotas and throttling](iot-hub-devguide-quotas-throttling.md) (Справочные материалы. Квоты и регулирование) |
| 5** | ошибки сервера; |

Дополнительные сведения см. в статье [Двойники устройства](iot-hub-devguide-device-twins.md).

## <a name="update-device-twins-reported-properties"></a>Обновление сообщаемых свойств двойника устройства

Чтобы обновить сообщаемые свойства, устройство отправляет запрос в Центр Интернета вещей с помощью публикации в указанном разделе MQTT. После обработки запроса Центр Интернета вещей выводит ответ с состоянием "Успех" или "Сбой" операции обновления путем публикации в другом разделе. Это устройство может быть подписано на раздел, чтобы уведомить его о запросе на обновление двойника. Для реализации этого типа взаимодействия запроса/ответа в МЗТТ мы`$rid`используем понятие идентификатора запроса (), предоставленного первоначально устройством в его запросе на обновление. Этот идентификатор запроса также включен в ответ от IoT Hub, чтобы позволить устройству соотнести ответ с его конкретным более ранним запросом.

Следующая последовательность действий описывает, как устройство обновляет сообщаемые свойства в двойнике устройства в Центре Интернета вещей:

1. Сначала устройство должно подписаться на раздел `$iothub/twin/res/#`, чтобы получать ответы операций из Центра Интернета вещей.

2. Устройство отправляет сообщение, содержащее обновление двойника устройства, в раздел `$iothub/twin/PATCH/properties/reported/?$rid={request id}`. Это сообщение включает значение **идентификатора запроса.**

3. Затем служба отправляет ответное сообщение, содержащее новое значение ETag для коллекции сообщаемых свойств в разделе `$iothub/twin/res/{status}/?$rid={request id}`. В этом сообщении отклика используется тот же **идентификатор запроса,** что и запрос.

Текст запроса содержит документ JSON, в котором имеются новые значения для переданных свойств. Каждый участник документа JSON обновляет или добавляет соответствующий участник в документ близнеца устройства. Если элементу задано значение `null`, то этот компонент удаляется из содержащего его объекта. Пример:

```json
{
    "telemetrySendFrequency": "35m",
    "batteryLevel": 60
}
```

Возможны следующие коды состояний:

|Состояние | Описание |
| ----- | ----------- |
| 204 | Успех (содержимое не возвращается) |
| 400 | Недопустимый запрос. Неправильно сформированный JSON. |
| 429 | Слишком много запросов (регулирование), как указано в статье [Reference - quotas and throttling](iot-hub-devguide-quotas-throttling.md) (Справочные материалы. Квоты и регулирование) |
| 5** | ошибки сервера; |

Фрагмент кода Python, приведенный ниже, демонстрирует процесс обновления свойств, сообщаемых двойником, по MQTT (с помощью клиента Paho MQTT):

```python
from paho.mqtt import client as mqtt

# authenticate the client with IoT Hub (not shown here)

client.subscribe("$iothub/twin/res/#")
rid = "1"
twin_reported_property_patch = "{\"firmware_version\": \"v1.1\"}"
client.publish("$iothub/twin/PATCH/properties/reported/?$rid=" +
               rid, twin_reported_property_patch, qos=0)
```

При успешном выполнении операции обновления сообщаемых двойником свойств, указанных выше, в сообщении публикации из Центра Интернета вещей будет следующий раздел: `$iothub/twin/res/204/?$rid=1&$version=6`, где `204` — это код состояния, указывающий на успешность, `$rid=1` соответствует идентификатору запроса, предоставленному устройством в коде, а `$version` соответствует версии раздела сообщаемых двойником устройства свойств после обновления.

Дополнительные сведения см. в статье [Двойники устройства](iot-hub-devguide-device-twins.md).

## <a name="receiving-desired-properties-update-notifications"></a>Получение уведомлений об обновлении требуемых свойств

При подключении устройства Центр Интернета вещей отправляет уведомления в раздел `$iothub/twin/PATCH/properties/desired/?$version={new version}`, в котором находится содержимое обновления, выполненного серверной частью решения. Пример:

```json
{
    "telemetrySendFrequency": "5m",
    "route": null,
    "$version": 8
}
```

Что касается обновлений свойств, `null` значения означают, что член объекта JSON удаляется. Кроме того, обратите внимание, что `$version` содержит новую версию раздела с требуемыми свойствами двойника.

> [!IMPORTANT]
> Центр Интернета вещей создает уведомления об изменении только в том случае, если устройства подключены. Убедитесь, что выполняется [процедура при повторном подключении устройства](iot-hub-devguide-device-twins.md#device-reconnection-flow), чтобы требуемые свойства продолжали синхронизироваться между Центром Интернета вещей и приложением для устройства.

Дополнительные сведения см. в статье [Двойники устройства](iot-hub-devguide-device-twins.md).

## <a name="respond-to-a-direct-method"></a>Ответ на прямой метод

Сначала устройство должно подписаться на `$iothub/methods/POST/#`. Центр Интернета вещей отправляет запросы метода в раздел `$iothub/methods/POST/{method name}/?$rid={request id}` с допустимым документом JSON или без текста.

В качестве ответа устройство отправляет сообщение без текста или с допустимой строкой JSON в раздел `$iothub/methods/res/{status}/?$rid={request id}`. В этом сообщении значение **request ID** должно совпадать с идентификатором в сообщении запроса, а в качестве **status** должно быть указано целое число.

Дополнительные сведения см. в статье [Прямые методы](iot-hub-devguide-direct-methods.md).

## <a name="additional-considerations"></a>Дополнительные сведения

Последнее замечание. Если на стороне облака требуется настроить реакцию на событие протокола MQTT, ознакомьтесь со статьей [о дополнительных протоколах для Центра Интернета вещей](iot-hub-protocol-gateway.md). Это программное обеспечение позволяет развернуть шлюз протокола с высокой производительностью, который взаимодействует непосредственно с Центром Интернета вещей. Шлюз протокола Azure IoT позволяет настроить протокол устройства для уже существующих развертываний MQTT или других настраиваемых протоколов. Однако при этом подходе необходимо запустить настраиваемый шлюз протокола и управлять им.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о протоколе MQTT см. в [документации по MQTT](https://mqtt.org/documentation).

Дополнительные сведения о планировании развертывания Центра Интернета вещей см. в следующих руководствах:

* [Каталог устройств, сертифицированных по программе Microsoft Azure Certified for IoT](https://catalog.azureiotsolutions.com/)
* [Поддержка дополнительных протоколов для центра IoT](iot-hub-protocol-gateway.md)
* [Сравнение центра IoT и Центров событий](iot-hub-compare-event-hubs.md)
* [Масштабирование центра IoT](iot-hub-scaling.md)

Для дальнейшего изучения возможностей Центра Интернета вещей см. следующие статьи:

* [Руководство разработчика для Центра Интернета вещей](iot-hub-devguide.md)
* [Краткое руководство. Развертывание первого модуля IoT Edge на устройстве под управлением 64-разрядной ОС Linux](../iot-edge/tutorial-simulate-device-linux.md)
