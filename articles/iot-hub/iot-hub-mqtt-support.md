---
title: Общие сведения о поддержке Azure MQTT в Центре Интернета вещей | Документация Майкрософт
description: 'Руководство разработчика: поддержка устройств, подключающихся к конечной точке для устройств Центра Интернета вещей по протоколу MQTT. Содержит сведения о встроенной поддержке MQTT в пакетах SDK для устройств Azure IoT.'
author: robinsh
ms.service: iot-hub
services: iot-hub
ms.topic: conceptual
ms.date: 10/12/2018
ms.author: robinsh
ms.openlocfilehash: 2b200692610302bb135982e5419dcda36d5cfe60
ms.sourcegitcommit: 7b25c9981b52c385af77feb022825c1be6ff55bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79271165"
---
# <a name="communicate-with-your-iot-hub-using-the-mqtt-protocol"></a>Взаимодействие с Центром Интернета вещей с помощью протокола MQTT

Центр Интернета вещей позволяет устройствам взаимодействовать с конечными точками устройств Центра Интернета вещей с помощью:

* [MQTT v 3.1.1](https://mqtt.org/) на порте 8883
* протокола MQTT версии 3.1.1 через WebSocket на порту 443.

Центр Интернета вещей не является полнофункциональным брокером MQTT и не поддерживает все функциональные возможности, указанные в стандарте MQTT версии 3.1.1. В этой статье описывается, как устройства могут использовать поддерживаемые MQTT поведения для связи с Центром Интернета вещей.

[!INCLUDE [iot-hub-basic](../../includes/iot-hub-basic-partial.md)]

Весь обмен данными Центра Интернета вещей с устройствами защищен с помощью протокола TLS/SSL. Таким образом Центр Интернета вещей не поддерживает небезопасные подключения через порт 1883.

## <a name="connecting-to-iot-hub"></a>Подключение к Центру Интернета вещей

Устройство может использовать протокол MQTT для подключения к центру Интернета вещей с помощью любого из следующих параметров.

* Библиотеки в пакетах [SDK для Интернета вещей Azure](https://github.com/Azure/azure-iot-sdks).
* Протокол MQTT напрямую.

Порт MQTT (8883) блокируется во многих корпоративных и образовательных сетевых средах. Если в брандмауэре не удается открыть порт 8883, рекомендуется использовать MQTT через веб-сокеты. MQTT через веб-сокеты взаимодействуют через порт 443, который почти всегда открыт в сетевых средах. Сведения о том, как указать протоколы MQTT и MQTT через веб-сокеты при использовании пакетов SDK для Интернета вещей Azure, см. в разделе [Использование пакетов SDK для устройств](#using-the-device-sdks).

## <a name="using-the-device-sdks"></a>Использование пакетов SDK для устройств

[Пакеты SDK для устройств](https://github.com/Azure/azure-iot-sdks) , поддерживающие протокол MQTT, доступны для Java, Node. js, C#C, и Python. Для установки подключения к Центру Интернета вещей пакеты SDK для устройств используют стандартную строку подключения к Центру Интернета вещей. Чтобы использовать протокол MQTT, параметр протокола клиента должен быть задан как **MQTT**. В параметре протокола клиента можно также указать MQTT через веб-сокеты. По умолчанию пакеты SDK для устройств подключаются к Центру Интернета вещей, если для флага **CleanSession** установлено значение **0**, и используют **качество обслуживания первого уровня** для обмена сообщениями с Центром Интернета вещей.

Когда устройство подключено к Центру Интернета вещей, пакеты SDK для устройства предоставляют методы, позволяющие устройству осуществлять обмен сообщениями с Центром Интернета вещей.

В следующей таблице приведены ссылки на примеры кода для каждого поддерживаемого языка и указывается параметр, используемый для установления подключения к центру Интернета вещей с помощью MQTT или протокола MQTT через веб-сокеты.

| Язык | Параметр протокола MQTT | Параметр протокола MQTT через веб-сокеты
| --- | --- | --- |
| [Node.js](https://github.com/Azure/azure-iot-sdk-node/blob/master/device/samples/simple_sample_device.js) | Azure-IOT-Device-mqtt. Mqtt | Azure-IOT-Device-mqtt. мкттвс |
| [Java](https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-samples/send-receive-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/SendReceive.java) |[Иосубклиентпротокол](https://docs.microsoft.com/java/api/com.microsoft.azure.sdk.iot.device.iothubclientprotocol?view=azure-java-stable). MQTT | Иосубклиентпротокол. MQTT_WS |
| [C](https://github.com/Azure/azure-iot-sdk-c/tree/master/iothub_client/samples/iothub_client_sample_mqtt_dm) | [MQTT_Protocol](https://docs.microsoft.com/azure/iot-hub/iot-c-sdk-ref/iothubtransportmqtt-h/mqtt-protocol) | [MQTT_WebSocket_Protocol](https://docs.microsoft.com/azure/iot-hub/iot-c-sdk-ref/iothubtransportmqtt-websockets-h/mqtt-websocket-protocol) |
| [C#](https://github.com/Azure/azure-iot-sdk-csharp/tree/master/iothub/device/samples) | [TransportType](https://docs.microsoft.com/dotnet/api/microsoft.azure.devices.client.transporttype?view=azure-dotnet). Mqtt | TransportType. Mqtt возвращается к MQTT через веб-сокеты, если происходит сбой MQTT. Чтобы указать только MQTT через веб-сокеты, используйте TransportType. Mqtt_WebSocket_Only |
| [Python](https://github.com/Azure/azure-iot-sdk-python/tree/master/azure-iot-device/samples) | Поддержка MQTT по умолчанию | Добавление `websockets=True` в вызове для создания клиента |

В следующем фрагменте показано, как указать протокол MQTT через веб-сокеты при использовании пакета SDK для Node. js для Azure IoT:

```javascript
var Client = require('azure-iot-device').Client;
var Protocol = require('azure-iot-device-mqtt').MqttWs;
var client = Client.fromConnectionString(deviceConnectionString, Protocol);
```

В следующем фрагменте показано, как указать протокол MQTT через веб-сокеты при использовании пакета SDK для Azure IoT Python:

```python
from azure.iot.device.aio import IoTHubDeviceClient
device_client = IoTHubDeviceClient.create_from_connection_string(deviceConnectionString, websockets=True)
```

### <a name="default-keep-alive-timeout"></a>Время ожидания проверки активности по умолчанию

Чтобы обеспечить постоянную активность подключения клиента или центра Интернета вещей, служба и клиент регулярно отправляют проверку связи проверки *активности* . Клиент, использующий пакет SDK для IoT, отправляет данные о неактивном состоянии через интервал, определенный в следующей таблице.

|Язык  |Интервал проверки активности по умолчанию  |Настраивается  |
|---------|---------|---------|
|Node.js     |   180 секунд      |     нет    |
|Java     |    230 секунд     |     нет    |
|C     | 240 секунд |  [Да](https://github.com/Azure/azure-iot-sdk-c/blob/master/doc/Iothub_sdk_options.md#mqtt-transport)   |
|C#     | 300 секунд |  [Да](https://github.com/Azure/azure-iot-sdk-csharp/blob/master/iothub/device/src/Transport/Mqtt/MqttTransportSettings.cs#L89)   |
|Python (v2)   | 60 секунд |  нет   |

В следующей [спецификации MQTT](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081)интервал проверки связи для поддержания активности в центре интернета вещей 1,5 раз превышает значение срока поддержания клиента. Однако центр Интернета вещей ограничивает максимальное время ожидания на стороне сервера до 29,45 минут (1767 секунд), так как все службы Azure привязаны к времени ожидания простоя TCP в подсистеме балансировки нагрузки Azure, что составляет 29,45 минут. 

Например, устройство, использующее пакет SDK для Java, отправляет проверку связи для проверки активности, а затем теряет подключение к сети. 230 секунды устройство пропустила проверку связи проверки активности, так как она находится в автономном режиме. Однако центр Интернета вещей не закрывает подключение немедленно — он ожидает другой `(230 * 1.5) - 230 = 115` секунд перед отключением устройства с ошибкой [404104 девицеконнектионклоседремотели](iot-hub-troubleshoot-error-404104-deviceconnectionclosedremotely.md). 

Максимальное значение для проверки активности клиента, которое можно задать, — `1767 / 1.5 = 1177` секунд. Любой трафик будет сбрасывать проверку активности. Например, успешное обновление маркера SAS сбрасывает срок поддержания активности.

### <a name="migrating-a-device-app-from-amqp-to-mqtt"></a>Переход от AMQP на MQTT в приложении устройства

Если вы используете [пакеты SDK для устройств](https://github.com/Azure/azure-iot-sdks), для переключения с использования AMQP на MQTT требуется изменить параметр протокола в инициализации клиента, как указано выше.

При этом обязательно проверьте следующее:

* AMQP возвращает ошибки для многих условий, а MQTT завершает подключение. В результате может потребоваться изменить логику обработки исключений.

* MQTT не поддерживает операции *отклонения* при получении [сообщений, отправляемых из облака на устройство](iot-hub-devguide-messaging.md). Если серверное приложение должно получить ответ от приложения устройства, рассмотрите возможность использования [прямых методов](iot-hub-devguide-direct-methods.md).

* AMQP не поддерживается в пакете SDK для Python

## <a name="using-the-mqtt-protocol-directly-as-a-device"></a>Непосредственное использование протокола MQTT (как устройство)

Если устройство не может использовать пакеты SDK для устройств, оно может подключаться к общедоступным конечным точкам устройства по протоколу MQTT по порту 8883. В пакете **подключения** устройство должно использовать следующие значения:

* В поле **Идентификатор клиента** укажите значение **идентификатор устройства**.

* В поле **Username** (Имя пользователя) укажите значение `{iothubhostname}/{device_id}/?api-version=2018-06-30`, где `{iothubhostname}` — это полная запись CName Центра Интернета вещей.

    Например, если имя Центра Интернета вещей — **contoso.azure-devices.net**, а имя устройства — **MyDevice01**, то полное поле **Username** (Имя пользователя) должно содержать:

    `contoso.azure-devices.net/MyDevice01/?api-version=2018-06-30`

* В поле **Пароль** укажите маркер SAS. Формат маркера SAS аналогичен описанному для протоколов HTTPS и AMQP:

  `SharedAccessSignature sig={signature-string}&se={expiry}&sr={URL-encoded-resourceURI}`

  > [!NOTE]
  > При использовании аутентификации с помощью сертификата X.509 пароли маркеров SAS не требуются. Дополнительные сведения см. [в разделе Настройка безопасности X. 509 в центре Интернета вещей Azure](iot-hub-security-x509-get-started.md) и следуйте приведенным [ниже](#tlsssl-configuration)инструкциям по коду.

  Дополнительные сведения о создании маркеров SAS см. в разделе устройство статьи [Использование маркеров безопасности центра Интернета вещей](iot-hub-devguide-security.md#use-sas-tokens-in-a-device-app).

  При тестировании можно также использовать кросс-платформенные [инструменты Azure IOT для Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.azure-iot-tools) или средство [Device Explorer](https://github.com/Azure/azure-iot-sdk-csharp/blob/master/tools/DeviceExplorer) , чтобы быстро создать маркер SAS, который можно скопировать и вставить в свой собственный код:

### <a name="for-azure-iot-tools"></a>Для средств Azure IoT

1. Разверните вкладку **AZURE IOT HUB DEVICES** (Устройства Центра Интернета вещей Azure) в левом нижнем углу Visual Studio Code.
  
2. Щелкните устройство правой кнопкой мыши и выберите **Generate SAS Token for Device** (Создать маркер безопасности SAS для этого устройства).
  
3. Задайте **время истечения срока действия** и нажмите клавишу "ВВОД".
  
4. Маркер SAS создается и копируется в буфер обмена.

### <a name="for-device-explorer"></a>Для Device Explorer

1. Перейдите на вкладку **Управление** в **обозревателе устройств**.

2. Щелкните **Маркер SAS** (вверху справа).

3. В разделе **SASTokenForm** выберите свое устройство в раскрывающемся списке **DeviceID**. Задайте значение **срока жизни**.

4. Щелкните **Создать** , чтобы создать маркер.

   Созданный маркер SAS имеет следующую структуру.

   `HostName={your hub name}.azure-devices.net;DeviceId=javadevice;SharedAccessSignature=SharedAccessSignature sr={your hub name}.azure-devices.net%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`

   Его часть используется в поле **Пароль** для подключения с использованием MQTT:

   `SharedAccessSignature sr={your hub name}.azure-devices.net%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`

Для пакетов подключения и отключения MQTT Центр Интернета вещей создает событие в канале **мониторинга операций**. Это событие содержит дополнительные сведения, которые помогут устранить неполадки с подключением.

Приложение устройства может указать сообщение **Will** в пакете **CONNECT**. Приложение для устройства должно использовать `devices/{device_id}/messages/events/` или `devices/{device_id}/messages/events/{property_bag}` в качестве значения параметра **Will topic name** (Будущее имя раздела) для определения **будущих сообщений**, которые будут пересылаться в качестве сообщения телеметрии. В этом случае, если сетевое соединение закрыто, но пакет **DISCONNECT** ранее не был получен с устройства, то концентратор Центр Интернета вещей отправляет сообщение **Will**, содержащееся в пакете **CONNECT**, в канал телеметрии. Канал телеметрии может быть либо конечной точкой **События** по умолчанию, либо настраиваемой конечной точкой, определяемой маршрутизацией Центра Интернета вещей. Сообщение имеет свойство **iothub-MessageType** со значением **Will**, назначенным ему.

### <a name="an-example-of-c-code-using-mqtt-without-azure-iot-c-sdk"></a>Пример кода на языке C с использованием MQTT без пакета SDK для Azure IoT C
В этом [репозитории](https://github.com/Azure-Samples/IoTMQTTSample)вы найдете несколько проектов C/C++ Demo, показывающих, как отправлять сообщения телеметрии, получать события с помощью центра Интернета вещей, не используя пакет SDK для Azure IOT C. 

В этих примерах для отправки сообщения в брокер MQTT, реализованный в центре Интернета вещей, используется библиотека Eclipse Москуитто.

Этот репозиторий содержит:

**Для Windows:**

* TelemetryMQTTWin32: содержит код для отправки сообщения телеметрии в центр Интернета вещей Azure, который создается и запускается на компьютере Windows.

* SubscribeMQTTWin32: содержит код для подписки на события данного центра Интернета вещей на компьютере Windows.

* DeviceTwinMQTTWin32: содержит код для запроса и подписки на события двойникаа устройства в центре Интернета вещей на компьютере Windows.

* PnPMQTTWin32: содержит код для отправки сообщения телеметрии с помощью подключения к центру Интернета вещей, подключаемого & Воспроизведение предварительных версий в центр Интернета вещей Azure, созданного и выполняемого на компьютере Windows. Дополнительные сведения о подключении к Интернету IoT & воспроизвести [здесь](https://docs.microsoft.com/azure/iot-pnp/overview-iot-plug-and-play)

**Для Linux:**

* Мкттлинукс: содержит код и сценарий сборки для запуска в Linux (WSL, Ubuntu и Raspbian были протестированы до сих пор).

* LinuxConsoleVS2019: содержит тот же код, но в проекте VS2019, предназначенном для WSL (подсистему Windows Linux). Этот проект позволяет выполнять отладку кода, выполняемого на Linux, пошагово в Visual Studio.

**Для mosquitto_pub:**

Эта папка содержит две команды, которые используются с mosquitto_pub служебной программой, предоставляемой Mosquitto.org.

* Mosquitto_sendmessage: для отправки простого текстового сообщения в центр Интернета вещей Azure, действующий как устройство.

* Mosquitto_subscribe: для просмотра событий, происходящих в центре Интернета вещей Azure.

## <a name="using-the-mqtt-protocol-directly-as-a-module"></a>Непосредственное использование протокола MQTT (как модуль)

Подключение к Центру Интернета вещей по протоколу MQTT с помощью удостоверения модуля аналогично подключению к устройству (описано [выше](#using-the-mqtt-protocol-directly-as-a-device)), но необходимо использовать следующее:

* Задайте для идентификатора клиента значение `{device_id}/{module_id}`.

* При аутентификации с использованием имени пользователя и пароля задайте для имени пользователя значение `<hubname>.azure-devices.net/{device_id}/{module_id}/?api-version=2018-06-30` и используйте в качестве пароля маркер SAS, связанный с удостоверением модуля.

* Используйте `devices/{device_id}/modules/{module_id}/messages/events/` в качестве раздела для публикации телеметрии.

* Используйте `devices/{device_id}/modules/{module_id}/messages/events/` как раздел WILL.

* Разделы двойников GET и PATCH идентичны для модулей и устройств.

* Раздел состояния двойников идентичны для модулей и устройств.

## <a name="tlsssl-configuration"></a>конфигурация протокола TLS/SSL

Чтобы напрямую использовать протокол MQTT, ваш клиент *должен* подключиться по протоколу TLS/SSL. Попытки пропустить этот шаг будут завершаться ошибками соединения.

Чтобы установить соединение TLS, может потребоваться скачать корневой сертификат DigiCert Baltimore и добавить ссылку на него. Этот сертификат используется в Azure для обеспечения безопасного подключения. Этот сертификат можно найти в репозитории [Azure-IOT-SDK-c](https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c) . Дополнительные сведения об этих сертификатах можно найти на [веб-сайте DigiCert](https://www.digicert.com/digicert-root-certificates.htm).

Пример реализации этой функции с помощью версии Python [библиотеки PAHO MQTT](https://pypi.python.org/pypi/paho-mqtt) в Eclipse Foundation может выглядеть следующим образом.

Сначала установите библиотеку Paho из командной строки:

```cmd/sh
pip install paho-mqtt
```

Затем запустите клиент в сценарии Python. Замените заполнители следующим образом.

* `<local path to digicert.cer>` — путь к локальному файлу, содержащему корневой сертификат DigiCert Baltimore. Этот файл можно создать путем копирования сведений о сертификате из [certs.c](https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c) в пакете Центра Интернета вещей Azure для C. Укажите строки `-----BEGIN CERTIFICATE-----` и `-----END CERTIFICATE-----`, удалите метки `"` в начале и в конце каждой строки, а также удалите знаки `\r\n` в конце каждой строки.

* `<device id from device registry>` — идентификатор устройства, добавленного в Центр Интернета вещей.

* `<generated SAS token>` — маркер SAS для устройства, созданного как описано ранее в этой статье.

* `<iot hub name>` — имя Центра Интернета вещей.

```python
from paho.mqtt import client as mqtt
import ssl

path_to_root_cert = "<local path to digicert.cer file>"
device_id = "<device id from device registry>"
sas_token = "<generated SAS token>"
iot_hub_name = "<iot hub name>"


def on_connect(client, userdata, flags, rc):
    print("Device connected with result code: " + str(rc))


def on_disconnect(client, userdata, rc):
    print("Device disconnected with result code: " + str(rc))


def on_publish(client, userdata, mid):
    print("Device sent message")


client = mqtt.Client(client_id=device_id, protocol=mqtt.MQTTv311)

client.on_connect = on_connect
client.on_disconnect = on_disconnect
client.on_publish = on_publish

client.username_pw_set(username=iot_hub_name+".azure-devices.net/" +
                       device_id + "/?api-version=2018-06-30", password=sas_token)

client.tls_set(ca_certs=path_to_root_cert, certfile=None, keyfile=None,
               cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1_2, ciphers=None)
client.tls_insecure_set(False)

client.connect(iot_hub_name+".azure-devices.net", port=8883)

client.publish("devices/" + device_id + "/messages/events/", "{id=123}", qos=1)
client.loop_forever()
```

Чтобы выполнить аутентификацию с помощью сертификата устройства, обновите приведенный выше фрагмент кода, дополнив следующие изменения (см [. статью как получить сертификат ЦС X. 509](./iot-hub-x509ca-overview.md#how-to-get-an-x509-ca-certificate) для подготовки к проверке подлинности на основе сертификата).

```python
# Create the client as before
# ...

# Set the username but not the password on your client
client.username_pw_set(username=iot_hub_name+".azure-devices.net/" +
                       device_id + "/?api-version=2018-06-30", password=None)

# Set the certificate and key paths on your client
cert_file = "<local path to your certificate file>"
key_file = "<local path to your device key file>"
client.tls_set(ca_certs=path_to_root_cert, certfile=cert_file, keyfile=key_file,
               cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1_2, ciphers=None)

# Connect as before
client.connect(iot_hub_name+".azure-devices.net", port=8883)
```

## <a name="sending-device-to-cloud-messages"></a>Отправка сообщений из устройства в облако

После успешного подключения устройство может отправлять сообщения в Центр Интернета вещей, используя `devices/{device_id}/messages/events/` или `devices/{device_id}/messages/events/{property_bag}` в качестве значения параметра **Имя раздела**. Элемент `{property_bag}` позволяет устройству отправлять сообщения с дополнительными свойствами в формате URL-адреса. Пример:

```text
RFC 2396-encoded(<PropertyName1>)=RFC 2396-encoded(<PropertyValue1>)&RFC 2396-encoded(<PropertyName2>)=RFC 2396-encoded(<PropertyValue2>)…
```

> [!NOTE]
> Этот `{property_bag}` элемент использует ту же кодировку, что и строки запроса в протоколе HTTPS.

Ниже приведен список реакций на события, характерных для реализации Центра Интернета вещей:

* Центр Интернета вещей не поддерживает сообщения со вторым уровнем качества обслуживания. Если приложение для устройства публикует сообщение со **вторым уровнем качества обслуживания**, то Центр Интернета вещей закрывает сетевое подключение.

* Центр Интернета вещей не сохраняет сообщения retain. Если устройство отправляет сообщение с флагом **RETAIN**, имеющим значение 1, то Центр Интернета вещей добавляет в сообщение свойство приложения **x-opt-retain**. В этом случае Центр Интернета вещей не хранит сообщение retain, а передает его во внутреннее приложение.

* Центр Интернета вещей поддерживает только одно активное подключение MQTT на устройство. Любое новое подключение MQTT от имени того же идентификатора устройства приводит к тому, что Центр Интернета вещей разрывает существующее подключение.

Дополнительные сведения см. в разделе [руководств разработчика по обмену сообщениями](iot-hub-devguide-messaging.md).

## <a name="receiving-cloud-to-device-messages"></a>Получение сообщений из облака на устройство

Для получения сообщений из Центра Интернета вещей устройство должно подписаться с использованием `devices/{device_id}/messages/devicebound/#` в качестве значения параметра **Topic Filter** (Фильтр разделов). Многоуровневый подстановочный знак `#` в параметре Topic Filter (Фильтр разделов) используется только для того, чтобы разрешить устройству получать дополнительные свойства в имени раздела. В Центре Интернета вещей запрещено использовать подстановочные знаки `#` или `?` для фильтрации подразделов. Так как Центр Интернета вещей не является универсальным брокером службы сообщений на основе шаблона "издатель-подписчик", то он поддерживает только задокументированные имена и фильтры разделов.

Устройство не будет получать сообщения из Центра Интернета вещей, пока не будет успешно подписано на соответствующую конечную точку устройства, представленную фильтром разделов `devices/{device_id}/messages/devicebound/#`. Когда подписка выполнена, устройство получает сообщения, переданные из облака на устройство, только с момента подписки. Если устройство подключается с флагом **CleanSession**, имеющим значение **0**, то подписка будет сохраняться в разных сеансах. В этом случае при следующем подключении с флагом **CleanSession 0** устройство получает ожидающие сообщения, отправленные на него, пока оно было отключено. Если устройство использует флаг **CleanSession** со значением **1**, то оно не будет получать сообщения из Центра Интернета вещей, пока не будет подписано на конечную точку устройства.

Центр Интернета вещей доставляет сообщения с **именем раздела** `devices/{device_id}/messages/devicebound/`или `devices/{device_id}/messages/devicebound/{property_bag}` при наличии свойств сообщения. `{property_bag}` содержит закодированные в формате URL-адреса пары "ключ-значение" свойств сообщения. В контейнер свойств входят только свойства приложений и задаваемые пользователем системные свойства (такие как **messageId** или **correlationId**). Имена системных свойств имеют префикс **$** , свойства приложений используют исходное имя свойства без префикса.

Если приложение для устройства подписывается на раздел со **вторым уровнем качества обслуживания**, то Центр Интернета вещей присваивает пакету **SUBACK** уровень качества обслуживания не выше первого. После этого Центр Интернета вещей доставляет сообщения на устройство, используя первый уровень качества обслуживания.

## <a name="retrieving-a-device-twins-properties"></a>Получение свойств двойника устройства

Сначала устройство подписывается на `$iothub/twin/res/#`, чтобы получать ответы операций. Затем оно отправляет пустое сообщение в раздел `$iothub/twin/GET/?$rid={request id}` с заполненным значением **request ID** (идентификатор запроса). Затем служба отправляет ответное сообщение, содержащее данные двойника устройства в разделе `$iothub/twin/res/{status}/?$rid={request id}`, используя то же значение **идентификатора запроса**, что и в запросе.

Идентификатор запроса может быть любым допустимым значением свойства сообщения в соответствии с [руководством разработчика по обмену сообщениями в центре Интернета вещей](iot-hub-devguide-messaging.md), а состояние проверяется как целое число.

Текст ответа содержит раздел properties двойника устройства, как показано в следующем примере ответа:

```json
{
    "desired": {
        "telemetrySendFrequency": "5m",
        "$version": 12
    },
    "reported": {
        "telemetrySendFrequency": "5m",
        "batteryLevel": 55,
        "$version": 123
    }
}
```

Возможны следующие коды состояний:

|Состояние | Description |
| ----- | ----------- |
| 200 | Успешно |
| 429 | Слишком много запросов (регулируется) в соответствии с [регулированием центра Интернета вещей](iot-hub-devguide-quotas-throttling.md) |
| 5** | ошибки сервера; |

Дополнительные сведения см. в разделе [руководством разработчика двойниковов устройств](iot-hub-devguide-device-twins.md).

## <a name="update-device-twins-reported-properties"></a>Обновление сообщаемых свойств двойника устройства

Чтобы обновить сообщаемые свойства, устройство отправляет запрос в Центр Интернета вещей с помощью публикации в указанном разделе MQTT. После обработки запроса Центр Интернета вещей выводит ответ с состоянием "Успех" или "Сбой" операции обновления путем публикации в другом разделе. Это устройство может быть подписано на раздел, чтобы уведомить его о запросе на обновление двойника. Чтобы реализовать этот тип взаимодействия "запрос-ответ" в MQTT, мы используем концепцию идентификатора запроса (`$rid`), предоставленного устройством в его запросе на обновление. Этот идентификатор запроса также включается в ответ центра Интернета вещей, чтобы разрешить устройству сопоставлять ответ с определенным ранее запросом.

Следующая последовательность действий описывает, как устройство обновляет сообщаемые свойства в двойнике устройства в Центре Интернета вещей:

1. Сначала устройство должно подписаться на раздел `$iothub/twin/res/#`, чтобы получать ответы операций из Центра Интернета вещей.

2. Устройство отправляет сообщение, содержащее обновление двойника устройства, в раздел `$iothub/twin/PATCH/properties/reported/?$rid={request id}`. Это сообщение содержит значение **request ID** (идентификатор запроса).

3. Затем служба отправляет ответное сообщение, содержащее новое значение ETag для коллекции сообщаемых свойств в разделе `$iothub/twin/res/{status}/?$rid={request id}`. В этом ответном сообщении используется то же значение **request ID**, что и в запросе.

Текст запроса содержит документ JSON, в котором имеются новые значения для переданных свойств. Каждый элемент документа JSON обновляет или добавляет соответствующий компонент в документе двойника устройства. Если элементу задано значение `null`, то этот компонент удаляется из содержащего его объекта. Пример:

```json
{
    "telemetrySendFrequency": "35m",
    "batteryLevel": 60
}
```

Возможны следующие коды состояний:

|Состояние | Description |
| ----- | ----------- |
| 204 | Успех (содержимое не возвращается) |
| 400 | Недопустимый запрос. Неправильно сформированный JSON. |
| 429 | Слишком много запросов (регулируется) в соответствии с [регулированием центра Интернета вещей](iot-hub-devguide-quotas-throttling.md) |
| 5** | ошибки сервера; |

Фрагмент кода Python, приведенный ниже, демонстрирует процесс обновления свойств, сообщаемых двойником, по MQTT (с помощью клиента Paho MQTT):

```python
from paho.mqtt import client as mqtt

# authenticate the client with IoT Hub (not shown here)

client.subscribe("$iothub/twin/res/#")
rid = "1"
twin_reported_property_patch = "{\"firmware_version\": \"v1.1\"}"
client.publish("$iothub/twin/PATCH/properties/reported/?$rid=" +
               rid, twin_reported_property_patch, qos=0)
```

При успешном выполнении операции обновления сообщаемых двойником свойств, указанных выше, в сообщении публикации из Центра Интернета вещей будет следующий раздел: `$iothub/twin/res/204/?$rid=1&$version=6`, где `204` — это код состояния, указывающий на успешность, `$rid=1` соответствует идентификатору запроса, предоставленному устройством в коде, а `$version` соответствует версии раздела сообщаемых двойником устройства свойств после обновления.

Дополнительные сведения см. в разделе [руководством разработчика двойниковов устройств](iot-hub-devguide-device-twins.md).

## <a name="receiving-desired-properties-update-notifications"></a>Получение уведомлений об обновлении требуемых свойств

При подключении устройства Центр Интернета вещей отправляет уведомления в раздел `$iothub/twin/PATCH/properties/desired/?$version={new version}`, в котором находится содержимое обновления, выполненного серверной частью решения. Пример:

```json
{
    "telemetrySendFrequency": "5m",
    "route": null,
    "$version": 8
}
```

Как и для обновлений свойств, `null` значения означают, что элемент объекта JSON удаляется. Кроме того, обратите внимание, что `$version` содержит новую версию раздела с требуемыми свойствами двойника.

> [!IMPORTANT]
> Центр Интернета вещей создает уведомления об изменении только в том случае, если устройства подключены. Чтобы обеспечить синхронизацию требуемых свойств между центром Интернета вещей и приложением устройства, необходимо реализовать поток повторного [подключения устройства](iot-hub-devguide-device-twins.md#device-reconnection-flow) .

Дополнительные сведения см. в разделе [руководством разработчика двойниковов устройств](iot-hub-devguide-device-twins.md).

## <a name="respond-to-a-direct-method"></a>Ответ на прямой метод

Сначала устройство должно подписаться на `$iothub/methods/POST/#`. Центр Интернета вещей отправляет запросы метода в раздел `$iothub/methods/POST/{method name}/?$rid={request id}` с допустимым документом JSON или без текста.

В качестве ответа устройство отправляет сообщение без текста или с допустимой строкой JSON в раздел `$iothub/methods/res/{status}/?$rid={request id}`. В этом сообщении значение **request ID** должно совпадать с идентификатором в сообщении запроса, а в качестве **status** должно быть указано целое число.

Дополнительные сведения см. в разделе [руководств разработчика прямых методов](iot-hub-devguide-direct-methods.md).

## <a name="additional-considerations"></a>Дополнительные сведения

Конечно, если вам нужно настроить поведение протокола MQTT на стороне облака, следует ознакомиться с [шлюзом протокола Интернета вещей Azure](iot-hub-protocol-gateway.md). Это программное обеспечение позволяет развернуть шлюз протокола с высокой производительностью, который взаимодействует непосредственно с Центром Интернета вещей. Шлюз протокола Azure IoT позволяет настроить протокол устройства для уже существующих развертываний MQTT или других настраиваемых протоколов. Однако при этом подходе необходимо запустить настраиваемый шлюз протокола и управлять им.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о протоколе MQTT см. в [документации по MQTT](https://mqtt.org/documentation).

Дополнительные сведения о планировании развертывания Центра Интернета вещей см. в следующих руководствах:

* [Каталог устройств, сертифицированных по программе Azure Certified for IoT](https://catalog.azureiotsolutions.com/)
* [Поддержка дополнительных протоколов](iot-hub-protocol-gateway.md)
* [Сравнение с концентраторами событий](iot-hub-compare-event-hubs.md)
* [Масштабирование, высокая доступность и аварийное восстановление](iot-hub-scaling.md)

Для дальнейшего изучения возможностей Центра Интернета вещей см. следующие статьи:

* [Руководство разработчика для Центра Интернета вещей](iot-hub-devguide.md)
* [Краткое руководство. Развертывание первого модуля IoT Edge на устройстве под управлением 64-разрядной ОС Linux](../iot-edge/tutorial-simulate-device-linux.md)
