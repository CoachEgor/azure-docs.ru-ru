---
title: Защитите серверную часть SPA с помощью OAuth 2,0, используя Azure Active Directory B2C и управление API Azure.
description: Защитите API с помощью OAuth 2,0, используя Azure Active Directory B2C, управление API Azure и простую проверку подлинности для вызова из JavaScript SPA.
services: api-management, azure-ad-b2c, app-service
documentationcenter: ''
author: WillEastbury
manager: alberts
editor: ''
ms.service: api-management
ms.workload: mobile
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 02/20/2020
ms.author: wieastbu
ms.custom: fasttrack-new
ms.openlocfilehash: ae776fc3fb1f9eb4b7fa9747f2769dcccb25e042
ms.sourcegitcommit: 05a650752e9346b9836fe3ba275181369bd94cf0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79136352"
---
# <a name="protect-spa-backend-with-oauth-20-azure-active-directory-b2c-and-azure-api-management"></a>Защита серверной части SPA с помощью OAuth 2,0, Azure Active Directory B2C и Azure API Management

В этом сценарии показано, как настроить экземпляр службы управления API Azure для защиты API.
Мы будем использовать протокол OAuth 2,0 с Azure AD B2C, наряду с управлением API для защиты серверной части функций Azure с помощью Еасяус.

## <a name="aims"></a>Предназначен
Мы посмотрим, как служба управления API может использоваться в упрощенном сценарии с функциями и Azure AD B2C Azure. Вы создадите приложение JavaScript (JS), вызывающее API-интерфейс, который будет подписывать пользователей с Azure AD B2C. Затем вы будете использовать функции политики Validate-JWT службы управления API для защиты серверного API.

Для глубокой защиты мы используем Еасяус для повторной проверки маркера внутри API серверной части.

## <a name="prerequisites"></a>предварительные требования
Чтобы выполнить шаги в этой статье, необходимо иметь следующее:
* Учетная запись хранения Azure (StorageV2) общего назначения v2 для размещения одностраничного приложения с одним внешним интерфейсом
* Экземпляр службы управления API Azure 
* Пустое приложение-функция Azure (выполняющее среду выполнения версии 2 .NET Core в плане потребления Windows) для размещения вызванного API
* Клиент Azure AD B2C, связанный с подпиской. 

Хотя на практике вы бы использовали ресурсы в одном регионе в производственных рабочих нагрузках, в этом практическом руководстве Развертывание области развертывания не имеет значения.

## <a name="overview"></a>Обзор
Ниже приведена иллюстрация используемых компонентов и последовательность между ними после завершения процесса.
![Используемые компоненты и последовательность](../api-management/media/howto-protect-backend-frontend-azure-ad-b2c/image-arch.png "Используемые компоненты и последовательность")

Ниже приведен краткий обзор шагов.

1. Создание Azure AD B2C вызова (интерфейсного интерфейса, управления API) и приложений API с областями и предоставление доступа через API
1. Создайте политики регистрации или входа, чтобы разрешить пользователям выполнять вход с помощью Azure AD B2C 
1. Настройка управления API с помощью новых идентификаторов и ключей клиента Azure AD B2C для включения авторизации пользователей OAuth2 в консоли разработчика
1. Создание API функции
1. Настройте API функции, чтобы включить Еасяус с новым ИДЕНТИФИКАТОРом и ключами клиента Azure AD B2C и заблокировать для APIM VIP. 
1. Создание определения API в управлении API
1. Настройка Oauth2 для конфигурации API управления API
1. Настройте политику **CORS** и добавьте политику **Validate-JWT** , чтобы проверить маркер OAuth для каждого входящего запроса.
1. Создание вызывающего приложения для использования API
1. Отправка примера с помощью JS SPA
1. Настройка клиентского приложения Sample JS с помощью нового идентификатора клиента Azure AD B2C и ключей 
1. Тестирование клиентского приложения

## <a name="configure-azure-ad-b2c"></a>Настройка Azure AD B2C 
Откройте колонку Azure AD B2C на портале и выполните следующие действия.
1. Выберите вкладку **приложения** . 
1. Нажмите кнопку "Добавить" и создайте три приложения для следующих целей.
   * Интерфейсный клиент.
   * API серверной функции.
   * Используемых Портал разработчика управления API (если вы не используете службу управления API Azure на уровне потребления, дополнительные сведения об этом сценарии см. ниже).
1. Задайте WebApp/Web API для всех 3 приложений и задайте для параметра "разрешить неявный поток" значение "Да" только для внешнего клиента.
1. Теперь задайте URI идентификатора приложения, выберите уникальное значение и соответствующее создаваемой службе.
1. Используйте заполнители для URL-адресов ответов, например https://localhost, мы будем обновлять эти URL-адреса позже.
1. Нажмите кнопку "создать", а затем повторите шаги 2-5 для каждого из трех указанных выше приложений, записав URI AppID, имя и идентификатор приложения для последующего использования для всех трех приложений.
1. Откройте приложение портала разработчика для управления API из списка приложений и выберите вкладку *ключи* (в разделе Общие) и нажмите кнопку "создать ключ", чтобы создать ключ проверки подлинности.
1. После нажатия кнопки сохранить запишите ключ в безопасном месте для дальнейшего использования. Обратите внимание, что это единственный шанс просмотреть и скопировать этот ключ.
1. Теперь перейдите на вкладку *опубликованные области* (в разделе доступ к API).
1. Создайте и назовите область для API функции и запишите область и заполненное полное значение области, а затем нажмите кнопку "Сохранить".
   > [!NOTE]
   > Области Azure AD B2C являются фактическими разрешениями в API, которые другие приложения могут запрашивать доступ к через колонку доступа API из своих приложений, фактически вы только что создали разрешения приложения для вызванного API.
1. Откройте два других приложения и перейдите на вкладку *доступ через API* .
1. Предоставьте им доступ к области API внутреннего сервера и по умолчанию, который уже присутствует в нем ("доступ к профилю пользователя").
1. Создайте ключ для каждой из них, выбрав вкладку *ключи* в разделе "Общие", чтобы создать ключ проверки подлинности и записать эти ключи в безопасном месте.

## <a name="create-a-sign-up-or-sign-in-user-flow"></a>Создание потока пользователя "регистрация или вход"
1. Вернуться к корню (или "Обзор") колонки Azure AD B2C 
1. Затем выберите "Маршруты пользователей (политики)" и щелкните "новый поток пользователей".
1. Выберите тип потока пользователя "регистрация и вход"
1. Присвойте политике имя и запишите ее для последующего использования.
1. Затем в разделе "поставщики удостоверений" установите флажок "Регистрация идентификатора пользователя" (это может быть "регистрация по электронной почте") и нажмите кнопку "ОК". 
1. В разделе "атрибуты и утверждения пользователей" щелкните "Дополнительно...". затем выберите параметры утверждения, которые пользователи должны ввести и вернуть в маркер. Проверьте по меньшей мере "отображаемое имя" и "адрес электронной почты" для получения и возврата, а затем нажмите кнопку "ОК", а затем кнопку "создать".
1. Выберите политику, созданную в списке, а затем нажмите кнопку "запустить поток пользователя".
1. В этом действии откроется колонка запуск пользователя, выберите внешнее приложение, а затем запишите адрес домена b2clogin.com, который отображается в раскрывающемся списке в поле "Выбор домена".
1. Щелкните ссылку вверху, чтобы открыть конечную точку конфигурации "хорошо известная OpenID Connect", и запишите значения authorization_endpoint и token_endpoint, а также значение самой ссылки как хорошо известную конечную точку конфигурации OpenID Connect.

   > [!NOTE]
   > Политики B2C позволяют предоставлять конечные точки входа в Azure AD B2C, чтобы иметь возможность записывать различные компоненты данных и выполнять вход пользователей различными способами. В этом случае мы настроили конечную точку регистрации или входа, которая предоставляла хорошо известную конечную точку конфигурации, в частности, наша созданная политика была определена в URL-адресе параметром p =.
   > 
   > Как только это будет сделано, вы получите функциональную платформу бизнес-клиентов, которая будет подписывать пользователей в нескольких приложениях. 
   > Если вы хотите, можно щелкнуть здесь кнопку "запустить поток пользователя" (чтобы пройти процедуру регистрации или входа) и приступить к выполнению действий на практике, но шаг перенаправления завершается ошибкой, так как приложение еще не развернуто.

## <a name="build-the-function-api"></a>Создание API функции
1. Вернитесь к стандартному клиенту Azure AD в портал Azure, чтобы мы могли еще раз настроить элементы в подписке. 
1. Перейдите в колонку "приложения-функции" портал Azure откройте пустое приложение-функцию, а затем создайте новую функцию в своем портале.
1. Вставьте пример кода из приведенного ниже в Run. CSX поверх существующего кода, который отображается.

   ```csharp
   
   using System.Net;
   using Microsoft.AspNetCore.Mvc;
   using Microsoft.Extensions.Primitives;
   
   public static async Task<IActionResult> Run(HttpRequest req, ILogger log)
   {
      log.LogInformation("C# HTTP trigger function processed a request.");
      
      return (ActionResult)new OkObjectResult($"Hello World, time and date are {DateTime.Now.ToString()}");
   }
   
   ```

   > [!NOTE]
   > Только что вставленный код функции сценария c# просто записывает строку в журналы функций и возвращает текст "Hello World" с некоторыми динамическими данными (датой и временем).

3. Выберите "интегрировать" в левой колонке, а затем выберите "Расширенный редактор" в правом верхнем углу панели.
4. Вставьте пример кода ниже существующего JSON.

   ```json
   {
      "bindings": [
       {
        "authLevel": "function",
        "name": "req",
        "type": "httpTrigger",
        "direction": "in",
        "methods": [
           "get"
        ],
        "route": "hello"
       },
       {
         "name": "$return",
         "type": "http",
         "direction": "out"
       }
     ]
   }
   ```

5. Вернитесь на вкладку HttpTrigger1, нажмите кнопку "получить URL-адрес функции", а затем скопируйте отображаемый URL-адрес.

   > [!NOTE]
   > Только что созданные привязки просто указывают функциям реагировать на анонимные HTTP-запросы GET на только что скопированный URL. (https://yourfunctionappname.azurewebsites.net/api/hello?code=secretkey) теперь у нас есть масштабируемый серверный API HTTPS, который способен возвращать очень простые полезные данные.
   > Теперь можно проверить вызов этого API из веб-браузера, используя приведенный выше URL-адрес. можно также удалить часть? Code = секрет URL-адреса и доказать, что функции Azure будут возвращать ошибку 401.

## <a name="configure-and-secure-the-function-api"></a>Настройка и защита API-интерфейса функции
1. Необходимо настроить две дополнительные области в приложении-функции (ограничения проверки подлинности и сети).
1. Сначала давайте настроим проверку подлинности и авторизацию, поэтому щелкните имя приложения-функции (рядом с значком &lt;Z&gt; функции), чтобы отобразить страницу обзора.
1. Затем выберите вкладку "компоненты платформы" и щелкните "Проверка подлинности/авторизация".
1. Включите функцию проверки подлинности службы приложений.
1. В разделе "поставщики проверки подлинности" выберите "Azure Active Directory" и выберите "Дополнительно" в параметре режима управления.
1. Вставьте идентификатор приложения API серверной функции (из Azure AD B2C в поле "идентификатор клиента").
1. Вставьте известную конечную точку конфигурации Open-ID из политики регистрации или входа в поле URL-адрес издателя (ранее мы записали эту конфигурацию).
1. Нажмите кнопку "ОК".
1. Задайте действие, которое будет выполняться, когда запрос не прошел проверку подлинности, чтобы "войти с помощью Azure Active Directory", а затем нажмите кнопку Сохранить.

   > [!NOTE]
   > Теперь API-интерфейс функции развернут и должен вызывать 401 ответов, если правильный ключ не предоставлен, и должен возвращать данные при появлении допустимого запроса.
   > Вы добавили дополнительную защиту на уровне глубокой защиты в Еасяус, настроив параметр "Login with Azure AD" для обработки запросов без проверки подлинности. Имейте в виду, что это изменит поведение неавторизованного запроса между серверной частью приложение-функция и сервером SPA, так как Еасяус будет выдавать перенаправление 302 в AAD вместо ответа 401, не поддерживающего проверку подлинности, мы исправим это с помощью службы управления API позже.
   > Мы по-прежнему не установили безопасность IP, если у вас есть допустимый ключ и маркер OAuth2, любой пользователь может вызвать его из любого места. в идеале мы хотим принудительно выполнять все запросы через Управление API.
   > Если вы используете уровень потребления для управления API, вы не сможете выполнить блокировку с помощью виртуального IP-адреса, так как для этого уровня нет выделенного статического IP, необходимо полагаться на метод блокировки вызовов API через общий секретный ключ функции. , поэтому шаги 11-13 будут невозможны.

1. Закройте колонку "Проверка подлинности и авторизация" 
1. Выберите "сеть" и щелкните "ограничения доступа".
1. Затем заблокируйте разрешенные IP-адреса приложения-функции для виртуального IP-адреса экземпляра управления API. Этот виртуальный IP-адрес показан в разделе "Управление API — Обзор" портала.
1. Если вы хотите продолжить взаимодействие с порталом функций и выполнить дополнительные действия, приведенные ниже, следует также добавить собственный общедоступный IP-адрес или диапазон CIDR.
1. Если в списке есть запись Allow, Azure добавит неявное запрещающее правило для блокировки всех остальных адресов. 

Вам потребуется добавить отформатированные блоки CIDR на панель ограничения IP-адресов. Если вам нужно добавить один адрес, например, в качестве виртуального IP-адреса управления API, необходимо добавить его в формате XX. XX. XX. XX.

   > [!NOTE]
   > Теперь API-интерфейс функции не следует вызывать из любого места, отличного от управления через Управление API, или вашего адреса.
   
## <a name="import-the-function-app-definition"></a>Импорт определения приложения функции
1. Откройте *колонку управления API*, а затем откройте *свой экземпляр*.
1. Выберите колонку API из раздела управления API своего экземпляра.
1. В области "добавить новый API" выберите "приложение-функция", а затем в верхней части всплывающего окна выберите "полная".
1. Нажмите кнопку Обзор, выберите приложение-функцию, в котором вы размещаете API, и нажмите кнопку Выбрать.
1. Присвойте API имя и описание для внутреннего использования управления API и добавьте его в продукт "неограниченный".
1. Обязательно запишите базовый URL-адрес для последующего использования, а затем нажмите кнопку Создать.

## <a name="configure-oauth2-for-api-management"></a>Настройка Oauth2 для управления API

1. Затем выберите колонку OAuth 2,0 на вкладке Безопасность и нажмите кнопку Добавить.
1. Укажите значения для *отображаемого имени* и *описания* для добавленной конечной точки OAuth (эти значения будут отображаться на следующем шаге в качестве конечной точки Oauth2).
1. Можно ввести любое значение в URL-адрес страницы регистрации клиента, так как это значение не будет использоваться.
1. Проверьте тип предоставления *неявной проверки подлинности* и оставьте установленным тип предоставления кода авторизации.
1. Перейдите в поля конечная точка *авторизации* и *маркера* и введите значения, полученные ранее в XML-документе с известными настройками.
1. Прокрутите вниз и заполните *дополнительный параметр Body* с именем Resource и идентификатором клиента API серверной функции из Azure AD B2C регистрации приложения.
1. Выберите "учетные данные клиента", задайте идентификатор клиента для приложения консоли разработчика. пропустите этот шаг при использовании модели управления API потребления.
1. Установите секрет клиента на записанный ранее ключ. пропустите этот шаг при использовании модели управления API потребления.
1. Наконец, Теперь запишите redirect_uri предоставления кода проверки подлинности из управления API для последующего использования.

## <a name="set-up-oauth2-for-your-api"></a>Настройка Oauth2 для API
1. Ваш API появится в левой части портала в разделе "все API". Откройте API, щелкнув его.
1. Перейдите на вкладку "Параметры".
1. Обновите параметры, выбрав "OAuth 2,0" в подменю "Авторизация пользователя".
1. Выберите сервер OAuth, который вы определили ранее.
1. Установите флажок "область переопределения" и введите область, записанную для вызова API серверной части ранее в.

   > [!NOTE]
   > Теперь у нас есть экземпляр управления API, который знает, как получить маркеры доступа из Azure AD B2C для авторизации запросов и распознает нашу конфигурацию Oauth2 Azure Active Directory B2C.

## <a name="set-up-the-cors-and-validate-jwt-policies"></a>Настройка политик **CORS** и **Validate-JWT**

> Следующие разделы должны следовать вне зависимости от используемого уровня APIM. 

1. Вернитесь на вкладку Конструирование и выберите "все API", а затем нажмите кнопку представление кода, чтобы открыть редактор политик.
1. Измените раздел Inbound и вставьте приведенный ниже XML-код, чтобы он выглядел следующим образом.

   ```xml
   <inbound>
      <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid.">
         <openid-config url="https://tenant.b2clogin.com/tenant.onmicrosoft.com/v2.0/.well-known/openid-configuration?p=B2C_1_MyDefaultPolicy" />
         <required-claims>
            <claim name="aud">
               <value>your-backend-api-application-client-id</value>
            </claim>
         </required-claims>
      </validate-jwt>
      <cors>
         <allowed-origins>
            <origin>*</origin>
         </allowed-origins>
         <allowed-methods>
           <method>GET</method>
         </allowed-methods>
         <allowed-headers>
            <header>*</header>
         </allowed-headers>
         <expose-headers>
           <header>*</header>
         </expose-headers>
       </cors>
   </inbound>
   ```
1. Измените URL-адрес OpenID Connect-config так, чтобы он совпадал с известной конечной точкой Azure AD B2C для политики регистрации или входа.
1. Измените значение утверждения, чтобы оно соответствовало действительному ИДЕНТИФИКАТОРу приложения, также известному как идентификатор клиента для приложения API серверной части, и сохраните.

   > [!NOTE]
   > Теперь управление API может отвечать на запросы между источниками к приложениям с помощью JS-приложений, и оно выполняет регулирование, ограничение скорости и предварительную проверку маркера проверки подлинности JWT перед перенаправлением запроса API-интерфейсу функции.

   > [!NOTE]
   > Следующий раздел является необязательным и не применяется к уровню **потребления** , который не поддерживает портал разработчика.
   > Если вы не планируете использовать портал разработчика или не можете использовать его, так как вы используете уровень потребления, пропустите этот шаг и сразу переходите к [разделу "Построение JavaScript SPA для использования API"](#build-the-javascript-spa-to-consume-the-api).

## <a name="optional-configure-the-developer-portal"></a>Используемых Настройка портала разработчика

1. Откройте колонку Azure AD B2C и перейдите к разделу Регистрация приложения для портала разработчика.
1. Задайте для записи "URL-адрес ответа" тот, который вы задали при настройке redirect_uri предоставления кода проверки подлинности в управлении API ранее.

   Теперь, когда авторизация пользователя OAuth 2,0 включена на `Echo API`, консоль разработчика получает маркер доступа для пользователя перед вызовом API.

1. Перейдите к любой операции в `Echo API` на портале разработчика и выберите команду **попробовать** , чтобы открыть консоль разработчика.
1. Обратите внимание на новый элемент в разделе **Авторизация**, соответствующий только что добавленному серверу авторизации.
1. В раскрывающемся списке Авторизация выберите **код авторизации** , и вам будет предложено войти в клиент Azure AD. Если вы уже вошли в учетную запись, возможно, вам не будет предложено.
1. После успешного входа в запрос к запросу добавляется заголовок `Authorization: Bearer` с маркером доступа Azure AD B2C, закодированный в Base64. 
1. Выберите **Отправить** , и вы можете успешно вызвать API.

   > [!NOTE]
   > Теперь управление API может получить маркеры для портала разработчика, чтобы протестировать API и понять его определение и отобразить соответствующую тестовую страницу на портале разработки.

1. В колонке "Обзор" портала управления API щелкните "портал разработчика", чтобы войти в систему от имени администратора API.
1. Здесь вы и другие выбранные потребители вашего API могут тестировать и вызывать их из консоли.
1. Выберите "продукты", затем выберите "без ограничений", затем выберите API, который мы создали ранее, и щелкните "попробовать".
1. Расскройте ключ подписки API и скопируйте его в безопасном месте вместе с URL-адресом запроса, который потребуется позже.
1. Кроме того, выберите в раскрывающемся списке Проверка подлинности OAuth значение неявное, и вам может потребоваться выполнить аутентификацию с помощью всплывающего окна.
1. Нажмите кнопку "Отправить", и если все хорошо, приложение-функция должен ответить на сообщение Hello через службу управления API с сообщением 200 ОК и некоторым JSON.

   > [!NOTE]
   > Поздравляем! теперь у вас есть Azure AD B2C, управление API и функции Azure, которые работают вместе для публикации, защиты и использования API. Возможно, вы заметили, что API на самом деле защищен дважды с помощью этого метода, один раз с заголовком API управления OCP-Subscription и Key, а также один раз для авторизации: Bearer JWT.
   > Вы должны быть правильными, так как этот пример является одностраничным приложением JavaScript, мы используем ключ управления API только для вызовов с ограничением частоты и выставления счетов.
   > Фактическая авторизация и проверка подлинности обрабатываются Azure AD B2C и инкапсулируются в JWT, который проверяется дважды, по управлению API, а затем по функциям Azure.

## <a name="build-the-javascript-spa-to-consume-the-api"></a>Создание JavaScript SPA для использования API
1. Откройте колонку учетные записи хранения в портал Azure 
1. Выберите созданную учетную запись и откройте колонку "статический веб-сайт" в разделе "Параметры" (если вы не видите параметр "статический веб-сайт", проверьте, создана ли учетная запись версии 2).
1. Задайте для компонента статического веб-размещения значение "включено" и задайте для индекса имя документа значение "index. HTML", а затем нажмите кнопку "Сохранить".
1. Запишите содержимое основной конечной точки, так как это расположение, где будет размещаться интерфейсный сайт. 

   > [!NOTE]
   > Вы можете использовать хранилище BLOB-объектов Azure + перезапись CDN, а функция размещения статических веб-сайтов в хранилище больших двоичных объектов предоставляет нам контейнер по умолчанию для обслуживания статического веб-содержимого, HTML/JS и CSS в службе хранилища Azure и будет выдавать для нас страницу по умолчанию для нулевой работы.

## <a name="upload-the-js-spa-sample"></a>Отправка примера с помощью JS SPA
1. В колонке учетной записи хранения выберите колонку BLOB-объектов в разделе Служба BLOB-объектов и щелкните контейнер $web, который отображается на правой панели.
1. Сохраните приведенный ниже код в файле локально на компьютере в формате index. HTML, а затем отправьте файл index. HTML в контейнер $web.

   ```html
   <!doctype html>
   <html lang="en">
   <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Sample JS SPA</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
   </head>
   <body>
        <div class="container-fluid">
            <div class="row">
                <div class="col-md-12">
                    <nav class="navbar navbar-expand-lg navbar-light bg-light navbar-dark bg-dark">
                        <a class="navbar-brand" href="#">Sample Code</a>
                        <ul class="navbar-nav ml-md-auto">
                            <li class="nav-item dropdown">
                                <a class="btn btn-large btn-success" onClick="login()">Sign In</a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <div class="jumbotron">
                        <h2>
                    <div id="message">Hello, world!</div>
                    </h2>
                        <p>
                            <a class="btn btn-primary btn-large" onClick="GetAPIData()">Call API</a>
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
        <script src="https://secure.aadcdn.microsoftonline-p.com/lib/1.0.0/js/msal.js"></script>
        <script lang="javascript">
            var applicationConfig = {
                clientID: "clientidgoeshere",
                authority: "https://tenant.b2clogin.com/tfp/tenant/policy",
                b2cScopes: ["https://tenant/app/scope"],
                webApi: 'http://functionurl',
                subKey: 'apimkeygoeshere'
            };
            var msalConfig = {
                auth: {
                        clientId: applicationConfig.clientID, 
                        authority:  applicationConfig.authority,
                        validateAuthority: false
                },
                cache: {
                        cacheLocation: "localStorage",
                        storeAuthStateInCookie: true
                }
            };
            var clientApplication = new Msal.UserAgentApplication(msalConfig);
            function login() {
                var loginRequest = {
                    scopes: applicationConfig.b2cScopes
                };
                clientApplication.loginPopup(loginRequest).then(function (loginResponse) {
                    var tokenRequest = {
                        scopes: applicationConfig.b2cScopes
                    };
                    clientApplication.acquireTokenSilent(tokenRequest).then(function (tokenResponse) {
                        document.getElementById("signinbtn").innerHTML = "Logged in as: " + clientApplication.account.name;
                        document.getElementById("callapibtn").hidden = false
                        }).catch(function (error) {
                            clientApplication.acquireTokenPopup(tokenRequest).then(function (tokenResponse) {
                                }).catch (function (error) {
                                    console.log("Error acquiring the popup:\n" + error);
                                });
                        })
                    }).catch (function (error) {
                        console.log("Error during login:\n" + error);
                });
            }
            function GetAPIData() {
                var tokenRequest = {
                    scopes: applicationConfig.b2cScopes
                }
                clientApplication.acquireTokenSilent(tokenRequest).then(function (tokenResponse) {
                    callApiWithAccessToken(tokenResponse.accessToken);
                    }).catch(function (error) {
                        clientApplication.acquireTokenPopup(tokenRequest).then(function (tokenResponse) {
                            callApiWithAccessToken(tokenResponse.accessToken);
                            
                        }).catch(function (error) {
                            console.log("Error acquiring the access token to call the Web api:\n" + error);
                        });
                    })
            }
            function callApiWithAccessToken(token)
            {
                console.log("calling "  + applicationConfig.webApi +  " with " + token);
                    // Make the api call here
                $.ajax({
                    type: "get",
                    headers: {'Authorization': 'Bearer ' + token, 'Ocp-Apim-Subscription-Key': applicationConfig.subKey},                   url: applicationConfig.webApi
                }
                ).done(function (body) {
                    document.getElementById("message").innerHTML = "The API Said " + body;
                });
            }
        </script>
    </body>
   </html>
   
   ```

1. Перейдите на основную конечную точку статического веб-сайта, сохраненную ранее в последнем разделе.

   > [!NOTE]
   > Поздравляем! вы только что развернули одностраничное приложение JavaScript в службе хранилища Azure, так как мы еще не настроили приложение JS с ключами для API или не настроили приложение JS с помощью сведений о Azure AD B2C, но страница не будет работать, если открыть ее.

## <a name="configure-the-js-spa-for-azure-ad-b2c"></a>Настройте параметр JS SPA для Azure AD B2C
1. Теперь мы понимаем, что все: мы можем настроить SPA с помощью соответствующего адреса API управления API и правильных Azure AD B2C идентификаторов приложения или клиента.
1. Вернитесь в колонку портал Azure хранилище и щелкните index. HTML, а затем выберите "изменить BLOB-объект". 
1. Обновите сведения о проверке подлинности, чтобы они соответствовали вашему интерфейсному приложению, зарегистрированному в B2C ранее, указывая, что значения "b2cScopes" предназначены для серверной части API.
1. Ключ webApi и URL-адрес API можно найти на панели тестирования управления API для операции API.
1. Создайте ключ подписки APIM по заголовку для управления API обратно в колонку управления API, выбрав "подписки", а затем щелкнув "добавить подписку", а затем сохранив запись. Нажатие многоточия (...) рядом с созданной строкой позволит отобразить ключи, чтобы можно было скопировать первичный ключ.
1. Он должен выглядеть примерно так:-  

   ```javascript
   var applicationConfig =
      clientID: "{aadb2c-clientid-goeshere}",
      authority: "https://{tenant}.b2clogin.com/{tenant}/{policy}",
      b2cScopes: ["https://{tenant}/{app}/{scope}"], 
      webApi: 'http://{apim-url-for-your-function}',
      subKey: '{apim-subscription-key-goes-here}'
   };
   ```

1. Щелкните Сохранить

## <a name="set-the-redirect-uris-for-the-azure-ad-b2c-frontend-app"></a>Задание URI перенаправления для многосерверного приложения Azure AD B2C
1. Откройте колонку Azure AD B2C и перейдите к регистрации приложения для внешнего приложения JavaScript.
1. Задайте URL-адрес перенаправления, указанный при настройке основной конечной точки статического веб-сайта выше.

   > [!NOTE] 
   > Эта конфигурация приведет к тому, что клиент внешнего приложения получит маркер доступа с соответствующими утверждениями от Azure AD B2C.
   > SPA сможет добавить это как токен носителя в заголовок HTTPS в вызове API серверной части.
   > Перед передачей запроса на получение API-интерфейса функции Azure служба управления API предварительно проверяет вызовы маркера, предельный размер в конечную точку с помощью ключа подписчика.
   > SPA будет отображать ответ в браузере.

   > *Поздравляем! вы настроили Azure AD B2C, управление API Azure, функции Azure, авторизация службы приложений Azure для оптимального решения.*

   > [!NOTE]
   > Теперь у нас есть простое приложение с простым защищенным API, протестировать его.

## <a name="test-the-client-application"></a>Тестирование клиентского приложения
1. Откройте пример URL-адреса приложения, который вы заговорили в созданной ранее учетной записи хранения.
1. Нажмите кнопку "войти" в правом верхнем углу, чтобы открыть Azure AD B2C профиль регистрации или входа.
1. Подпись POST в разделе "вход как" на экране будет заполнена с помощью JWT.
1. Теперь нажмите кнопку "вызвать веб-API", и на странице необходимо обновить значения, отправленные из защищенного API.

## <a name="and-were-done"></a>И все готово
Описанные выше действия можно адаптировать и изменить, чтобы обеспечить множество различных применений Azure AD B2C с помощью управления API.

## <a name="next-steps"></a>Дальнейшие действия
* Узнайте больше об [Azure Active Directory и OAuth 2.0](../active-directory/develop/authentication-scenarios.md).
* См. другие [видео](https://azure.microsoft.com/documentation/videos/index/?services=api-management) об управлении API.
* Другие способы защиты внутренней серверной службы см. в разделе [Взаимная проверка подлинности на основе сертификата](api-management-howto-mutual-certificates.md).
* Рассмотрите возможность использования API Graph Azure AD для назначения настраиваемых утверждений и использования политики управления API для проверки их наличия в токене.

* [Создание экземпляра службы управления API Azure](get-started-create-service-instance.md)

* [Импорт и публикация первого API](import-and-publish.md)
