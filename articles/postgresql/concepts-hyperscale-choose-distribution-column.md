---
title: Выберите столбцы дистрибутива - Hyperscale (Citus) - База данных Azure для PostgreS'L
description: Узнайте, как выбрать столбцы дистрибутива в общих гипермасштабных сценариях в базе данных Azure для PostgreS'L.
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: 8ced9767d81affceef851820ee587f4f3dd24deb
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74975675"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>Выберите столбцы дистрибутива в базе данных Azure для PostgreS-L - Hyperscale (Citus)

Выбор столбца распределения каждой таблицы является одним из наиболее важных решений по моделированию, которые вы будете принимать. База данных Azure для PostgreS'L - Hyperscale (Citus) хранит строки в осколки в зависимости от значения столбца распределения строк.

Правильный выбор группирует данные вместе на одних и тех же физических узлах, что делает запросы быстрыми и добавляет поддержку для всех функций S'L. Неправильный выбор делает систему работать медленно и не будет поддерживать все функции S'L в узлах.

В этой статье приводятся советы по колонке распределения для двух наиболее распространенных сценариев Hyperscale (Citus).

### <a name="multi-tenant-apps"></a>Мультитенантные приложения

Архитектура мультитенантов использует форму моделирования иерархической базы данных для распределения запросов между узлами в группе серверов. Верхняя часть иерархии данных известна как *идентификатор клиента* и должна храниться в столбце на каждой таблице.

Hyperscale (Citus) проверяет запросы, чтобы узнать, какой идентификатор клиента они включают, и находит соответствующий осколок таблицы. Он направляет запрос в один рабочий узло, содержащее осколок. Запуск запроса со всеми соответствующими данными, размещенными на одном и том же узлах, называется colocation.

Следующая диаграмма иллюстрирует colocation в модели мультитенантных данных. Он содержит две таблицы, Счета `account_id`и кампании, каждая из которых распространяется по . Затененные коробки представляют собой осколки. Зеленые осколки хранятся вместе на одном рабочем узеле, а синие осколки хранятся на другом узеле. Обратите внимание, как запрос соединения между учетными записями и кампаниями имеет все необходимые данные вместе на одном узлах, когда обе таблицы ограничены одним и тем же идентификатором учетной записи.\_

![Мультитенантная колокация](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

Чтобы применить эту конструкцию в вашей собственной схеме, определите, что представляет собой арендатор в вашем приложении. Общие экземпляры включают компанию, учетную запись, организацию или клиента. Название столбца будет `company_id` что-то вроде или `customer_id`. Изучите каждый из ваших запросов и спросите себя, будет ли это работать, если бы он имел дополнительные положения ГДЕ, чтобы ограничить все таблицы, участвующие в строках с тем же идентификатором арендатора?
Запросы в мультитенантной модели относятся к арендатору. Например, запросы о продажах или запасах используются в определенном хранилище.

#### <a name="best-practices"></a>Рекомендации

-   **Раздел распределенные таблицы общим\_столбцом идентификатора клиента.** Например, в приложении SaaS, где арендаторы являются компаниями, идентификатор арендатора,\_скорее всего, будет идентификатором компании.\_
-   **Преобразуйте небольшие таблицы кросс-тенантов в справочные таблицы.** Когда несколько арендаторов разделяют небольшую таблицу информации, распространяйте ее в качестве справочной таблицы.
-   **Ограничьте фильтрацию всех\_запросов приложений по идентификатору клиента.** Каждый запрос должен запрашивать информацию для одного арендатора одновременно.

Ознакомьте [учебник для мультитенантов,](./tutorial-design-database-hyperscale-multi-tenant.md) например, как создать такого рода приложения.

### <a name="real-time-apps"></a>Приложения, работающие в режиме реального времени

Архитектура мультитенантов вводит иерархическую структуру и использует colocation данных для маршрутизатора запросов на одного клиента. Напротив, архитектуры в реальном времени зависят от конкретных свойств распределения данных для достижения высокой параллельной обработки.

Мы используем "идентификатор сущности" в качестве термина для столбцов распределения в модели реального времени. Типичными объектами являются пользователи, хосты или устройства.

Запросы в режиме реального времени обычно запрашиваются для числовых агрегатов, сгруппированных по дате или категории. Hyperscale (Citus) отправляет эти запросы каждому осколок для получения частичных результатов и собирает окончательный ответ на узло координатора. Запросы работают быстрее всего, когда как можно больше узлов вносят свой вклад, и когда ни один узла не должен выполнять непропорционально большое количество работы.

#### <a name="best-practices"></a>Рекомендации

-   **Выберите столбец с высокой кардинальностью в качестве столбца распределения.** Для сравнения, поле status на таблице заказов со значениями New, Paid и Shipped является плохим выбором столбца распределения. Он предполагает только те несколько значений, что ограничивает количество осколков, которые могут хранить данные, и количество узлов, которые могут обрабатывать его. Среди столбцов с высокой кардинальностью также хорошо выбирать те столбцы, которые часто используются в положениях группы или в качестве ключей соединения.
-   **Выберите столбец с равным распределением.** Если распределить таблицу на столбце, перекосе на определенные общие значения, данные в таблице, как правило, накапливаются в определенных осколках. Узлы, которые держат эти осколки в конечном итоге делать больше работы, чем другие узлы.
-   **Распределите таблицы фактов и измерений на их общих столбцах.**
    Ваша таблица фактов может иметь только один ключ распределения. Таблицы, которые соединяются на другом ключе, не будут расположены со таблицей фактов. Выберите одно измерение, чтобы свести сью на основе того, как часто он присоединяется и размер присоединения строк.
-   **Измените некоторые таблицы измерений в справочные таблицы.** Если таблица измерений не может быть совместина со таблицей фактов, можно улучшить производительность запроса, распространяя копии таблицы измерений на все узлы в виде справочной таблицы.

Ознакомьте [учебник в режиме реального времени](./tutorial-design-database-hyperscale-realtime.md) для примера того, как создать такого рода приложения.

### <a name="time-series-data"></a>Данные временных рядов

В рабочей нагрузке временных рядов приложения загоняют последние сведения, архивируя старую информацию.

Наиболее распространенной ошибкой в моделировании информации временных рядов в Hyperscale (Citus) является использование самой метки времени в качестве столбца распределения. Распределение хэша, основанное на времени, распределяет время, казалось бы, наугад, на разные осколки, вместо того, чтобы держать диапазоны времени вместе в осколки. Запросы, которые включают время, как правило, эталонные диапазоны времени, например, самые последние данные. Этот тип распределения хэша приводит к накладным сетям.

#### <a name="best-practices"></a>Рекомендации

-   **Не выбирайте метку времени в качестве столбца распределения.** Выберите другой столбец распределения. В приложении с несколькими тенантами используйте идентификатор клиента или в приложении в режиме реального времени используйте идентификатор сущности.
-   **Вместо этого используйте раздел таблицы PostgreS'L для времени.** Используйте раздел таблицы, чтобы разбить большую таблицу данных, заказанных временем, на несколько унаследованных таблиц с каждой таблицей, содержащей различные временные диапазоны. Распространение таблицы Postgres в Hyperscale (Citus) создает осколки для наследственных таблиц.

Прочитайте [учебник по расписанию](https://aka.ms/hyperscale-tutorial-timeseries) для примера того, как создать такого рода приложения.

## <a name="next-steps"></a>Дальнейшие действия
- Узнайте, как [colocation](concepts-hyperscale-colocation.md) между распределенными данными помогает быстро работать запросы.
