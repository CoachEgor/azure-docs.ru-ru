---
title: Жизненный цикл активации и деактивации Azure Service Fabric
description: Описание жизненного цикла приложения и ServicePackage на узле
author: tugup
ms.topic: conceptual
ms.date: 05/1/2020
ms.author: tugup
ms.openlocfilehash: b106061805ea5485893df292c40974d3ee9bcadb
ms.sourcegitcommit: dabd9eb9925308d3c2404c3957e5c921408089da
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2020
ms.locfileid: "86258824"
---
# <a name="azure-service-fabric-hosting-lifecycle"></a>Жизненный цикл размещения Service Fabric Azure
В этой статье приводятся общие сведения о событиях, происходящих при активации приложения на узле и различных конфигурациях кластера, используемых для управления поведением.

Прежде чем продолжить, убедитесь, что вы понимаете различные понятия и связи, описанные в статье [Моделирование приложения в структуре службы][a1]. 

> [!NOTE]
> Если явно не указано иное, в этой статье:
>
> - *Реплика* относится как к реплике службы с отслеживанием состояния, так и к экземпляру службы без отслеживания состояния.
> - *CodePackage* обрабатывается как эквивалент процесса *ServiceHost* , который регистрирует *serviceType*, и размещает реплики служб этого *serviceType*.
>

## <a name="activation-of-applicationservicepackage"></a>Активация приложения или ServicePackage

Конвейер для активации выглядит следующим образом:

1. Скачайте ApplicationPackage. Например: ApplicationManifest.xml и т. д.
2. Настройка среды для приложения, например создание пользователей и т. д.
3. Запуск отслеживания приложения для деактивации.
4. Скачайте ServicePackage. Например: ServiceManifest.xml, код, конфигурация, пакеты данных и т. д.
5. Настройте среду для пакета службы для ex: Настройка брандмауэра, выделение портов для конечных точек и т. д.
6. Запустите отслеживание ServicePackage для деактивации.
7. Запустите SetupEntryPoint содержащиеся и дождитесь завершения.
8. Запустите Маинентрипоинт из содержащиеся.

### <a name="servicetype-blocklisting"></a>ServiceType Добавление
**Сервицетипедисаблефаилуресрешолд** определяет количество сбоев (активаций, загрузки, CodePackageных сбоев), по истечении которых у serviceType будет запланировано добавление. Поэтому первый сбой активации или загрузки или CodePackage сбоя должен активировать расписание ServiceType добавление. Конфигурация **сервицетипедисаблеграцеинтервал** определяет интервал отсрочки, по истечении которого serviceType помечается как добавлен на этом узле. Обратите внимание, что для выполнения всех этих операций активация, Загрузка или перезагрузка CodePackage должны по-прежнему находиться в режиме повторной попытки внутри системы и контролироваться подсистемой размещения. Повторная попытка, например: CodePackage будет запланирована к повторному запуску после сбоя, или Service Fabric попытается загрузить пакеты снова.
После добавлен появится сообщение об ошибке "" System. Hosting ", о которой сообщила ошибка для свойства" ServiceTypeRegistration: ServiceType ". ServiceType отключен на узле. "

ServiceType будет включен обратно на узле 
- Если операция активации завершилась успешно или достигнет **активатионмаксфаилурекаунт** повторов после сбоя.
- Если операция скачивания завершилась успешно или достигнет **деплойментмаксфаилурекаунт** повторов после сбоя.
- Если CodePackage, на котором произошел сбой, начинает резервное копирование и успешно регистрирует ServiceType.

Причина включения serviceType снова после попыток **активатионмаксфаилурекаунт** / **деплойментмаксфаилурекаунт** — это максимальное число попыток, Service Fabric будет выполняться для активации или загрузки приложения на узле. Если это не удалось, то текущая операция не выполняется повторно, так как Service Fabric хочет предоставить службе другую возможность активации, которая может быть успешной, в результате чего проблема будет автоматически восстановлена, она привязывается к жизненному циклу операции активации и загрузки. Новая операция активации или загрузки, активируемая путем размещения реплики, может снова запустить ServiceType Добавление или выполнить ее.

> [!NOTE]
> Если CodePackage, не регистрирующий ServiceType, не повлияет на ServiceType. Только CodePackage, где происходит сбой реплики, повлияет на ServiceType.
>

### <a name="codepackage-crash"></a>Сбой CodePackage
В случае сбоя CodePackage Service Fabric использует отработку отказа для повторного запуска, а обратная отработка не зависит от того, зарегистрировал ли пакет кода тип с нами или нет.

Значение возврата всегда равно min (RetryTime, **активатионмаксретринтервал**), и это значение может быть константой, линейным или экспоненциальным, исходя из конфигурации **активатионретрибаккоффекспонентиатионбасе** .

- Константа: Если **активатионретрибаккоффекспонентиатионбасе** = = 0, то RetryTime = **активатионретрибаккоффинтервал**;
- Линейный: Если **активатионретрибаккоффекспонентиатионбасе** = = 0, то RetryTime = Континуаусфаилурекаунт * **Активатионретрибаккоффинтервал** , где ContinousFailureCount — число сбоев или неудачных попыток активации CodePackage.
- Экспонента: RetryTime = (**активатионретрибаккоффинтервал** в секундах) * (**активатионретрибаккоффекспонентиатионбасе** ^ континуаусфаилурекаунт);
    
Вы можете управлять поведением так же, как и быстрыми перезапусками. Давайте поговорим о линейном. Это означает, что если CodePackage завершается сбоем, интервал запуска будет после 10, 20, 30 40 секунд до деактивации CodePackage. 
    
Максимальное время, в течение которого Service Fabric отключается (ожидает) после того, как ошибка регулируется **активатионмаксретринтервал**
    
Если ваш CodePackage аварийно завершает работу и создает резервную копию, он должен остаться на **кодепаккажеконтинуаусекситфаилурересетинтервал** , чтобы Service Fabric считать его работоспособным, после чего он перезапишет отчет о работоспособности как OK и сбросит континаусфаилурекаунт.

### <a name="codepackage-not-registering-servicetype"></a>CodePackage не регистрирует ServiceType
Если CodePackage остается в активном состоянии и ожидается регистрация ServiceType с нами, но никогда не происходит, в этом случае Service Fabric создаст предупреждение HealthReport, когда **параметра servicetyperegistrationtimeout** говорит, что serviceType не настроен в течение времени ожидания.

### <a name="activation-failure"></a>Сбой активации
Service Fabric всегда использует линейную отработку отказа (то же, что и CodePackage сбой) при обнаружении ошибки во время активации. Это означает, что операция активации будет возобновлена после (от 0 + 10 + 20 + 30 + 40) = 100 сек (первая повторная попытка выполняется немедленно). После повторной попытки активации.
    
Максимальная задержка активации может быть **активатионмаксретринтервал** и повторите **активатионмаксфаилурекаунт**.

### <a name="download-failure"></a>Сбой скачивания
Service Fabric всегда использует линейную отрезку при возникновении ошибки во время загрузки. Это означает, что операция активации будет возобновлена после (от 0 + 10 + 20 + 30 + 40) = 100 сек (первая повторная попытка выполняется немедленно). После этого загрузка не будет повторена. Линейная отключающая выгрузка для загрузки равна Континуаусфаилурекаунт ***деплойментретрибаккоффинтервал** и может быть максимально возможной в **деплойментмаксретринтервал**. Как и активация, операция скачивания может повторить попытку для **активатионмаксфаилурекаунт**.

> [!NOTE]
> Перед изменением конфигураций необходимо учитывать несколько примеров.

* Если CodePackage поддерживает аварийное завершение работы и выполняет резервное копирование, ServiceType будет отключен. Но если в конфигурации активации есть быстрый перезапуск, CodePackage может быть несколько раз, прежде чем он сможет увидеть отключение ServiceType. Например, предположим, что у вас есть CodePackage, регистрирует ServiceType с Service Fabric, а затем завершается. В этом случае, когда размещение получает регистрацию типа, **сервицетипедисаблеграцеинтервал** период отменяется. И это может повторяться до тех пор, пока CodePackage не получит значение больше **сервицетипедисаблеграцеинтервал** , а затем на узле будет отключен serviceType. Это может быть во время до отключения ServiceType на узле.

* В случае активации, когда Service Fabric системе необходимо разместить реплику на узле, RA (Реконфигуратионажент) запрашивает размещение подсистемы для активации приложения и повторяет запрос на активацию каждые 15 секунд (**рапмессажеретринтервал**). Чтобы Service Fabric система определила, что ServiceType отключен, операция активации в размещении должна находиться в течение более длительного периода, чем интервал повтора и **сервицетипедисаблеграцеинтервал**. Например, пусть для кластера в качестве конфигурации **активатионмаксфаилурекаунт** задано значение 5, а **активатионретрибаккоффинтервал** — значение 1 с. Это означает, что операция активации будет возобновлена после (0 + 1 + 2 + 3 + 4) = 10 с (первая повторная попытка выполняется немедленно) и после этого размещения получится повторить попытку. В этом случае операция активации завершится и не будет повторена через 15 секунд. Это произошло из-за того, что Service Fabric исчерпаны все повторные попытки в течение 15 секунд. Таким образом, при каждой повторной попытке из Реконфигуратионажент создается новая операция активации в подсистеме размещения, и шаблон продолжает повторяться, а ServiceType никогда не будет отключен на узле. Так как ServiceType не будет отключен в компоненте FM системы узла SF (FailoverManager), реплика не будет перемещена на другой узел.
> 

## <a name="deactivation"></a>Деактивация

При активации ServicePackage на узле он будет отслеживанием для деактивации. Активатор — это сущность, которая отслеживает ее.
Деактиватор работает двумя способами:

1.  Периодически: при каждом **деактиватионсканинтервал**проверяется наличие сервицепаккажес, которая никогда не размещает реплику и помечает их как кандидаты для деактивации.
2.  Репликаклосе: Если реплика закрыта, то деактиватор получает Декрементусажекаунт. Если счетчик переходит к 0, то есть ServicePackage не размещает ни одной реплики и, следовательно, является кандидатом на деактивацию.

 В зависимости от режима активации " [монопольный"/"общий][a2]" кандидаты на деактивацию планируются после **деактиватионграцеинтервал** для Шаредмоде/ **ексклусивемодедеактиватионграцеинтервал** для ексклусивемоде. Если в этот раз в то время, когда происходит новое размещение реплики, деактивация отменяется.

### <a name="periodically"></a>Проверяет
Пример 1. Предположим, что активатор выполняет сканирование в момент времени T (**деактиватионсканинтервал**). Следующая проверка будет по адресу 2T. Предположим, что активация ServicePackage была выполнена в T + 1. В этом ServicePackage не размещена реплика, поэтому ее необходимо деактивировать. Чтобы ServicePackage быть кандидатом на деактивацию, он должен находиться в состоянии нет реплики в течение крайнего времени T. Это означает, что он будет иметь право деактивации в 2T + 1. Таким образом, проверка в 2T не найдет этот ServicePackage в качестве кандидата для деактивации. Следующий цикл деактивации 3T запланирует эту ServicePackage для деактивации, так как теперь она не находится в состоянии реплики для времени T.  

Пример 2. Предположим, что ServicePackage активируется во время T-1, а деактиватор выполняет сканирование в T. В ServicePackage не размещена реплика. Затем при следующем сканировании 2T этот ServicePackage будет найден как кандидат на деактивацию и, следовательно, будет запланирован на деактивацию.  

Пример 3. Предположим, что ServicePackage активируется в T – 1, а деактиватор выполняет сканирование в T. В ServicePackage еще не размещена реплика. Теперь в T + 1 размещена реплика, т. е. Размещение получает Инкрементусажекаунт, что означает создание реплики. Теперь на 2T этой ServicePackage не будет запланирована деактивация. Теперь деактивация будет перенесена в логику Репликаклосе, описанную ниже.

Пример 4. Предположим, что ваш ServicePackage большой, например 10 ГБ, Загрузка на узел может занять некоторое время. После активации приложения деактиватор отслеживает его жизненный цикл. Теперь, если у вас небольшая конфигурация **деактиватионсканинтервал** , вы можете столкнуться с проблемами, когда ServicePackage не получает время на активацию на узле, так как все время прошло для загрузки. Чтобы преодолеть проблему, можно [предварительно скачать ServicePackage на узле][p1]. 

> [!NOTE]
> Поэтому ServicePackage может быть деактивирован в любом месте между (**деактиватионсканинтервал** и 2 ***деактиватионсканинтервал**) + **деактиватионграцеинтервал** / **ексклусивемодедеактиватионграцеинтервал**. 
>

### <a name="replica-close"></a>Закрытие реплики:
Деактиватор сохраняет количество реплик, которые содержит ServicePackage. Если ServicePackage владеет репликой, а реплика закрыта или отключена, размещение получает Декрементусажекаунт. При открытии реплики размещение получает Инкрементусажекаунт. Уменьшение означает, что в ServicePackage теперь размещается не менее одной реплики, а число сбрасывается в 0, то ServicePackage планирует деактивацию, а время, после которого оно будет деактивировано, будет **деактиватионграцеинтервал** / **ексклусивемодедеактиватионграцеинтервал**. 

Например, предположим, что уменьшение происходит в T, и ServicePackage планируется деактивировать в 2T + X (**деактиватионграцеинтервал** / **ексклусивемодедеактиватионграцеинтервал**). Если во время размещения получается Инкрементусаже, означающее, что реплика создана, деактивация отменяется.

> [!NOTE]
>Итак, как именно эти настройки означают: **деактиватионграцеинтервал** / **ексклусивемодедеактиватионграцеинтервал**: время, заданное ServicePackage для повторного размещения другой реплики после размещения любой реплики. 
**Деактиватионсканинтервал**: минимальное время, заданное ServicePackage для размещения реплики, если она никогда не размещает реплику, т. е. Если не используется.
>

### <a name="ctrlc"></a>CTRL+C
Когда ServicePackage передает **деактиватионграцеинтервал** / **ексклусивемодедеактиватионграцеинтервал** и все еще не размещает реплику, деактивация не может быть отменена. CodePackage выдают обработчик CTRL + C, который означает, что теперь конвейер деактивации должен пройти, чтобы обработать процесс. В течение этого времени, если новая реплика для одного и того же ServicePackageа пытается разместить ее, произойдет сбой, так как не удается перейти от деактивации к активации.

## <a name="cluster-configs"></a>Конфигурации кластера

Конфигурации со значением по умолчанию, влияющим на активацию или декативатион.

### <a name="servicetype"></a>ServiceType
**Сервицетипедисаблефаилуресрешолд**: по умолчанию 1. Пороговое значение счетчика сбоев, после которого FM (FailoverManager) получает уведомления об отключении типа службы на этом узле и попытке размещения другого узла.
**Сервицетипедисаблеграцеинтервал**: по умолчанию 30 сек. интервал времени, по истечении которого можно отключить тип службы.
**Параметра servicetyperegistrationtimeout**: по умолчанию 300 с. Время ожидания регистрации ServiceType в Service Fabric.

### <a name="activation"></a>Активация
**Активатионретрибаккоффинтервал**: по умолчанию 10 с. интервал перезадержки при каждой ошибке активации.
**Активатионмаксфаилурекаунт**: по умолчанию 20. Максимальное число, для которого система повторит попытку повторной активации, прежде чем приступать к выполнению. 
**Активатионретрибаккоффекспонентиатионбасе**: по умолчанию 1,5.
**Активатионмаксретринтервал**: по умолчанию 3600 сек. Max-Off для активации при сбоях.
**Кодепаккажеконтинуаусекситфаилурересетинтервал**: по умолчанию 300 с. Время ожидания сброса счетчика сбоев непрерывного выхода для CodePackage.

### <a name="download"></a>Загрузка
**Деплойментретрибаккоффинтервал**: по умолчанию 10. Задержка интервала сбоев развертывания.
**Деплойментмаксретринтервал**: по умолчанию 3600 с. Max-Off для развертывания при сбоях.
**Деплойментмаксфаилурекаунт**: по умолчанию 20. Прежде чем развертывание приложения на узле завершится сбоем, это развертывание будет выполнено столько раз, сколько задано для DeploymentMaxFailureCount.

### <a name="deactivation"></a>Деактивация
**Деактиватионсканинтервал**: по умолчанию 600 с. минимальное время, заданное ServicePackage для размещения реплики, если она никогда не размещает реплику, например Если не используется.
**Деактиватионграцеинтервал**: по умолчанию 60 с. Время, переданное ServicePackage на размещение еще одной реплики, после размещения любой реплики в случае модели с **общим** процессом.
**Ексклусивемодедеактиватионграцеинтервал**: по умолчанию 1 с. Время, переданное ServicePackage на размещение еще одной реплики, после размещения любой реплики в случае модели с **монопольным** процессом.

## <a name="next-steps"></a>Дальнейшие действия
[Создайте пакет приложения][a3] и подготовьте его к развертыванию.

[Развертывание и удаление приложений с помощью PowerShell][a4]. В статье представлены сведения об управлении экземплярами приложений с помощью PowerShell.

<!--Link references--In actual articles, you only need a single period before the slash-->
[a1]: service-fabric-application-model.md
[a2]: service-fabric-hosting-model.md
[a3]: service-fabric-package-apps.md
[a4]: service-fabric-deploy-remove-applications.md

[p1]: /powershell/module/servicefabric/copy-servicefabricservicepackagetonode
