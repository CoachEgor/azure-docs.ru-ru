---
title: Руководящие принципы для надежных коллекций
description: Руководящие принципы и рекомендации по использованию надежных коллекций Service Fabric в приложении Azure Service Fabric.
ms.topic: conceptual
ms.date: 03/10/2020
ms.openlocfilehash: db37067069b2a9eb08009eb6bb373f6fce1cafa9
ms.sourcegitcommit: b80aafd2c71d7366838811e92bd234ddbab507b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81398529"
---
# <a name="guidelines-and-recommendations-for-reliable-collections-in-azure-service-fabric"></a>Инструкции и рекомендации для надежных коллекций в Azure Service Fabric
В этом разделе приведены инструкции по использованию надежных коллекций и диспетчера надежных состояний. Цель этого руководства — помочь пользователям избежать распространенных ошибок.

Инструкции составлены как простые рекомендации со словами *Делайте*, *Постарайтесь*, *Избегайте* и *Не делайте* в начале.

* Не изменяйте объекты пользовательского типа, возвращаемые операциями чтения (например, `TryPeekAsync` или `TryGetValueAsync`). Надежные коллекции, как и параллельные коллекции, возвращают ссылку на объект, а не его копию.
* Обязательно создайте глубокую копию возвращенного объекта пользовательского типа, прежде чем изменять этот объект. Поскольку структуры и встроенные типы передаются по значению, вам необязательно создавать их глубокую копию, если они не содержат поля или свойства со ссылками, которые вы собираетесь изменить.
* Не используйте `TimeSpan.MaxValue` для времени ожидания. Время ожидания следует использовать для выявления взаимоблокировок.
* Не используйте транзакцию после того, как она была зафиксирована, прервана или удалена.
* Не используйте перечисление за пределами области транзакции, в которой оно было создано.
* Не создавайте транзакцию в `using` отчете другой транзакции, поскольку она может привести к взаимоблокировкам.
* Не создавайте надежное состояние с `IReliableStateManager.GetOrAddAsync` помощью надежного состояния в одной и той же транзакции. Это приводит к недействительнойОперации Исключение.
* Убедитесь, что реализация `IComparable<TKey>` правильна. Система использует соответствующую зависимость `IComparable<TKey>` для слияния контрольных точек и строк.
* Используете блокировку изменения при чтении элемента с целью обновить его, чтобы предотвратить взаимоблокировки определенного класса.
* Рекомендуем использовать менее 1000 надежных коллекций на раздел. Лучше использовать большее количество элементов в надежных коллекциях, чем большее количество надежных коллекций с меньшим количеством элементов.
* Постарайтесь поддерживать размер элементов (например, TKey + TValue для надежного словаря) до 80 КБ: чем меньше, тем лучше. Это позволит уменьшить объем использования кучи больших объектов, а также снизить требования к дискам и сетевым операциям ввода-вывода. Часто это также помогает уменьшить репликацию повторяющихся данных при обновлении только небольшой части значения. Распространенный способ добиться этого в надежном словаре — разбить строки на несколько строк.
* Возможно, вас заинтересует применение функций архивации и восстановления для аварийного восстановления.
* Избегайте совместного использования операций с одной сущностью и операций с несколькими сущностями (например, `GetCountAsync`, `CreateEnumerableAsync`) в одной и той же транзакции ввиду различных уровней изоляции.
* Обработайте исключение InvalidOperationException. Пользовательские транзакции могут быть прерваны системой по разным причинам. Например, если диспетчер надежных состояний изменяет свою роль с основной на какую-то другую, или когда транзакция с длительным временем выполнения блокирует усечение журнала транзакций. В таких случаях пользователь может получить исключение InvalidOperationException, указывающее на то, что его транзакция уже завершена. Если предположить, что завершение транзакции не было запрошено пользователем, то лучший способ обработки этого исключения — удалить транзакцию и проверить, не получен ли сигнал в виде токена отмены (или изменена роль реплики). И если нет, то создать новую транзакцию и повторить попытку.  

При этом нужно помнить о следующем:

* Время ожидания по умолчанию составляет четыре секунды для всех API надежных коллекций. Большинство пользователей должны использовать время ожидания по умолчанию.
* Во всех API надежных коллекций токеном отмены по умолчанию является `CancellationToken.None` .
* Параметр типа ключа (*TKey*) для надежного словаря должен правильно реализовывать `GetHashCode()` и `Equals()`. Ключи должны быть неизменяемыми.
* Чтобы обеспечить высокую доступность надежных коллекций, в каждой службе необходимый и минимальный размер набора реплик должен быть равен как минимум 3.
* Операции чтения в базе данных-получателе могут считывать версии без кворума.
  Это означает, что версия данных, считываемая из отдельной базы данных-получателя, может быть ложно увеличена.
  Чтение из базы данных-источника всегда стабильно и не может вызывать ложное увеличение номера версии.
* Вы несете ответственность за обеспечение безопасности и конфиденциальности данных, сохраненных приложением в надежной коллекции. К этим данным применяются средства защиты, предоставляемые, к примеру, службой управления хранилищем. Для защиты неактивных данных можно использовать шифрование диска операционной системы.  

## <a name="volatile-reliable-collections"></a>Нестабильные надежные коллекции
При принятии решения об использовании нестабильных надежных коллекций, рассмотрим следующее:

* ```ReliableDictionary```имеет нестабильную поддержку
* ```ReliableQueue```имеет нестабильную поддержку
* ```ReliableConcurrentQueue```НЕ имеет волатильной поддержки
* Неустойчивые услуги не могут быть нестабильными. Изменение ```HasPersistedState``` флага ```false``` на требующее воссоздания всей службы с нуля
* Неустойчивые услуги не могут быть выполнены. Изменение ```HasPersistedState``` флага ```true``` на требующее воссоздания всей службы с нуля
* ```HasPersistedState```является конфигурацией уровня обслуживания. Это означает, что **все** коллекции будут либо сохраняются, либо нестабильны. Вы не можете смешивать летучие и упорные коллекции
* Потеря кворума волатильного раздела приводит к полной потере данных
* Резервное копирование и восстановление не доступны для нестабильных служб

## <a name="next-steps"></a>Дальнейшие действия
* [Работа с Reliable Collections](service-fabric-work-with-reliable-collections.md)
* [Транзакции и блокировки](service-fabric-reliable-services-reliable-collections-transactions-locks.md)
* Управление данными
  * [Резервное копирование и восстановление](service-fabric-reliable-services-backup-restore.md)
  * [Уведомления](service-fabric-reliable-services-notifications.md)
  * [Влияние сериализации данных на обновление приложений](service-fabric-application-upgrade-data-serialization.md)
  * [Конфигурация диспетчера надежных состояний](service-fabric-reliable-services-configuration.md)
* Прочее
  * [Get started with Reliable Services](service-fabric-reliable-services-quick-start.md) (Начало работы с Reliable Services)
  * [Справочник разработчика по надежным коллекциям](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)
