---
title: X.509 Сертификат на основе аутентификации в кластере ткани обслуживания
description: Узнайте о проверке подлинности сертификатов в кластерах Service Fabric и о том, как обнаруживать, смягчать и устранять проблемы, связанные с сертификатами.
ms.topic: conceptual
ms.date: 03/16/2020
ms.custom: sfrev
ms.openlocfilehash: 699015e322c599dea996b3a8b9dbc0a4589440ab
ms.sourcegitcommit: b80aafd2c71d7366838811e92bd234ddbab507b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81429672"
---
# <a name="x509-certificate-based-authentication-in-service-fabric-clusters"></a>X.509 Проверка подлинности сертификатов в кластерах Service Fabric

Эта статья дополняет введение [в безопасность кластеров Service Fabric](service-fabric-cluster-security.md)и впадает в детали проверки подлинности на основе сертификатов в кластерах Service Fabric. Мы полагаем, что читатель знаком с основными концепциями безопасности, а также с элементами управления, которые Service Fabric предоставляет для управления безопасностью кластера.  

Темы, охватываемые этим названием:

* Основы проверки подлинности на основе сертификатов
* Идентичности и их соответствующие роли
* Правила конфигурации сертификата
* Устранение неполадок и часто задаваемые вопросы

## <a name="certificate-based-authentication-basics"></a>Основы проверки подлинности на основе сертификатов
В качестве краткого переподготовки, в области безопасности, сертификат является инструментом, предназначенным для привязки информации о сущности (субъекте) к их обладанию парой асимметричных криптографических ключей, и поэтому представляет собой основную конструкцию криптографии ключей. Ключи, представленные сертификатом, могут быть использованы для защиты данных или для доказательства личности держателей ключей; при использовании в сочетании с системой public Key Infrastructure (PKI) сертификат может представлять дополнительные черты предмета, такие как владение доменом интернета, или определенные привилегии, предоставленные ему эмитентом сертификата (известный как Сертификационный орган или CA). Распространенным применением сертификатов является поддержка криптографического протокола Transport Layer Security (TLS), позволяющего обеспечивать безопасную связь через компьютерную сеть. В частности, клиент и сервер используют сертификаты для обеспечения конфиденциальности и целостности их общения, а также для проведения взаимной аутентификации.

В Service Fabric фундаментальный слой кластера (Federation) также основывается на TLS (среди других протоколов) для создания надежной, безопасной сети участвующих узлов. Соединения в кластер через AI-аДИ клиентов Service Fabric используют TLS, а также для защиты трафика, а также для установления идентификационных данных сторон. В частности, при использовании для проверки подлинности в Service Fabric сертификат может быть использован для доказательства следующих утверждений: а) ведущий сертификата имеет в распоряжении личный ключ сертификата b) хэш сертификата SHA-1 ('thumbprint') соответствует декларации, включенной в определение кластера, или в) выдающееся значение общего имени сертификата соответствует декларации, включенной в определение кластера , и эмитент сертификата известен или доверен.

В приведенном выше списке 'b' известен как "прижимая палец"; в этом случае декларация относится к конкретному сертификату, и сила схемы проверки подлинности основывается на предпосылке, что вычислительно нецелесообразно подделывать сертификат, который производит такое же значение хэша, как и другой, оставаясь при этом действительным, хорошо сформировавым объектом во всех других отношениях. Пункт 'c' представляет собой альтернативную форму объявления сертификата, где сила схемы зависит от сочетания предмета сертификата и органа выдачи. В этом случае декларация относится к классу сертификатов - любые два сертификата с одинаковыми характеристиками считаются полностью эквивалентными. 

В следующих разделах подробно разъясняется, как время выполнения Service Fabric использует и проверяет сертификаты для обеспечения безопасности кластера.

## <a name="identities-and-their-respective-roles"></a>Идентичности и их соответствующие роли
Прежде чем вникать в детали аутентификации или обеспечения безопасности каналов связи, важно перечислить участвующих участников и соответствующие роли, которые они играют в кластере:
- время выполнения Service Fabric, называемое «системой»: набор служб, обеспечивающих абстракции и функциональность, представляющие кластер. При общекластерной связи между системными экземплярами мы будем использовать термин «кластерная идентичность»; при отсылке к кластеру в качестве получателя/цели трафика из-за пределов кластера мы будем использовать термин «идентификация сервера».
- размещение приложений, называемых «приложениями»: код, предоставленный владельцем кластера, который организован и выполнен в кластере
- клиентов: сущности, которым разрешено подключаться и выполнять функциональность в кластере, в соответствии с конфигурацией кластера. Мы проводим различие между двумя уровнями привилегий - "пользователь" и "админ", соответственно. Клиент «пользователя» ограничен в основном только для чтения операций (но не все только для чтения функциональности), в то время как "админ" клиент имеет неограниченный доступ к функциональности кластера. (Для получения более подробной информации обратитесь к [ролям безопасности в кластере Service Fabric.)](service-fabric-cluster-security-roles.md)
- (Только для Azure) службы Service Fabric, которые организовывают и разоблачают элементы управления для работы и управления кластерами Service Fabric, называют просто «обслуживанием». В зависимости от среды "служба" может относиться к поставщику ресурсов службы Azure Fabric или другим поставщикам ресурсов, принадлежащим и управляемым командой Service Fabric.

В безопасном кластере каждая из этих ролей может быть настроена со своей собственной, определенной идентификацией, объявленной сопряжением предопределенного имени роли и соответствующей учетными данными. Service Fabric поддерживает декларирование учетных данных в качестве сертификатов или принципа обслуживания на основе домена. (Идентификаторы на основе Windows-/Kerberos также поддерживаются, но выходят за рамки данной статьи; обратитесь к [безопасности на основе Windows в кластерах Service Fabric.)](service-fabric-windows-cluster-windows-security.md) В кластерах Azure роли клиентов также могут быть объявлены в качестве [идентификаторов на основе активных каталогов Azure.](service-fabric-cluster-creation-setup-aad.md)

Как упоминалось выше, время выполнения Service Fabric определяет два уровня привилегий в кластере: 'админ' и 'пользователь'. Клиент администратора и компонент «системы» будут работать с привилегиями администратора и поэтому неотличимы друг от друга. После установления подключения в/к кластеру аутентифицированный абонент будет предоставлен службой Service Fabric, одной из двух ролей в качестве базы для последующего авторизации. Мы подробно рассмотрим аутентификацию в следующих разделах.

## <a name="certificate-configuration-rules"></a>Правила конфигурации сертификата
### <a name="validation-rules"></a>Правила проверки
Настройки безопасности кластера Service Fabric в принципе описывают следующие аспекты:
- тип аутентификации; это время создания, непреложной характеристикой кластера. Примерами таких настроек являются «ClusterCredentialType», «ServerCredentialType», а допустимые значения — «нет», «x509» или «окна». В этой статье основное внимание уделяется аутентификации типа x509.
- правила проверки подлинности; эти параметры устанавливаются владельцем кластера и описывают, какие учетные данные должны быть приняты для заданной роли. Примеры будут рассмотрены подробно непосредственно ниже.
- настройки, используемые для настройки или тонкого изменения результата проверки подлинности; примеры здесь включают флаги (де-)ограничения исполнения списков отзыва сертификатов и т.д.

> [!NOTE]
> Примеры конфигурации кластера приведены ниже, являются выдержками из кластера, проявляемого в формате XML, как наиболее переваренный формат, который непосредственно поддерживает функциональность Service Fabric, описанную в этой статье. Те же настройки могут быть выражены непосредственно в представлениях JSON определения кластера, будь то автономный манифест кластера json или шаблон манги ресурсов Azure.

Правило проверки сертификата включает в себя следующие элементы:
- соответствующая роль: клиент, клиент админ (привилегированная роль)
- учетные данные, принятые для роли, объявленные либо отпечатком пальца мигина или предметом общего имени

#### <a name="thumbprint-based-certificate-validation-declarations"></a>Заявления о проверке сертификата на основе отпечатков пальцев
В случае правил проверки на основе отпечатков пальцев учетные данные, представленные абонентом, запрашивающим подключение к кластеру, будут проверены следующим образом:
  - учетные данные являются действительным, хорошо сформированным сертификатом: его цепочка может быть построена, подписи совпадают
  - Сертификат является действительным во времени (Не до <и теперь < не после)
  - хэш сертификата SHA-1 соответствует декларации, как сравнение строки без учета случаев, исключая все пробелы

Любые ошибки доверия, возникающие при построении цепочки или проверке, будут подавлены для деклараций на основе отпечатков пальцев, за исключением сертификатов с истекшим сроком действия, хотя положения существуют и в этом случае. В частности, сбои, связанные с: статус отзыва, будучи неизвестным или оффлайн, недоверчивый корень, недействительный ключ использования, частичная цепочка считаются нефатальными ошибками; предпосылкой, в данном случае, является то, что сертификат является лишь конвертом для ключевой пары - безопасность заключается в том, что владелец кластера установил в местах меры для защиты частного ключа.

Следующий отрывок из кластерного манифеста иллюстрирует такой набор правил проверки на основе отпечатков пальцев:

```xml
<Section Name="Security">
  <Parameter Name="ClusterCredentialType" Value="X509" />
  <Parameter Name="ServerAuthCredentialType" Value="X509" />
  <Parameter Name="AdminClientCertThumbprints" Value="d5ec...4264" />
  <Parameter Name="ClientCertThumbprints" Value="7c8f...01b0" />
  <Parameter Name="ClusterCertThumbprints" Value="abcd...1234,ef01...5678" />
  <Parameter Name="ServerCertThumbprints" Value="ef01...5678" />
</Section>
```

Каждая из вышеуказанных записей относится к конкретной идентификации, описанной ранее; каждая запись также позволяет указать несколько значений, как запятая разделенный список строк. В этом примере, после успешной проверки входящих учетных данных, ведущий сертификата с отпечатком пальца SHA-1 'd5ec... 4264' будет предоставлена роль «админ»; наоборот, проверка подлинности вызывающего абонента с сертификатом '7c8f... 01b0' будет предоставлена "пользовательская" роль, ограниченная в первую очередь только для чтения операций. Входящий абонент, который представляет сертификат, отпечаток пальца которого либо "abcd ... 1234' или 'ef01... 5678' будет принят в качестве однорангового узла в кластере. Наконец, клиент, подключающийся к конечной точке управления кластера, ожидает, что отпечаток пальца серверного сертификата будет 'ef01... 5678'. 

Как упоминалось ранее, Service Fabric действительно содержит положения о принятии просроченных сертификатов; причина в том, что сертификаты имеют ограниченный срок службы, и при декларировании отпечатком пальца (что относится к конкретному экземпляру сертификата), разрешение срокдействия сертификата приведет либо к сбою в подключении к кластеру, либо к откровенному сбою кластера. Это все слишком легко забыть или пренебречь вращающейся отпечатком пальца закрепленный сертификат, и, к сожалению, восстановление после такой ситуации трудно.

С этой целью владелец кластера может прямо заявить, что самоподписанные сертификаты, объявленные отпечатком пальца, считаются действительными следующим образом:

```xml
  <Section Name="Security">
    <Parameter Name="AcceptExpiredPinnedClusterCertificate" Value="true" />
  </Section>
```
Такое поведение не распространяется на сертификаты, выданные CA; в этом случае отозванное, известное, что сертификат с истекшим сроком действия может стать «действительным», как только он больше не фигурирует в списке отзыва сертификатов CA и, таким образом, представляет угрозу безопасности. С самоподписанными сертификатами владелец кластера считается единственной стороной, ответственной за защиту частного ключа сертификата, чего не скажешь о сертификатах, выданных CA, - владелец кластера может быть не в курсе того, как и когда их сертификат был объявлен скомпрометированным.

#### <a name="common-name-based-certificate-validation-declarations"></a>Общие декларации проверки сертификатов на основе имен
Общие именные декларации принимают одну из следующих форм:
- субъект общее имя (только)
- вопрос общее имя с эмитентом прижимая

Давайте сначала рассмотрим выдержку из кластерного манифеста, иллюстрирующего оба стиля декларации:
```xml
    <Section Name="Security/ServerX509Names">
      <Parameter Name="server.demo.system.servicefabric.azure-int" Value="" />
    </Section>
    <Section Name="Security/ClusterX509Names">
      <Parameter Name="cluster.demo.system.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
```
Декларации относятся соответственно к идентификаторам сервера и кластера; обратите внимание, что декларации на основе CN имеют свои собственные разделы в кластерном манифесте, отдельно от стандарта «Безопасность». В обоих декларациях "Имя" представляет выдающееся общее название сертификата субъекта, а поле "Value" представляет ожидаемого эмитента следующим образом:

- в первом случае в декларации говорится, что общий элемент имени выдающегося субъекта сертификата сервера должен соответствовать строке "server.demo.system.servicefabric.servicefabric.azure-int"; пустое поле «Значение» означает ожидание того, что корневой цепочке сертификатов доверяют на удере/машине, где проверяется сертификат сервера; на Windows это означает, что сертификат может приковать любой из сертификатов, установленных в магазине 'Trusted Root CA';
- во втором случае в декларации говорится, что докладчик сертификата принимается в качестве однорангового узла в кластере, если общее имя сертификата совпадает со строкой "cluster.demo.system.servicefabric.azure-int", *а* отпечаток пальца прямого эмитента сертификата соответствует одной из записей, разделенных запятой в поле "Value". (Этот тип правил известен как «общее имя с зажимом эмитента».)

В любом случае цепочка сертификата построена и, как ожидается, будет безошибочной; то есть ошибки отзыва, частичная цепочка или недействительные ошибки доверия считаются фатальными, и проверка сертификата завершится неудачей. Закрепление эмитентов приведет к рассмотрению статуса «недоверчивого корня» как нефатальной ошибки; несмотря на видимость, это более строгая форма проверки, поскольку она позволяет владельцу кластера ограничить набор авторизованных/принятых эмитентов своим PKI.

После создания цепочки сертификатов она проверяется по стандартной политике TLS/SSL с заявленным объектом в качестве удаленного имени; сертификат будет считаться совпадением, если его общее имя или любое из альтернативных имен субъекта совпадают с декларацией CN из кластерного манифеста. В этом случае wildcards поддерживаются, а соответствие строки нечувствительно.

(Мы должны уточнить, что описанная выше последовательность может быть выполнена для каждого типа использования ключей, заявленных сертификатом; если сертификат определяет использование ключа проверки подлинности клиента, цепочка построена и оценена сначала для роли клиента. В случае успеха, оценка завершается и проверка успешно. Если в сертификате нет использования аутентификации клиента или проверка не сработала, время выполнения Service Fabric будет построено и оценить цепочку для проверки подлинности сервера.)

Для завершения примера следующий отрывок иллюстрирует декларирование сертификатов клиента по общему имени:
```xml
    <Section Name="Security/AdminClientX509Names">
      <Parameter Name="admin.demo.client.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
    <Section Name="Security/ClientX509Names">
      <Parameter Name="user.demo.client.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
```

Приведенные выше декларации соответствуют удостоверениям админа и пользователя, соответственно; проверка сертификатов, заявленных таким образом, точно так же, как описано в предыдущих примерах, сертификатах кластера и сервера.

> [!NOTE]
> Общие именные декларации предназначены для упрощения ротации и, в целом, управления кластерными сертификатами. Тем не менее, рекомендуется придерживаться следующих рекомендаций для обеспечения постоянной доступности и безопасности кластера:
  * предпочитают эмитента прижимая к полагаться на надежные корни
  * избегать смешивания эмитентов из разных PKIs
  * обеспечить, чтобы все ожидаемые эмитенты были указаны в декларации о сертификате; несоответствие эмитента приведет к сбой проверки
  * убедитесь, что конечные точки политики сертификата PKI обнаруживаются, доступны и доступны - это означает, что конечные точки ЗОС, CRL или OCSP объявляются в сертификате листа и что они доступны, чтобы строительство цепочки сертификатов могло завершиться.

Связывая все это вместе, получив запрос на подключение в кластере, защищенном сертификатами X.509, время выполнения Service Fabric будет использовать настройки безопасности кластера для проверки учетных данных удаленной стороны, описанной выше; в случае успеха, вызываец/удаленная сторона считается аутентифицированной. Если учетные данные соответствуют нескольким правилам проверки, время выполнения предоставляет вызывающему абоненту самую привилегированная роль любого из соответствующих правил. 

### <a name="presentation-rules"></a>Правила презентации
В предыдущем разделе описано, как работает аутентификация в кластере, защищенном сертификатами; в этом разделе будет объяснено, как само время выполнения Service Fabric обнаруживает и загружает сертификаты, которые она использует для связи в кластере; мы называем эти правила «презентации».

Как и в случае с правилами проверки, правила представления определяют роль и связанную с ней декларацию учетных данных, выраженную либо отпечатком пальцами, либо общим именем. В отличие от правил проверки, общие декларации на основе имен не содержат положений, касающихся закрепления эмитента; это обеспечивает большую гибкость, а также повышение производительности. Правила представления объявляются в разделе 'NodeType' кластерного манифеста для каждого отдельного типа узлов; настройки разделены от разделов безопасности кластера, чтобы каждый тип узла иметь свою полную конфигурацию в одном разделе. В кластерах Azure Service Fabric сертификат типа сертификата узла по умолчанию соответствует соответствующим настройкам в разделе безопасности определения кластера.

#### <a name="thumbprint-based-certificate-presentation-declarations"></a>Заявления о представлении сертификатов на основе thumbprint
Как уже говорилось ранее, время выполнения Service Fabric различает свою роль в качестве одноранговых узлов в кластере и сервера для операций управления кластером. В принципе, эти параметры могут быть настроены отчетливо, но на практике они, как правило, совпадают. Для остальной части этой статьи мы предположим, что настройки соответствуют простоте.

Рассмотрим следующий отрывок из кластерного манифеста:
```xml
  <NodeTypes>
    <NodeType Name="nt1vm">
      <Certificates>
        <ClusterCertificate X509FindType="FindByThumbprint" X509FindValue="cc71...1984" X509FindValueSecondary="49e2...19d6" X509StoreName="my" Name="ClusterCertificate" />
        <ServerCertificate X509FindValue="cc71...1984" Name="ServerCertificate" />
        <ClientCertificate X509FindValue="cc71...1984" Name="ClientCertificate" />
      </Certificates>
    </NodeType>
  </NodeTypes>
```
Элемент «ClusterCertificate» демонстрирует полную схему, включая дополнительные параметры ('X509FindValueSecondary') или те, которые соответствуют значениям по умолчанию ('X509StoreName'); другие декларации показывают сокращенную форму. В вышеупомянутом заявлении о кластерном сертификате указывается, что параметры безопасности узлов типа 'nt1vm' инициализированы с сертификатом 'cc71. 1984' как основной, и '49e2.. Сертификат 19d6 как вторичный; оба сертификата, как ожидается,\'будут найдены в хранилище сертификатов LocalMachine My (или эквивалентный путь Linux, *var/lib/sfcerts).*

#### <a name="common-name-based-certificate-presentation-declarations"></a>Общие декларации о представлении сертификатов на основе имен
Сертификаты типа узла также могут быть объявлены по данному общему имени, как показано ниже:

```xml
  <NodeTypes>
    <NodeType Name="nt1vm">
      <Certificates>
        <ClusterCertificate X509FindType="FindBySubjectName" X509FindValue="demo.cluster.azuredocpr.system.servicefabric.azure-int" Name="ClusterCertificate" />
      </Certificates>
    </NodeType>
  </NodeTypes>
```

Для любого типа декларации узел Service Fabric будет считывать конфигурацию при запуске, находить и загружать указанные сертификаты и сортировать их в порядке убывания атрибута NotAfter; просроченные сертификаты игнорируются, и первый элемент списка выбирается в качестве учетных данных клиента для любого соединения Service Fabric, попытанным этим узлам. (По сути, Service Fabric отдает предпочтение самому дальнему истеканию сертификата.)

Обратите внимание, что для общих имен на основе презентационных деклараций, сертификат считается совпадением, если его предмет общее название равно X509FindValue (или X509FindValueSecondary) поле декларации в качестве случая чувствительных, точное сравнение строки. Это контрастирует с правилами проверки, которые поддерживают сопоставление подстановочных знаков, а также сравнение строк без чувствительного.  

### <a name="miscellaneous-certificate-configuration-settings"></a>Разные настройки конфигурации сертификата
Ранее отмечалось, что настройки безопасности кластера Service Fabric также позволяют тонко изменять поведение кода проверки подлинности. В то время как статья о [настройках кластера Service Fabric](service-fabric-cluster-fabric-settings.md) представляет собой полный и самый актуальный список настроек, мы расширим значение нескольких параметров безопасности, чтобы завершить полный разоблачение проверки подлинности на основе сертификатов. Для каждого параметра мы объясним намерение, значение/поведение по умолчанию, как оно влияет на аутентификацию и какие значения приемлемы.

Как уже упоминалось, проверка сертификата всегда подразумевает построение и оценку цепочки сертификата. Для сертификатов, выданных CA, этот явно простой вызов OS API обычно влечет за собой несколько исходящих вызовов в различные конечные точки выдачи PKI, кэширование ответов и так далее. Учитывая распространенность вызовов проверки сертификатов в кластере Service Fabric, любые проблемы в конечных точках PKI могут привести к снижению доступности кластера или к прямой поломке. В то время как исходящие вызовы не могут быть подавлены (см. ниже в разделе часто задаваемые вопросы для получения дополнительной информации об этом), следующие настройки могут быть использованы для маскировки ошибок проверки, вызванных сбоем crL-вызовов.

  * CrlCheckingFlag - под разделом "Безопасность" строка преобразуется в UINT. Значение этого параметра используется Service Fabric для маскировки ошибок состояния цепочки сертификатов путем изменения поведения построения цепей; он передается на вызов Win32 CryptoAPI [CertGetCertificateChain](https://docs.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatechain) как параметр 'dwFlags', и может быть установлен на любую действительную комбинацию флагов, принятых функцией. Значение 0 заставляет время выполнения Service Fabric игнорировать любые ошибки состояния доверия - это не рекомендуется, так как его использование будет представлять собой значительную уязвимость безопасности. Значение по умолчанию 0x400000000 (CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT).

  Когда использовать: для локального тестирования, с самоподписанными сертификатами или сертификатами разработчика, которые не полностью сформированы/не имеют надлежащей инфраструктуры ключей от использования в обществе для поддержки сертификатов. Может также использовать в качестве смягчения в воздухе пробелы в средах во время перехода между PKIs.

  Как использовать: возьмем пример, который заставляет проверить отзыв, чтобы получить доступ только к кэшированным URL-адресам. Предполагая:
  ```C++
  #define CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY         0x80000000
  ```
  затем декларация в кластерном манифесте становится:
  ```xml
    <Section Name="Security">
      <Parameter Name="CrlCheckingFlag" Value="0x80000000" />
    </Section>
  ```

  * IgnoreCrlOfflineError - под разделом "Безопасность" булейт со значением "ложь" по умолчанию. Представляет собой ярлык для подавления состояния ошибки построения цепочки 'revocation offline' (или последующего состояния ошибки проверки политики цепочки).

  Когда использовать: локальное тестирование или сертификаты разработчика, не подкрепленные надлежащим PKI. Используйте в качестве смягчения в условиях, связанных с воздухом, или когда PKI, как известно, недоступен.

  Как использовать:
  ```xml
    <Section Name="Security">
      <Parameter Name="IgnoreCrlOfflineError" Value="true" />
    </Section>
  ```

  Другие примечательные настройки (все в разделе "Безопасность"):
  * AcceptExpiredPinnedClusterCertificate - обсуждается в разделе, посвященном проверке сертификата на основе отпечатков пальцев; позволяет принимать сертификаты кластера с истекшим сроком действия. 
  * СертификатExpirySafetyMargin - интервал, выраженный за несколько минут до отметки времени сертификата NotAfter и в течение которого сертификат считается подверженным риску истечения срока действия. Service Fabric отслеживает сертификат кластера (ы) и периодически излучает отчеты о состоянии их оставшейся доступности. Внутри интервала "безопасности" эти отчеты о состоянии здоровья повышены до "предупреждения". По умолчанию используется значение 30 дней.
  * CertificateHealthReportingInterval - контролирует частоту отчетов о работоспособности относительно оставшегося времени действия кластерных сертификатов. Отчеты будут излучаться только один раз в этот интервал. Значение выражается в секундах, с по умолчанию 8 часов.
  * EnforcePrevalidationOnSecurityChanges - boolean, контролирует поведение обновления кластера при обнаружении изменений параметров безопасности. Если установка "истинна" будет предпринята для обновления кластера, которая будет предпринята для обеспечения того, чтобы по крайней мере один из сертификатов, соответствующих любому из правил представления, мог пройти соответствующее правило проверки. Предварительная проверка выполняется до того, как новые настройки будут применены к любому узлам, но выполняется только на узлах, на которой размещается основная копия службы кластерного менеджера во время начала обновления. На момент написания этой статьи параметр имеет значение 'false', и будет настроен на "истинное" для новых кластеров Azure Service Fabric с версией времени выполнения, начинающаяся с 7.1.
 
### <a name="end-to-end-scenario-examples"></a>Сценарий от конца до конца (примеры)
Мы рассмотрели правила презентации, правила проверки и настройки флагов, но как все это работает вместе? В этом разделе мы проработаем два сквозных примера, демонстрирующих, как параметры безопасности могут использоваться для безопасного обновления кластера. Обратите внимание, что это не является всеобъемлющей диссертации по надлежащему управлению сертификатом в Service Fabric, ищите сопутствующие статьи на эту тему.

Разделение правил представления и проверки ставит очевидный вопрос (или озабоченность) в том, могут ли они расходиться, и каковы будут последствия. Действительно, возможно, что выбор сертификата аутентификации узла не пройдет правила проверки другого узла. Фактически это несоответствие является основной причиной инцидентов, связанных с аутентификацией. В то же время разделение этих правил позволяет кластеру продолжать работать во время обновления, которое изменяет параметры безопасности кластера. Учтите, что, сначала дополнив правила проверки в качестве первого шага, все узлы кластера будут сходиться на новых настройках, при этом используя текущие учетные данные. 

Напомним, что в кластере Service Fabric обновление проходит через (до 5) "обновить домены" или UD. Только узлы в текущем UD обновляются/изменяются в данный момент времени, и обновление переходит к следующему UD только в том случае, если это позволяет наличие кластера. (Обратитесь к [обновлениям кластера Service Fabric](service-fabric-cluster-upgrade.md) и другим статьям на ту же тему для более подробной информации.) Изменения сертификата/безопасности особенно опасны, поскольку они могут изолировать узлы из кластера или покидать кластер на грани потери кворума.

Мы будем использовать следующие обозначения для описания параметров безопасности узла:

Нк: «П:»ТПЗА», V: «ТПЗа», где:
  - 'Nk' представляет собой узло в домене обновления *k*
  - 'P' представляет текущие правила представления узла (если мы ссылаемся только на кластерные сертификаты); 
  - 'V' представляет текущие правила проверки узла (только сертификат кластера)
  - «ТПЗА» представляет собой декларацию на основе отпечатков пальцев (TP), при этом 'A' является отпечатком пальца сертификата
  - «CN-B» представляет собой общую декларацию на основе имен (CN), с «B» является общим именем сертификата, являясь общим названием сертификата 

#### <a name="rotating-a-cluster-certificate-declared-by-thumbprint"></a>Вращение сертификата кластера, заявленного отпечатком пальца
В следующей последовательности описывается, как 2-ступенчатое обновление может быть использовано для безопасного введения вторичного сертификата кластера, объявленного отпечатком пальца; первый этап вводит новую декларацию сертификата в правила проверки, а второй этап вводит ее в правила представления:
  - начальное состояние: N0 и P: «ТПЗА», V: «ТПЗа», ... Нк -: «ТпЗа», V: «ТПЗ» - кластер находится в состоянии покоя, все узлы имеют общую конфигурацию
  - по завершении обновления домена 0: N0 и P: «ТПЗА», V: «ТПЗа, ТПЗ», ... Нк -П. (П:«ТПЗ», V: «ТПЗ» - узлы в UD0 представят сертификат A и примут сертификаты A или B; все другие узлы присутствуют и принимают сертификат A
  - по завершении последнего домена обновления: N0 и «P:»TP,A, V: «ТПЗа», ТПЗБ, ... Нк -П. :ТпЗа, V: «ТПЗА, ТПЗБ» - все узлы представляют сертификат A, все узлы будут принимать либо сертификат A или B
      
На этом этапе кластер снова находится в равновесии, и может начаться второй этап обновления/изменения параметров безопасности:
  - при завершении обновления домена 0: N0 и P: «ТПЗ», ТпеБ, V: «ТПА, Тпе», Тпе, ... Нк :П: «ТПЗА», V: «ТПЗА, ТПЗБ» - узлы в UD0 начнут представлять B, который принимается любым другим узлом в кластере.
  - при завершении последнего домена обновления: N0 и P: «ТПЗ», ТПЗБ, V: «ТПЗА, ТПЗБ», ... Нк - «P:»TP-A, TP-B, V: «ТПЗА, ТПЗБ» - все узлы перешли на представление сертификата B. Сертификат A теперь может быть удален/удален из определения кластера с последующим набором обновлений.

#### <a name="converting-a-cluster-from-thumbprint--to-common-name-based-certificate-declarations"></a>Преобразование кластера из отпечатков пальцев в общие имена на основе сертификата деклараций
Аналогичным образом, изменение типа объявления сертификата (от отпечатка пальца к общему имени) будет осуществляться по той же схеме, что и выше. Обратите внимание, что правила проверки позволяют декларировать сертификаты данной роли как отпечатком пальца, так и общим именем в одном и том же определении кластера. Однако, напротив, правила представления допускают только одну форму декларации. Кстати, безопасный подход к преобразованию кластерного сертификата из отпечатков пальцев в общее имя заключается в том, чтобы ввести целевой сертификат сначала с помощью отпечатка пальца, а затем изменить это заявление на общее имя на основе. В следующем примере мы предположим, что отпечаток пальца 'A' и общее имя "B" относятся к одному и тому же сертификату. 

  - начальное состояние: N0 и P: «ТПЗА», V: «ТПЗа», ... Нк -: «ТпЗа», V: «ТПЗ» - кластер находится в состоянии покоя, все узлы имеют общую конфигурацию, а основной отпечаток пальца сертификата является основным
  - по завершении обновления домена 0: N0 и P: «ТПЗА», V: «ТПЗа», CN'B, ... Нк - П: «ТПЗа», V: «ТПЗ» - узлы в UD0 представят сертификат A и примут сертификаты с отпечаток пальца А или общим именем B; все другие узлы присутствуют и принимают сертификат A
  - по завершении последнего домена обновления: N0 и «P:»TP,A, V: «ТПЗа», CN'B, ... Нк -П. (П: «ТПЗ», V: «ТПЗА», CN'B - все узлы представляют сертификат А, все узлы будут принимать либо сертификат A (TP) или B (CN)

На этом этапе мы можем приступить к изменению правил представления с последующим обновлением:
  - при завершении обновления домена 0: N0 и «P: »CN»B, V: «ТПЗА, CN»B, ... Нк -П. (П:«ТПЗ», V: «ТПЗА, CN»B» - узлы в UD0 представят сертификат B, найденный CN, и примут сертификаты с отпечаток пальца А или общим именем B; все другие узлы присутствуют и принимают сертификат A только, выбранный отпечатком пальца
  - при завершении последнего домена обновления: N0 и «P: »CN»B, V: «ТПЗА, CN»B, ... Нк -: «П:КНЗБ», V: «ТПЗА, CN»B » - все узлы, присутствующие в сертификате B, найденном CN, все узлы будут принимать либо сертификат A (TP) или B (CN)
    
Завершение этапа 2 также знаменует собой преобразование кластера в общие сертификаты на основе имен; заявления проверки на основе отпечатков пальцев могут быть удалены в последующем обновлении кластера.

> [!NOTE]
> В кластерах Azure Service Fabric представленные выше рабочие процессы организуются поставщиком ресурсов Service Fabric; владелец кластера по-прежнему отвечает за предоставление сертификатов в кластер в соответствии с указанными правилами (презентация или проверка), и рекомендуется выполнять изменения в несколько этапов.

В отдельной статье мы затронут тему управления и предоставления сертификатов в кластер Service Fabric.

## <a name="troubleshooting-and-frequently-asked-questions"></a>Устранение неполадок и часто задаваемые вопросы
Хотя отладка проблем, связанных с аутентификацией, в кластерах Service Fabric непростая, мы надеемся, что следующие подсказки и советы могут помочь. Самый простой способ начать исследования — изучить журналы событий Service Fabric на узлах кластера - не обязательно те, которые проявляют симптомы, но и узлы, которые находятся, но не могут подключиться к одному из своих соседей. В Windows значимые события обычно регистрируются в каналах «Приложения и услуги» (Microsoft-ServiceFabric-Admin' или «Оперативные» каналы, соответственно. Иногда это может быть полезно, чтобы [CAPI2 лесозаготовки](https://docs.microsoft.com/archive/blogs/benjaminperkins/enable-capi2-event-logging-to-troubleshoot-pki-and-ssl-certificate-issues), чтобы захватить более подробную информацию о проверке сертификата, поиск CRL / CTL и т.д. (Не забудьте отключить его после завершения repro, это может быть довольно многословным.)

Типичными симптомами, проявляющимися в кластере, испытываемом проблемы с аутентификацией, являются: 
  - узлов вниз / велосипед 
  - попытки подключения отклоняются
  - попытки подключения являются сроки

Каждый из симптомов может быть вызван различными проблемами, и та же первопричина может показать различные проявления; как таковой, мы просто перечислим небольшую выборку типичных проблем, с рекомендациями по их устранению. 

* Узлы могут обмениваться сообщениями, но не могут подключиться. Возможной причиной прекращения попыток соединения является ошибка "сертификат не совпадает" - одна из сторон в соединениях Service Fabric--Service Fabric представляет сертификат, который не соответствует правилам проверки получателя. Может сопровождаться любой из следующих ошибок: 
  ```C++
  0x80071c44    -2147017660 FABRIC_E_SERVER_AUTHENTICATION_FAILED
  ```
  Для дальнейшей диагностики/исследования: на каждом из узлов, пытающихся подключения, определите, какой сертификат представлен; изучить сертификат и попытаться подражать правилам проверки (проверить на отпечаток пальца или общее равенство имен, проверить отпечатки пальцев эмитента, если указано).

  Другим распространенным сопроводительным кодом ошибки может быть:
  ```C++
  0x800b0109    -2146762487 CERT_E_UNTRUSTEDROOT
  ```
  В этом случае сертификат объявляется общим именем, и любой из следующих применим:
    - эмитентов не возлагаются, а корневому сертификату не доверяют, или
    - эмитенты возлагаются, но декларация не включает отпечаток пальца непосредственного эмитента этого сертификата

* Узла вверх, но не может подключиться к другим узлам; другие узлы не получают входящий трафик из неисправного узла. В этом случае возможно, что загрузка сертификата не удается на локальном узлах. Ищите следующие ошибки:
  - сертификат не найден - убедитесь, что сертификаты, заявленные в правилах презентации, могут быть решены с одержимое содержанием хранилища сертификатов LocalMachine(My (или, как указано) сертификата. 
    Возможные причины сбоя могут включать: 
      - недействительные символы в декларации отпечатков пальцев
      - сертификат не устанавливается
      - срок действия сертификата истек
      - декларация общего имени включает в себя приставку 'CN'
      - в декларации указывается, что в магазине сертификата не существует точного совпадения (декларация: CN'.mydomain.com, фактический сертификат: CN'server.mydomain.com)

  - неизвестные учетные данные - указывает либо недостающий закрытый ключ, соответствующий сертификату, обычно сопровождаемый кодом ошибки: 
    ```C++ 
    0x8009030d  -2146893043 SEC_E_UNKNOWN_CREDENTIALS
    0x8009030e  -2146893042 SEC_E_NO_CREDENTIALS
    ```
    Чтобы исправить существование частного ключа; проверить SFAdmins предоставляется "читать" выполнить "доступ к частному ключу.

  - плохой тип поставщика - указывает на сертификат Crypto New Generation (CNG) ("Поставщик ключей Microsoft Key Storage"); в настоящее время Service Fabric поддерживает только сертификаты CAPI1. Обычно сопровождается кодом ошибки:
    ```C++
    0x80090014  -2146893804 NTE_BAD_PROV_TYPE
    ```
    Чтобы исправить ситуацию, воссоздайте кластерный сертификат с помощью поставщика CAPI1 (например, "Microsoft Enhanced RSA и ApES Cryptographic Provider"). Для получения более подробной информации о криптопровайдерах, обратитесь к [Понимание криптографических провайдеров](https://docs.microsoft.com/windows/win32/seccertenroll/understanding-cryptographic-providers)

