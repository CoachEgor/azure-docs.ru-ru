---
title: Сеансы обмена сообщениями служебной шины Azure | Документация Майкрософт
description: Обработка последовательностей сообщений служебной шины Azure с помощью сеансов.
services: service-bus-messaging
documentationcenter: ''
author: axisc
manager: timlt
editor: spelluru
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 01/23/2019
ms.author: aschhab
ms.openlocfilehash: 7da3c3de5074df80c676238e4d43dbd677b0a3b4
ms.sourcegitcommit: f52ce6052c795035763dbba6de0b50ec17d7cd1d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76720237"
---
# <a name="message-sessions-first-in-first-out-fifo"></a>Сеансы сообщений и обработка в порядке очереди (FIFO) 

Сеансы службы "Служебная шина Microsoft Azure" обеспечивают согласованную и упорядоченную обработку несвязанных последовательностей связанных сообщений. Чтобы реализовать надежный механизм FIFO в служебной шине, необходимо использовать сеансы. В служебной шине не регламентируется характер связи между сообщениями и не указывается конкретная модель, определяющая, где начинается или заканчивается последовательность сообщений.

> [!NOTE]
> Ценовая категория "Базовый" Служебной шины не поддерживает сеансы, а категории "Стандартный" и "Премиум" — поддерживают. Дополнительные сведения см. на странице [цен на служебную шину](https://azure.microsoft.com/pricing/details/service-bus/).

Любой отправитель может создать сеанс при отправке сообщений в очередь или раздел, задав свойству [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) какой-либо определяемый приложением идентификатор, уникальный в рамках сеанса. На уровне протокола AMQP 1.0 это значение соответствует свойству *group-id*.

В очередях или подписках с поддержкой сеансов сеансы создаются при наличии по крайней мере одного сообщения, для которого указан [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) сеанса. Для созданного сеанса нет определенного интервала времени или API, определяющего его срок действия или существования. Теоретически, сообщение для сеанса может быть получено сегодня, а следующее — через год, и если значение **SessionId** совпадает, то с точки зрения служебной шины это тот же самый сеанс.

Обычно в приложении четко определено, где начинается и заканчивается набор связанных сообщений. Однако служебная шина не устанавливает какие-либо конкретные правила для этого.

Например, чтобы разграничить последовательность для передачи файла, можно задать для свойства **Label** первого сообщения значение **start**, для промежуточных сообщений задать для этого свойства значение **content**, а для последнего сообщения — значение **end**. Относительное положение сообщений с содержимым может быть вычислено как разница между значением *SequenceNumber* текущего сообщения и значением *SequenceNumber* сообщения **start**.

Функция сеансов в служебной шине позволяет выполнить специальную операцию получения посредством [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Для включения этой функции нужно задать свойство [requiresSession](/azure/templates/microsoft.servicebus/namespaces/queues#property-values) для очереди или подписки с помощью Azure Resource Manager или установить соответствующий флаг на портале. Это необходимо сделать прежде, чем пытаться использовать операции связанных API.

На портале флаг устанавливается с помощью следующего флажка:

![][2]

> [!NOTE]
> Если сеансы включены в очереди или подписке, клиентские приложения ***больше не*** могут отправлять и получать обычные сообщения. Все сообщения должны быть отправлены в рамках сеанса (путем установки идентификатора сеанса) и получены путем получения сеанса.

Интерфейсы API для сеансов существуют в клиентах очереди и подписки. Существует императивная модель, в которой вы управляете получением сеансов и сообщений, и модель на основе обработчика, например *OnMessage*, в которой сложность управления циклом получения скрыта.

## <a name="session-features"></a>Функции сеансов

Сеансы обеспечивают параллельное демультиплексирование потоков сообщений с сохранением и гарантией порядка доставки.

![][1]

Получатель [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) создается клиентом, принимающим сеанс. Клиент вызывает [QueueClient.AcceptMessageSession](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesession#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSession) или [QueueClient.AcceptMessageSessionAsync](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesessionasync#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSessionAsync) в C#. В реактивной модели обратного вызова он регистрирует обработчик сеанса.

Когда объект [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) принимается и хранится в клиенте, этот клиент накладывает монопольную блокировку на все сообщения со значением [SessionId](/dotnet/api/microsoft.servicebus.messaging.messagesession.sessionid#Microsoft_ServiceBus_Messaging_MessageSession_SessionId) этого сеанса, имеющиеся в очереди или подписке, а также на все сообщения с этим значением **SessionId**, которые продолжают поступать во время сеанса.

Блокировка снимается, когда вызывается функция **Close** или **CloseAsync**. Если же приложение не может выполнить операцию закрытия, блокировка снимается, когда истекает ее срок действия. Блокировка сеанса должна рассматриваться как монопольная блокировка файла. Это означает, что приложение должно закрыть сеанс, как только он стал не нужен и (или) оно не ожидает поступления новых сообщений.

Когда несколько параллельных получателей извлекают сообщения из очереди, сообщения, относящиеся к определенному сеансу, отправляются в конкретный получатель, который в настоящее время наложил блокировку для этого сеанса. Благодаря этой операции поток сообщений с чередованием, находящийся в одной очереди или подписке, четко демультиплексируется для различных получателей. Эти получатели могут находиться на разных клиентских компьютерах, так как управление блокировкой осуществляется на стороне службы, внутри служебной шины.

На предыдущем рисунке показано три параллельных приемника сеансов. У одного сеанса с `SessionId` = 4 нет активного владеющего клиента. Это означает, что сообщения не будут доставлены из этого конкретного сеанса. Сеанс работает по-разному, как и подочередь.

Блокировка сеанса, накладываемая получателем сеанса, — это "зонтик" для блокировки сообщений, используемый для режима согласования *PeekLock*. Получатель не может одновременно обработать два сообщения "на лету", но сообщения должны обрабатываться по порядку. Новое сообщение можно будет получить только после того, как предыдущее сообщение будет обработано или отправлено в очередь недоставленных сообщений. Если сообщение отбрасывается, то это же сообщение обслуживается повторно при следующей операции получения.

## <a name="message-session-state"></a>Состояние сеанса обмена сообщениями

При обработке рабочих процессов в крупномасштабных высокодоступных облачных системах обработчик рабочих процессов, связанный с определенным сеансом, должен обладать механизмами восстановления после непредвиденных сбоев, а также иметь возможность возобновлять частично выполненную работу в другом процессе или на другом компьютере.

Функция состояния сеанса позволяет добавлять определяемые приложением заметки для сеанса обмена сообщениями внутри брокера, чтобы записанное состояние обработки, относящееся к этому сеансу, становилось мгновенно доступным при получении этого сеанса новым обработчиком.

С точки зрения служебной шины состояние сеанса обмена сообщениями — непрозрачный двоичный объект, который может содержать данные, размер которых равен размеру одного сообщения, что составляет 256 КБ для служебной шины категории "Стандартный" и 1 МБ для служебной шины категории "Премиум". Состояние обработки относительно сеанса может сохраняться в состоянии сеанса, или состояние сеанса может указывать на некоторое место хранения либо запись базы данных, где содержатся эти сведения.

Интерфейсы API для управления состоянием сеанса, [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) и [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate#Microsoft_ServiceBus_Messaging_MessageSession_GetState), можно найти в объекте [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Сеанс, для которого ранее не было задано состояние сеанса, возвращает в интерфейс API **GetState** **пустую** ссылку. Очистка заданного ранее состояния сеанса выполняется с помощью [SetState(null)](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_).

Обратите внимание, что состояние сеанса не изменяется до очистки (возвращается значение **NULL**), даже если потреблены все сообщения в сеансе.

Все существующие сеансы в очереди или подписке могут быть перечислены с помощью метода **SessionBrowser** в интерфейсе API Java и с помощью метода [GetMessageSessions](/dotnet/api/microsoft.servicebus.messaging.queueclient.getmessagesessions#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessions) в интерфейсах API [QueueClient](/dotnet/api/microsoft.azure.servicebus.queueclient) и [SubscriptionClient](/dotnet/api/microsoft.azure.servicebus.subscriptionclient) в клиенте .NET.

Состояние сеанса, хранящееся в очереди или подписке, учитывается при подсчете квоты хранилища этой сущности. Поэтому, когда приложение завершает работу с сеансом, рекомендуется очищать его сохраненное состояние, чтобы избежать затрат на внешнее управление.

## <a name="impact-of-delivery-count"></a>Влияние счетчика доставки

Определение числа доставок для каждого сообщения в контексте сеансов немного отличается от определения в случае отсутствия сеансов. Ниже приведена таблица, в которой приводится сводка по увеличению числа доставок.

| Сценарий | Увеличивается счетчик доставки сообщений |
|----------|---------------------------------------------|
| Сеанс принят, но блокировка сеанса истекает (из-за истечения времени ожидания) | Да |
| Сеанс принят, сообщения в сеансе не завершены (даже если они заблокированы) и сеанс закрыт. | Нет |
| Сеанс принят, сообщения завершаются, а затем сеанс явным образом закрывается | Н/д (это стандартный поток. Здесь сообщения удаляются из сеанса. |

## <a name="next-steps"></a>Дальнейшие действия

- Пример использования клиента .NET Framework для обработки сообщений, поддерживающих сеанс, см. в [статье примеры Microsoft. Azure. servicebus](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.Azure.ServiceBus/Sessions) или [Microsoft. servicebus. Messaging](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/Sessions) . 

Дополнительные сведения об обмене сообщениями через служебную шину см. в следующих статьях:

* [Очереди, разделы и подписки служебной шины](service-bus-queues-topics-subscriptions.md)
* [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md)
* [Как использовать разделы и подписки служебной шины](service-bus-dotnet-how-to-use-topics-subscriptions.md)

[1]: ./media/message-sessions/sessions.png
[2]: ./media/message-sessions/queue-sessions.png
