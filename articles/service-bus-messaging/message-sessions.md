---
title: Сеансы обмена сообщениями служебной шины Azure | Документация Майкрософт
description: В этой статье объясняется, как использовать сеансы для совместной и упорядоченной обработки неограниченных последовательностей связанных сообщений.
services: service-bus-messaging
documentationcenter: ''
author: axisc
manager: timlt
editor: spelluru
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 01/24/2020
ms.author: aschhab
ms.openlocfilehash: 4df6396d156c3fe1b75e3cac3d3f4aad7f23553a
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "77660671"
---
# <a name="message-sessions"></a>Сеансы обмена сообщениями
Сеансы службы "Служебная шина Microsoft Azure" обеспечивают согласованную и упорядоченную обработку несвязанных последовательностей связанных сообщений. Сеансы могут быть использованы в первую очередь в, первый из (FIFO) и запрос-ответ моделей. В этой статье показано, как использовать сеансы для реализации этих шаблонов при использовании Service Bus. 

## <a name="first-in-first-out-fifo-pattern"></a>Первый в, первый из (FIFO) шаблон
Чтобы реализовать гарантию FIFO в сервисном автобусе, используйте сеансы. Service Bus не является предписывающим о характере связи между сообщениями, а также не определяет конкретную модель для определения того, где начинается или заканчивается последовательность сообщений.

> [!NOTE]
> Базовый уровень Service Bus не поддерживает сеансы. а категории "Стандартный" и "Премиум" — поддерживают. Для различий между этими уровнями, [см.](https://azure.microsoft.com/pricing/details/service-bus/)

Любой отправитель может создать сеанс при отправке сообщений в очередь или раздел, задав свойству [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) какой-либо определяемый приложением идентификатор, уникальный в рамках сеанса. На уровне протокола AMQP 1.0 это значение соответствует свойству *group-id*.

В очередях или подписках, связанных с сеансом, сеансы возникали, когда есть по крайней мере одно сообщение с [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId)сеанса. После того, как сеанс существует, нет определенного времени или API для того, когда сеанс истекает или исчезает. Теоретически, сообщение для сеанса может быть получено сегодня, а следующее — через год, и если значение **SessionId** совпадает, то с точки зрения служебной шины это тот же самый сеанс.

Обычно в приложении четко определено, где начинается и заканчивается набор связанных сообщений. Сервисный автобус не устанавливает каких-либо конкретных правил.

Например, чтобы разграничить последовательность для передачи файла, можно задать для свойства **Label** первого сообщения значение **start**, для промежуточных сообщений задать для этого свойства значение **content**, а для последнего сообщения — значение **end**. Относительное положение сообщений с содержимым может быть вычислено как разница между значением *SequenceNumber* текущего сообщения и значением *SequenceNumber* сообщения **start**.

Функция сеансов в служебной шине позволяет выполнить специальную операцию получения посредством [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Для включения этой функции нужно задать свойство [requiresSession](/azure/templates/microsoft.servicebus/namespaces/queues#property-values) для очереди или подписки с помощью Azure Resource Manager или установить соответствующий флаг на портале. Это необходимо, прежде чем пытаться использовать связанные операции API.

На портале флаг устанавливается с помощью следующего флажка:

![][2]

> [!NOTE]
> Когда сеансы включены в очередь или подписку, клиентские приложения ***больше не*** могут отправлять/получать регулярные сообщения. Все сообщения должны быть отправлены в рамках сеанса (путем установки идентификатора сеанса) и получены путем получения сеанса.

Интерфейсы API для сеансов существуют в клиентах очереди и подписки. Есть императивная модель, которая контролирует при получении сеансов и сообщений, и модель на основе обработчика, похожая на *OnMessage,* которая скрывает сложность управления циклом получения.

### <a name="session-features"></a>Функции сеансов

Сеансы обеспечивают параллельное демультиплексирование потоков сообщений с сохранением и гарантией порядка доставки.

![][1]

Получатель [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) создается клиентом, принимающим сеанс. Клиент вызывает [QueueClient.AcceptMessageSession](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesession#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSession) или [QueueClient.AcceptMessageSessionAsync](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesessionasync#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSessionAsync) в C#. В реактивной модели обратного вызова он регистрирует обработчик сеанса.

Когда объект [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) принимается и в то время как он удерживается клиентом, этот клиент держит эксклюзивную блокировку всех сообщений с [SessionId](/dotnet/api/microsoft.servicebus.messaging.messagesession.sessionid#Microsoft_ServiceBus_Messaging_MessageSession_SessionId) сеанса, которые существуют в очереди или подписке, а также на все сообщения с **этим SessionId,** которые все еще приходят во время сеанса.

Блокировка освобождается при вызове **Close** или **CloseAsync** или когда срок действия блокировки истекает в случаях, когда приложение не в состоянии сделать операцию закрытия. Блокировка сеанса должна рассматриваться как эксклюзивная блокировка файла, что означает, что приложение должно закрыть сеанс, как только оно больше не нужно и/или не ожидает дальнейших сообщений.

Когда несколько параллельных получателей извлекают сообщения из очереди, сообщения, относящиеся к определенному сеансу, отправляются в конкретный получатель, который в настоящее время наложил блокировку для этого сеанса. С этой операцией, переплетенный поток сообщений в одной очереди или подписка чисто де-мультиплекса до различных приемников и эти приемники могут также жить на разных клиентских машинах, так как управление блокировкой происходит сервис-сторона, внутри Service Bus.

На предыдущем рисунке показано три параллельных приемника сеансов. У одного сеанса с `SessionId` = 4 нет активного владеющего клиента. Это означает, что сообщения не будут доставлены из этого конкретного сеанса. Сеанс работает по-разному, как и подочередь.

Блокировка сеанса, накладываемая получателем сеанса, — это "зонтик" для блокировки сообщений, используемый для режима согласования *PeekLock*. Приемник не может иметь два сообщения одновременно "в полете", но сообщения должны быть обработаны в порядке. Новое сообщение можно будет получить только после того, как предыдущее сообщение будет обработано или отправлено в очередь недоставленных сообщений. Если сообщение отбрасывается, то это же сообщение обслуживается повторно при следующей операции получения.

### <a name="message-session-state"></a>Состояние сеанса обмена сообщениями

Когда рабочие процессы обрабатываются в высокомасштабных облачных системах с высокой доступностью, обработчик рабочего процесса, связанный с определенным сеансом, должен быть в состоянии восстановиться после непредвиденных сбоев и может частично возобновить работу над другим процессом или машиной из где началась работа.

Функция состояния сеанса позволяет добавлять определяемые приложением заметки для сеанса обмена сообщениями внутри брокера, чтобы записанное состояние обработки, относящееся к этому сеансу, становилось мгновенно доступным при получении этого сеанса новым обработчиком.

С точки зрения служебной шины состояние сеанса обмена сообщениями — непрозрачный двоичный объект, который может содержать данные, размер которых равен размеру одного сообщения, что составляет 256 КБ для служебной шины категории "Стандартный" и 1 МБ для служебной шины категории "Премиум". Состояние обработки относительно сеанса может сохраняться в состоянии сеанса, или состояние сеанса может указывать на некоторое место хранения либо запись базы данных, где содержатся эти сведения.

Интерфейсы API для управления состоянием сеанса, [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) и [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate#Microsoft_ServiceBus_Messaging_MessageSession_GetState), можно найти в объекте [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Сеанс, для которого ранее не было задано состояние сеанса, возвращает в интерфейс API **GetState****пустую** ссылку. Очистка заданного ранее состояния сеанса выполняется с помощью [SetState(null)](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_).

Состояние сеанса сохраняется до тех пор, пока оно не будет устранено (возвращение **нулевой),** даже если все сообщения в сеансе потребляются.

Все существующие сеансы в очереди или подписке могут быть перечислены с помощью метода **SessionBrowser** в интерфейсе API Java и с помощью метода [GetMessageSessions](/dotnet/api/microsoft.servicebus.messaging.queueclient.getmessagesessions#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessions) в интерфейсах API [QueueClient](/dotnet/api/microsoft.azure.servicebus.queueclient) и [SubscriptionClient](/dotnet/api/microsoft.azure.servicebus.subscriptionclient) в клиенте .NET.

Состояние сеанса, хранящееся в очереди или подписке, учитывается при подсчете квоты хранилища этой сущности. Поэтому, когда приложение завершает работу с сеансом, рекомендуется очищать его сохраненное состояние, чтобы избежать затрат на внешнее управление.

### <a name="impact-of-delivery-count"></a>Влияние количества поставок

Определение количества доставки в одном сообщении в контексте сессий несколько отличается от определения в отсутствие сеансов. Вот таблица, обобщающая, когда количество доставки приравлено.

| Сценарий | Является ли количество сообщений с увеличением |
|----------|---------------------------------------------|
| Сессия принимается, но блокировка сеанса истекает (из-за тайм-аута) | Да |
| Сессия принимается, сообщения в сеансе не завершаются (даже если они заблокированы), а сеанс закрыт | нет |
| Сессия принимается, сообщения завершаются, а затем сеанс явно закрывается | N/A (Это стандартный поток. Здесь сообщения удаляются из сеанса) |

## <a name="request-response-pattern"></a>Шаблон запроса-ответа
[Шаблон запрос-ответ](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html) — это устоявшийся шаблон интеграции, который позволяет приложению отправителя отправлять запрос и предоставляет получателю возможность правильно отправить ответ обратно в приложение отправителя. Этот шаблон обычно требует недолговечной очереди или темы для приложения для отправки ответов. В этом сценарии сеансы обеспечивают простое альтернативное решение с сопоставимой семантикой. 

Несколько приложений могут отправлять свои запросы в одну очередь запросов, с определенным параметром заголовка, установленным для однозначной идентификации приложения отправителя. Приложение получателя может обрабатывать запросы, поступающие в очередь, и отправлять ответы в включенной очереди сеансов, установив идентификатор сеанса в уникальный идентификатор, отправленный отправителем в сообщении запроса. Приложение, отправившей запрос, может получать сообщения в определенном идентификаторе сеанса и правильно обрабатывать ответы.

> [!NOTE]
> Приложение, отправляя исходные запросы, должно `SessionClient.AcceptMessageSession(SessionID)` знать об идентификаторе сеанса и использовать его для блокировки сеанса, на котором он ожидает ответа. Рекомендуется использовать GUID, который однозначно идентифицирует экземпляр приложения как идентификатор сеанса. Не должно быть обработчика сеансов или `AcceptMessageSession(timeout)` в очереди, чтобы гарантировать, что ответы доступны для блокировки и обработки определенными приемниками.

## <a name="next-steps"></a>Дальнейшие действия

- Например, пример, который использует клиент .NET Framework для обработки сообщений с пониманием от сеанса, можно ознакомиться с [образцами Microsoft.Azure.ServiceBus](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.Azure.ServiceBus/Sessions) или [примерами Microsoft.ServiceBus.Messaging.](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/Sessions) 

Дополнительные сведения об обмене сообщениями через служебную шину см. в следующих статьях:

* [Очереди, разделы и подписки служебной шины](service-bus-queues-topics-subscriptions.md)
* [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md)
* [Как использовать разделы и подписки служебной шины](service-bus-dotnet-how-to-use-topics-subscriptions.md)

[1]: ./media/message-sessions/sessions.png
[2]: ./media/message-sessions/queue-sessions.png
