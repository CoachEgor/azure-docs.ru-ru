---
title: Обмен сообщениями служебной шины Azure — очереди, разделы и подписки
description: В этой статье представлен обзор сущностей обмена сообщениями служебной шины Azure (очередей, разделов и подписок).
ms.topic: article
ms.date: 06/23/2020
ms.openlocfilehash: deeebf56d6e2f4ccfac37c70170a0d1cb4d272a9
ms.sourcegitcommit: d7008edadc9993df960817ad4c5521efa69ffa9f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/08/2020
ms.locfileid: "86119179"
---
# <a name="service-bus-queues-topics-and-subscriptions"></a>Очереди, разделы и подписки служебной шины

Служебная шина Microsoft Azure поддерживает набор облачных технологий промежуточного уровня, ориентированных на обработку сообщений. Эти технологии представлены надежными очередями сообщений, а также возможностями публикации и подписки в рамках обмена сообщениями. Такие возможности обмена сообщениями через посредника можно рассматривать как несвязанные функции обмена сообщениями, поддерживающие публикацию, подписывание, временное разделение и сценарии балансировки нагрузки с помощью рабочей нагрузки обмена сообщениями служебной шины. Разделенный обмен данными имеет множество преимуществ. Например, клиенты и серверы могут подключаться по необходимости, выполняя свои операции в асинхронном режиме.

Сущности обмена сообщениями, образующие основные возможности обмена сообщениями в служебной шине, представлены очередями, разделами и подписками, а также правилами и действиями.

## <a name="queues"></a>Очереди

Очереди предлагают доставку сообщений конкурирующим потребителям по типу *FIFO* (первым пришел, первым вышел). То есть обычно получатели принимают и обрабатывают сообщения в том порядке, в котором они были добавлены в очередь, и каждое сообщение принимается и обрабатывается только одним потребителем сообщений. Основное преимущество использования очередей — временное разделение компонентов приложений. Другими словами, производителям (отправителям) и потребителям (получателям) не приходится отправлять и получать сообщения в одно и то же время, поскольку сообщения надежно хранятся в очереди. Более того, производителю не нужно ждать ответ от потребителя, чтобы продолжить обработку и отправку дальнейших сообщений.

Сопутствующее преимущество заключается в выравнивании нагрузки — оно позволяет производителям и потребителям отправлять и получать сообщения с разной скоростью. Во многих приложениях уровень системной нагрузки со временем меняется, однако длительность обработки каждой единицы работы, как правило, остается постоянной. Обмен сообщениями между производителем и потребителем с использованием очереди предусматривает подготовку потребляющего приложения к обработке средней, а не пиковой нагрузки. При колебаниях входящей нагрузки просто изменяется глубина очереди. Эта возможность позволяет существенно сократить расходы на инфраструктуру, необходимую для обработки нагрузки приложения. По мере возрастания нагрузки могут потребоваться дополнительные рабочие процессы для чтения из очереди. Каждое сообщение обрабатывается одним рабочим процессом. Кроме того, балансировка нагрузки по запросу обеспечивает оптимальное использование рабочих компьютеров с разной вычислительной мощностью, позволяет извлекать сообщения с максимально доступной скоростью. Такой подход часто называют моделью "конкурирующих потребителей".

Использование очередей в качестве посредника между производителями и потребителями сообщений уменьшает зависимость между компонентами. Так как производители и потребители не зависят друг от друга, обновление потребителя не оказывает влияния на производителя.

### <a name="create-queues"></a>Создание очередей

Очередь можно создать с помощью [портала Azure](service-bus-quickstart-portal.md), [PowerShell](service-bus-quickstart-powershell.md), [CLI](service-bus-quickstart-cli.md) или [шаблонов Resource Manager](service-bus-resource-manager-namespace-queue.md). Затем можно отправлять и получать сообщения с помощью [объекта QueueClient](/dotnet/api/microsoft.azure.servicebus.queueclient).

Чтобы быстро научиться создавать очереди, а затем отправлять и получать сообщения из очереди и в ней, см. [краткие руководства](service-bus-quickstart-portal.md) для каждого метода. Более подробное руководство по использованию очереди см. в статье [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md).

Работающий пример см. в статье с [примером BasicSendReceiveUsingQueueClient](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/GettingStarted/Microsoft.Azure.ServiceBus/BasicSendReceiveUsingQueueClient) на GitHub.

### <a name="receive-modes"></a>Режимы приема

Вы можете указать два режима получения сообщений служебной шины: *ReceiveAndDelete* или *PeekLock*. В режиме [ReceiveAndDelete](/dotnet/api/microsoft.azure.servicebus.receivemode) операция получения выполняется одним снимком; то есть, когда служебная шина получает запрос от потребителя, она помечает сообщение как потребленное и возвращает его приложению-потребителю. Режим **ReceiveAndDelete** представляет собой самую простую модель, которая лучше всего работает в ситуациях, когда приложение может не обрабатывать сообщение при сбое. Чтобы понять этот сценарий, рассмотрим сценарий, в котором объект-получатель выдает запрос на получение и выходит из строя до его обработки. Служебная шина помечает сообщение как использованное. Следовательно, когда после перезапуска приложение снова начнет обрабатывать сообщения, оно пропустит сообщение, использованное до сбоя.

В режиме [PeekLock](/dotnet/api/microsoft.azure.servicebus.receivemode) процесс получения становится двухэтапной операцией. Это позволяет поддерживать приложения, которые не допускают пропуск сообщений. Получив запрос, служебная шина находит следующее сообщение, блокирует его, чтобы другие потребители не могли его принять, а затем возвращает его приложению. Когда приложение завершает обработку сообщения (или надежно сохраняет его для последующей обработки), оно завершает второй этап процесса получения, вызывая метод [CompleteAsync](/dotnet/api/microsoft.azure.servicebus.queueclient.completeasync) для полученного сообщения. Когда служебная шина фиксирует вызов **CompleteAsync**, сообщение помечается как использованное.

Если приложение по каким-либо причинам не может обработать сообщение, оно может вызвать для полученного сообщения метод [AbandonAsync](/dotnet/api/microsoft.azure.servicebus.queueclient.abandonasync) (вместо метода [CompleteAsync](/dotnet/api/microsoft.azure.servicebus.queueclient.completeasync)). Благодаря этому методу служебная шина разблокирует сообщение в очереди, сделав его доступным для приема тем же или другим конкурирующим потребителем. Кроме того, блокирование связано с определенным временем ожидания. Если приложение не сможет обработать сообщение до превышения времени ожидания блокировки (например, при сбое приложения), служебная шина автоматически разблокирует сообщение, сделав его снова доступным для получения (фактически выполняя операцию [AbandonAsync](/dotnet/api/microsoft.azure.servicebus.queueclient.abandonasync) по умолчанию).

Если сбой приложения происходит после обработки сообщения, но перед отправкой запроса **CompleteAsync**, такое сообщение будет повторно доставлено в приложение после перезапуска. Такой процесс предполагает принцип обработки сообщения *хотя бы один раз*. Тем не менее в некоторых случаях это же сообщение может быть доставлено повторно. Если сценарий не допускает повторную обработку, для обнаружения дубликатов требуется дополнительная логика в приложении. Это реализуется с помощью свойства сообщения [MessageId](/dotnet/api/microsoft.azure.servicebus.message.messageid), которое остается постоянным в ходе разных попыток доставки. Такой подход предполагает концепцию обработки *только один раз*.

## <a name="topics-and-subscriptions"></a>Разделы и подписки

В отличие от очередей, в которых каждое сообщение обрабатывается одним потребителем, *разделы* и *подписки* предоставляют возможность взаимодействия типа "один ко многим" в рамках шаблона *публикации или подписки*. Каждое опубликованное сообщение становится доступным в рамках каждой подписки, зарегистрированной в разделе. Это особенно удобно при масштабировании с учетом большого количества получателей. Сообщения отправляются в раздел и доставляются в одну или несколько связанных подписок в зависимости от правил фильтрации, которые могут быть заданы для каждой подписки. Подписки могут использовать дополнительные фильтры для ограничения получаемых сообщений. Сообщения отправляются в раздел так же, как и в очередь; при этом непосредственно из раздела получить их нельзя. Зато их можно получить из подписок. Подписка раздела напоминает виртуальную очередь, которая получает копии сообщений, отправленных в раздел. Сообщения передаются из подписки так же, как и из очереди.

Продолжая сравнение, следует отметить, что при отправке из очереди сообщения распределяются непосредственно в раздел, а при извлечении — в подписку. Помимо прочего, эта возможность означает, что подписки также поддерживают схемы для очередей, описанные ранее в этом разделе, в том числе конкуренцию потребителей, временное разделение, а также выравнивание и балансировку нагрузки.

### <a name="create-topics-and-subscriptions"></a>Создание разделов и подписок

Создание раздела подобно созданию очереди, как показано в примере, приведенном в предыдущем разделе. Затем сообщения отправляются с помощью [класса TopicClient](/dotnet/api/microsoft.azure.servicebus.topicclient). Для получения сообщений создайте одну или несколько подписок для раздела. Как и в случае с очередью, сообщения извлекаются из подписки с помощью объекта [SubscriptionClient](/dotnet/api/microsoft.azure.servicebus.subscriptionclient), используемого вместо объекта [QueueClient](/dotnet/api/microsoft.azure.servicebus.queueclient). Создайте клиент подписки, передав в качестве параметров имя раздела, имя подписки и (необязательно) режим получения.

Полный рабочий пример см. в статье с [примером BasicSendReceiveUsingTopicSubscriptionClient](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/GettingStarted/Microsoft.Azure.ServiceBus/BasicSendReceiveUsingTopicSubscriptionClient) на сайте GitHub.

### <a name="rules-and-actions"></a>Правила и действия

Во многих ситуациях сообщения с определенными характеристиками должны обрабатываться разными способами. Для этого можно настроить подписки, обеспечивающие поиск сообщений с нужными свойствами, после чего можно определенным образом изменить эти свойства. Подписки служебной шины регистрируют все сообщения, отправленные в раздел, однако в виртуальную очередь подписки можно скопировать только подмножество этих сообщений. Это возможно благодаря использованию фильтров подписок. Такие изменения называются *действиями фильтров*. При создании подписки можно указать выражение фильтра, которое работает со свойствами сообщения, свойствами системы (например, **меткой**) и пользовательскими свойствами приложения (например, **StoreName**). В этом случае выражение фильтра SQL является необязательным. без выражения фильтра SQL любое действие фильтра, определенное в подписке, будет выполняться для всех сообщений в этой подписке.

Полный рабочий пример см. в статье с [примером TopicSubscriptionWithRuleOperations](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/GettingStarted/Microsoft.Azure.ServiceBus/TopicSubscriptionWithRuleOperationsSample) на GitHub.

Дополнительные сведения о возможных значениях фильтров см. в документации по классам [SqlFilter](/dotnet/api/microsoft.azure.servicebus.sqlfilter) и [SqlRuleAction](/dotnet/api/microsoft.azure.servicebus.sqlruleaction).

## <a name="java-message-service-jms-20-entities-preview"></a>Сущности 2,0 (служба сообщений Java (JMS)) (Предварительная версия)

Клиентские приложения, подключающиеся к расширенной служебной шине Azure и использующие [БИБЛИОТЕКУ JMS служебной шины Azure](https://search.maven.org/artifact/com.microsoft.azure/azure-servicebus-jms) , могут использовать указанные ниже сущности.

### <a name="queues"></a>Очереди

Очереди в JMS семантически сравнимы с традиционными очередями служебной шины, описанными выше.

Чтобы создать очередь, используйте приведенные ниже методы класса. `JMSContext`

```java
Queue createQueue(String queueName)
```

### <a name="topics"></a>Разделы

Разделы в JMS семантически сравнимы с традиционными разделами служебной шины, описанными выше.

Чтобы создать раздел, используйте приведенные ниже методы класса. `JMSContext`

```java
Topic createTopic(String topicName)
```

### <a name="temporary-queues"></a>Временные очереди

Когда клиентскому приложению требуется временная сущность, существующая в течение времени существования приложения, она может использовать временные очереди. Они используются в шаблоне " [запрос-ответ](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html) ".

Чтобы создать временную очередь, используйте приведенные ниже методы `JMSContext` класса.

```java
TemporaryQueue createTemporaryQueue()
```

### <a name="temporary-topics"></a>Временные разделы

Как и временные очереди, существуют временные разделы, позволяющие публиковать или подписываться через временную сущность, которая существует в течение всего времени существования приложения.

Чтобы создать временный раздел, используйте приведенные ниже методы `JMSContext` класса.

```java
TemporaryTopic createTemporaryTopic()
```

### <a name="java-message-service-jms-subscriptions"></a>Подписки на службу сообщений Java (JMS)

Хотя они семантически похожи на описанные выше подписки (т. е. существуют в разделе и включают семантику публикации/подписки), в спецификации службы сообщений Java представлены концепции **общих**, **необщих**, **устойчивых** и **неустойчивых** атрибутов для данной подписки.

> [!NOTE]
> Следующие подписки доступны на уровне Premium служебной шины Azure для предварительной версии для клиентских приложений, подключающихся к служебной шине Azure с помощью [библиотеки JMS в служебной шине Azure](https://search.maven.org/artifact/com.microsoft.azure/azure-servicebus-jms).
>
> Для общедоступной предварительной версии эти подписки нельзя создать с помощью портал Azure.
>

#### <a name="shared-durable-subscriptions"></a>Общие устойчивые подписки

Общая устойчивая подписка используется, когда все сообщения, опубликованные в разделе, должны быть получены и обработаны приложением, независимо от того, активно ли приложение от подписки.

Так как это общая подписка, все приложения, которые прошли проверку подлинности для получения из служебной шины, могут получить из подписки.

Чтобы создать общую устойчивую подписку, используйте приведенные ниже методы `JMSContext` класса.

```java
JMSConsumer createSharedDurableConsumer(Topic topic, String name)

JMSConsumer createSharedDurableConsumer(Topic topic, String name, String messageSelector)
```

Общая устойчивая подписка остается существующей, если не удалена с помощью `unsubscribe` метода `JMSContext` класса.

```java
void unsubscribe(String name)
```

#### <a name="unshared-durable-subscriptions"></a>Несовместное использование устойчивых подписок

Как и в случае с общей устойчивой подпиской, Нераспространенная устойчивая подписка используется, когда все сообщения, опубликованные в разделе, должны быть получены и обработаны приложением, независимо от того, активно ли приложение от подписки.

Однако, так как это необщая подписка, она может получить только приложение, создавшее подписку.

Чтобы создать недоступную устойчивую подписку, используйте приведенные ниже методы из `JMSContext` класса- 

```java
JMSConsumer createDurableConsumer(Topic topic, String name)

JMSConsumer createDurableConsumer(Topic topic, String name, String messageSelector, boolean noLocal)
```

> [!NOTE]
> Эта `noLocal` функция в настоящее время не поддерживается и игнорируется.
>

Необщая устойчивая подписка остается существующей, если не удалена с помощью `unsubscribe` метода `JMSContext` класса.

```java
void unsubscribe(String name)
```

#### <a name="shared-non-durable-subscriptions"></a>Общие неустойчивые подписки

Общая неустойчивая подписка используется, когда нескольким клиентским приложениям требуется получать и обрабатывать сообщения из одной подписки, только пока они не будут активно потребляться или получены из нее.

Так как подписка не устойчива, она не сохраняется. При отсутствии активных потребителей в этой подписке сообщения не поступают.

Чтобы создать общую неустойчивую подписку, создайте, `JmsConsumer` как показано в приведенных ниже методах `JMSContext` класса.

```java
JMSConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName)

JMSConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName, String messageSelector)
```

Общая неустойчивая подписка будет существовать до тех пор, пока в ней не поступают активные потребители.

#### <a name="unshared-non-durable-subscriptions"></a>Неустойчивые подписки без общих ресурсов

Неустойчивая подписка используется, когда клиентскому приложению требуется получение и обработка сообщения из подписки, только пока она активно не использует ее. В этой подписке может существовать только один потребитель, т. е. Клиент, создавший подписку.

Так как подписка не устойчива, она не сохраняется. Сообщения не получаются этой подпиской, если на ней нет активных потребителей.

Чтобы создать необщую неустойчивую подписку, создайте объект, `JMSConsumer` как показано в приведенных ниже методах из класса жмсконтекст. 

```java
JMSConsumer createConsumer(Destination destination)

JMSConsumer createConsumer(Destination destination, String messageSelector)

JMSConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal)
```

> [!NOTE]
> Эта `noLocal` функция в настоящее время не поддерживается и игнорируется.
>

Неустойчивая подписка будет существовать до тех пор, пока от нее не будет получен активный потребитель.

#### <a name="message-selectors"></a>Селекторы сообщений

Так же как **и фильтры и действия** для обычных подписок служебной шины, для подписок JMS существуют **селекторы сообщений** .

Селекторы сообщений могут быть настроены для каждой подписки JMS и существовать как условие фильтра в свойствах заголовка сообщения. Доставляются только сообщения со свойствами заголовка, соответствующими выражению селектора сообщений. Значение null или пустая строка указывает на отсутствие селектора сообщений для подписки или потребителя JMS.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения и примеры использования обмена сообщениями в служебной шине Microsoft Azure см. в следующих дополнительных статьях:

* [Основные сведения об обмене сообщениями через служебную шину](service-bus-messaging-overview.md)
* [Краткое руководство по отправке и получению сообщений Служебной шины Azure с помощью портала Azure и .NET](service-bus-quickstart-portal.md)
* [Руководство. Обновление информации о запасах с помощью портала Azure, разделов и подписок](service-bus-tutorial-topics-subscriptions-portal.md)


