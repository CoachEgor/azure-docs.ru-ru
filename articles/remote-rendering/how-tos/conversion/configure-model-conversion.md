---
title: Настройка преобразования модели
description: Описание всех параметров преобразования модели
author: florianborn71
ms.author: flborn
ms.date: 03/06/2020
ms.topic: how-to
ms.openlocfilehash: eb287b812c477b2e472c48d7bd8f44574a398bac
ms.sourcegitcommit: 642a297b1c279454df792ca21fdaa9513b5c2f8b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80681575"
---
# <a name="configure-the-model-conversion"></a>Настройка преобразования модели

В этой главе документы рассматриваются варианты преобразования модели.

## <a name="settings-file"></a>Файл настроек

Если вызванный `ConversionSettings.json` файл находится в контейнере ввода рядом с моделью ввода, он используется для обеспечения дополнительной конфигурации для процесса преобразования модели.

Содержимое файла должно удовлетворять следующую схему Json:

```json
{
    "$schema" : "http://json-schema.org/schema#",
    "description" : "ARR ConversionSettings Schema",
    "type" : "object",
    "properties" :
    {
        "scaling" : { "type" : "number", "exclusiveMinimum" : 0, "default" : 1.0 },
        "recenterToOrigin" : { "type" : "boolean", "default" : false },
        "opaqueMaterialDefaultSidedness" : { "type" : "string", "enum" : [ "SingleSided", "DoubleSided" ], "default" : "DoubleSided" },
        "material-override" : { "type" : "string", "default" : "" },
        "gammaToLinearMaterial" : { "type" : "boolean", "default" : false },
        "gammaToLinearVertex" : { "type" : "boolean", "default" : false },
        "sceneGraphMode": { "type" : "string", "enum" : [ "none", "static", "dynamic" ], "default" : "dynamic" },
        "generateCollisionMesh" : { "type" : "boolean", "default" : true },
        "unlitMaterials" : { "type" : "boolean", "default" : false },
        "fbxAssumeMetallic" : { "type" : "boolean", "default" : true },
        "axis" : {
            "type" : "array",
            "items" : {
                "type" : "string",
                "enum" : ["default", "+x", "-x", "+y", "-y", "+z", "-z"]
            },
            "minItems": 3,
            "maxItems": 3
        }
    },
    "additionalProperties" : false
}
```

Пример `ConversionSettings.json` файла может быть:

```json
{
    "scaling" : 0.01,
    "recenterToOrigin" : true,
    "material-override" : "box_materials_override.json"
}
```

### <a name="geometry-parameters"></a>Параметры геометрии

* `scaling`- Этот параметр масштабирует модель равномерно. Масштабирование может использоваться для роста или сжатия модели, например для отображения модели здания на столешницы. Поскольку двигатель рендеринга ожидает, что длина будет указана в метрах, другое важное использование этого параметра возникает, когда модель определяется в разных единицах. Например, если модель определена в сантиметрах, то применение шкалы 0,01 должно отображать модель в нужном размере.
Некоторые форматы исходных данных (например, .fbx) предоставляют подсказку масштабирования единицы, и в этом случае преобразование неявно масштабирует модель до единиц метра. Неявное масштабирование, предусмотренное форматом исходного кода, будет применяться поверх параметра масштабирования.
Окончательный коэффициент масштабирования применяется к вершинам геометрии и локальным преобразованиям узлов графика графика графика. Масштабирование для преобразования корневой сущности остается неизмененным.

* `recenterToOrigin`- государства, которые должны быть преобразованы таким образом, чтобы ее ограничивающий ящик был сосредоточен на источнике.
Центрирование важно, если исходная модель смещена далеко от происхождения, так как в этом случае проблемы с точностью плавающей точки могут привести к визуализации артефактов.

* `opaqueMaterialDefaultSidedness`- Двигатель рендеринга предполагает, что непрозрачные материалы являются двусторонними.
Если это не предполагаемое поведение, этот параметр должен быть установлен на "SingleSided". Для получения дополнительной информации [см.](../../overview/features/single-sided-rendering.md)

### <a name="material-overrides"></a>Материал переопределения

* `material-override`- Этот параметр позволяет настроить обработку материалов [во время преобразования.](override-materials.md)

### <a name="color-space-parameters"></a>Параметры цветового пространства

Двигатель рендеринга ожидает, что значения цвета будут находиться в линейном пространстве.
Если модель определена с помощью гамма-пространства, то эти параметры должны быть установлены в верной.

* `gammaToLinearMaterial`- Преобразование цветов материала из гамма-пространства в линейное пространство
* `gammaToLinearVertex`- Преобразование цветов вершины из гамма-пространства в линейное пространство

> [!NOTE]
> Для файлов FBX эти настройки настроены `true` по умолчанию. Для всех остальных типов `false`файлов по умолчанию.

### <a name="scene-parameters"></a>Параметры сцены

* `sceneGraphMode`- Определяет, как преобразуется график сцены в исходном файле:
  * `dynamic`(по умолчанию): Все объекты в файле разоблачаются как [сущности](../../concepts/entities.md) в API и могут быть преобразованы независимо. Иерархия узлов во времени выполнения идентична структуре в исходном файле.
  * `static`: Все объекты подвергаются воздействию API, но не могут быть преобразованы самостоятельно.
  * `none`: График сцены сворачивается в один объект.

Каждый режим имеет различную производительность выполнения. В `dynamic` режиме, стоимость производительности весы линейно с числом [сущностей](../../concepts/entities.md) в графике, даже если ни одна часть не перемещается. Он должен использоваться только тогда, когда перемещение частей индивидуально необходимо для приложения, например для анимации "представление взрыва".

Режим `static` экспортирует полный график сцены, но части внутри этого графика имеют постоянную трансформацию относительно его корневой части. Однако корневой узла объекта все еще можно перемещать, поворачивать или масштабировать без значительных затрат на производительность. Кроме того, [пространственные запросы](../../overview/features/spatial-queries.md) будут возвращать отдельные части, и каждая часть может быть изменена через [переопределения состояния.](../../overview/features/override-hierarchical-state.md) В этом режиме накладные расходы на время выполнения на объект ничтожно ничтожны. Он идеально подходит для больших сцен, где вы все еще нуждаетесь в проверке на объект, но не изменяются в объекте.

Режим `none` имеет наименьшее время выполнения накладных расходов, а также немного лучше время загрузки. Инспекция или преобразование отдельных объектов в этом режиме невозможна. Случаи использования являются, например, фотограммометрии моделей, которые не имеют значимого графика график в первую очередь.

> [!TIP]
> Многие приложения загружают несколько моделей. Следует оптимизировать параметры преобразования для каждой модели в зависимости от того, как она будет использоваться. Например, если вы хотите отобразить модель автомобиля, чтобы пользователь разобрал и `dynamic` детально проинспектировал, необходимо преобразовать ее в режим. Однако, если вы дополнительно хотите разместить автомобиль в салоне среды, `static` эта `none`модель может быть преобразована с `sceneGraphMode` набором или даже .

### <a name="physics-parameters"></a>Параметры физики

* `generateCollisionMesh`- Если вам нужна поддержка [пространственных запросов](../../overview/features/spatial-queries.md) на модели, эта опция должна быть включена. В худшем случае создание сетки столкновения может удвоить время преобразования. Модели с сетками столкновения загружаются `dynamic` дольше, а при использовании графика они также имеют более высокую производительность выполнения накладных расходов. Для общей оптимальной производительности следует отключить эту опцию на всех моделях, на которых не нужны пространственные запросы.

### <a name="unlit-materials"></a>Неосвещенные материалы

* `unlitMaterials`- По умолчанию конверсия предпочтет создавать [материалы PBR.](../../overview/features/pbr-materials.md) Эта опция говорит преобразователь для лечения всех материалов, как [цветные материалы,](../../overview/features/color-materials.md) а не. Если у вас есть данные, которые уже включают освещение, такие как модели, созданные с помощью фотограмметрии, эта опция позволяет быстро применять правильное преобразование для всех материалов, без необходимости [переопределять каждый материал](override-materials.md) в отдельности.

### <a name="converting-from-older-fbx-formats-with-a-phong-material-model"></a>Преобразование из старых форматов FBX с моделью материала Phong

* `fbxAssumeMetallic`- Старые версии формата FBX определяют их материалы с помощью модели материала Phong. Процесс преобразования должен сделать вывод о том, как эти материалы отображают карту [модели PBR](../../overview/features/pbr-materials.md)рендера. Обычно это работает хорошо, но двусмысленность может возникнуть, когда материал не имеет текстур, высокие спекулятивные значения, и не-серый цвет альбедо. В этом обстоятельстве, преобразование должно выбирать между приоритетами высоких спекулятивных значений, определяя высоко отражающий, металлический материал, где цвет альбедо растворяется, или приоритеты цвета альбедо, определяя что-то вроде блестящего красочного пластика. По умолчанию процесс преобразования предполагает, что высокоспекулятивные значения подразумевают металлический материал в тех случаях, когда применяется двусмысленность. Этот параметр можно `false` установить для переключения на противоположное.

### <a name="coordinate-system-overriding"></a>Координация системы переопределения

* `axis`- Переопределить координатсистемные модульные векторы. Значения по `["+x", "+y", "+z"]`умолчанию . Теоретически формат FBX имеет заголовок, в котором определяются эти векторы, и преобразование использует эту информацию для преобразования сцены. Формат glTF также определяет систему фиксированных координат. На практике некоторые активы либо имеют неверную информацию в заголовке, либо были сохранены с помощью другой конвенции системы координат. Эта опция позволяет переопределить систему координат, чтобы компенсировать. Например: `"axis" : ["+x", "+z", "-y"]` обменяется оси и Y-оси и держать координацию системы handness путем инвертирования Y-оси направлении.

### <a name="vertex-format"></a>Формат Vertex

Можно настроить формат вершины для сетки, чтобы торговать точностью для экономии памяти. Более низкий удобов памяти позволяет загрузить более крупные модели или достичь более высокой производительности. Однако, в зависимости от ваших данных, неправильный формат может существенно повлиять на качество рендеринга.

> [!CAUTION]
> Изменение формата вершины должно быть последним средством, когда модели больше не вписываются в память, или при оптимизации для наилучшей производительности. Изменения могут легко ввести визуализировать артефакты, как очевидные, так и тонкие. Если вы не знаете, на что следует обратить внимание, вы не должны менять значение по умолчанию.

Эти корректировки возможны:

* Конкретные потоки данных могут быть явно включены или исключены.
* Точность потоков данных может быть снижена, чтобы уменьшить след памяти.

Следующий `vertex` раздел `.json` в файле является необязательным. Для каждой части, которая явно не указана, служба преобразования возвращается к своей настройке по умолчанию.

```json
{
    ...
    "vertex" : {
        "position"  : "32_32_32_FLOAT",
        "color0"    : "NONE",
        "color1"    : "NONE",
        "normal"    : "NONE",
        "tangent"   : "NONE",
        "binormal"  : "NONE",
        "texcoord0" : "32_32_FLOAT",
        "texcoord1" : "NONE"
    },
    ...
```

Заставляя компонент, `NONE`гарантируется, что выходная сетка не имеет соответствующего потока.

#### <a name="component-formats-per-vertex-stream"></a>Форматы компонентов в потоке вершин

Эти форматы разрешены для соответствующих компонентов:

| Компонент Vertex | Поддерживаемые форматы (смелый и по умолчанию) |
|:-----------------|:------------------|
|position| **32_32_32_FLOAT**, 16_16_16_16_FLOAT |
|цвет0| **8_8_8_8_UNSIGNED_NORMALIZED**, НЕТ |
|color1| 8_8_8_8_UNSIGNED_NORMALIZED, **НЕТ**|
|нормальный| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, НЕТ |
|тангенс| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, НЕТ |
|двухнормальные| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, НЕТ |
|texcoord0| **32_32_FLOAT**, 16_16_FLOAT, НЕТ |
|texcoord1| **32_32_FLOAT**, 16_16_FLOAT, НЕТ |

#### <a name="supported-component-formats"></a>Поддерживаемые форматы компонентов

Следы памяти форматов таковы:

| Формат | Описание | Байты на вершину |
|:-------|:------------|:---------------|
|32_32_FLOAT|двухкомпонентная полная точность плавающей точки|8
|16_16_FLOAT|двухкомпонентная половина плавающей точки точности|4
|32_32_32_FLOAT|трехкомпонентная полная точность плавающей точки|12
|16_16_16_16_FLOAT|четыре компонента половины плавающей точки точности|8
|8_8_8_8_UNSIGNED_NORMALIZED|четырехкомпонентный байт, нормализованный в диапазоне `[0; 1]`|4
|8_8_8_8_SIGNED_NORMALIZED|четырехкомпонентный байт, нормализованный в диапазоне `[-1; 1]`|4

#### <a name="best-practices-for-component-format-changes"></a>Рекомендации по изменениям формата компонентов

* `position`: Редко достаточно, чтобы точность была достаточной. **16_16_16_16_FLOAT** вводит заметные артефакты количественной оценки, даже для небольших моделей.
* `normal`, `tangent` `binormal`: Обычно эти значения меняются вместе. Если нет заметных артефактов освещения, которые являются результатом нормальной количественной оценки, нет никаких причин для повышения их точности. В некоторых случаях, однако, эти компоненты могут быть установлены на **NONE:**
  * `normal`, `tangent`и `binormal` нужны только тогда, когда по крайней мере один материал в модели должны быть освещены. В ARR это тот случай, когда [материал PBR](../../overview/features/pbr-materials.md) используется на модели в любое время.
  * `tangent`и `binormal` необходимы только тогда, когда любой из освещенных материалов использует нормальную текстуру карты.
* `texcoord0`, `texcoord1` : Текстурные координаты могут использовать пониженную `[0; 1]` точность **(16_16_FLOAT),** когда их значения остаются в диапазоне и когда адресованные текстуры имеют максимальный размер 2048 x 2048 пикселей. Если эти ограничения будут превышены, качество отображения текстуры пострадает.

#### <a name="example"></a>Пример

Предположим, у вас есть модель фотограмметрии, которая имеет освещение запеченные в текстуры. Все, что необходимо для визуализации модели, это положения вершины и координаты текстур.

По умолчанию преобразователь должен предположить, что вы можете использовать материалы `normal`PBR на модели в какой-то момент, поэтому он будет генерировать, `tangent`и `binormal` данные для вас. Следовательно, использование памяти на `position` вершине составляет `texcoord0` (12 байтов) - (8 байтов) - `normal` (4 байта) - `tangent` (4 байта) - `binormal` 32 байта. Большие модели этого типа могут легко иметь много миллионов головорезов в результате чего модели, которые могут занять несколько гигабайт памяти. Такие большие объемы данных повлияют на производительность, и вы даже можете исчерпстать память.

Зная, что вам никогда не нужно динамическое освещение `[0; 1]` на модели, `normal`и `tangent`зная, что все координаты текстуры находятся в диапазоне, вы можете установить, `binormal` и `NONE` `texcoord0` до половины точности ( ),`16_16_FLOAT`в результате чего только 16 байтов на вершину. Сокращение данных сетки в два раза позволяет загрузить более крупные модели и потенциально повышает производительность.

## <a name="typical-use-cases"></a>Стандартные сценарии использования

Поиск хороших настроек импорта для данного случая использования может быть утомительным процессом. С другой стороны, настройки преобразования могут оказать значительное влияние на производительность времени выполнения.

Существуют определенные классы случаев использования, которые подходят для конкретных оптимизаций. Ниже приведены некоторые примеры.

### <a name="use-case-architectural-visualization--large-outdoor-maps"></a>Случай использования: Архитектурная визуализация / большие карты на открытом воздухе

* Эти типы сцен, как правило, статические, то есть они не нуждаются в подвижных частях. Соответственно, `sceneGraphMode` можно установить `static` или `none`даже, что повышает производительность времени выполнения. В `static` режиме корневой узла сцены все еще можно перемещать, поворачивать и масштабировать, например, динамически переключаться между масштабом 1:1 (для просмотра от первого лица) и видом сверху таблицы.

* Когда вам нужно переместить части вокруг, что, как правило, также означает, что вам нужна поддержка для raycasts или других [пространственных запросов,](../../overview/features/spatial-queries.md)так что вы можете выбрать эти части, в первую очередь. С другой стороны, если вы не собираетесь что-то перемещать, высока вероятность того, что вы также не нуждаетесь в нем для участия в пространственных запросах и, следовательно, можете отключить `generateCollisionMesh` флаг. Этот переключатель оказывает значительное влияние на время конверсии, время загрузки, а также затраты на обновление времени выполнения на кадр.

* Если приложение не использует [вырезанные плоскости,](../../overview/features/cut-planes.md) `opaqueMaterialDefaultSidedness` флаг должен быть выключен. Увеличение производительности, как правило, 20%-30%. Вырезать плоскости все еще могут быть использованы, но не будет задних лиц при взгляде на внутренние части объектов, который выглядит нелогичным. Для получения дополнительной информации [см.](../../overview/features/single-sided-rendering.md)

### <a name="use-case-photogrammetry-models"></a>Пример использования: модели фотограмметрии

При визуализации моделей фотограмметрии обычно нет необходимости в `sceneGraphMode` графике сцены, так что вы можете `none`установить. Поскольку эти модели редко содержат сложный график сцены с самого начала, влияние этого варианта должно быть незначительным, однако.

Поскольку освещение уже запекается в текстурах, динамическое освещение не требуется. Таким образом:

* Установите `unlitMaterials` флаг, чтобы `true` превратить все материалы в неосвещенные цветовые [материалы.](../../overview/features/color-materials.md)
* Удалите ненужные данные из формата вершины. Смотрите [пример](#example) выше.

### <a name="use-case-visualization-of-compact-machines-etc"></a>Пример использования: Визуализация компактных машин и т.д.

В этих случаях использования модели часто имеют очень высокую детализацию в небольшом объеме. Рендерер сильно оптимизирован для хорошого обращения с такими случаями. Однако большинство оптимизаций, упомянутых в предыдущем случае использования, здесь не применяются:

* Отдельные детали должны быть выбираемыми и `dynamic`подвижными, поэтому должны быть оставлены. `sceneGraphMode`
* Отливки лучей, как правило, являются неотъемлемой частью приложения, поэтому должны быть созданы сетки столкновений.
* Вырезать самолеты `opaqueMaterialDefaultSidedness` выглядят лучше с флагом включен.

## <a name="next-steps"></a>Дальнейшие действия

* [Преобразование модели](model-conversion.md)
* [Цветные материалы](../../overview/features/color-materials.md)
* [Материалы PBR](../../overview/features/pbr-materials.md)
* [Переопределение материалов при преобразовании модели](override-materials.md)
