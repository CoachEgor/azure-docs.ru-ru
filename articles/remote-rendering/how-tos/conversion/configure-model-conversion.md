---
title: Настройка преобразования модели
description: Описание всех параметров преобразования модели.
author: florianborn71
ms.author: flborn
ms.date: 03/06/2020
ms.topic: how-to
ms.openlocfilehash: 83f80f893620a225c928be2ad7ad1679b3a9c465
ms.sourcegitcommit: fdec8e8bdbddcce5b7a0c4ffc6842154220c8b90
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2020
ms.locfileid: "83652232"
---
# <a name="configure-the-model-conversion"></a>Настройка преобразования модели

В этой главе описываются параметры преобразования модели.

## <a name="settings-file"></a>Файл параметров

Если файл `ConversionSettings.json` находится во входном контейнере рядом с входной моделью, то он используется для дополнительной настройки процесса преобразования модели.

Содержимое этого файла должно соответствовать приведенной ниже схеме JSON.

```json
{
    "$schema" : "http://json-schema.org/schema#",
    "description" : "ARR ConversionSettings Schema",
    "type" : "object",
    "properties" :
    {
        "scaling" : { "type" : "number", "exclusiveMinimum" : 0, "default" : 1.0 },
        "recenterToOrigin" : { "type" : "boolean", "default" : false },
        "opaqueMaterialDefaultSidedness" : { "type" : "string", "enum" : [ "SingleSided", "DoubleSided" ], "default" : "DoubleSided" },
        "material-override" : { "type" : "string", "default" : "" },
        "gammaToLinearMaterial" : { "type" : "boolean", "default" : false },
        "gammaToLinearVertex" : { "type" : "boolean", "default" : false },
        "sceneGraphMode": { "type" : "string", "enum" : [ "none", "static", "dynamic" ], "default" : "dynamic" },
        "generateCollisionMesh" : { "type" : "boolean", "default" : true },
        "unlitMaterials" : { "type" : "boolean", "default" : false },
        "fbxAssumeMetallic" : { "type" : "boolean", "default" : true },
        "deduplicateMaterials" : { "type" : "boolean", "default" : true },
        "axis" : {
            "type" : "array",
            "items" : {
                "type" : "string",
                "enum" : ["default", "+x", "-x", "+y", "-y", "+z", "-z"]
            },
            "minItems": 3,
            "maxItems": 3
        }
    },
    "additionalProperties" : false
}
```

Пример файла `ConversionSettings.json`:

```json
{
    "scaling" : 0.01,
    "recenterToOrigin" : true,
    "material-override" : "box_materials_override.json"
}
```

### <a name="geometry-parameters"></a>Параметры геометрии

* `scaling` — этот параметр равномерно масштабирует модель. Масштабирование можно использовать для увеличения или уменьшения модели, например, чтобы отобразить модель здания на ровной поверхности. Так как подсистема визуализации принимает значения длины в метрах, другой важный способ применения этого параметра проявляется, когда модель определена в других единицах. Например, если модель определена в сантиметрах, то применение масштаба 0,01 должно привести к отображению модели в правильном размере.
Некоторые форматы исходных данных (например, FBX) предоставляют указание масштаба единиц. В этом случае процесс преобразования неявно масштабирует модель в метрических единицах измерения. Неявное масштабирование на основе исходного формата переопределит параметр масштабирования.
Окончательный коэффициент масштабирования применяется к вершинам геометрии и локальным преобразованиям узлов графа сцены. Масштабирование при преобразовании корневой сущности остается неизменным.

* `recenterToOrigin` — указывает, что модель должна быть преобразована таким образом, чтобы ее ограничивающий прямоугольник был расположен по центру в источнике.
Центрирование важно, если исходная модель перемещается далеко из источника, так как в этом случае проблемы точности с плавающей запятой могут вызвать артефакты отрисовки.

* `opaqueMaterialDefaultSidedness` — подсистема визуализации предполагает, что непрозрачные материалы являются двусторонними.
Если это не так, для этого параметра следует задать значение "SingleSided". Чтобы узнать больше, ознакомьтесь с [отрисовкой односторонних объектов](../../overview/features/single-sided-rendering.md).

### <a name="material-overrides"></a>Переопределение материалов

* `material-override` — этот параметр позволяет [настроить обработку материалов во время преобразования](override-materials.md).

### <a name="material-de-duplication"></a>Дедупликация материалов

* `deduplicateMaterials` — этот параметр включает или отключает автоматическую дедупликацию материалов с общими свойствами и текстурами. Дедупликация выполняется после обработки переопределения материалов. По умолчанию он включен.

### <a name="color-space-parameters"></a>Параметры цветового пространства

Подсистема визуализации ожидает, что значения цвета будут находиться в линейном пространстве.
Если модель определена с помощью гамма-пространства, то для этих параметров следует задать значение True.

* `gammaToLinearMaterial` — преобразование цвета материалов из гамма-пространства в линейное пространство.
* `gammaToLinearVertex` — преобразование цвета вершин из гамма-пространства в линейное пространство.

> [!NOTE]
> Для FBX-файлов эти параметры по умолчанию имеют значение `true`. Для всех остальных типов файлов значение по умолчанию — `false`.

### <a name="scene-parameters"></a>Параметры сцены

* `sceneGraphMode` — определяет, как преобразуется граф сцены в исходном файле.
  * `dynamic` (значение по умолчанию). Все объекты в файле предоставляются как [сущности](../../concepts/entities.md) в API и могут быть преобразованы независимо друг от друга. Иерархия узлов во время выполнения идентична структуре в исходном файле.
  * `static`. Все объекты представлены в API, но не могут быть преобразованы независимо друг от друга.
  * `none`. Граф сцены сворачивается в один объект.

Каждый режим обеспечивает разную производительность во время выполнения. В режиме `dynamic` нагрузка на ресурсы линейно пропорциональна числу [сущностей](../../concepts/entities.md) в графе, даже если ни одна часть не перемещается. Его следует использовать только в том случае, если для приложения требуется перемещать части по отдельности, например, чтобы анимировать "деталировочный чертеж".

Режим `static` экспортирует полный граф сцены, но части в этом графе используют постоянное преобразование относительно его корневой части. Однако корневой узел объекта по-прежнему можно перемещать, поворачивать или масштабировать без значительной нагрузки на ресурсы. Более того, [пространственные запросы](../../overview/features/spatial-queries.md) будут возвращать отдельные части, и каждую часть можно будет изменить с помощью [переопределений состояния](../../overview/features/override-hierarchical-state.md). В этом режиме дополнительные затраты времени выполнения на объект незначительны. Этот режим идеально подходит для больших сцен, в которых требуется проверка отдельных объектов, но не изменяется преобразование каждого отдельного объекта.

Режим `none` обеспечивает минимальные затраты времени выполнения, а также немного меньшее время загрузки. Проверка или преобразование отдельных объектов в этом режиме невозможны. К вариантам использования можно отнести фотограмметрические модели, в которых в принципе отсутствует осмысленный граф сцены.

> [!TIP]
> Многие приложения будут загружать несколько моделей. Необходимо оптимизировать параметры преобразования для каждой модели в зависимости от того, как она будет использоваться. Например, если вы хотите отобразить модель автомобиля, чтобы пользователь мог подробно ее осмотреть, необходимо преобразовать ее в режиме `dynamic`. Но если вы также хотите поместить автомобиль в демонстрационную среду, то эту модель можно преобразовать, задав для параметра `sceneGraphMode` значение `static` или даже `none`.

### <a name="physics-parameters"></a>Параметры физики

* `generateCollisionMesh` — если требуется поддержка [пространственных запросов](../../overview/features/spatial-queries.md) к модели, этот параметр должен быть включен. В худшем случае создание сетки столкновений может удвоить время преобразования. Модели с сетками столкновений загружаются дольше, а при использовании графа сцены `dynamic` они также повышают нагрузку на ресурсы во время выполнения. Чтобы обеспечить общую оптимальную производительность, следует отключить этот параметр для всех моделей, для которых не требуются пространственные запросы.

### <a name="unlit-materials"></a>Неосвещенные материалы

* `unlitMaterials` — по умолчанию при преобразовании будут предпочтительно создаваться [материалы PBR](../../overview/features/pbr-materials.md). А этот параметр указывает преобразователю обрабатывать все материалы как [цветовые материалы](../../overview/features/color-materials.md). Если у вас есть данные, которые уже содержат освещение, например модели, созданные с помощью фотограмметрии, этот параметр позволяет быстро применить правильное преобразование для всех материалов без необходимости [переопределять каждый материал](override-materials.md) по отдельности.

### <a name="converting-from-older-fbx-formats-with-a-phong-material-model"></a>Преобразование устаревших форматов FBX с моделью материала по методу Фонга

* `fbxAssumeMetallic` — в устаревших версиях формата FBX материалы определяются с помощью модели материала по методу Фонга. В процессе преобразования необходимо определить, как эти материалы сопоставляются с [моделью PBR](../../overview/features/pbr-materials.md). Обычно все происходит без проблем, но может возникнуть неоднозначность, когда у материала нет текстур, высоких отражающих значений и не серого диффузного цвета. В этом случае процессу преобразования нужно выбрать, отдать предпочтение высоким отражающим значениям, определив сильно отражающий металлический материал, на котором диффузный цвет рассеивается, или отдать предпочтение диффузному цвету, определив нечто вроде блестящего цветного пластика. В случаях неоднозначности по умолчанию процессом преобразования предполагается, что высокие отражающие значения означают металлический материал. Этому параметру можно присвоить значение `false`, чтобы преобразование выполнялось наоборот.

### <a name="coordinate-system-overriding"></a>Переопределение системы координат

* `axis` — позволяет переопределить единичные векторы системы координат. Значения по умолчанию: `["+x", "+y", "+z"]`. Теоретически формат FBX содержит заголовок, в котором определены эти векторы, а преобразование использует эти сведения для преобразования сцены. Формат glTF также определяет фиксированную систему координат. На практике некоторые ресурсы либо содержат неправильную информацию в заголовке, либо были сохранены с использованием другого соглашения о системе координат. Этот параметр позволяет переопределить систему координат, чтобы компенсировать это. Например: `"axis" : ["+x", "+z", "-y"]` поменяет местами оси Z и Y и сохранит направленность системы координат, инвертировав направление оси Y.

### <a name="vertex-format"></a>Формат вершин

Можно настроить формат вершин для сетки, чтобы сэкономить память в ущерб точности. Меньшая занимаемая память позволит загружать модели большего размера или повысить производительность. Однако, в зависимости от данных, неправильный формат может значительно повлиять на качество отрисовки.

> [!CAUTION]
> Изменение формата вершин должно быть последним средством, если модели больше не помещаются в память или требуется оптимизировать их для максимального повышения производительности. Изменения могут легко привести к появлению артефактов визуализации, как очевидных, так и малозаметных. Не следует изменять значение по умолчанию, если только вы не уверены, что знаете, что делаете.

Возможны следующие корректировки.

* Можно явно включить или исключить определенные потоки данных.
* Точность потоков данных можно уменьшить, чтобы сократить занимаемую память.

Следующий раздел `vertex` в файле `.json` является необязательным. Для каждой части, которая не указана явно, служба преобразования применяет значение по умолчанию.

```json
{
    ...
    "vertex" : {
        "position"  : "32_32_32_FLOAT",
        "color0"    : "NONE",
        "color1"    : "NONE",
        "normal"    : "NONE",
        "tangent"   : "NONE",
        "binormal"  : "NONE",
        "texcoord0" : "32_32_FLOAT",
        "texcoord1" : "NONE"
    },
    ...
```

Принудительное применение `NONE` для компонента гарантирует, что выходная сетка не будет содержать соответствующий поток.

#### <a name="component-formats-per-vertex-stream"></a>Форматы компонентов для потока вершин

Ниже приведены форматы, которые допускаются для соответствующих компонентов.

| Компонент вершины | Поддерживаемые форматы (полужирным шрифтом выделен формат по умолчанию) |
|:-----------------|:------------------|
|position| **32_32_32_FLOAT**, 16_16_16_16_FLOAT |
|color0| **8_8_8_8_UNSIGNED_NORMALIZED**, NONE |
|color1| 8_8_8_8_UNSIGNED_NORMALIZED, **NONE**|
|нормальный| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, NONE |
|tangent| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, NONE |
|binormal| **8_8_8_8_SIGNED_NORMALIZED**, 16_16_16_16_FLOAT, NONE |
|texcoord0| **32_32_FLOAT**, 16_16_FLOAT, NONE |
|texcoord1| **32_32_FLOAT**, 16_16_FLOAT, NONE |

#### <a name="supported-component-formats"></a>Поддерживаемые форматы компонентов

Ниже приведены значения занимаемой памяти для форматов.

| Формат | Описание | Байт на вершину |
|:-------|:------------|:---------------|
|32_32_FLOAT|Двухкомпонентная полная точность с плавающей запятой.|8
|16_16_FLOAT|Двухкомпонентная половинная точность с плавающей запятой.|4
|32_32_32_FLOAT|Трехкомпонентная полная точность с плавающей запятой.|12
|16_16_16_16_FLOAT|Четырехкомпонентная половинная точность с плавающей запятой.|8
|8_8_8_8_UNSIGNED_NORMALIZED|Четырехкомпонентный байт, нормализованный до диапазона `[0; 1]`.|4
|8_8_8_8_SIGNED_NORMALIZED|Четырехкомпонентный байт, нормализованный до диапазона `[-1; 1]`.|4

#### <a name="best-practices-for-component-format-changes"></a>Рекомендации по изменению формата компонентов

* `position`: В редких случаях понижение точности приемлемо. **16_16_16_16_FLOAT** добавляет заметные артефакты квантования даже для небольших моделей.
* `normal`, `tangent`, `binormal`. Обычно эти значения изменяются вместе. Если нет заметных артефактов освещения из-за обычного квантования, то нет причин увеличивать их точность. Однако в некоторых случаях для этих компонентов можно задать значение **NONE**.
  * `normal`, `tangent` и `binormal` необходимы только в том случае, если хотя бы один материал в модели должен быть освещен. В ARR это происходит, когда в любой момент времени в модели используется [материал PBR](../../overview/features/pbr-materials.md).
  * `tangent` и `binormal` необходимы только в том случае, если в одном из освещенных материалов используется текстура с картой нормалей.
* `texcoord0`, `texcoord1`: координаты текстур могут использовать сниженную точность (**16_16_FLOAT**), если их значения остаются в диапазоне `[0; 1]` и для их текстур задан максимальный размер 2048 на 2048 пикселей. Если эти ограничения превышены, качество наложения текстур снизится.

#### <a name="example"></a>Пример

Предположим, что у вас есть фотограмметрическая модель, которая содержит текстуры с освещением. Все, что необходимо для отрисовки модели, — это позиции вершин и координаты текстур.

По умолчанию преобразователь должен предположить, что в какой-то момент времени вы захотите использовать в модели материалы PBR, поэтому он создаст данные `normal`, `tangent` и `binormal`. Следовательно, использование памяти на вершину составит `position` (12 байт) + `texcoord0` (8 байт) + `normal` (4 байта) + `tangent` (4 байта) + `binormal` (4 байта) = 32 байта. Большие модели этого типа могут легко содержать много миллионов вершин, в результате чего они могут занимать несколько гигабайт памяти. Такие большие объемы данных повлияют на производительность, и даже может закончится свободная память.

Зная, что для модели не требуется динамическое освещение и все координаты текстур находятся в диапазоне `[0; 1]`, можно задать для `normal`, `tangent` и `binormal` значения `NONE` и `texcoord0`, указав половинную точность (`16_16_FLOAT`), в результате чего на вершину потребуется всего 16 байт. Урезание данных сетки вполовину позволит загружать модели большего размера и может повысить производительность.

## <a name="typical-use-cases"></a>Стандартные сценарии использования

Поиск оптимальных параметров импорта для конкретного варианта использования может быть утомительным. С другой стороны, параметры преобразования могут оказать значительное влияние на производительность среды выполнения.

Существуют определенные классы вариантов использования, которые соответствуют конкретным оптимизациям. Несколько примеров приведено ниже.

### <a name="use-case-architectural-visualization--large-outdoor-maps"></a>Вариант использования. Архитектурная визуализация и крупные внешние карты

* Сцены этого типа обычно являются статическими, то есть не требуют движущихся частей. Соответственно, `sceneGraphMode` может иметь значение `static` или даже `none`, что повышает производительность среды выполнения. В режиме `static` корневой узел сцены по-прежнему можно перемещать, поворачивать и масштабировать, например, чтобы динамически переключаться между масштабом 1:1 (для вида от первого лица) и видом сверху.

* Если необходимо перемещать части, это, как правило, также означает, что требуется поддержка отслеживания лучей или других [пространственных запросов](../../overview/features/spatial-queries.md), чтобы эти части в принципе можно было выбрать. С другой стороны, если вы не собираетесь ничего перемещать, вероятнее всего, не потребуется выполнять пространственные запросы и, следовательно, можно отключить флаг `generateCollisionMesh`. Этот параметр оказывает значительное влияние на время преобразования, время загрузки, а также на затраты на обновление каждого кадра во время выполнения.

* Если приложение не использует [вырезание плоскостей](../../overview/features/cut-planes.md), флаг `opaqueMaterialDefaultSidedness` должен быть отключен. Увеличение производительности обычно составляет 20–30 %. Вырезание плоскостей по-прежнему можно будет использовать, но при просмотре внутренних частей объектов у них не будет обратной стороны, что будет выглядеть парадоксально. Чтобы узнать больше, ознакомьтесь с [отрисовкой односторонних объектов](../../overview/features/single-sided-rendering.md).

### <a name="use-case-photogrammetry-models"></a>Вариант использования. Фотограмметрические модели

При отрисовке фотограмметрических моделей обычно нет необходимости в графе сцены, поэтому для `sceneGraphMode` можно задать значение `none`. Так как эти модели редко содержат сложный граф сцены, то влияние этого параметра должно быть незначительным.

Так как освещение уже содержится в текстурах, динамическое освещение не требуется. Таким образом:

* Установите для флага `unlitMaterials` значение `true`, чтобы преобразовать все материалы в неосвещенные [цветовые материалы](../../overview/features/color-materials.md).
* Удалите ненужные данные из формата вершин. Ознакомьтесь с [примером](#example) выше.

### <a name="use-case-visualization-of-compact-machines-etc"></a>Вариант использования. Визуализация компактных механизмов и т. д.

В этих случаях модели часто используют очень высокую детализацию в небольшом объеме. Отрисовщик сильно оптимизирован для обработки таких случаев. Однако большинство оптимизаций, упомянутых в предыдущем варианте использования, здесь не применяется.

* Требуется возможность выбирать и перемещать отдельные части, поэтому для `sceneGraphMode` нужно оставить значение `dynamic`.
* Операции отслеживания лучей обычно являются неотъемлемой частью приложения, поэтому необходимо создавать сетки столкновений.
* Вырезание плоскостей выглядит лучше, если включен флаг `opaqueMaterialDefaultSidedness`.

## <a name="next-steps"></a>Дальнейшие действия

* [Преобразование модели](model-conversion.md)
* [Цветовые материалы](../../overview/features/color-materials.md)
* [Материалы PBR](../../overview/features/pbr-materials.md)
* [Переопределение материалов во время преобразования модели](override-materials.md)
