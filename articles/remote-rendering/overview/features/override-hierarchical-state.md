---
title: Переопределение иерархического состояния
description: Описание компонентов переопределения иерархического состояния.
author: florianborn71
ms.author: flborn
ms.date: 02/10/2020
ms.topic: article
ms.openlocfilehash: 40857e83457222365e61a224ead19bd1d1d31ae7
ms.sourcegitcommit: 0690ef3bee0b97d4e2d6f237833e6373127707a7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/21/2020
ms.locfileid: "83758985"
---
# <a name="hierarchical-state-override"></a>Переопределение иерархического состояния

Довольно часто возникает необходимость динамически изменять вид отдельных частей [модели](../../concepts/models.md), например скрывать вложенные графы или добавлять прозрачность некоторым частям. Изменять материалы для каждой затронутой части не очень практично, так как для этого требуется итеративно обрабатывать весь граф сцены, а также управлять клонированием материалов и назначать их на каждом узле.

Чтобы решить такую задачу с минимально возможными издержками, используйте `HierarchicalStateOverrideComponent`. Этот компонент реализует обновление иерархического состояния для произвольных ветвей графа сцены. Это означает, что состояние можно определить на любом уровне графа сцены, и оно будет передаваться вниз по иерархии до того места, где будет переопределено другим состоянием или применено к конечному объекту.

В качестве примера мы рассмотрим модель автомобиля, который нам нужно сделать полностью прозрачным, за исключением внутренностей двигателя. Такой вариант использования требует всего двух экземпляров компонента:

* Первый компонент назначается корневому узлу модели, чтобы включить прозрачную отрисовку для всего автомобиля.
* Второй компонент назначается корневому узлу двигателя, где состояние явным образом переопределяется (режим прозрачности отключается).

## <a name="features"></a>Компоненты

Ниже представлен полный фиксированный набор состояний, которые могут быть переопределены.

* **Hidden**: Скрывает или отображает соответствующие сетки в графе сцены.
* **Tint color.** Отрисованный объект можно открасить цветом с определенными значениями оттенка и насыщенности. На рисунке ниже демонстрируется выделение цветом обода колеса.
  
  ![Оттенок цвета](./media/color-tint.png)

* **See-through.** Геометрия отрисовывается полупрозрачной, например для того, чтобы отобразить внутренние части объекта. На следующем рисунке мы видим, что весь автомобиль отрисовывается в режиме прозрачности, за исключением красного тормозного суппорта:

  ![Прозрачность](./media/see-through.png)

  > [!IMPORTANT]
  > Эффект прозрачности работает, только если включен [режим отрисовки](../../concepts/rendering-modes.md) *TileBasedComposition*.

* **Selected.** Геометрия отрисовывается с [контуром выделенного фрагмента](outlines.md).

  ![Контур выделенного фрагмента](./media/selection-outline.png)

* **DisableCollision.** Геометрия исключается из рассмотрения при [пространственных запросах](spatial-queries.md). Флаг **Hidden** не исключает столкновения, поэтому часто нужно устанавливать оба этих флага.

## <a name="hierarchical-overrides"></a>Иерархические переопределения

`HierarchicalStateOverrideComponent` можно присоединить на нескольких уровнях иерархии объектов. Для каждого типа сущности может существовать только один компонент каждого типа, поэтому каждый `HierarchicalStateOverrideComponent` управляет одновременно состояниями сокрытия, прозрачности, выбора, цветовых оттенков и столкновений.

Это означает, что каждое состояние определяется одним из следующих значений:

* `ForceOn` — состояние включено для всей сетки, начиная с этого узла и ниже;
* `ForceOff` — состояние отключено для всей сетки, начиная с этого узла и ниже;
* `InheritFromParent` — этот компонент переопределения не влияет на это состояние.

Состояния можно изменять напрямую или с помощью функции `SetState`:

```cs
HierarchicalStateOverrideComponent component = ...;

// set one state directly
component.HiddenState = HierarchicalEnableState.ForceOn;

// set a state with the SetState function
component.SetState(HierarchicalStates.SeeThrough, HierarchicalEnableState.InheritFromParent);

// set multiple states at once with the SetState function
component.SetState(HierarchicalStates.Hidden | HierarchicalStates.DisableCollision, HierarchicalEnableState.ForceOff);
```

```cpp
ApiHandle<HierarchicalStateOverrideComponent> component = ...;

// set one state directly
component->HiddenState(HierarchicalEnableState::ForceOn);

// set a state with the SetState function
component->SetState(HierarchicalStates::SeeThrough, HierarchicalEnableState::InheritFromParent);

// set multiple states at once with the SetState function
component->SetState(
    (HierarchicalStates)((int32_t)HierarchicalStates::Hidden | (int32_t)HierarchicalStates::DisableCollision), HierarchicalEnableState::ForceOff);

```

### <a name="tint-color"></a>Цвет оттенка

Переопределение цвета оттенка имеет дополнительную особенность: кроме состояния включения, выключения и наследования, оно имеет еще одно свойство для цвета оттенка. Значение альфа-канала для цвета оттенка определяет весовой коэффициент эффекта окраски. Если задано значение 0,0, цвет оттенка не виден, а если задано значение 1,0, объект отрисовывается с чистым цветом оттенком. При промежуточных значениях итоговый цвет объекта смешивается с цветом оттенка. Цвет оттенка можно изменять для каждого кадра, чтобы создать цветовую анимацию.

## <a name="performance-considerations"></a>Вопросы производительности

Экземпляр `HierarchicalStateOverrideComponent` сам по себе не требует много ресурсов в среде выполнения. Но мы рекомендуем не увеличивать без необходимости количество активных компонентов. Например, при реализации системы выбора объектов с отрисовкой выделения рекомендуется удалить этот компонент при снятии выделения. Если вы будете хранить компоненты с нейтральными свойствами, нагрузка будет быстро повышаться.

Прозрачная отрисовка создает больше нагрузки на GPU сервера, чем стандартная отрисовка. Если *прозрачность* включена для больших частей графа сцены, и при этом несколько уровней геометрии остаются видимыми, это может существенно влиять на производительность. Это же справедливо и для объектов с [контурами выделенного фрагмента](../../overview/features/outlines.md#performance).

## <a name="next-steps"></a>Дальнейшие действия

* [Контуры](../../overview/features/outlines.md)
* [Режимы отрисовки](../../concepts/rendering-modes.md)
* [Пространственные запросы](../../overview/features/spatial-queries.md)
