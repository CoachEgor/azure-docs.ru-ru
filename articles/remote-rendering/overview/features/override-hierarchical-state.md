---
title: Переопределение иерархического состояния
description: Описание компонентов переопределения иерархического состояния.
author: florianborn71
ms.author: flborn
ms.date: 02/10/2020
ms.topic: article
ms.openlocfilehash: 5ef5af77831c01ae484398c1f2d8905e5e2bc11e
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2020
ms.locfileid: "84021336"
---
# <a name="hierarchical-state-override"></a>Переопределение иерархического состояния

Довольно часто возникает необходимость динамически изменять вид отдельных частей [модели](../../concepts/models.md), например скрывать вложенные графы или добавлять прозрачность некоторым частям. Изменять материалы для каждой затронутой части не очень практично, так как для этого требуется итеративно обрабатывать весь граф сцены, а также управлять клонированием материалов и назначать их на каждом узле.

Чтобы решить такую задачу с минимально возможными издержками, используйте `HierarchicalStateOverrideComponent`. Этот компонент реализует обновление иерархического состояния для произвольных ветвей графа сцены. Это означает, что состояние можно определить на любом уровне графа сцены, и оно будет передаваться вниз по иерархии до того места, где будет переопределено другим состоянием или применено к конечному объекту.

В качестве примера мы рассмотрим модель автомобиля, который нам нужно сделать полностью прозрачным, за исключением внутренностей двигателя. Такой вариант использования требует всего двух экземпляров компонента:

* Первый компонент назначается корневому узлу модели, чтобы включить прозрачную отрисовку для всего автомобиля.
* Второй компонент назначается корневому узлу двигателя, где состояние явным образом переопределяется (режим прозрачности отключается).

## <a name="features"></a>Компоненты

Ниже представлен полный фиксированный набор состояний, которые могут быть переопределены.

* **`Hidden`**: Соответствующие сетки в графе сцены скрыты или показаны.
* **`Tint color`**: Визуализированный объект может быть оттенок цвета с индивидуальным цветом оттенка и насыщенностью оттенка. На рисунке ниже демонстрируется выделение цветом обода колеса.
  
  ![Оттенок цвета](./media/color-tint.png)

* **`See-through`**: Геометрия визуализируется полупрозрачным образом, например для отображения внутренних частей объекта. На следующем рисунке мы видим, что весь автомобиль отрисовывается в режиме прозрачности, за исключением красного тормозного суппорта:

  ![Прозрачность](./media/see-through.png)

  > [!IMPORTANT]
  > Эффект прозрачности работает, только если включен [режим отрисовки](../../concepts/rendering-modes.md) *TileBasedComposition*.

* **`Selected`**: Геометрия отображается с [контуром выделения](outlines.md).

  ![Контур выделенного фрагмента](./media/selection-outline.png)

* **`DisableCollision`**: Геометрия исключена из [пространственных запросов](spatial-queries.md). **`Hidden`** Флаг не влияет на флаг состояния столкновений, поэтому эти два флага часто устанавливаются вместе.

## <a name="hierarchical-overrides"></a>Иерархические переопределения

`HierarchicalStateOverrideComponent` можно присоединить на нескольких уровнях иерархии объектов. Для каждого типа сущности может существовать только один компонент каждого типа, поэтому каждый `HierarchicalStateOverrideComponent` управляет одновременно состояниями сокрытия, прозрачности, выбора, цветовых оттенков и столкновений.

Это означает, что каждое состояние определяется одним из следующих значений:

* `ForceOn` — состояние включено для всей сетки, начиная с этого узла и ниже;
* `ForceOff` — состояние отключено для всей сетки, начиная с этого узла и ниже;
* `InheritFromParent` — этот компонент переопределения не влияет на это состояние.

Состояния можно изменять напрямую или с помощью функции `SetState`:

```cs
HierarchicalStateOverrideComponent component = ...;

// set one state directly
component.HiddenState = HierarchicalEnableState.ForceOn;

// set a state with the SetState function
component.SetState(HierarchicalStates.SeeThrough, HierarchicalEnableState.InheritFromParent);

// set multiple states at once with the SetState function
component.SetState(HierarchicalStates.Hidden | HierarchicalStates.DisableCollision, HierarchicalEnableState.ForceOff);
```

```cpp
ApiHandle<HierarchicalStateOverrideComponent> component = ...;

// set one state directly
component->HiddenState(HierarchicalEnableState::ForceOn);

// set a state with the SetState function
component->SetState(HierarchicalStates::SeeThrough, HierarchicalEnableState::InheritFromParent);

// set multiple states at once with the SetState function
component->SetState(
    (HierarchicalStates)((int32_t)HierarchicalStates::Hidden | (int32_t)HierarchicalStates::DisableCollision), HierarchicalEnableState::ForceOff);

```

### <a name="tint-color"></a>Цвет оттенка

`tint color`Переопределение является немного особым, так как у него есть состояние ON/OFF/наследование и свойство оттенка цвета. Значение альфа-канала для цвета оттенка определяет весовой коэффициент эффекта окраски. Если задано значение 0,0, цвет оттенка не виден, а если задано значение 1,0, объект отрисовывается с чистым цветом оттенком. При промежуточных значениях итоговый цвет объекта смешивается с цветом оттенка. Цвет оттенка можно изменять для каждого кадра, чтобы создать цветовую анимацию.

## <a name="performance-considerations"></a>Вопросы производительности

Экземпляр `HierarchicalStateOverrideComponent` сам по себе не требует много ресурсов в среде выполнения. Но мы рекомендуем не увеличивать без необходимости количество активных компонентов. Например, при реализации системы выбора объектов с отрисовкой выделения рекомендуется удалить этот компонент при снятии выделения. Если вы будете хранить компоненты с нейтральными свойствами, нагрузка будет быстро повышаться.

Прозрачная отрисовка создает больше нагрузки на GPU сервера, чем стандартная отрисовка. Если *прозрачность* включена для больших частей графа сцены, и при этом несколько уровней геометрии остаются видимыми, это может существенно влиять на производительность. Это же справедливо и для объектов с [контурами выделенного фрагмента](../../overview/features/outlines.md#performance).

## <a name="next-steps"></a>Дальнейшие действия

* [Контуры](../../overview/features/outlines.md)
* [Режимы отрисовки](../../concepts/rendering-modes.md)
* [Пространственные запросы](../../overview/features/spatial-queries.md)
