---
title: Запросы производительности сервера
description: Как выполнять запросы производительности сервера через вызовы API
author: florianborn71
ms.author: flborn
ms.date: 02/10/2020
ms.topic: article
ms.openlocfilehash: 9a28dee2d1e6d1355b729a56e8eeb8447e4ed8c8
ms.sourcegitcommit: 642a297b1c279454df792ca21fdaa9513b5c2f8b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80682030"
---
# <a name="server-side-performance-queries"></a>Запросы производительности сервера

Хорошая рендеринговая производительность на сервере имеет решающее значение для стабильной частоты кадров и хорошего пользовательского опыта. Важно тщательно следить за характеристиками производительности на сервере и оптимизировать ее там, где это необходимо. Данные о производительности могут быть запрошены с помощью выделенных функций API.

Наиболее результативной для визуализации является данные ввода модели. Можно настроить входные данные, [описанные в настройке преобразования модели.](../../how-tos/conversion/configure-model-conversion.md)

Производительность клиентского приложения также может быть узким местом. Для углубленного анализа производительности клиентской стороны рекомендуется провести [прослед производительности.](../../how-tos/performance-tracing.md)

## <a name="clientserver-timeline"></a>Хронология клиента/сервера

Прежде чем вдаваясь в подробности о различных значениях задержки, стоит взглянуть на точки синхронизации между клиентом и сервером в Хронике:

![Хронология трубопровода](./media/server-client-timeline.png)

Иллюстрация показывает, как:

* *Оценка Pose* стартует клиентом при постоянной частоте кадров 60 Гц (каждые 16,6 мс)
* сервер затем начинает рендеринг, в зависимости от позы
* сервер отправляет назад закодированное видеоизображение
* клиент расшифровывает изображение, выполняет некоторые работы процессора и графического процессора на нем, а затем отображает изображение

## <a name="frame-statistics-queries"></a>Запросы статистики кадра

Статистика кадров предоставляет некоторую информацию высокого уровня для последнего кадра, например задержку. Данные, представленные в структуре, `FrameStatistics` измеряются на стороне клиента, поэтому API является синхронным вызовом:

````c#
void QueryFrameData(AzureSession session)
{
    FrameStatistics frameStatistics;
    if (session.GraphicsBinding.GetLastFrameStatistics(out frameStatistics) == Result.Success)
    {
        // do something with the result
    }
}
````

Извлеченный `FrameStatistics` объект содержит следующие члены:

| Участник | Объяснение |
|:-|:-|
| latencyposeToReceive | Задержка от оценки камеры на клиентском устройстве до тех пор, пока серверная рамка для этой позы не будет полностью доступна клиенту приложения. Это значение включает в себя поездку в облик, время рендеринга сервера, декодирование видео и компенсацию дрожь. Смотрите **интервал 1 на иллюстрации выше.**|
| latencyReceiveToPresent | Задержка от наличия полученного удаленного кадра до тех пор, пока клиентское приложение не вызывает PresentFrame на процессоре. |
| задержкаPresentPresentToDisplay  | Задержка от представления кадра на процессоре до тех пор, пока дисплей не загорится. Это значение включает время графического процессора клиента, любой буферизируя кадры, выполняемые ОС, аппаратную перепроекцию и время сканирования дисплея, зависящий от устройства. Смотрите **интервал 2 на иллюстрации выше.**|
| timeSinceLastPresent | Время между последующими вызовами presentFrame на процессоре. Значения, превышаюющие продолжительность дисплея (например, 16,6 мс на клиентском устройстве 60 Гц) указывают на проблемы, вызванные тем, что клиентское приложение не заканчивает рабочую нагрузку процессора вовремя. Смотрите **интервал 3 на иллюстрации выше.**|
| videoFramesReceived | Количество кадров, полученных с сервера в последнюю секунду. |
| videoFrameReusedCount | Количество полученных кадров в последнюю секунду, которые использовались на устройстве более одного раза. Значения ненулевых указывают на то, что кадры должны были быть повторно использованы и перепроектированы либо из-за дрожания сети, либо из-за чрезмерного времени рендеринга сервера. |
| videoFramesSkipped | Количество полученных кадров в последнюю секунду, которые были расшифрованы, но не показаны на дисплее, потому что появился новый кадр. Значения ненулевых указывают на то, что дрожание сети привело к задержке нескольких кадров, а затем к работе на клиентском устройстве вместе в результате взрыва. |
| videoFramesDiscarded | Очень похож на **videoFramesSkipped**, но причина для отбрасываются в том, что кадр пришел в так поздно, что он не может даже быть коррелированы с любой ожидающего позы больше. Если это произойдет, есть некоторые серьезные сетевые разногласия.|
| видеоFrameMinDelta | Минимальное количество времени между двумя последовательными кадрами, прибывающими в течение последней секунды. Вместе с videoFrameMaxDelta, этот диапазон дает указание на испуг, вызванный либо сети или видео кодека. |
| видеоFrameMaxDelta | Максимальное количество времени между двумя последовательными кадрами, прибывающими в течение последней секунды. Вместе с videoFrameMinDelta, этот диапазон дает указание на испуг, вызванный либо сетью или видео кодек. |

Сумма всех значений задержки, как правило, намного больше, чем доступное время кадра в 60 Гц. Это нормально, потому что несколько кадров находятся в полете параллельно, и новые запросы кадра стартуют с желаемой частотой кадров, как показано на иллюстрации. Однако, если задержка становится слишком большой, это влияет на качество [поздней стадии репроекции,](../../overview/features/late-stage-reprojection.md)и может поставить под угрозу общий опыт.

`videoFramesReceived`, `videoFrameReusedCount`и `videoFramesDiscarded` может быть использован для оценки производительности сети и сервера. Если `videoFramesReceived` он `videoFrameReusedCount` низкий и высокий, это может указывать на перегрузку сети или низкую производительность сервера. Высокое `videoFramesDiscarded` значение также указывает на перегрузку сети.

Наконец,`timeSinceLastPresent` `videoFrameMinDelta`, `videoFrameMaxDelta` , и дать представление о дисперсии входящих видео кадров и местных вызовов настоящее время. Высокая дисперсия означает нестабильную частоту кадров.

Ни одно из приведенных выше значений не дает четкого указания на чистую задержку сети (красные стрелки на иллюстрации), поскольку точное время, когда сервер занят визуализацией, должно быть вычтено из значения `latencyPoseToReceive`туда и обратно. Часть юаней на стороне сервера — это информация, недоступная клиенту. Однако в следующем пункте объясняется, как это значение приближается `networkLatency` к дополнительным входным данным с сервера и подвергается воздействию значения.

## <a name="performance-assessment-queries"></a>Запросы оценки производительности

*Запросы оценки производительности* предоставляют более подробную информацию о рабочей нагрузке процессора и графического процессора на сервере. Поскольку данные запрашиваются с сервера, запрос моментального снимка производительности следует обычному шаблону async:

``` cs
PerformanceAssessmentAsync _assessmentQuery = null;

void QueryPerformanceAssessment(AzureSession session)
{
    _assessmentQuery = session.Actions.QueryServerPerformanceAssessmentAsync();
    _assessmentQuery.Completed += (PerformanceAssessmentAsync res) =>
    {
        // do something with the result:
        PerformanceAssessment result = res.Result;
        // ...

        _assessmentQuery = null;
    };
}
```

В отличие `FrameStatistics` от `PerformanceAssessment` объекта, объект содержит информацию о сервере:

| Участник | Объяснение |
|:-|:-|
| timeCPU | Среднее время процессора сервера на кадр в миллисекундах |
| timeGPU | Среднее время графического процессора сервера на кадр в миллисекундах |
| использованиеCPU | Общее использование процессора сервера в процентах |
| использованиеГПУ | Общее использование GPU сервера в процентах |
| MemoryCPU | Общее использование основной памяти сервера в процентах |
| памятьГПУ | Общее использование выделенной видеопамяти в процентах графического процессора сервера |
| сетевойЛатенция | Приблизительная средняя задержка сети туда и обратно в миллисекундах. На рисунке выше, это соответствует сумме красных стрел. Значение вычисляется путем вычитания фактического `latencyPoseToReceive` времени `FrameStatistics`рендеринга сервера из значения. Хотя это приближение не является точным, оно дает некоторое представление о задержке сети, изолированной от значений задержки, вычисляемых на клиенте. |
| polygonsRendered | Количество треугольников, отображаемых в одном кадре. Это число также включает треугольники, которые отбираются позже во время рендеринга. Это означает, что это число не сильно меняется в разных позициях камеры, но производительность может сильно варьироваться, в зависимости от скорости выбраковки треугольника.|

Чтобы помочь вам оценить значения, каждая часть поставляется с классификацией качества, как **Великий**, **Хороший**, **Посредственный**, или **Плохо**.
Эта метрика оценки дает примерное представление о работоспособности сервера, но она не должна рассматриваться как абсолютная. Например, предположим, что вы видите 'посредственный' счет для времени GPU. Он считается посредственным, потому что он приближается к пределу для общего бюджета времени кадра. В вашем случае, однако, это может быть хорошим значением, тем не менее, потому что вы визуализации сложной модели.

## <a name="statistics-debug-output"></a>Статистический отлив выход

Класс `ARRServiceStats` обертывает как статистику кадров, так и запросы оценки производительности и обеспечивает удобную функциональность для возврата статистики в виде агрегированных значений или в качестве предварительно построенной строки. Следующий код — это самый простой способ отображить статистику сервера в клиентском приложении.

``` cs
ARRServiceStats _stats = null;

void OnConnect()
{
    _stats = new ARRServiceStats();
}

void OnDisconnect()
{
    _stats = null;
}

void Update()
{
    if (_stats != null)
    {
        // update once a frame to retrieve new information and build average values
        _stats.Update(Service.CurrentActiveSession);

        // retrieve a string with relevant stats information
        InfoLabel.text = _stats.GetStatsString();
    }
}
```

Приведенный выше код заполняет текстовую метку следующим текстом:

![Выход строки ArrServiceStats](./media/arr-service-stats.png)

`GetStatsString` API форматирует строку всех значений, но каждое отдельное значение также `ARRServiceStats` может быть запрошено программно из экземпляра.

Существуют также варианты членов, которые агрегируют значения с течением времени. Смотрите членов с `*Avg`суффиксом , `*Max`или `*Total`. Участник `FramesUsedForAverage` указывает, сколько кадров было использовано для этой агрегации.

## <a name="next-steps"></a>Дальнейшие действия

* [Создание следов производительности](../../how-tos/performance-tracing.md)
* [Настройка преобразования модели](../../how-tos/conversion/configure-model-conversion.md)
