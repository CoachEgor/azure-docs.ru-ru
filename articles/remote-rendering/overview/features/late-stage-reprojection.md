---
title: Перепроецирование на позднем этапе
description: Сведения о перепроецировании с поздним этапом и его использовании.
author: sebastianpick
ms.author: sepick
ms.date: 02/04/2020
ms.topic: article
ms.openlocfilehash: 4aa1148e544ff3451aa1cb956bc4a5fb932b9611
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "80680990"
---
# <a name="late-stage-reprojection"></a>Перепроецирование на позднем этапе

Перенастройка с *поздним этапом* (ЛСР) — это аппаратная функция, которая помогает стабилизировать голограммы при перемещении пользователя.

Статические модели должны визуально поддерживать свое положение при перемещении вокруг них. Если они выглядят нестабильными, это поведение может быть указано в ЛСР проблемах. Обратите внимание, что дополнительные динамические преобразования, такие как анимации или представления развертывания, могут маскировать это поведение.

Вы можете выбрать один из двух различных режимов ЛСР, а именно: **плоская ЛСР** или **Depth ЛСР**. Один из активных определяется тем, отправляет ли клиентское приложение буфер глубины.

Оба режима ЛСР улучшают стабильность, хотя они имеют свои уникальные ограничения. Начните с попыток глубины ЛСР, так как это может дать лучшие результаты в большинстве случаев.

## <a name="choose-lsr-mode-in-unity"></a>Выбор режима ЛСР в Unity

В редакторе Unity выберите *файл > параметры сборки*. Выберите *Параметры проигрывателя* в левом нижнем углу, а затем в разделе *Параметры проигрывателя > XR > пакеты sdk виртуальной реальности > Windows Mixed Reality* установите флажок **включить общий доступ к буферу глубины** :

![Флаг включения общего доступа к буферу глубины](./media/unity-depth-buffer-sharing-enabled.png)

Если это так, приложение будет использовать глубину ЛСР, в противном случае будет использоваться плоская ЛСР.

## <a name="depth-lsr"></a>ЛСР глубины

Чтобы ЛСР Depth, клиентское приложение должно предоставить допустимый буфер глубины, который содержит всю соответствующую геометрию, которую необходимо рассмотреть во время ЛСР.

Глубина ЛСР пытается стабилизировать видеокадр на основе содержимого заданного буфера глубины. Как следствие, содержимое, которое не было визуализировано, например прозрачные объекты, не может быть скорректировано ЛСР и может показывать нестабильность и репроектные артефакты.

## <a name="planar-lsr"></a>Плоская ЛСР

Плоская ЛСР не содержит сведений о глубине в пикселях, как это делает ЛСР глубины. Вместо этого выполняется перепроецирование всего содержимого на плоскости, которую необходимо предоставить каждому кадру.

Плоская ЛСР. репроецирование этих объектов лучше, близко к представленной плоскости. Чем дальше объект, тем более нестабильнее он будет выглядеть. Хотя ЛСР глубины лучше при перепроецировании объектов с различной глубиной, плоская ЛСР может улучшить качество содержимого с помощью плоскости.

### <a name="configure-planar-lsr-in-unity"></a>Настройка плоского ЛСР в Unity

Параметры плоскости являются производными от так называемой *фокусной точкой*, которую необходимо предоставить для каждого кадра `UnityEngine.XR.WSA.HolographicSettings.SetFocusPointForFrame`. Дополнительные сведения см. в разделе [API точки фокусировки Unity](https://docs.microsoft.com/windows/mixed-reality/focus-point-in-unity) . Если не задать точку фокусировки, будет выбрана резервная стратегия. Однако автоматическое резервное восстановление часто приводит к неоптимальным результатам.

Вы можете вычислить фокусную точку самостоятельно, хотя это может иметь смысл основываться на том, который вычисляется узлом удаленной отрисовки. Вызовите метод `RemoteManagerUnity.CurrentSession.GraphicsBinding.GetRemoteFocusPoint` , чтобы получить. Вам будет предложено указать кадр координат, в котором будет выражаться фокусная точка. В большинстве случаев вы просто хотите предоставить результат `UnityEngine.XR.WSA.WorldManager.GetNativeISpatialCoordinateSystemPtr` отсюда.

Как правило, клиент и узел отображают содержимое, которое не знает другая сторона, например элементы пользовательского интерфейса на клиенте. Таким образом, может иметь смысл объединить удаленную точку фокусировки с локально вычисленным.

Точки фокусировки, вычисленные в двух последовательных кадрах, могут сильно отличаться. Простое использование их "как есть" может привести к появлению голограмм. Чтобы предотвратить такое поведение, рекомендуется выполнить интерполяцию между предыдущей и текущей точками фокусировки.

## <a name="next-steps"></a>Дальнейшие шаги

* [Запросы данных о производительности на стороне сервера](performance-queries.md)
