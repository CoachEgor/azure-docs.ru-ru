---
title: Перепроекция на поздний этап
description: Информация о поздней стадии репроекции и о том, как ее использовать.
author: sebastianpick
ms.author: sepick
ms.date: 02/04/2020
ms.topic: article
ms.openlocfilehash: 4aa1148e544ff3451aa1cb956bc4a5fb932b9611
ms.sourcegitcommit: 642a297b1c279454df792ca21fdaa9513b5c2f8b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80680990"
---
# <a name="late-stage-reprojection"></a>Перепроекция на поздний этап

*Поздняя перепроекция* (LSR) — это аппаратная функция, которая помогает стабилизировать голограммы при движении пользователя.

Статические модели, как ожидается, визуально сохранить свои позиции, когда вы перемещаетесь вокруг них. Если они кажутся нестабильными, такое поведение может намекнуть на проблемы ЛСР. Имейте в виду, что дополнительные динамические преобразования, такие как анимация или представления о взрыве, могут замаскировать это поведение.

Вы можете выбрать между двумя различными режимами ЛСР, а именно **Planar LSR** или **Depth LSR.** Какой из них активен, определяется ли клиентское приложение отправкой буфера глубины.

Оба режима ЛСР улучшают стабильность голограммы, хотя они имеют свои отличительные ограничения. Начните с попытки Глубина ЛСР, как это, возможно, дает лучшие результаты в большинстве случаев.

## <a name="choose-lsr-mode-in-unity"></a>Выберите режим LSR в Unity

В редакторе Unity перейдите в *настройки файлов > сборки.* Выберите *настройки игрока* в левом нижнем углу, а затем проверьте под *настройками > XR > SDK виртуальной реальности > Windows Смешанная реальность* ли **проверка включения глубины буфера:**

![Флаг обмена буфером глубины](./media/unity-depth-buffer-sharing-enabled.png)

Если это так, ваше приложение будет использовать Глубина ЛСР, в противном случае он будет использовать Planar LSR.

## <a name="depth-lsr"></a>Глубина ЛСР

Для работы Depth LSR клиентское приложение должно предоставить действительный буфер глубины, содержащий всю соответствующую геометрию, которую следует учитывать во время LsR.

Глубина ЛСР пытается стабилизировать видеокадр на основе содержимого поставляемого буфера глубины. Как следствие, содержимое, которое не было отображено к нему, например прозрачные объекты, не может быть скорректировано ЛСР и может отображать нестабильность и артефакты репроекции.

## <a name="planar-lsr"></a>Планар ЛСР

Planar LSR не имеет информации о глубине на пиксель, как это делает Depth LSR. Вместо этого он перепроектирует все содержимое на основе плоскости, которую вы должны предоставить каждый кадр.

Planar LSR перепроектирует те объекты, которые лучше всего лежат рядом с поставленной плоскостью. Чем дальше объект, тем нестабильнее он будет выглядеть. В то время как Depth LSR лучше перепроектировать объекты на разных глубинах, Planar LSR может лучше работать для содержания, хорошо выравнивающегося с плоскостью.

### <a name="configure-planar-lsr-in-unity"></a>Налаживание планар ЛСР в единстве

Параметры плоскости являются производными от так называемой *точки фокусировки,* которую вы должны обеспечить каждый кадр через. `UnityEngine.XR.WSA.HolographicSettings.SetFocusPointForFrame` Подробнее о ней читайте [в аиСтерте "Точка фокуса единства".](https://docs.microsoft.com/windows/mixed-reality/focus-point-in-unity) Если вы не установите точку фокусировки, для вас будет выбран запасной запас. Однако автоматическое резервное копирование часто приводит к неоптимальным результатам.

Вы можете вычислить точку фокусировки самостоятельно, хотя, возможно, имеет смысл основывать ее на том, который рассчитывается хостом удаленного рендеринга. Звоните, `RemoteManagerUnity.CurrentSession.GraphicsBinding.GetRemoteFocusPoint` чтобы получить это. Вас просят предоставить координатную рамку, в которой можно выразить точку фокусировки. В большинстве случаев, вы просто хотите, чтобы обеспечить результат отсюда. `UnityEngine.XR.WSA.WorldManager.GetNativeISpatialCoordinateSystemPtr`

Обычно как клиент, так и хост визуализировать содержимое, о чем не знает другая сторона, например элементы uI на клиенте. Поэтому, возможно, имеет смысл объединить удаленную точку фокусировки с локально рассчитанной.

Точки фокусировки, рассчитанные в двух последовательных кадрах, могут быть совершенно разными. Простое использование их как есть может привести к голограммы, как представляется, прыгать вокруг. Чтобы предотвратить такое поведение, рекомендуется интерполировать между предыдущими и текущими точками фокусировки.

## <a name="next-steps"></a>Дальнейшие действия

* [Запросы производительности сервера](performance-queries.md)
