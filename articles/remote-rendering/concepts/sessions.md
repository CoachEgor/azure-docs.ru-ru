---
title: Сеансы удаленного рендеринга
description: Описывает, что такое сеанс удаленного рендеринга
author: jakrams
ms.author: jakras
ms.date: 02/21/2020
ms.topic: conceptual
ms.openlocfilehash: 91a59e1398bf5e68799ad16a20dfb824904edc8a
ms.sourcegitcommit: 642a297b1c279454df792ca21fdaa9513b5c2f8b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80681692"
---
# <a name="remote-rendering-sessions"></a>Сеансы удаленного рендеринга

В Azure Remote Rendering (ARR) *сеанс* является ключевой концепцией. В этой статье объясняется, что именно такое сеанс.

## <a name="overview"></a>Обзор

Дистанционное рендерирование Azure работает при разгрузке сложных задач в облаке. Эти задачи рендеринга не могут быть выполнены только любым сервером, так как большинство облачных серверов не имеют графических процессоров. Из-за большого объема данных и жесткого требования к производству результатов при интерактивных частотах кадров, ответственность, которую обрабатывает сервер, который обрабатывает пользователь, также не может быть передана другой машине на лету, как это возможно для более общего веб-трафика.

Это означает, что при использовании удаленного рендеринга Azure облачный сервер с необходимыми аппаратными возможностями должен быть зарезервирован исключительно для обработки запросов рендеринга. *Сеанс* относится ко всему, что связано с взаимодействием с этим сервером. Она начинается с первоначального запроса на резервирование *(аренда*) машины для вашего использования, продолжается со всеми командами для загрузки и манипулирования моделями, и заканчивается выпуском аренды на облачном сервере.

## <a name="managing-sessions"></a>Управление сеансами

Существует несколько способов управления сеансами и взаимодействия с ней. Независитй от языка способ создания, обновления и закрытия сеансов — это время через [aPI управления сеансами REST.](../how-tos/session-rest-api.md) В C и C , эти операции подвергаются через классы `AzureFrontend` и `AzureSession`. Для приложений Unity существуют дополнительные `ARRServiceUnity` функции утилиты, предоставляемые компонентом.

После *подключения* к активной сессии операции, такие как [загрузка моделей](models.md) и взаимодействие со сценой, подвергаются воздействию `AzureSession` класса.

### <a name="managing-multiple-sessions-simultaneously"></a>Управление несколькими сеансами одновременно

Полностью *подключиться* к нескольким сеансам с одного устройства невозможно. Тем не менее, вы можете создавать, наблюдать и закрывать столько сеансов, сколько захотите из одного приложения. До тех пор, пока приложение не предназначено для подключения к сеансу, ему не нужно работать на устройстве, как HoloLens 2, либо. Обоснование использования такой реализации может быть, если вы хотите контролировать сеансы через центральный механизм. Например, можно создать веб-приложение, в котором можно войти в приложение, в котором можно войти в приложение holoLenses. Затем приложение может отображать параметры на планшетах, например, какую модель CAD для отображения. Если пользователь делает выбор, эта информация передается всем HoloLenses для создания общего опыта.

## <a name="session-phases"></a>Этапы сеанса

Каждая сессия проходит несколько этапов.

### <a name="session-startup"></a>Запуск сессии

Когда вы просите ARR [создать новую сессию,](../how-tos/session-rest-api.md#create-a-session)первое, что он делает, это возвращает сеанс [UUID.](https://en.wikipedia.org/wiki/Universally_unique_identifier) Этот UUID позволяет задать запрос информации о сеансе. UUID и некоторые основные сведения о сеансе сохраняются в течение 30 дней, так что вы можете запросить эту информацию даже после того, как сеанс был остановлен. На этом этапе **состояние сеанса** будет сообщено как **Начало.**

Далее удаленная визуализация Azure пытается найти сервер, который может провести сеанс. Есть два параметра для этого поиска. Во-первых, он будет резервировать только серверы в вашем [регионе.](../reference/regions.md) Это потому, что задержка сети в разных регионах может быть слишком высокой, чтобы гарантировать достойный опыт. Вторым фактором является желаемый *размер,* который вы указали. В каждом регионе имеется ограниченное количество серверов, которые могут выполнять запрос *Standard* или *Premium.* Следовательно, если все серверы запрашиваемого размера в настоящее время используются в вашем регионе, создание сеанса завершится неудачей. Причина сбоя [может быть запрошена.](../how-tos/session-rest-api.md#get-sessions-properties)

> [!IMPORTANT]
> Если вы запрашиваете *стандартный* размер VM и запрос не удается из-за высокого спроса, это не означает, что запрос сервера *Premium* также не удастся. Так что если это вариант для вас, вы можете попробовать вернуться к *Premium* VM.

Когда служба находит подходящий сервер, она должна скопировать на него подходящую виртуальную машину (VM), чтобы превратить ее в хост удаленного рендеринга Azure. Этот процесс занимает несколько минут. После этого VM загружается и **состояние сеанса** переходит в **Ready.**

На данный момент сервер ожидает ввода исключительно. Это также точка, с которой вы получите счет за услугу.

### <a name="connecting-to-a-session"></a>Подключение к сеансу

Как только сеанс *будет готов,* вы можете *подключиться* к нему. При подключении устройство может отправлять команды для загрузки и модификации моделей. Каждый хост ARR обслуживает только одно клиентское устройство одновременно, поэтому, когда клиент подключается к сеансу, он имеет эксклюзивный контроль над отрисованный контент. Это также означает, что производительность рендеринга никогда не будет меняться по причинам, не зависящих от вас.

> [!IMPORTANT]
> Хотя только один клиент может *подключиться* к сеансу, базовая информация о сеансах, например их текущее состояние, может быть запрошена без подключения.

В то время как устройство подключено к сеансу, попытки других устройств подключиться зайдут из строя. Однако, как только подключенное устройство отключается добровольно или из-за какого-либо сбоя, сеанс принимает другой запрос на подключение. Все предыдущее состояние (загруженные модели и т.п.) отбрасывается таким образом, что следующее соединительное устройство получает чистый лист. Таким образом, сеансы могут быть повторно использованы много раз, на разных устройствах, и это может быть возможно, чтобы скрыть накладные расходы запуска сессии от конечном пользователя в большинстве случаев.

> [!IMPORTANT]
> Удаленный сервер никогда не изменяет состояние данных на стороне клиента. Все мутации данных (например, обновления преобразования и запросы на нагрузку) должны выполняться клиентским приложением. Все действия немедленно обновляют состояние клиента.

### <a name="session-end"></a>Окончание сессии

При запросе нового сеанса указано *максимальное время аренды,* обычно в диапазоне от одного до восьми часов. Это продолжительность, в течение которой хост будет принимать ваш вход.

Есть две регулярные причины для сессии до конца. Либо вы вручную требуете, чтобы сеанс был остановлен, либо истечет максимальный срок аренды. В обоих случаях любое активное подключение к хосту сразу закрывается, и служба закрывается на этом сервере. Затем сервер возвращается в пул Azure и может быть реквизирован для других целей. Остановка сеанса не может быть отменена или отменена. Запрос состояния **сеанса** на остановленном сеансе либо **возвращается остановленным,** либо **просроченным,** в зависимости от того, был ли он закрыт вручную или потому, что было достигнуто максимальное время аренды.

Сеанс также может быть остановлен из-за некоторого сбоя.

Во всех случаях, вы не будете выставлен счет дальше, как только сеанс остановлен.

> [!WARNING]
> Подключение к сеансу и длительное время не влияет на выставление счетов. То, что вы платите за услугу, зависит от *продолжительности сеанса,* это означает время, которое сервер зарезервирован исключительно для вас, и запрашиваемых аппаратных возможностей (размер VM). Если вы начинаете сеанс, подключаетесь в течение пяти минут, а затем не прекращаете сеанс, чтобы он продолжает работать до истечения срока аренды, вам будет выставлен счет за полное время аренды сеанса. И наоборот, *максимальное время аренды* в основном является страховой сеткой. Не имеет значения, запрашиваете ли вы сеанс со временем аренды в восемь часов, а затем используете его только в течение пяти минут, если вы вручную прекратите сеанс после этого.

#### <a name="extend-a-sessions-lease-time"></a>Продление времени аренды сеанса

Вы можете [продлить время аренды](../how-tos/session-rest-api.md#update-a-session) активного сеанса, если выяснится, что он вам нужен дольше.

## <a name="example-code"></a>Пример кода

Приведенный ниже код показывает простую реализацию запуска сеанса, ожидания *готового* состояния, подключения, а затем отключения и снова выключения.

``` cs
RemoteRenderingInitialization init = new RemoteRenderingInitialization();
// fill out RemoteRenderingInitialization parameters...

RemoteManagerStatic.StartupRemoteRendering(init);

AzureFrontendAccountInfo accountInfo = new AzureFrontendAccountInfo();
// fill out accountInfo details...

AzureFrontend frontend = new AzureFrontend(accountInfo);

RenderingSessionCreationParams sessionCreationParams = new RenderingSessionCreationParams();
// fill out sessionCreationParams...

AzureSession session = await frontend.CreateNewRenderingSessionAsync(sessionCreationParams).AsTask();

RenderingSessionProperties sessionProperties;
while (true)
{
    sessionProperties = await session.GetPropertiesAsync().AsTask();
    if (sessionProperties.Status != RenderingSessionStatus.Starting &&
        sessionProperties.Status != RenderingSessionStatus.Unknown)
    {
        break;
    }
}

if (sessionProperties.Status != RenderingSessionStatus.Ready)
{
    // Do some error handling and either terminate or retry.
}

// Connect to server
Result connectResult = await session.ConnectToRuntime(new ConnectToRuntimeParams()).AsTask();

// Connected!

while(...)
{
    // per frame update

    session.Actions.Update();
}

// Disconnect
session.DisconnectFromRuntime();

// stop the session
await session.StopAsync().AsTask();

// shut down the remote rendering SDK
RemoteManagerStatic.ShutdownRemoteRendering();
```

`AzureFrontend` Несколько `AzureSession` экземпляров и экземпляров можно поддерживать, манипулировать и запрашивать из кода. Но только одно устройство может `AzureSession` подключиться к одновременному.

Срок службы виртуальной машины не `AzureFrontend` привязан к `AzureSession` экземпляру или экземпляру. `AzureSession.StopAsync`должны быть вызваны, чтобы остановить сессию.

Постоянный идентификатор `AzureSession.SessionUUID()` сеанса можно запрашивать через и кэшировать локально. С помощью этого идентификатора приложение может вызвать `AzureFrontend.OpenSession` привязку к этой сессии.

Когда `AzureSession.IsConnected` это `AzureSession.Actions` верно, возвращает `RemoteManager`экземпляр , который содержит функции для [загрузки моделей,](models.md)манипулировать [объектами](entities.md)и [запросинформации информации](../overview/features/spatial-queries.md) о отображенной сцене.

## <a name="next-steps"></a>Дальнейшие действия

* [Entities](entities.md)
* [Модели](models.md)
