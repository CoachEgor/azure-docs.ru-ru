---
title: Сеансы Удаленной отрисовки
description: Описание сеанса Удаленной отрисовки.
author: jakrams
ms.author: jakras
ms.date: 02/21/2020
ms.topic: conceptual
ms.custom: devx-track-csharp
ms.openlocfilehash: 8f2adc846247c4f06c9356f482501fd01c5463bf
ms.sourcegitcommit: 957c916118f87ea3d67a60e1d72a30f48bad0db6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2020
ms.locfileid: "92202690"
---
# <a name="remote-rendering-sessions"></a>Сеансы Удаленной отрисовки

В Удаленной отрисовке Azure (ARR) *сеанс* является ключевым понятием. В этой статье объясняется, что такое сеанс.

## <a name="overview"></a>Обзор

Удаленная отрисовка Azure разгружает сложные задачи отрисовки в облако. Эти задачи отрисовки не могут быть выполнены любым сервером, так как в большинстве облачных серверов отсутствует GPU. Ввиду объема задействованных данных и жесткого требования получать результаты с интерактивной частотой кадров ответственность за то, какой сервер обрабатывает запрос того или иного пользователя, также не может перекладываться на другой компьютер в реальном времени, как это допускается для более универсального интернет-трафика.

Это означает, что при использовании Удаленной отрисовки Azure облачный сервер с необходимыми возможностями оборудования должен быть зарезервирован исключительно для обработки запросов отрисовки. К *сеансу* относится все, что участвует во взаимодействии с этим сервером. Он начинается с начального запроса на резервирование (*аренду*) компьютера, затем выполняются все команды для загрузки и обработки моделей, а завершается сеанс освобождением аренды на облачном сервере.

## <a name="managing-sessions"></a>Управление сеансами

Существует несколько способов управления сеансами и взаимодействия с ними. Независимый от языка способ создания, обновления и завершения сеансов основывается на [REST API управления сеансами](../how-tos/session-rest-api.md). В C# и C++ эти операции предоставляются через классы `AzureFrontend` и `AzureSession`. Для приложений Unity существуют дополнительные служебные функции, предоставляемые компонентом `ARRServiceUnity`.

После *подключения* к активному сеансу такие операции, как [загрузка моделей](models.md) и взаимодействие с ними, предоставляются через класс `AzureSession`.

### <a name="managing-multiple-sessions-simultaneously"></a>Одновременное управление несколькими сеансами

Невозможно полностью *подключиться* к нескольким сеансам с одного устройства. Тем не менее вы можете создавать, отслеживать и завершать любое количество сеансов из одного приложения. Если приложению не нужно подключаться к сеансу, его не нужно запускать на таком устройстве, как HoloLens 2. Такой вариант использования может быть реализован в том случае, если требуется управлять сеансами с помощью централизованного механизма. Например, можно создать веб-приложение, в котором несколько планшетов и устройств HoloLens могут войти в систему. Затем приложение может отображать на планшетах параметры, например для выбора отображаемой модели САПР. Если пользователь сделает выбор, эти сведения передаются на все устройства HoloLens для создания общего интерфейса.

## <a name="session-phases"></a>Этапы сеанса

Каждый сеанс проходит несколько этапов.

### <a name="session-startup"></a>Запуск сеанса

Когда вы указываете ARR [создать новый сеанс](../how-tos/session-rest-api.md#create-a-session), первым делом эта служба возвращает [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) сеанса. Этот UUID позволяет запрашивать сведения о сеансе. UUID и некоторые основные сведения о сеансе сохраняются в течение 30 дней, поэтому эти данные можно запросить даже после остановки сеанса. На этом этапе **состоянием сеанса** будет **Запуск**.

Затем Удаленная отрисовка Azure пытается найти сервер, на котором можно разместить ваш сеанс. Для этого поиска используются два параметра. Во-первых, будут резервироваться серверы только в вашем [регионе](../reference/regions.md). Это обусловлено тем, что задержка в сети между регионами может быть слишком высокой, чтобы гарантировать приемлемый результат. Второй фактор — требуемый *размер*, который вы указали. В каждом регионе существует ограниченное количество серверов, которые могут выполнить запрос размера уровня " [*стандартный*](../reference/vm-sizes.md) " или " [*премиум*](../reference/vm-sizes.md) ". Следовательно, если все серверы запрошенного размера в вашем регионе в настоящее время используются, создание сеанса завершится ошибкой. Причину сбоя [можно запросить](../how-tos/session-rest-api.md#get-sessions-properties).

> [!IMPORTANT]
> Если вы запрашиваете *стандартный* Размер сервера и запрос завершается сбоем из-за высокого спроса, это не означает, что запрос сервера *Premium* также завершится сбоем. Поэтому, если это возможность, можно попробовать вернуться к размеру сервера *Premium* .

Когда служба находит подходящий сервер, ей нужно скопировать на него соответствующую виртуальную машину, чтобы превратить этот сервер в узел Удаленной отрисовки Azure. Этот процесс занимает несколько минут. После этого виртуальная машина загрузится, а **состояние сеанса** изменится на **Готово**.

На этом этапе сервер находится в режиме ожидания входных данных. Именно на этом этапе начинает взиматься плата за службу.

### <a name="connecting-to-a-session"></a>Подключение к сеансу

Когда сеанс *готов*, к нему можно *подключиться*. После подключения устройство может отправлять команды для загрузки и изменения моделей. Каждый узел ARR одновременно обслуживает только одно клиентское устройство, поэтому, когда клиент подключается к сеансу, он имеет монопольный контроль над отрисованным содержимым. Это также означает, что производительность отрисовки не будет изменяться по неподвластным вам причинам.

> [!IMPORTANT]
> Хотя к сеансу может *подключиться* только один клиент, основные сведения о сеансе, например его текущее состояние, можно запросить без подключения.

Пока устройство подключено к сеансу, попытки других устройств подключиться будут завершаться сбоем. Однако после отключения подключенного устройства (самостоятельного или из-за какого-либо сбоя) сеанс примет другой запрос на подключение. Все предыдущие состояния (загруженные модели и т. д.) отменяются, чтобы при следующем подключении устройства сеанс был очищен. Таким образом, сеансы можно многократно использовать с помощью разных устройств. Кроме того, в большинстве случаев можно скрыть дополнительные временные затраты на запуск сеанса от пользователя.

> [!IMPORTANT]
> Удаленный сервер никогда не изменяет состояние данных на стороне клиента. Все изменения данных (например, обновление преобразований и запросы на загрузку) должны выполняться клиентским приложением. Все действия немедленно обновляют состояние клиента.

### <a name="session-end"></a>Окончание сеанса

При запросе нового сеанса указывается *максимальный срок аренды*, обычно в диапазоне от 1 до 8 часов. Это время, в течение которого узел будет принимать ваши входные данные.

Существуют две распространенные причины завершения сеанса. Либо вы вручную запрашиваете остановку сеанса, либо истекает максимальный срок аренды. В обоих случаях все активные подключения к узлу мгновенно закрываются и служба завершает работу на этом сервере. Затем сервер возвращается в пул Azure и может использоваться для других задач. Остановку сеанса невозможно откатить или отменить. Запрос **состояния** остановленного сеанса вернет значение **Остановлено** или **Просрочено** в зависимости от того, был ли сеанс завершен вручную или истек его максимальный срок аренды.

Сеанс также может быть остановлен из-за какого-либо сбоя.

Во всех случаях после остановки сеанса плата уже не взымается.

> [!WARNING]
> Факты подключения к сеансу и их длительность не влияют на выставление счетов. Плата за службу зависит от *длительности сеанса*, что означает время, в течение которого сервер зарезервирован исключительно для вас и требуемые возможности оборудования ( [выделенный размер](../reference/vm-sizes.md)). Если вы запустили сеанс, подключились на пять минут, а затем не остановили сеанс, и он работал до истечения срока аренды, вам будет выставлен счет за полный срок аренды сеанса. И наоборот, *максимальный срок аренды* — это страховка. Не имеет значения, запросили ли вы сеанс со сроком аренды в восемь часов, а затем использовали его только пять минут, если затем вы вручную остановили этот сеанс.

#### <a name="extend-a-sessions-lease-time"></a>Продление срока аренды сеанса

Вы можете [продлить срок аренды](../how-tos/session-rest-api.md#modify-and-query-session-properties) активного сеанса, если это необходимо.

## <a name="example-code"></a>Пример кода

В приведенном ниже коде показана простая реализация запуска сеанса, ожидания состояния *готовности*, подключения, а затем отключения и завершения.

```cs
RemoteRenderingInitialization init = new RemoteRenderingInitialization();
// fill out RemoteRenderingInitialization parameters...

RemoteManagerStatic.StartupRemoteRendering(init);

AzureFrontendAccountInfo accountInfo = new AzureFrontendAccountInfo();
// fill out accountInfo details...

AzureFrontend frontend = new AzureFrontend(accountInfo);

RenderingSessionCreationParams sessionCreationParams = new RenderingSessionCreationParams();
// fill out sessionCreationParams...

AzureSession session = await frontend.CreateNewRenderingSessionAsync(sessionCreationParams).AsTask();

RenderingSessionProperties sessionProperties;
while (true)
{
    sessionProperties = await session.GetPropertiesAsync().AsTask();
    if (sessionProperties.Status != RenderingSessionStatus.Starting &&
        sessionProperties.Status != RenderingSessionStatus.Unknown)
    {
        break;
    }
    // REST calls must not be issued too frequently, otherwise the server returns failure code 429 ("too many requests"). So we insert the recommended delay of 10s
    await Task.Delay(TimeSpan.FromSeconds(10));
}

if (sessionProperties.Status != RenderingSessionStatus.Ready)
{
    // Do some error handling and either terminate or retry.
}

// Connect to server
Result connectResult = await session.ConnectToRuntime(new ConnectToRuntimeParams()).AsTask();

// Connected!

while(...)
{
    // per frame update

    session.Actions.Update();
}

// Disconnect
session.DisconnectFromRuntime();

// stop the session
await session.StopAsync().AsTask();

// shut down the remote rendering SDK
RemoteManagerStatic.ShutdownRemoteRendering();
```

Код может осуществлять обслуживание, обработку и выполнение запросов для нескольких экземпляров `AzureFrontend` и `AzureSession`. Но только одно устройство может одновременно подключаться к `AzureSession`.

Время существования виртуальной машины не привязано к экземпляру `AzureFrontend` или `AzureSession`. Для завершения сеанса необходимо вызвать `AzureSession.StopAsync`.

Постоянный идентификатор сеанса можно запросить с помощью `AzureSession.SessionUUID()` и сохранить в локальный кэш. С помощью этого идентификатора приложение может вызвать `AzureFrontend.OpenSession` для привязки к этому сеансу.

Если `AzureSession.IsConnected` имеет значение true, то `AzureSession.Actions` возвращает экземпляр `RemoteManager`, который содержит функции, позволяющие [загружать модели](models.md), управлять [сущностями](entities.md) и [запрашивать сведения](../overview/features/spatial-queries.md) об отрисованной сцене.

## <a name="api-documentation"></a>Документирование API

* [Класс C# Азуресессион](/dotnet/api/microsoft.azure.remoterendering.azuresession)
* [C# Азурефронтенд. Креатеневрендерингсессионасинк ()](/dotnet/api/microsoft.azure.remoterendering.azurefrontend.createnewrenderingsessionasync)
* [C# Азурефронтенд. Опенрендерингсессион ()](/dotnet/api/microsoft.azure.remoterendering.azurefrontend.openrenderingsession)
* [Класс C++ Азуресессион](/cpp/api/remote-rendering/azuresession)
* [C++ Азурефронтенд:: Креатеневрендерингсессионасинк](/cpp/api/remote-rendering/azurefrontend#createnewrenderingsessionasync)
* [C++ Азурефронтенд:: Опенрендерингсессион](/cpp/api/remote-rendering/azurefrontend#openrenderingsession)

## <a name="next-steps"></a>Дальнейшие действия

* [Сущности](entities.md)
* [Модели](models.md)