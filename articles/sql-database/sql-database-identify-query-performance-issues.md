---
title: Типы проблем с производительностью запросов в базе данных Azure S'L
description: В этой статье узнайте о типах проблем производительности запросов в базе данных Azure S'L, а также узнайте, как определить и разрешить запросы с этими проблемами
services: sql-database
ms.service: sql-database
ms.subservice: performance
ms.custom: ''
ms.devlang: ''
ms.topic: conceptual
author: jovanpop-msft
ms.author: jovanpop
ms.reviewer: jrasnick, carlrab
ms.date: 03/10/2020
ms.openlocfilehash: e155321c2727bf4ee871ef7be7b61b6a523ec1fc
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79256137"
---
# <a name="detectable-types-of-query-performance-bottlenecks-in-azure-sql-database"></a>Обнаруживаемые типы узких мест производительности запроса в базе данных Azure S'L

При попытке разрешить узкое место производительности начните с определения того, происходит ли узкое место во время выполнения запроса в запущенном состоянии или в состоянии ожидания. Различные резолюции применяются в зависимости от этого определения. Используйте следующую диаграмму, чтобы помочь понять факторы, которые могут вызвать либо проблемы, связанные с запуском, либо проблемы, связанные с ожиданием. В этой статье рассматриваются проблемы и решения, связанные с каждым типом проблемы.

Для обнаружения этих типов узких мест в производительности можно использовать интеллектуальные исследования данных по интеллектуальным анализам на [серверах](sql-database-intelligent-insights-troubleshoot-performance.md#detectable-database-performance-patterns) Лазурного вида или [DMV](sql-database-monitoring-with-dmvs.md) сервера S'L.

![Состояния рабочей нагрузки](./media/sql-database-monitor-tune-overview/workload-states.png)

**Проблемы, связанные с запуском:** Проблемы, связанные с запуском, как правило, связаны с проблемами компиляции, что приводит к неоптимальному плану запросов или проблемам выполнения, связанным с недостаточными или чрезмерно используемыми ресурсами.
**Проблемы, связанные с ожиданием**: Проблемы, связанные с ожиданием, как правило, связаны с:

- блокировки;
- Ввод-вывод
- Содержание, связанное с использованием TempDB
- ожидание временно предоставляемого буфера памяти.

## <a name="compilation-problems-resulting-in-a-suboptimal-query-plan"></a>Проблемы компиляции, приводящие к неоптимальному плану запросов

Неоптимальный план, генерируемый оптимизатором запроса S'L, может быть причиной медленной производительности запроса. Оптимизатор запросов S'L может создать неоптимальный план из-за отсутствующего индекса, некачественной статистики, неправильной оценки количества строк, которые необходимо обработать, или неточной оценки требуемой памяти. Если вы знаете, что запрос был выполнен быстрее в прошлом или в другом экземпляре (либо управляемый экземпляр, либо экземпляр S'L Server), сравните фактические планы выполнения, чтобы увидеть, отличаются ли они.

- Определите все недостающие индексы с помощью одного из этих методов:

  - Используйте [интеллектуальные исследования](sql-database-intelligent-insights-troubleshoot-performance.md#missing-index).
  - [Советник по базам данных](sql-database-advisor.md) для отдельных и объединенных баз данных.
  - DMVs. В этом примере показано влияние отсутствующего индекса, как обнаружить [недостающие индексы](sql-database-performance-guidance.md#identifying-and-adding-missing-indexes) с помощью DMV и влияние реализации рекомендации о недостающих индексах.
- Попробуйте применить [подсказки запроса,](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) [обновить статистику](https://docs.microsoft.com/sql/t-sql/statements/update-statistics-transact-sql)или [восстановить индексы,](https://docs.microsoft.com/sql/relational-databases/indexes/reorganize-and-rebuild-indexes) чтобы получить лучший план. Включите [автоматическую коррекцию плана](sql-database-automatic-tuning.md) в базу данных Azure S'L для автоматического устранения этих проблем.

  В [этом примере](sql-database-performance-guidance.md#query-tuning-and-hinting) показано влияние плана неоптимального запроса из-за параметризированного запроса, как обнаружить это условие и как использовать подсказку запроса для решения.

- Попробуйте изменить уровень совместимости базы данных и реализовать интеллектуальную обработку запросов. Оптимизатор запросов может генерировать другой план запросов в зависимости от уровня совместимости для вашей базы данных. Более высокие уровни совместимости обеспечивают более [интеллектуальные возможности обработки запросов.](https://docs.microsoft.com/sql/relational-databases/performance/intelligent-query-processing)

  - Для получения дополнительной информации [Query Processing Architecture Guide](https://docs.microsoft.com/sql/relational-databases/query-processing-architecture-guide)об обработке запросов см.
  - Чтобы изменить уровни совместимости баз данных и узнать больше о различиях между уровнями совместимости, [см.](https://docs.microsoft.com/sql/t-sql/statements/alter-database-transact-sql-compatibility-level)
  - Чтобы узнать больше об оценке кардинальности, [см.](https://docs.microsoft.com/sql/relational-databases/performance/cardinality-estimation-sql-server)

## <a name="resolving-queries-with-suboptimal-query-execution-plans"></a>Разрешение запросов с неоптимальными планами выполнения запросов

В следующих разделах обсуждаются способы решения запросов с помощью плана выполнения неоптимального запроса.

### <a name="queries-that-have-parameter-sensitive-plan-psp-problems"></a><a name="ParamSniffing"></a>Запросы, которые имеют проблемы с чувствительным параметром (PSP)

Проблема паративного плана (PSP) возникает, когда оптимизатор запроса генерирует план выполнения запроса, оптимальный только для определенного значения параметра (или набора значений), а план кэшированного времени не является оптимальным для значений параметров, которые используются в последовательных Казни. Неоптимальные планы могут вызвать проблемы с производительностью запроса и ухудшить общую пропускную способность рабочей нагрузки.

Для получения дополнительной информации о нюхании [Query-processing architecture guide](/sql/relational-databases/query-processing-architecture-guide#ParamSniffing)параметров и обработке запросов см.

Несколько обходных пути могут смягчить проблемы PSP. Каждый обходной путь имеет связанные компромиссы и недостатки:

- Использование указания запроса [RECOMPILE](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) при каждом выполнении запроса. Этот метод позволяет заменить время компиляции и увеличение загрузки ЦП на улучшение качества плана. Этот `RECOMPILE` вариант часто невозможен для рабочих нагрузок, которые требуют высокой пропускной выгоды.
- Используйте [опцион (OPTIMIZE ДЛЯ...)](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) подсказку запроса, чтобы переопределить фактическое значение параметра с типичным значением параметра, которое производит план, который достаточно хорош для большинства возможностей значения параметра. Для этого варианта требуется хорошее понимание оптимальных значений параметров и связанных с ними характеристик плана.
- Используйте [option (OPTIMIZE FOR UNKNOWN)](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) подсказка запроса, чтобы переопределить фактическое значение параметра и вместо этого использовать средний вектор плотности. Вы также можете сделать это, захватив входящие значения параметров в локальных переменных, а затем используя локальные переменные в предикатах вместо использования самих параметров. Для этого исправления, средняя плотность должна быть *достаточно хороша.*
- Отменяйте параметр, полностью нюхая с помощью DISABLE_PARAMETER_SNIFFING [подсказки](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) запроса.
- Используйте подсказку запроса [KEEPFIXEDPLAN,](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) чтобы предотвратить перекомпиляции в кэше. Это решение предполагает, что достаточно хороший общий план уже находится в кэше. Вы также можете отключить автоматические обновления статистики, чтобы уменьшить вероятность того, что хороший план будет выселен и будет составлен новый плохой план.
- Принудить план, явно используя подсказку запроса [USE PLAN,](https://docs.microsoft.com/sql/t-sql/queries/hints-transact-sql-query) переписав запрос и добавив подсказку в текст запроса. Или установите конкретный план, используя Магазин запросов или [включив автоматическую настройку.](sql-database-automatic-tuning.md)
- Замена одной процедуры вложенным набором процедур, каждая из которых может использоваться на основе условной логики и связанных значений параметров.
- Создание альтернатив выполнения динамической строки для статического определения процедуры.

Для получения дополнительной информации о решении проблем PSP, см.

- [Я чувствую запах параметра](https://docs.microsoft.com/archive/blogs/queryoptteam/i-smell-a-parameter)
- [Конор против динамических S'L против процедур против качества плана для параметризированных запросов](https://blogs.msdn.microsoft.com/conor_cunningham_msft/2009/06/03/conor-vs-dynamic-sql-vs-procedures-vs-plan-quality-for-parameterized-queries/)
- [Методы оптимизации запросов в сервере S'L: нюхают параметры](https://www.sqlshack.com/query-optimization-techniques-in-sql-server-parameter-sniffing/)

### <a name="compile-activity-caused-by-improper-parameterization"></a>Деятельность компиляции, вызванная неправильной параметризацией

Когда запрос имеет буквальные данные, либо движок базы данных автоматически параметрызирует заявление или пользователь явно параметры оператора, чтобы уменьшить количество компиляций. Большое количество компиляций для запроса с использованием одного и того же шаблона, но различные буквальное значение может привести к высокому использованию процессора. Аналогичным образом, если вы лишь частично параметризируете запрос, который по-прежнему имеет буквы, движок базы данных не параметрызирует запрос дальше.

Вот пример частично параметризованного запроса:

```sql
SELECT *
FROM t1 JOIN t2 ON t1.c1 = t2.c1
WHERE t1.c1 = @p1 AND t2.c2 = '961C3970-0E54-4E8E-82B6-5545BE897F8F'
```

В этом `t1.c1` примере, берет `@p1`, но `t2.c2` продолжает принимать GUID как буквальное. В этом случае, если вы `c2`измените значение для, запрос рассматривается как другой запрос, и произойдет новая компиляция. Чтобы уменьшить компиляции в этом примере, можно также параметризировать GUID.

Следующий запрос показывает количество запросов по хэшу запроса, чтобы определить, правильно ли параметризирован запрос:

```sql
SELECT TOP 10
  q.query_hash
  , count (distinct p.query_id ) AS number_of_distinct_query_ids
  , min(qt.query_sql_text) AS sampled_query_text
FROM sys.query_store_query_text AS qt
  JOIN sys.query_store_query AS q
     ON qt.query_text_id = q.query_text_id
  JOIN sys.query_store_plan AS p
     ON q.query_id = p.query_id
  JOIN sys.query_store_runtime_stats AS rs
     ON rs.plan_id = p.plan_id
  JOIN sys.query_store_runtime_stats_interval AS rsi
     ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id
WHERE
  rsi.start_time >= DATEADD(hour, -2, GETUTCDATE())
  AND query_parameterization_type_desc IN ('User', 'None')
GROUP BY q.query_hash
ORDER BY count (distinct p.query_id) DESC
```

### <a name="factors-that-affect-query-plan-changes"></a>Факторы, влияющие на изменения плана запроса

Перекомпиляция плана выполнения запроса может привести к порожденным планом запроса, который отличается от исходного кэшированного плана. Существующий исходный план может быть автоматически перекомпилирован по разным причинам:

- Изменения в схеме упоминаются в запросе
- Изменения данных в таблицах ссылаются на запрос
- Параметры контекста запроса были изменены

Компилированный план может быть извлечен из кэша по различным причинам, таким как:

- Перезапуск инстанции
- Изменения конфигурации с базой данных
- нехватка памяти;
- Явные запросы на очистку кэша

Если вы используете подсказку RECOMPILE, план не будет кэшироваться.

Перекомпиляция (или свежая компиляция после выселения кэша) может привести к генерации плана выполнения запроса, идентичного исходному. Когда план изменяется из предыдущего или исходного плана, эти объяснения, скорее всего,:

- **Измененный физический дизайн**: Например, вновь созданные индексы более эффективно покрывают требования запроса. Новые индексы могут быть использованы в новой компиляции, если оптимизатор запроса решит, что использование этого нового индекса является более оптимальным, чем использование структуры данных, первоначально выбранной для первой версии выполнения запроса. Любые физические изменения в упомянутых объектах могут привести к выбору нового плана во время компиляции.

- **Различия ресурсов сервера**: Когда план в одной системе отличается от плана в другой системе, доступность ресурсов, например количество доступных процессоров, может влиять на то, какой план генерируется. Например, если в одной системе больше процессоров, может быть выбран параллельный план.

- **Различные статистические данные**: Статистика, связанная с упомянутыми объектами, может измениться или существенно отличаться от статистики исходной системы. Если статистика меняется и происходит перекомпиляция, оптимизатор запроса использует статистику, начиная с момента их изменения. Распределение и частоты пересмотренных статистических данных могут отличаться от частот первоначальной компиляции. Эти изменения используются для создания оценок кардинальности. (*Оценки кардинальности* — это количество строк, которые, как ожидается, будут проходить через логическое дерево запросов.) Изменения в оценках кардинальности могут привести к выбору различных физических операторов и связанных с ними заказов операций. Даже незначительные изменения в статистике могут привести к изменению плана выполнения запросов.

- **Измененный уровень совместимости базы данных или версия оценки кардинальности:** Изменения уровня совместимости базы данных могут привести к новым стратегиям и функциям, которые могут привести к выполнению другого плана выполнения запросов. Помимо уровня совместимости базы данных, отключенный или включенный флаг трассировки 4199 или измененное состояние конфигурации с охватом базы данных QUERY_OPTIMIZER_HOTFIXES также может влиять на выбор плана выполнения запроса во время компиляции. След флаги 9481 (силовое наследие CE) и 2312 (сила по умолчанию CE) также влияют на план.

## <a name="resource-limits-issues"></a>Проблемы с ограничениями ресурсов

Медленная производительность запроса, не связанная с неоптимальными планами запросов и отсутствующими индексами, как правило, связана с недостаточными или неиспользованными ресурсами. Если план запроса является оптимальным, запрос (и база данных) может поразить предельные ресурсы для базы данных, эластичного пула или управляемого экземпляра. Примером может быть избыточная пропускная запись записи журнала для уровня обслуживания.

- Обнаружение проблем с ресурсами с помощью портала Azure: Чтобы узнать, являются ли проблемы ограничения ресурсов, [см.](sql-database-monitor-tune-overview.md#sql-database-resource-monitoring) Для отдельных баз данных и эластичных пулов см. [Рекомендации по производительности советника по базам данных](sql-database-advisor.md) и [анализ производительности запросов.](sql-database-query-performance.md)
- Обнаружение предельных ресурсов с помощью [интеллектуальных анализов](sql-database-intelligent-insights-troubleshoot-performance.md#reaching-resource-limits)
- Обнаружение проблем с ресурсами с помощью [DMVs:](sql-database-monitoring-with-dmvs.md)

  - [Sys.dm_db_resource_stats](sql-database-monitoring-with-dmvs.md#monitor-resource-use) DMV возвращает процессор, ввосёртый и расход памяти для базы данных S'L. Одна строка существует для каждого 15-секундного интервала, даже если в базе данных нет активности. Исторические данные хранятся в течение одного часа.
  - [Sys.resource_stats](sql-database-monitoring-with-dmvs.md#monitor-resource-use) DMV возвращает данные об использовании и хранении процессора для базы данных Azure s'L. Данные собираются и агрегируются с интервалом в пять минут.
  - [Много отдельных запросов, которые вместе потребляют большой объем ЦП](sql-database-monitoring-with-dmvs.md#many-individual-queries-that-cumulatively-consume-high-cpu)
  - 

Если вы определяете проблему как недостаточную ресурс, можно обновить ресурсы, чтобы увеличить емкость базы данных S'L, чтобы поглотить требования к процессору. Для получения дополнительной информации в [базе данных Azure S'L](sql-database-elastic-pool-scale.md)см. [Scale single database resources in Azure SQL Database](sql-database-single-database-scale.md) Для получения информации о масштабировании управляемого экземпляра [см.](sql-database-managed-instance-resource-limits.md#service-tier-characteristics)

## <a name="performance-problems-caused-by-increased-workload-volume"></a>Проблемы с производительностью, вызванные увеличением объема рабочей нагрузки

Увеличение трафика приложений и объема рабочей нагрузки может привести к увеличению использования процессора. Но вы должны быть осторожны, чтобы правильно диагностировать эту проблему. Когда вы видите проблему с высоким уровнем процессора, ответьте на эти вопросы, чтобы определить, вызвано ли увеличение изменениями в объеме рабочей нагрузки:

- Являются ли запросы из приложения причиной проблемы с высоким процессором?
- Для [верхних запросов, потребляющих процессор, которые можно определить:](sql-database-monitoring-with-dmvs.md#the-cpu-issue-occurred-in-the-past)

  - Связаны ли несколько планов выполнения с тем же запросом? Если да, то почему?
  - Для запросов с тем же планом выполнения время выполнения было последовательным? Увеличилось ли количество выполнения? Если это так, увеличение рабочей нагрузки, вероятно, вызывает проблемы с производительностью.

Таким образом, если план выполнения запроса не выполнен по-разному, но использование процессора увеличилось вместе с количеством выполнения, проблема с производительностью, скорее всего, связана с увеличением рабочей нагрузки.

Не всегда легко определить изменение объема рабочей нагрузки, которое приводит к проблеме процессора. Учитывайте следующие факторы:

- **Изменено использование ресурсов:** Например, рассмотрим сценарий, в котором использование процессора увеличилось до 80 процентов в течение длительного периода времени. Использование процессора само по себе не означает изменение объема рабочей нагрузки. Регрессии в плане выполнения запроса и изменения в распределении данных также могут способствовать более широкому использованию ресурсов, даже если приложение выполняет ту же рабочую нагрузку.

- **Появление нового запроса:** приложение может управлять новым набором запросов в разное время.

- **Увеличение или уменьшение количества запросов**: Этот сценарий является наиболее очевидным показателем рабочей нагрузки. Количество запросов не всегда соответствует дополнительному использованию ресурсов. Тем не менее, эта метрика по-прежнему является важным сигналом, предполагая, что другие факторы остаются неизменными.

Используйте Интеллектуальные Исследования для обнаружения [увеличения рабочей нагрузки](sql-database-intelligent-insights-troubleshoot-performance.md#workload-increase) и [планирования регрессий.](sql-database-intelligent-insights-troubleshoot-performance.md#plan-regression)

## <a name="waiting-related-problems"></a>Проблемы, связанные с ожиданием

После устранения неоптимального плана и *проблем, связанных с ожиданием,* связанных с проблемами выполнения, проблема с производительностью, как правило, возникает, что запросы, вероятно, ждут какого-то ресурса. Проблемы, связанные с ожиданием, могут быть вызваны:

- **Блокировка:**

  Один запрос может удерживать блокировку объектов в базе данных, в то время как другие пытаются получить доступ к тем же объектам. Вы можете определить блокирующие запросы с помощью [DMV](sql-database-monitoring-with-dmvs.md#monitoring-blocked-queries) или [Интеллектуальных Исследования](sql-database-intelligent-insights-troubleshoot-performance.md#locking).
- **Проблемы с итоговым и**

  Возможно, запросы будут ждать, пока страницы будут записаны на файлы данных или журналов. В этом случае, `INSTANCE_LOG_RATE_GOVERNOR` `WRITE_LOG`проверить `PAGEIOLATCH_*` , или ждать статистики в DMV. Спомощью DMV можно [определить проблемы с производительностью и см.](sql-database-monitoring-with-dmvs.md#identify-io-performance-issues)
- **Проблемы TempDB**

  Если рабочая нагрузка использует временные таблицы или в планах есть разливы TempDB, запросы могут иметь проблемы с пропускной результатом TempDB. См, использующих DMV, чтобы [выставить проблемы TempDB](sql-database-monitoring-with-dmvs.md#identify-tempdb-performance-issues)под идентификацию.
- **Проблемы, связанные с памятью**

  Если рабочая нагрузка не имеет достаточной памяти, продолжительность жизни страницы может снизиться, или запросы могут получить меньше памяти, чем им нужно. В некоторых случаях встроенный интеллект в «Оптимизаторе запросов» исправляет проблемы, связанные с памятью. Смотрите с помощью DMVs для [выявления проблем с предоставлением памяти.](sql-database-monitoring-with-dmvs.md#identify-memory-grant-wait-performance-issues)

### <a name="methods-to-show-top-wait-categories"></a>Методы отображижимых верхних категорий ожидания

Эти методы обычно используются для отображитого верхних категорий типов ожидания:

- Используйте Intelligent Insights для определения запросов с ухудшением производительности из-за [увеличения ожиданий](sql-database-intelligent-insights-troubleshoot-performance.md#increased-wait-statistic)
- Используйте [магазин запросов,](https://docs.microsoft.com/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store) чтобы найти статистику ожидания для каждого запроса с течением времени. В хранилище запросов типы времени ожидания объединены в категории ожидания. Вы можете найти отображение категорий ожидания ждать типов в [sys.query_store_wait_stats](https://docs.microsoft.com/sql/relational-databases/system-catalog-views/sys-query-store-wait-stats-transact-sql#wait-categories-mapping-table).
- Используйте [sys.dm_db_wait_stats](https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-db-wait-stats-azure-sql-database) для возврата информации обо всех ожиданиях, встречающихся с потоками, выполняемыми во время операции запроса. Это агрегированное представление можно использовать для диагностики проблем с производительностью с базой данных Azure S'L, а также с конкретными запросами и пакетами. Запросы могут ждать на ресурсах, ожиданиях очередей или внешних ожиданиях.
- Используйте [sys.dm_os_waiting_tasks](https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-os-waiting-tasks-transact-sql) для возврата информации о очереди задач, ожидающих на определенном ресурсе.

В сценариях с высоким уровнем процессора статистика «Магазин запросов» и ожидание могут не отражать использование процессора, если:

- Запросы с высоким уровнем емких процессоров по-прежнему исполняются.
- Запросы с высоким уровнем емки процессора запускались при сбою.

DMVs, отслеживающие статистику поиска запросов и ожидание, показывают результаты только для успешно завершенных и приуроченных запросов. Они не отображают данные для выполнения в настоящее время инструкций до завершения инструкций. Используйте динамическое представление управления [sys.dm_exec_requests](https://docs.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-requests-transact-sql) для отслеживания в настоящее время выполнения запросов и связанного времени работы.

> [!TIP]
> Дополнительные инструменты:
>
> - [TigerToolbox ждет и защелки](https://github.com/Microsoft/tigertoolbox/tree/master/Waits-and-Latches)
> - [TigerToolbox usp_whatsup](https://github.com/Microsoft/tigertoolbox/tree/master/usp_WhatsUp)

## <a name="next-steps"></a>Дальнейшие действия

[Обзор мониторинга и настройки базы данных СЗЛ](sql-database-monitor-tune-overview.md)