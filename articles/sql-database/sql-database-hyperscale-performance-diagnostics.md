---
title: Диагностика производительности в гипермасштабе
description: В этой статье описывается, как устранить проблемы с производительностью Hyperscale в базе данных Azure S'L.
services: sql-database
ms.service: sql-database
ms.subservice: service
ms.custom: seo-lt-2019
ms.topic: troubleshooting
author: denzilribeiro
ms.author: denzilr
ms.reviewer: sstein
ms.date: 10/18/2019
ms.openlocfilehash: 26bd6ddb9d8255b8e2510133fc4b6aa645f89f68
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "75615061"
---
# <a name="sql-hyperscale-performance-troubleshooting-diagnostics"></a>Диагностика устранения неполадок в гипермасштабах

Для устранения неполадок в базе данных Hyperscale [общие методы настройки производительности](sql-database-monitor-tune-overview.md) на вычислительном узеле вычислительной базы данных Azure S'L является отправной точкой исследования производительности. Однако, учитывая [распределенную архитектуру](sql-database-service-tier-hyperscale.md#distributed-functions-architecture) Hyperscale, дополнительные диагностические технологии были добавлены для оказания помощи. В этой статье описаны диагностические данные, связанные с hyperscale.

## <a name="log-rate-throttling-waits"></a>Регистрация скорость регулирования ждет

Каждый уровень службы баз данных Azure S'L имеет ограничения скорости генерации журналов, установленные с [помощью управления тарифами журналов.](sql-database-resource-limits-database-server.md#transaction-log-rate-governance) В Hyperscale предел генерации журнала в настоящее время установлен до 100 МБ/сек, независимо от уровня обслуживания. Тем не менее, бывают случаи, когда скорость генерации журнала на первичной вычислительной реплике должна быть задушена для поддержания возможности восстановления SLAs. Такое регулирование происходит, когда [сервер страницы или другая вычислительная реплика](sql-database-service-tier-hyperscale.md#distributed-functions-architecture) значительно стоит за применением новых записей журнала из службы журнала.

Следующие типы ожидания (в [sys.dm_os_wait_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql/)) описывают причины, по которым скорость журнала может быть задушена на первичной вычисляющей реплике:

|Тип ожидания    |Описание                         |
|-------------          |------------------------------------|
|RBIO_RG_STORAGE        | Происходит, когда основная скорость генерации вычислительных узлов Hyperscale заглушается из-за задержки потребления журнала на сервере страницы (ы).         |
|RBIO_RG_DESTAGE        | Происходит, когда скорость генерации системы журналов Hyperscale вычисляет узла, из-за задержки потребления журнала долгосрочным хранилищем журналов.         |
|RBIO_RG_REPLICA        | Происходит, когда Hyperscale базы данных вычислить узла системы генерации в настоящее время регулируется из-за задержки потребления журнала читаемой вторичной реплики (ы).         |
|RBIO_RG_LOCALDESTAGE   | Происходит, когда hyperscale базы данных вычислить узла системы генерации в настоящее время регулируется из-за задержки потребления журнала службы журнала.         |

## <a name="page-server-reads"></a>Сервер страницы читает

Вычисляемые реплики не кэшируют полную копию базы данных локально. Локальные данные для вычисляемой реплики хранятся в пуле буфера (в памяти) и в локальном кэше упругого буферного пула (RBPEX), который является частичным (не покрывающим) кэшом страниц данных. Этот локальный кэш RBPEX размером пропорционально размеру вычисления и в три раза превышает память вычислительного уровня. RBPEX похож на буферный пул в том, что он имеет наиболее часто доступные данные. Каждый сервер страницы, с другой стороны, имеет покрытие кэша RBPEX для части базы данных, которая она поддерживает.
 
При выдаче считывания на вычислительной реплике, если данные не существуют в пуле буфера или локальном кэше RBPEX, выдается вызов функции getPage (pageId, LSN), и страница извлекается с соответствующего сервера страницы. Чтения с серверов страниц являются удаленными чтениями и, таким образом, медленнее, чем читает из местных RBPEX. При устранении проблем с производительностью, связанных с выполнением итоговых решений, мы должны быть в состоянии сказать, сколько IOs было сделано с помощью относительно более медленного удаленного сервера страницы.

Несколько DMV и расширенных событий имеют столбцы и поля, которые определяют количество удаленных считываний с сервера страницы, которые можно сравнить с общей считывания. Хранилище запросов также фиксирует удаленные считывания как часть статистики времени выполнения запроса.

- Столбцы для отчета о считывании сервера страницдоступны в представлениях засхотов и каталога, таких как:
    - [sys.dm_exec_requests](/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-requests-transact-sql/)
    - [sys.dm_exec_query_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-query-stats-transact-sql/)
    - [sys.dm_exec_procedure_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-procedure-stats-transact-sql/)
    - [sys.dm_exec_trigger_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-trigger-stats-transact-sql/)
    - [sys.query_store_runtime_stats](/sql/relational-databases/system-catalog-views/sys-query-store-runtime-stats-transact-sql/)
- Чтения сервера страниц добавляются к следующим расширенным событиям:
    - sql_statement_completed
    - sp_statement_completed
    - sql_batch_completed
    - rpc_completed
    - scan_stopped
    - query_store_begin_persist_runtime_stat
    - запрос-store_execution_runtime_info
- ActualPageServerReads/ActualPageServerReadAheads добавляются в план запроса XML для реальных планов. Пример:

`<RunTimeCountersPerThread Thread="8" ActualRows="90466461" ActualRowsRead="90466461" Batches="0" ActualEndOfScans="1" ActualExecutions="1" ActualExecutionMode="Row" ActualElapsedms="133645" ActualCPUms="85105" ActualScans="1" ActualLogicalReads="6032256" ActualPhysicalReads="0" ActualPageServerReads="0" ActualReadAheads="6027814" ActualPageServerReadAheads="5687297" ActualLobLogicalReads="0" ActualLobPhysicalReads="0" ActualLobPageServerReads="0" ActualLobReadAheads="0" ActualLobPageServerReadAheads="0" />`

> [!NOTE]
> Для просмотра этих атрибутов в окне свойств плана запроса требуется SSMS 18.3 или позже.

## <a name="virtual-file-stats-and-io-accounting"></a>Виртуальная статистика файлов и бухгалтерский учет

В базе данных [Azure S'L, sys.dm_io_virtual_file_stats()](/sql/relational-databases/system-dynamic-management-views/sys-dm-io-virtual-file-stats-transact-sql/) DMF является основным способом мониторинга IO сервера S'L. Характеристики IO в Hyperscale отличаются из-за [распределенной архитектуры.](sql-database-service-tier-hyperscale.md#distributed-functions-architecture) В этом разделе мы сосредоточиваемся на IO (читает и записывает) на файлы данных, как видно из этого DMF. В Hyperscale каждый файл данных, видимый в этом DMF, соответствует серверу удаленной страницы. Упомянутый здесь кэш RBPEX — это локальный кэш на основе SSD, который не охватывает кэш на вычислительной реплике.

### <a name="local-rbpex-cache-usage"></a>Местное использование кэша RBPEX

Локальный кэш RBPEX существует на вычислительной реплике на локальном хранении SSD. Таким образом, io против этого кэша быстрее, чем IO против удаленных серверов страниц. В настоящее время [sys.dm_io_virtual_file_stats()](/sql/relational-databases/system-dynamic-management-views/sys-dm-io-virtual-file-stats-transact-sql/) в базе данных Hyperscale имеет специальную строку, сообщая о МОК против локального кэша RBPEX на вычислительной реплике. Эта строка имеет значение `database_id` 0 `file_id` для обеих столбцов и столбцов. Например, ниже приведенный ниже запрос возвращает статистику использования RBPEX после запуска базы данных.

`select * from sys.dm_io_virtual_file_stats(0,NULL);`

Соотношение считываемых на RBPEX к агрегированным считываемым данным, сделанным на всех других файлах данных, обеспечивает соотношение попадания кэша RBPEX.

### <a name="data-reads"></a>Данные считывает

- При считывании, выдаваемом движком сервера S'L на вычислительной реплике, они могут обслуживаться либо локальным кэшом RBPEX, либо удаленными серверами страниц, либо комбинацией этих двух, если они читают несколько страниц.
- Когда вычисляемые реплики считывает некоторые страницы из определенного файла, например file_id 1, если эти данные находятся исключительно в локальном кэше RBPEX, все IO для этого чтения учитывается против file_id 0 (RBPEX). Если какая-то часть этих данных находится в локальном кэше RBPEX, а часть находится на удаленном сервере страницы, то IO учитывается в file_id 0 для части, подаваемой от RBPEX, а часть, обслуживаемых с удаленного сервера страницы, приходится на file_id 1. 
- Когда вычисляемый реплика запрашивает страницу в определенном [LSN](/sql/relational-databases/sql-server-transaction-log-architecture-and-management-guide/) с сервера страницы, если сервер страницы не догнал запрашиваемую LSN, прочитанный на вычисляемых репликах будет ждать, пока сервер страницы не догонит до того, как страница вернется в вычисляемую реплику. Для любого чтения с сервера страницы на вычислительной реплике, вы увидите PAGEIOLATCH_ типа ожидания, если он ждет на этом итогах. В Hyperscale это время ожидания включает как время, чтобы догнать запрашиваемую страницу на сервере страницы для LSN требуется, и время, необходимое для передачи страницы с сервера страницы на вычислительную реплику.
- Большие чтения, такие как чтение вперед часто делается с помощью ["Scatter-Gather" Читает](/sql/relational-databases/reading-pages/). Это позволяет считывать до 4 МБ страниц одновременно, считается одним чтением в движке сервера S'L Server. Однако, когда данные читаются в RBPEX, эти считывания учитываются как несколько отдельных 8 КБ читает, так как буфер ный бассейн и RBPEX всегда используют 8 КБ страниц. В результате количество прочитаных IOs, показанных против RBPEX, может быть больше фактического количества IOs, выполняемых двигателем.

### <a name="data-writes"></a>Данные пишет

- Основная вычисляемые реплики не записывается непосредственно на серверы страниц. Вместо этого записи журналов из службы журнала воспроизводится на соответствующих серверах страниц. 
- Пишет, что происходит на вычислительной реплики в основном пишет в местный RBPEX (file_id 0). Для записей на логических файлах, которые больше, чем 8 КБ, другими словами, те, которые сделали с помощью [Gather-write,](/sql/relational-databases/writing-pages/)каждая операция записи переведена на несколько 8 КБ отдельных пишет В RBPEX, так как буферный пул и RBPEX всегда используют 8 КБ страниц. В результате количество написать IOs, увиденных против RBPEX, может быть больше, чем фактическое количество IOs, выполняемых двигателем.
- Не-RBPEX файлы, или файлы данных, кроме file_id 0, которые соответствуют страницы серверов, также показывают пишет. На уровне службы Hyperscale эти записи моделируются, поскольку вычислительные реплики никогда не пишутся непосредственно на серверы страниц. Запись IOPS и пропускная запись учитываются по мере их возникновения на вычислительной реплике, но задержка файлов данных, помимо file_id 0, не отражает фактическую задержку записи сервера страницы.

### <a name="log-writes"></a>Записи журнала

- На первичном вычислении запись журнала учитывается в file_id 2 sys.dm_io_virtual_file_stats. Запись журнала на первичном вычислении — это запись в зону посадки журнала.
- Записи журнала не затвердеваются на вторичной реплике на коммите. В Hyperscale журнал применяется службой журнала к вторичным репликам асинхронно. Поскольку записи журналов на самом деле не происходят на вторичных репликах, любой учет иноты журналов на вторичных репликах предназначен только для целей отслеживания.

## <a name="data-io-in-resource-utilization-statistics"></a>Данные IO в статистике использования ресурсов

В базе данных, не относявшейся к гипермасштабированию, в `avg_data_io_percent` столбце сообщается в [sys.dm_db_resource_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-resource-stats-azure-sql-database) и [sys.resource_stats представлений,](/sql/relational-databases/system-catalog-views/sys-resource-stats-azure-sql-database) объединенные считываемыми и записными IOPS в файлах данных, относительно лимита данных управления [ресурсами](/azure/sql-database/sql-database-resource-limits-database-server#resource-governance) IOPS. Такое же значение сообщается на портале, что и _процент данных IO_. 

В базе данных Hyperscale эта колонка сообщает об использовании данных IOPS относительно лимита локального `tempdb`хранения только на вычислительной реплике, в частности, в отношении RBPEX и . Значение 100% в этой колонке указывает на то, что управление ресурсами ограничивает локальные IOPS хранения. Если это коррелирует с проблемой производительности, настройте рабочую нагрузку, чтобы генерировать меньше истогов или увеличьте цель службы баз данных, чтобы увеличить [лимит](sql-database-vcore-resource-limits-single-databases.md)управления ресурсами _Max Data IOPS._ Для управления ресурсами RBPEX читает и пишет, система рассчитывает отдельные 8 КБ IoOs, а не больше IoOs, которые могут быть выданы движком сервера S'L. 

Данные IO против удаленных серверов страниц не сообщается в представлениях использования ресурсов или на портале, но сообщается в [sys.dm_io_virtual_file_stats()](/sql/relational-databases/system-dynamic-management-views/sys-dm-io-virtual-file-stats-transact-sql/) DMF, как отмечалось ранее.


## <a name="additional-resources"></a>Дополнительные ресурсы

- Для vCore ограничения ресурсов для Hyperscale одной базы данных см [Hyperscale уровень обслуживания vCore пределы](sql-database-vcore-resource-limits-single-databases.md#hyperscale---provisioned-compute---gen5)
- Для настройки производительности данных базы данных Azure S'L [см.](sql-database-performance-guidance.md)
- Для настройки производительности с помощью магазина запросов см. [мониторинг производительности с помощью магазина запросов](/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store/)
- Для скриптов мониторинга DMV см. [Мониторинг производительности базы данных Azure S'L с использованием динамических представлений управления](sql-database-monitoring-with-dmvs.md)
