---
title: Работа с типами данных и объектами R и SQL
titleSuffix: Azure SQL Database Machine Learning Services (preview)
description: Узнайте, как работать с типами данных и объектами данных в R с базой данных SQL Azure с помощью Службы машинного обучения (Предварительная версия), включая распространенные проблемы, которые могут возникнуть.
services: sql-database
ms.service: sql-database
ms.subservice: machine-learning
ms.custom: ''
ms.devlang: r
ms.topic: conceptual
author: garyericson
ms.author: garye
ms.reviewer: davidph
manager: cgronlun
ms.date: 04/11/2019
ms.openlocfilehash: 7dfd12729c5697d1935d098cbd4ed863a4551acd
ms.sourcegitcommit: f52ce6052c795035763dbba6de0b50ec17d7cd1d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76719880"
---
# <a name="work-with-r-and-sql-data-in-azure-sql-database-machine-learning-services-preview"></a>Работа с данными R и SQL в Службы машинного обучения базы данных SQL Azure (Предварительная версия)

В этой статье обсуждаются некоторые распространенные проблемы, которые могут возникнуть при перемещении данных между R и базой данных SQL в [службы машинного обучения (с R) в базе данных SQL Azure](sql-database-machine-learning-services-overview.md). Опыт, который вы получите в этом упражнении, позволит приобрести основные навыки для работы с данными в собственном сценарии.

Ниже перечислены распространенные проблемы, которые могут возникнуть.

- Иногда типы данных не совпадают
- Могут иметь место неявные преобразования
- Иногда требуются операции приведения и преобразования.
- R и SQL используют разные объекты данных.

[!INCLUDE[ml-preview-note](../../includes/sql-database-ml-preview-note.md)]

## <a name="prerequisites"></a>предварительные требования

- Если у вас еще нет подписки Azure, [создайте учетную запись Azure](https://azure.microsoft.com/free/), прежде чем начинать работу.

- Чтобы запустить пример кода в этих упражнениях, сначала необходимо включить в Базе данных SQL Azure Службы машинного обучения (с поддержкой R). Во время использования общедоступной предварительной версии корпорация Майкрософт подключит вас и включит машинное обучение для имеющейся или новой базы данных. Выполните шаги, приведенные в разделе [Sign up for the preview](sql-database-machine-learning-services-overview.md#signup) (Регистрация для получения предварительной версии).

- Убедитесь, что у вас установлена последняя версия [SQL Server Management Studio](https://docs.microsoft.com/sql/ssms/sql-server-management-studio-ssms) (SSMS). Вы можете выполнять сценарии R с помощью других инструментов управления базами данных или выполнения запросов, но в этом кратком руководстве вы будете использовать SSMS.

## <a name="working-with-a-data-frame"></a>Работа с кадром данных

Когда скрипт возвращает результаты из R в SQL, он должен возвращать данные в виде **данных. Frame**. Любой другой тип объекта, создаваемого в сценарии (список, коэффициент, вектор или двоичные данные) нужно преобразовать в кадр данных, если необходимо вывести его в результатах хранимой процедуры. К счастью существует несколько функций R, поддерживающих изменение других объектов на кадр данных. Можно даже сериализовать двоичную модель и вернуть ее в кадр данных, что будет сделано позже в этой статье.

Во-первых, давайте поэкспериментируем с некоторыми базовыми объектами R — векторами, матрицами и списками — и посмотрим, как преобразование в кадр данных изменяет выходные данные, передаваемые в SQL.

Сравните эти два сценария "Hello World" на языке R. Сценарии выглядят почти одинаково, однако первый сценарий возвращает один столбец с тремя значениями, а второй — три столбца, каждый из которых содержит по одному значению.

**Пример 1**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N' mytextvariable <- c("hello", " ", "world");
OutputDataSet <- as.data.frame(mytextvariable);
'
    , @input_data_1 = N'';
```

**Пример 2**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N' OutputDataSet<- data.frame(c("hello"), " ", c("world"));'
    , @input_data_1 = N'';
```

Почему результаты настолько отличаются?

Обычно ответ можно найти, использовав команду R `str()`. Добавьте функцию `str(object_name)` в скрипте R для получения сведений о схеме данных возвращаемого объекта R в виде информационного сообщения. Сообщения можно просмотреть на вкладке **сообщения** в SSMS.

Чтобы выяснить, почему пример 1 и пример 2 имеют различные результаты, вставьте строку `str(OutputDataSet)` в конце определения `@script` переменной в каждой инструкции следующим образом:

**Пример 1 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
mytextvariable <- c("hello", " ", "world");
OutputDataSet <- as.data.frame(mytextvariable);
str(OutputDataSet);
'
    , @input_data_1 = N'  ';
```

**Пример 2 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
OutputDataSet <- data.frame(c("hello"), " ", c("world"));
str(OutputDataSet);
'
    , @input_data_1 = N'  ';
```

Теперь просмотрите текст на вкладке **Сообщения**, в котором можно определить причину такой разницы.

**Результаты примера 1**

```text
STDOUT message(s) from external script:
'data.frame':   3 obs. of  1 variable:
$ mytextvariable: Factor w/ 3 levels " ","hello","world": 2 1 3
```

**Результаты примера 2**

```text
STDOUT message(s) from external script:
'data.frame':   1 obs. of  3 variables:
$ c..hello..: Factor w/ 1 level "hello": 1
$ X...      : Factor w/ 1 level " ": 1
$ c..world..: Factor w/ 1 level "world": 1
```

Как видно, небольшие изменения в синтаксисе R сильно повлияли на схему результатов. Сведения о различиях в типах данных R подробно описаны в разделе *Data* Structures статьи [«Advanced R» by Hadley Wickham](http://adv-r.had.co.nz).

Сейчас помните, что необходимо проверить ожидаемые результаты при приведении объектов R в кадры данных.

> [!TIP]
> Можно также использовать функции идентификации R, такие как `is.matrix`, `is.vector`, чтобы получить сведения о внутренней структуре данных.

## <a name="implicit-conversion-of-data-objects"></a>Неявное преобразование объектов данных

Каждый объект данных R имеет собственные правила обработки значений при совместном использовании с другими объектами данных, если два объекта данных имеют одинаковое количество измерений или если какой бы то ни было объект данных содержит разнородные типы данных.

Например, предположим, что необходимо выполнить умножение матрицы с помощью языка R. Необходимо умножить матрицу с одним столбцом с тремя значениями по массиву с четырьмя значениями и в результате 4x3 матрицу.

Сначала создайте небольшую таблицу тестовых данных.

```sql
CREATE TABLE RTestData (col1 INT NOT NULL)

INSERT INTO RTestData
VALUES (1);

INSERT INTO RTestData
VALUES (10);

INSERT INTO RTestData
VALUES (100);
GO
```

Теперь выполните следующий скрипт.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
x <- as.matrix(InputDataSet);
y <- array(12:15);
OutputDataSet <- as.data.frame(x %*% y);
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS((
            [Col1] INT
            , [Col2] INT
            , [Col3] INT
            , Col4 INT
            ));
```

Один столбец с тремя значениями преобразуется в матрицу с одним столбцом. Так как матрица представляет собой особый вид массива в R, массив `y` неявно приводится к матрице с одним столбцом, чтобы обеспечить соответствие двух аргументов.

**Результаты**

|Col1|Col2|Col3|Col4|
|---|---|---|---|
|12|13|14|15|
|120|130|140|150|
|1200|1300|1400|1500|

Однако обратите внимание, что происходит при изменении размера массива `y`.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
x <- as.matrix(InputDataSet);
y <- array(12:14);
OutputDataSet <- as.data.frame(y %*% x);
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS(([Col1] INT));
```

На этот раз код R вернет одно значение в качестве результата.

**Результаты**
    
|Col1|
|---|
|1542|

Почему? Так как в этом случае два аргумента могут обрабатываться как векторы одинаковой длины, код R возвращает скалярное произведение в виде матрицы.  Это ожидаемое поведение в соответствии с правилами линейной переточки. Однако это может вызвать проблемы, если нисходящий приложению требуется, чтобы выходная схема никогда не изменялась!

## <a name="merge-or-multiply-columns-of-different-length"></a>Слияние или перемножение столбцов разной длины

R обеспечивает большую гибкость для работы с векторами различных размеров и для объединения структур в виде столбцов в кадры данных. Списки векторов могут выглядеть как таблица, но они не подчиняются всем правилам, управляющим таблицами базы данных.

Например, следующий скрипт определяет числовой массив, длина которого равна 6, и сохраняет его в переменной R `df1`. Затем числовой массив объединяется с целыми числами таблицы RTestData (созданной выше), которая содержит три (3) значения, чтобы создать кадр данных `df2`.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
df1 <- as.data.frame( array(1:6) );
df2 <- as.data.frame( c( InputDataSet , df1 ));
OutputDataSet <- df2;
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS((
            [Col2] INT NOT NULL
            , [Col3] INT NOT NULL
            ));
```

Чтобы заполнить кадр данных, R повторно использует элементы, полученные из RTestData, столько раз, сколько требуется в соответствии с числом элементов в массиве `df1`.

**Результаты**
    
|*Col2*|*Col3*|
|----|----|
|1|1|
|10|2|
|100|3|
|1|4|
|10|5|
|100|6|

Помните, что кадр данных выглядит только как таблица, но на самом деле является списком векторов.

## <a name="cast-or-convert-sql-data"></a>Приведение или преобразование данных SQL

R и SQL не используют одни и те же типы данных, поэтому при выполнении запроса в SQL для получения данных и последующем передаче их в среду выполнения R, обычно происходит некоторый тип неявного преобразования. При возврате данных из R в SQL происходит еще один набор преобразований.

- SQL отправляет данные из запроса в процесс R и преобразует их во внутреннее представление для повышения эффективности.
- Среда выполнения R загружает данные в переменную data.frame и выполняет собственные операции с данными.
- Ядро СУБД возвращает данные в SQL с помощью защищенного внутреннего подключения и представляет данные в виде типов данных SQL.
- Данные можно получить, подключившись к SQL с помощью клиентской или сетевой библиотеки, которая может выдавать SQL-запросы и работать с табличными наборами данных. Это клиентское приложение может и по-другому влиять на данные.

Чтобы увидеть, как это работает, выполните подобный запрос в хранилище данных [AdventureWorksDW](https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks). Это представление возвращает данные продаж, используемые для создания прогнозов.

```sql
USE AdventureWorksDW
GO

SELECT ReportingDate
    , CAST(ModelRegion AS VARCHAR(50)) AS ProductSeries
    , Amount
FROM [AdventureWorksDW].[dbo].[vTimeSeries]
WHERE [ModelRegion] = 'M200 Europe'
ORDER BY ReportingDate ASC
```

> [!NOTE]
> Можно использовать любую версию AdventureWorks или создать другой запрос, используя собственную базу данных. Точка заключается в попытке выполнить обработку некоторых данных, содержащих текстовые, DateTime и числовые значения.

Теперь попробуйте использовать этот запрос в качестве входных данных для хранимой процедуры.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
str(InputDataSet);
OutputDataSet <- InputDataSet;
'
    , @input_data_1 = N'
           SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = ''M200 Europe''
           ORDER BY ReportingDate ASC ;'
WITH RESULT SETS undefined;
```

Если появляется сообщение об ошибке, возможно, необходимо внести некоторые изменения в текст запроса. Например, строковый предикат в предложении WHERE нужно заключать в два набора одинарных кавычек.

После того, как запрос начнет действовать, просмотрите результаты выполнения функции `str`, чтобы увидеть, как R обрабатывает входные данные.

**Результаты**

```text
STDOUT message(s) from external script: 'data.frame':    37 obs. of  3 variables:
STDOUT message(s) from external script: $ ReportingDate: POSIXct, format: "2010-12-24 23:00:00" "2010-12-24 23:00:00"
STDOUT message(s) from external script: $ ProductSeries: Factor w/ 1 levels "M200 Europe",..: 1 1 1 1 1 1 1 1 1 1
STDOUT message(s) from external script: $ Amount       : num  3400 16925 20350 16950 16950
```

- Столбец datetime был обработан с использованием типа данных R **POSIXct**.
- Текстовый столбец "ProductSeries" определен в качестве **коэффициента**, то есть категориальной переменной. Строковые значения обрабатываются как коэффициенты по умолчанию. Если передать строку в R, она преобразуется в целое число для внутреннего использования и сопоставляется со строками на выходе.

## <a name="summary"></a>Сводка

Даже в этих коротких примерах можно увидеть, как следует проверять последствия преобразования данных при передаче запросов SQL в качестве входных данных. Поскольку некоторые типы данных SQL не поддерживаются в R, рассмотрите следующие способы избежать ошибок:

- Проверяйте данные заранее, а также проверяйте столбцы и значения в схеме, которые могут вызвать проблему при передаче в код R.
- Указывайте столбцы из источника входных данных по отдельности. Не используйте `SELECT *`. Определите способ обработки каждого столбца.
- Во избежание непредвиденных ситуаций во время подготовки входных данных при необходимости выполняйте явные приведения.
- Избегайте передачи столбцов данных (например, идентификаторов GUID или идентификаторов GUID строк). Они вызывают ошибки и не требуются для моделирования.

Дополнительные сведения о поддерживаемых и неподдерживаемых типах данных R см. в разделе [библиотеки r и типы данных](/sql/advanced-analytics/r/r-libraries-and-data-types).
