---
title: Работа с типами данных R и SQL и объектов
titleSuffix: Azure SQL Database Machine Learning Services (preview)
description: Узнайте, как работать с типами данных и объекты данных в R с использованием распространенных проблем, которые могут возникнуть, включая службы машинного обучения (Предварительная версия), базы данных SQL Azure.
services: sql-database
ms.service: sql-database
ms.subservice: machine-learning
ms.custom: ''
ms.devlang: r
ms.topic: conceptual
author: garyericson
ms.author: garye
ms.reviewer: davidph
manager: cgronlun
ms.date: 04/11/2019
ms.openlocfilehash: 01d3af14963e92393d34a952bddc8097b7b08f18
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "65232614"
---
# <a name="work-with-r-and-sql-data-in-azure-sql-database-machine-learning-services-preview"></a>Работа с данными SQL и R в SQL базы данных служб машинного обучения Azure (Предварительная версия)

В этой статье рассматриваются некоторые из распространенных проблем, которые могут возникнуть при перемещении данных между R и базы данных SQL в [служб машинного обучения (с помощью R) в базе данных SQL Azure](sql-database-machine-learning-services-overview.md). Вы получаете выполняйте это упражнение опытом предоставляет важные фона при работе с данными в собственный сценарий.

Часто возникающие проблемы, которые могут возникнуть:

- Иногда не совпадают типы данных
- Неявные преобразования могут допускаться
- Иногда требуются операции CAST и convert
- R и SQL используют разные объекты данных

[!INCLUDE[ml-preview-note](../../includes/sql-database-ml-preview-note.md)]

## <a name="prerequisites"></a>Технические условия

- Если у вас еще нет подписки Azure, [создайте учетную запись Azure](https://azure.microsoft.com/free/), прежде чем начинать работу.

- Чтобы запустить пример кода в этих упражнениях, сначала необходимо включить в Базе данных SQL Azure Службы машинного обучения (с поддержкой R). Во время использования общедоступной предварительной версии корпорация Майкрософт подключит вас и включит машинное обучение для имеющейся или новой базы данных. Выполните шаги, приведенные в разделе [Sign up for the preview](sql-database-machine-learning-services-overview.md#signup) (Регистрация для получения предварительной версии).

- Убедитесь, что у вас установлена последняя версия [SQL Server Management Studio](https://docs.microsoft.com/sql/ssms/sql-server-management-studio-ssms) (SSMS). Вы можете выполнять сценарии R с помощью других инструментов управления базами данных или выполнения запросов, но в этом кратком руководстве вы будете использовать SSMS.

## <a name="working-with-a-data-frame"></a>Работа с кадр данных

Когда скрипт возвращает результаты из R в SQL, оно должно возвращать данные в виде **data.frame**. Любой другой тип объекта, создаваемого в скрипте — будь то список, коэффициент, вектор или двоичные данные - должны преобразовываться в кадр данных, если вы хотите вывести его как часть результатов хранимой процедуры. К счастью существует несколько функций R, поддерживающих изменение других объектов в кадр данных. Можно сериализовать двоичную модель и возвратить его в кадр данных, что вы сделаете далее в этой статье.

Во-первых давайте поэкспериментировать с некоторыми базовыми объектами R — векторами, матрицами и списками - и посмотрим, как преобразование в кадр данных изменяет выходные данные, передаваемые в SQL.

Сравните эти два сценария «Hello, World!» в R. Сценарии выглядят почти одинаково, но первый возвращает один столбец из трех значений, тогда как второй возвращает три столбца с одним значением каждого.

**Пример 1**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N' mytextvariable <- c("hello", " ", "world");
OutputDataSet <- as.data.frame(mytextvariable);
'
    , @input_data_1 = N'';
```

**Пример 2**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N' OutputDataSet<- data.frame(c("hello"), " ", c("world"));'
    , @input_data_1 = N'';
```

Почему отличаются результаты таким образом?

Обычно ответ можно найти с помощью R `str()` команды. Добавьте функцию `str(object_name)` в любом месте в скрипте R, чтобы данные схемы заданного объекта R возвращаются как информационное сообщение. Вы можете просматривать сообщения в **сообщений** вкладку в среде SSMS.

Чтобы выяснить, почему в примере 1 и 2 отсутствует такой разные результаты, вставьте строку `str(OutputDataSet)` в конце `@script` определение переменной в каждой инструкции следующим образом:

**Пример 1 с функцией str добавлен**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
mytextvariable <- c("hello", " ", "world");
OutputDataSet <- as.data.frame(mytextvariable);
str(OutputDataSet);
'
    , @input_data_1 = N'  ';
```

**Пример 2 с помощью функции str добавлен**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
OutputDataSet <- data.frame(c("hello"), " ", c("world"));
str(OutputDataSet);
'
    , @input_data_1 = N'  ';
```

Теперь просмотрите текст в **сообщений** чтобы увидеть, почему вывод будет отличаться.

**Результаты примера 1**

```text
STDOUT message(s) from external script:
'data.frame':   3 obs. of  1 variable:
$ mytextvariable: Factor w/ 3 levels " ","hello","world": 2 1 3
```

**Результаты примера 2**

```text
STDOUT message(s) from external script:
'data.frame':   1 obs. of  3 variables:
$ c..hello..: Factor w/ 1 level "hello": 1
$ X...      : Factor w/ 1 level " ": 1
$ c..world..: Factor w/ 1 level "world": 1
```

Как вы видите, небольшие изменения в синтаксисе R сильно повлияли на схему результатов. Все сведения, различия в типах данных R рассматриваются подробно в *структуры данных* статьи [«Advanced R», (Hadley Wickham)](http://adv-r.had.co.nz).

Пока просто Учтите, что необходимо проверить ожидаемые результаты при приведении объектов R в кадры данных.

> [!TIP]
> Также можно использовать функции удостоверений R, такие как `is.matrix`, `is.vector`, которая возвращает сведения о структуре внутренних данных.

## <a name="implicit-conversion-of-data-objects"></a>Неявное преобразование объектов данных

Каждый объект данных R имеет собственные правила обработки значений в сочетании с другими объектами данных, если объекты данных имеют одинаковое количество измерений, или в том случае, если любой объект данных содержит разнородные типы данных.

Например предположим, что вы хотите осуществить Перемножение матриц с помощью языка R. Вы хотите перемножить matrix один столбец с тремя значениями массивом с четырьмя значениями и в результате ожидать матрицу 4 x 3.

Во-первых Создайте небольшую таблицу тестовых данных.

```sql
CREATE TABLE RTestData (col1 INT NOT NULL)

INSERT INTO RTestData
VALUES (1);

INSERT INTO RTestData
VALUES (10);

INSERT INTO RTestData
VALUES (100);
GO
```

Теперь выполните следующий сценарий.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
x <- as.matrix(InputDataSet);
y <- array(12:15);
OutputDataSet <- as.data.frame(x %*% y);
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS((
            [Col1] INT
            , [Col2] INT
            , [Col3] INT
            , Col4 INT
            ));
```

На самом деле столбец из трех значений преобразуется в матрицу с одним столбцом. Так как матрица представляет собой особый вид массива в R, массив `y` неявно приводится к матрице одного столбца, чтобы сделать соответствие двух аргументов.

**Результаты**

|Col1|Col2|Col3|Col4|
|---|---|---|---|
|12|13|14|15|
|120|130|140|150|
|1200|1300|1400|1500|

Тем не менее, обратите внимание, что происходит при изменении размера массива `y`.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
x <- as.matrix(InputDataSet);
y <- array(12:14);
OutputDataSet <- as.data.frame(y %*% x);
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS(([Col1] INT));
```

Теперь R возвращает одно значение как результат.

**Результаты**
    
|Col1|
|---|
|1542|

Почему? Таким образом так как эти два аргумента могут обрабатываться как векторы одинаковой длины, R возвращает скалярное произведение в виде матрицы.  Это ожидаемое поведение в соответствии с правилами линейной алгебры. Тем не менее может вызвать проблемы, если нисходящее приложение ожидает, что схема вывода не должна изменяться!

## <a name="merge-or-multiply-columns-of-different-length"></a>Слияние или Перемножение столбцов разной длины

R обеспечивает большую гибкость для работы с векторами различных размеров и для объединения этих столбцов структуры в кадры данных. Списки векторов могут выглядеть как таблица, но они не подчиняются всем правилам, управляющим таблицами базы данных.

Например, следующий скрипт определяет числовой массив длиной в 6 символов и сохраняет его в переменной R `df1`. Затем числовой массив объединяется с целыми числами из таблицы RTestData (созданной ранее) которого содержит три (3) значения, для формирования нового кадра данных, `df2`.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
df1 <- as.data.frame( array(1:6) );
df2 <- as.data.frame( c( InputDataSet , df1 ));
OutputDataSet <- df2;
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS((
            [Col2] INT NOT NULL
            , [Col3] INT NOT NULL
            ));
```

Чтобы заполнить кадр данных, R повторяется, элементы, полученные из RTestData, столько раз, сколько требуется для соответствия числу элементов в массиве `df1`.

**Результаты**
    
|*Col2*|*Col3*|
|----|----|
|1|1|
|10|2|
|100|3|
|1|4\.|
|10|5|
|100|6|

Помните, что кадр данных только выглядит как таблица, но фактически является списком векторов.

## <a name="cast-or-convert-sql-data"></a>CAST или convert данных SQL

R и SQL используются те же типы данных, поэтому при выполнении запроса в SQL для получения данных и передайте его в среду выполнения R, некоторые тип месте обычно выполняется неявное преобразование. Другой набор преобразований происходит при возвращении данных из R в SQL.

- SQL передает данные из запроса в процесс R и преобразует его во внутреннее представление, для повышения эффективности.
- Среда выполнения R загружает данные в переменную data.frame и выполняет собственные операции с данными.
- Ядро СУБД возвращает данные в SQL с использованием защищенному внутреннему соединению и представляет данные в контексте типов данных SQL.
- Вы получите данные путем подключения к SQL с помощью клиентской или сетевой библиотеки, которая может выполнять SQL-запросы и обрабатывать табличные наборы данных. Это клиентское приложение может повлиять на данные другими способами.

Чтобы узнать, как это работает, выполните запрос, подобный следующему [AdventureWorksDW](https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks) хранилище данных. Это представление возвращает данные о продажах, используемому при создании прогнозов.

```sql
USE AdventureWorksDW
GO

SELECT ReportingDate
    , CAST(ModelRegion AS VARCHAR(50)) AS ProductSeries
    , Amount
FROM [AdventureWorksDW].[dbo].[vTimeSeries]
WHERE [ModelRegion] = 'M200 Europe'
ORDER BY ReportingDate ASC
```

> [!NOTE]
> Можно использовать любую версию AdventureWorks или создайте другой запрос, используя базу данных из собственных. Точка находится в том, чтобы обработать некоторые данные, которые содержит текст, даты и времени и числовых значений.

Теперь попробуйте, используя этот запрос для ввода в хранимую процедуру.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
str(InputDataSet);
OutputDataSet <- InputDataSet;
'
    , @input_data_1 = N'
           SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = ''M200 Europe''
           ORDER BY ReportingDate ASC ;'
WITH RESULT SETS undefined;
```

Если отобразится сообщение об ошибке, вы, вероятно, потребуется внести некоторые изменения в тексте запроса. Например строковый предикат в предложении WHERE должен заключаться в два набора одинарных кавычек.

Получив запрос, в работе, просмотрите результаты `str` функцию, чтобы увидеть, как R обрабатывает входные данные.

**Результаты**

```text
STDOUT message(s) from external script: 'data.frame':    37 obs. of  3 variables:
STDOUT message(s) from external script: $ ReportingDate: POSIXct, format: "2010-12-24 23:00:00" "2010-12-24 23:00:00"
STDOUT message(s) from external script: $ ProductSeries: Factor w/ 1 levels "M200 Europe",..: 1 1 1 1 1 1 1 1 1 1
STDOUT message(s) from external script: $ Amount       : num  3400 16925 20350 16950 16950
```

- Столбец datetime была обработана с использованием типа данных R, **POSIXct**.
- Текстовый столбец «ProductSeries» определен в качестве **идентификации**, то есть категориальной переменной. Строковые значения обрабатываются как коэффициенты по умолчанию. Если передать строку в R, он преобразуется в целое число для внутреннего использования и сопоставляется со строками на выходе.

## <a name="summary"></a>Сводка

Из даже эти краткие примеры вы увидите необходимость проверить влияние преобразования данных при передаче SQL запросов в качестве входных данных. Так как некоторые типы данных SQL не поддерживаются языком R, рассмотрим эти способы избежания ошибок:

- Проверяйте данные заранее и проверяйте столбцы или значения в схеме, возможно, возникла проблема при передаче в код R.
- Указывайте столбцы из источника входных данных по отдельности, вместо того чтобы использовать `SELECT *`и узнать, как будет обрабатываться каждого столбца.
- Выполняйте явные приведения, при необходимости, при подготовке входных данных, чтобы избежать непредвиденных проблем.
- Избегайте столбцов передачи данных (например, идентификаторы GUID или идентификаторами rowguids), привести к ошибкам и не используются для моделирования.

Дополнительные сведения о поддерживаемых и неподдерживаемых типов данных R, см. в разделе [R библиотеки и типы данных](/sql/advanced-analytics/r/r-libraries-and-data-types).
