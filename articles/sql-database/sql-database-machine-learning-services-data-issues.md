---
title: Работа с типами и объектами данных R и S'L
titleSuffix: Azure SQL Database Machine Learning Services (preview)
description: Узнайте, как работать с типами данных и объектами данных в R с базой данных Azure S'L с помощью служб машинного обучения (предварительный просмотр), включая общие проблемы, с которыми вы можете столкнуться.
services: sql-database
ms.service: sql-database
ms.subservice: machine-learning
ms.custom: ''
ms.devlang: r
ms.topic: conceptual
author: garyericson
ms.author: garye
ms.reviewer: davidph
manager: cgronlun
ms.date: 04/11/2019
ms.openlocfilehash: 0bb3abc7b7102da55c9ededcadd7a301f74065ab
ms.sourcegitcommit: 8a9c54c82ab8f922be54fb2fcfd880815f25de77
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "80349327"
---
# <a name="work-with-r-and-sql-data-in-azure-sql-database-machine-learning-services-preview"></a>Work with R and SQL data in Azure SQL Database Machine Learning Services (preview) (Работа с данными R и SQL в Службе машинного обучения в Базе данных SQL Azure)

В этой статье рассматриваются некоторые из общих проблем, с которыми вы можете столкнуться при перемещении данных между базой данных R и S'L в [службах машинного обучения (с R) в базе данных Azure S'L.](sql-database-machine-learning-services-overview.md) Опыт, который вы получите в этом упражнении, позволит приобрести основные навыки для работы с данными в собственном сценарии.

[!INCLUDE[ml-preview-note](../../includes/sql-database-ml-preview-note.md)]

Общие проблемы, с которыми вы можете столкнуться, включают:

- Иногда типы данных не совпадают
- Могут иметь место неявные преобразования
- Иногда требуются операции приведения и преобразования.
- R и SQL используют разные объекты данных.

## <a name="prerequisites"></a>Предварительные требования

- Если у вас нет подписки Azure, [создайте учетную запись перед началом.](https://azure.microsoft.com/free/)

- Чтобы запустить пример кода в этих упражнениях, сначала необходимо включить в Базе данных SQL Azure Службы машинного обучения (с поддержкой R). Во время использования общедоступной предварительной версии корпорация Майкрософт подключит вас и включит машинное обучение для имеющейся или новой базы данных. Выполните шаги, приведенные в разделе [Sign up for the preview](sql-database-machine-learning-services-overview.md#signup) (Регистрация для получения предварительной версии).

- Убедитесь, что у вас установлена последняя версия [SQL Server Management Studio](https://docs.microsoft.com/sql/ssms/sql-server-management-studio-ssms) (SSMS). Вы можете выполнять сценарии R с помощью других инструментов управления базами данных или выполнения запросов, но в этом кратком руководстве вы будете использовать SSMS.

## <a name="working-with-a-data-frame"></a>Работа с рамой данных

Когда скрипт возвращает результаты от R до S'L, он должен вернуть данные в виде **data.frame.** Любой другой тип объекта, создаваемого в сценарии (список, коэффициент, вектор или двоичные данные) нужно преобразовать в кадр данных, если необходимо вывести его в результатах хранимой процедуры. К счастью существует несколько функций R, поддерживающих изменение других объектов на кадр данных. Вы даже можете сериализировать двоичную модель и вернуть ее в рамку данных, что вы будете делать позже в этой статье.

Во-первых, давайте поэкспериментируем с некоторыми основными объектами R - векторами, матрицами и списками - и посмотрим, как преобразование в кадр данных изменяет выход, передаваемый в S'L.

Сравните эти два сценария "Hello World" на языке R. Сценарии выглядят почти одинаково, однако первый сценарий возвращает один столбец с тремя значениями, а второй — три столбца, каждый из которых содержит по одному значению.

**Пример 1**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N' mytextvariable <- c("hello", " ", "world");
OutputDataSet <- as.data.frame(mytextvariable);
'
    , @input_data_1 = N'';
```

**Пример 2**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N' OutputDataSet<- data.frame(c("hello"), " ", c("world"));'
    , @input_data_1 = N'';
```

Почему результаты настолько отличаются?

Обычно ответ можно найти, использовав команду R `str()`. Добавьте функцию `str(object_name)` в скрипте R для получения сведений о схеме данных возвращаемого объекта R в виде информационного сообщения. Вы можете просматривать сообщения во вкладке **Сообщения** в SSMS.

Чтобы понять, почему результаты примера 1 и 2 так сильно отличаются, вставьте строку `str(OutputDataSet)` в конце определения переменной `@script` в каждой инструкции следующим образом:

**Пример 1 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
mytextvariable <- c("hello", " ", "world");
OutputDataSet <- as.data.frame(mytextvariable);
str(OutputDataSet);
'
    , @input_data_1 = N'  ';
```

**Пример 2 с добавленной функцией str**

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
OutputDataSet <- data.frame(c("hello"), " ", c("world"));
str(OutputDataSet);
'
    , @input_data_1 = N'  ';
```

Теперь просмотрите текст на вкладке **Сообщения**, в котором можно определить причину такой разницы.

**Результаты примера 1**

```text
STDOUT message(s) from external script:
'data.frame':    3 obs. of  1 variable:
$ mytextvariable: Factor w/ 3 levels " ","hello","world": 2 1 3
```

**Результаты примера 2**

```text
STDOUT message(s) from external script:
'data.frame':    1 obs. of  3 variables:
$ c..hello..: Factor w/ 1 level "hello": 1
$ X...      : Factor w/ 1 level " ": 1
$ c..world..: Factor w/ 1 level "world": 1
```

Как видно, небольшие изменения в синтаксисе R сильно повлияли на схему результатов. Для всех деталей, различия в типах данных R подробно описаны в разделе *Структуры данных* в ["Advanced R" Хэдли Уикхем](http://adv-r.had.co.nz).

Сейчас помните, что необходимо проверить ожидаемые результаты при приведении объектов R в кадры данных.

> [!TIP]
> Вы также можете использовать функции `is.matrix` `is.vector`идентификации R, такие как, для возврата информации о внутренней структуре данных.

## <a name="implicit-conversion-of-data-objects"></a>Неявное преобразование объектов данных

Каждый объект данных R имеет собственные правила обработки значений в сочетании с другими объектами данных, если объекты данных имеют одинаковое количество измерений или если любой объект данных содержит разнородные типы данных.

Например, предположим, что вы хотите выполнить умножение матрицы с помощью R. Вы хотите умножить матрицу с одной колонкой с тремя значениями на массив с четырьмя значениями и ожидать матрицы 4x3 в результате.

Сначала создайте небольшую таблицу тестовых данных.

```sql
CREATE TABLE RTestData (col1 INT NOT NULL)

INSERT INTO RTestData
VALUES (1);

INSERT INTO RTestData
VALUES (10);

INSERT INTO RTestData
VALUES (100);
GO
```

Теперь запустите следующий сценарий.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
x <- as.matrix(InputDataSet);
y <- array(12:15);
OutputDataSet <- as.data.frame(x %*% y);
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS((
            [Col1] INT
            , [Col2] INT
            , [Col3] INT
            , Col4 INT
            ));
```

Один столбец с тремя значениями преобразуется в матрицу с одним столбцом. Так как матрица представляет собой особый вид массива в R, массив `y` неявно приводится к матрице с одним столбцом, чтобы обеспечить соответствие двух аргументов.

**Результаты**

|Col1|Col2|Col3|Col4|
|---|---|---|---|
|12|13|14|15|
|120|130|140|150|
|1200|1300|1400|1500|

Однако обратите внимание, что происходит при изменении размера массива `y`.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
x <- as.matrix(InputDataSet);
y <- array(12:14);
OutputDataSet <- as.data.frame(y %*% x);
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS(([Col1] INT));
```

На этот раз код R вернет одно значение в качестве результата.

**Результаты**
    
|Col1|
|---|
|1542|

Почему? Так как в этом случае два аргумента могут обрабатываться как векторы одинаковой длины, код R возвращает скалярное произведение в виде матрицы.  Это ожидаемое поведение в соответствии с правилами линейной алгебры. Тем не менее, это может вызвать проблемы, если приложение ниже по течению ожидает, что схема вывода никогда не изменится!

## <a name="merge-or-multiply-columns-of-different-length"></a>Слияние или перемножение столбцов разной длины

R обеспечивает большую гибкость для работы с векторами различных размеров и для объединения структур в виде столбцов в кадры данных. Списки векторов могут выглядеть как таблица, но они не подчиняются всем правилам, управляющим таблицами базы данных.

Например, следующий скрипт определяет числовой массив, длина которого равна 6, и сохраняет его в переменной R `df1`. Числовой массив затем сочетается с целыми числами таблицы RTestData (создана выше), которая содержит три `df2`(3) значения, чтобы сделать новую рамку данных, .

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
df1 <- as.data.frame( array(1:6) );
df2 <- as.data.frame( c( InputDataSet , df1 ));
OutputDataSet <- df2;
'
    , @input_data_1 = N' SELECT [Col1]  from RTestData;'
WITH RESULT SETS((
            [Col2] INT NOT NULL
            , [Col3] INT NOT NULL
            ));
```

Чтобы заполнить кадр данных, R повторно использует элементы, полученные из RTestData, столько раз, сколько требуется в соответствии с числом элементов в массиве `df1`.

**Результаты**
    
|*Col2*|*Col3*|
|----|----|
|1|1|
|10|2|
|100|3|
|1|4|
|10|5|
|100|6|

Помните, что рамка данных выглядит только как таблица, но на самом деле представляет собой список векторов.

## <a name="cast-or-convert-sql-data"></a>Отбрасывая или преобразовывая данные S'L

R и S'L не используют одни и те же типы данных, поэтому при запуске запроса в S'L для получения данных, а затем передается в R время выполнения, обычно происходит некоторый тип неявного преобразования. Другой набор конверсий происходит при возврате данных с R в S'L.

- СЗЛ передвигает данные из запроса в процесс R и преобразует их во внутреннее представление для повышения эффективности.
- Среда выполнения R загружает данные в переменную data.frame и выполняет собственные операции с данными.
- Движок базы данных возвращает данные в S'L с помощью защищенного внутреннего соединения и представляет данные с точки зрения типов данных S'L.
- Данные получаются, подключившись к S'L, используя клиентскую или сетевую библиотеку, которая может выдавать запросы s-L и обрабатывать таблетные наборы данных. Это клиентское приложение может и по-другому влиять на данные.

Чтобы узнать, как это работает, запустите запрос, подобный этому, на хранилище данных [AdventureWorksDW.](https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks) Это представление возвращает данные продаж, используемые для создания прогнозов.

```sql
USE AdventureWorksDW
GO

SELECT ReportingDate
    , CAST(ModelRegion AS VARCHAR(50)) AS ProductSeries
    , Amount
FROM [AdventureWorksDW].[dbo].[vTimeSeries]
WHERE [ModelRegion] = 'M200 Europe'
ORDER BY ReportingDate ASC
```

> [!NOTE]
> Можно использовать любую версию AdventureWorks или создать другой запрос, используя собственную базу данных. Смысл в том, чтобы попытаться обрабатывать некоторые данные, которые содержат текст, время даты и числовые значения.

Теперь попробуйте использовать этот запрос в качестве ввода в сохраненную процедуру.

```sql
EXECUTE sp_execute_external_script @language = N'R'
    , @script = N'
str(InputDataSet);
OutputDataSet <- InputDataSet;
'
    , @input_data_1 = N'
           SELECT ReportingDate
         , CAST(ModelRegion as varchar(50)) as ProductSeries
         , Amount
           FROM [AdventureWorksDW].[dbo].[vTimeSeries]
           WHERE [ModelRegion] = ''M200 Europe''
           ORDER BY ReportingDate ASC ;'
WITH RESULT SETS undefined;
```

Если появляется сообщение об ошибке, возможно, необходимо внести некоторые изменения в текст запроса. Например, строковый предикат в предложении WHERE нужно заключать в два набора одинарных кавычек.

После того, как запрос начнет действовать, просмотрите результаты выполнения функции `str`, чтобы увидеть, как R обрабатывает входные данные.

**Результаты**

```text
STDOUT message(s) from external script: 'data.frame':    37 obs. of  3 variables:
STDOUT message(s) from external script: $ ReportingDate: POSIXct, format: "2010-12-24 23:00:00" "2010-12-24 23:00:00"
STDOUT message(s) from external script: $ ProductSeries: Factor w/ 1 levels "M200 Europe",..: 1 1 1 1 1 1 1 1 1 1
STDOUT message(s) from external script: $ Amount       : num  3400 16925 20350 16950 16950
```

- Столбец datetime был обработан с использованием типа данных R **POSIXct**.
- В качестве **фактора,** означающего категорическую переменную, была определена текстовая колонка "ProductSeries". Строковые значения обрабатываются как коэффициенты по умолчанию. Если передать строку в R, она преобразуется в целое число для внутреннего использования и сопоставляется со строками на выходе.

## <a name="summary"></a>Сводка

Даже в этих коротких примерах можно увидеть, как следует проверять последствия преобразования данных при передаче запросов SQL в качестве входных данных. Поскольку некоторые типы данных S'L не поддерживаются R, рассмотрим следующие способы избежать ошибок:

- Проверяйте данные заранее, а также проверяйте столбцы и значения в схеме, которые могут вызвать проблему при передаче в код R.
- Указывайте столбцы из источника входных данных по отдельности. Не используйте `SELECT *`. Определите способ обработки каждого столбца.
- Во избежание непредвиденных ситуаций во время подготовки входных данных при необходимости выполняйте явные приведения.
- Избегайте передачи столбцов данных (например, идентификаторов GUID или идентификаторов GUID строк). Они вызывают ошибки и не требуются для моделирования.

Для получения дополнительной информации об поддерживаемых [R libraries and data types](/sql/advanced-analytics/r/r-libraries-and-data-types)и неподдерживаемых типах r-данных см.
