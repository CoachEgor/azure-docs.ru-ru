---
title: Управление историческими данными в временных таблицах
description: Узнайте, как использовать политику темпорального хранения для постоянного контроля над историческими данными.
services: sql-database
ms.service: sql-database
ms.subservice: development
ms.custom: ''
ms.devlang: ''
ms.topic: conceptual
author: bonova
ms.author: bonova
ms.reviewer: carlrab
ms.date: 09/25/2018
ms.openlocfilehash: 3c2460c6f5e0905f45106148ecc3e8a949cf221f
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "73820687"
---
# <a name="manage-historical-data-in-temporal-tables-with-retention-policy"></a>Управление историческими данными в темпоральных таблицах с политикой хранения

Темпоральные таблицы увеличивают размер базы данных больше, чем обычные таблицы, особенно если исторические данные хранятся в течение длительного времени. Поэтому политика хранения для исторических данных является важной составляющей управления жизненным циклом любой темпоральной таблицы. Темпоральные таблицы в базе данных SQL Azure включают удобный механизм хранения, который помогает выполнить эту задачу.

Хранение темпоральных журналов можно настроить на уровне отдельных таблиц, что позволит пользователям создавать гибкие политики устаревания. Применять темпоральные журналы легко: для настройки во время создания таблицы или изменения схемы требуется только один параметр.

Как только политика хранения определена, база данных Azure SQL начинает регулярно проверять, подходят ли исторические строки для автоматической очистки данных. Идентификация совпадающих строк и их удаление из таблицы журналов осуществляется прозрачно, в рамках фоновой задачи, которая планируются и выполняются системой. Условие устаревания строк в таблицах журналов проверяется по столбцу, представляющему окончание периода SYSTEM_TIME. Например, если срок хранения составляет шесть месяцев, для очистки подходят строки, отвечающие следующему условию:

```
ValidTo < DATEADD (MONTH, -6, SYSUTCDATETIME())
```

В предыдущем примере предполагается, что столбец **ValidTo** соответствует концу SYSTEM_TIME периода.

## <a name="how-to-configure-retention-policy"></a>Настройка политики хранения

Прежде чем настраивать политику хранения для темпоральной таблицы, проверьте, включена ли функция темпорального хранения исторических данных *на уровне базы данных*.

```
SELECT is_temporal_history_retention_enabled, name
FROM sys.databases
```

Флаг базы данных **is_temporal_history_retention_enabled** по умолчанию установлен, однако пользователи могут его изменить с помощью инструкции ALTER DATABASE. Он также автоматически получает значение OFF (Выкл.) после [восстановления до точки во времени](sql-database-recovery-using-backups.md). Чтобы включить очистку хранения журналов для базы данных, выполните следующую инструкцию:

```sql
ALTER DATABASE <myDB>
SET TEMPORAL_HISTORY_RETENTION  ON
```

> [!IMPORTANT]
> Срок хранения для темпоральных таблиц можно настроить, даже если флаг **is_temporal_history_retention_enabled** имеет значение OFF, но в этом случае не будет активироваться автоматическая очистка для устаревших строк.

Политика хранения настраивается во время создания таблицы путем указания значения для параметра HISTORY_RETENTION_PERIOD:

```sql
CREATE TABLE dbo.WebsiteUserInfo
(  
    [UserID] int NOT NULL PRIMARY KEY CLUSTERED
  , [UserName] nvarchar(100) NOT NULL
  , [PagesVisited] int NOT NULL
  , [ValidFrom] datetime2 (0) GENERATED ALWAYS AS ROW START
  , [ValidTo] datetime2 (0) GENERATED ALWAYS AS ROW END
  , PERIOD FOR SYSTEM_TIME (ValidFrom, ValidTo)
 )  
 WITH
 (
     SYSTEM_VERSIONING = ON
     (
        HISTORY_TABLE = dbo.WebsiteUserInfoHistory,
        HISTORY_RETENTION_PERIOD = 6 MONTHS
     )
 );
```

База данных SQL Azure позволяет указать срок хранения, используя различные единицы времени: DAYS (дни), WEEKS (недели), MONTHS (месяцы) и YEARS (годы). Если параметр HISTORY_RETENTION_PERIOD опущен, это означает, что срок хранения НЕ ОГРАНИЧЕН (INFINITE). Кроме того, ключевое слово INFINITE можно использовать явным образом.

В некоторых сценариях настройка хранения может потребоваться после создания таблицы либо для того, чтобы изменить значение, заданное ранее. В этом случае используйте инструкцию ALTER TABLE:

```sql
ALTER TABLE dbo.WebsiteUserInfo
SET (SYSTEM_VERSIONING = ON (HISTORY_RETENTION_PERIOD = 9 MONTHS));
```

> [!IMPORTANT]
> Если для параметра SYSTEM_VERSIONING задать значение OFF, значение срока хранения *не сохраняется*. Если для параметра SYSTEM_VERSIONING задать значение ON, не указывая явно значение HISTORY_RETENTION_PERIOD, будет установлен неограниченный (INFINITE) срок хранения.

Чтобы узнать текущее состояние политики хранения, выполните указанный ниже запрос, объединяющий флаг включения временного хранения на уровне базы данных со сроками хранения для отдельных таблиц:

```sql
SELECT DB.is_temporal_history_retention_enabled,
SCHEMA_NAME(T1.schema_id) AS TemporalTableSchema,
T1.name as TemporalTableName,  SCHEMA_NAME(T2.schema_id) AS HistoryTableSchema,
T2.name as HistoryTableName,T1.history_retention_period,
T1.history_retention_period_unit_desc
FROM sys.tables T1  
OUTER APPLY (select is_temporal_history_retention_enabled from sys.databases
where name = DB_NAME()) AS DB
LEFT JOIN sys.tables T2   
ON T1.history_table_id = T2.object_id WHERE T1.temporal_type = 2
```


## <a name="how-sql-database-deletes-aged-rows"></a>Как База данных SQL удаляет устаревшие строки?

Процесс очистки зависит от макета индекса таблицы журналов. Следует отметить, что *ограниченный срок хранения можно настроить только для таблиц журналов с кластеризованным индексом (columnstore или сбалансированным деревом)*. Для очистки устаревших данных во всех темпоральных таблицах с ограниченным периодом хранения создается фоновая задача.
Логика очистки для кластеризованного индекса типа rowstore (сбалансированное дерево) удаляет устаревшие строки мелкими фрагментами (не более 10 000), чтобы свести к минимуму нагрузку на журнал базы данных и подсистему ввода-вывода. Несмотря на то что в логике очистки используется индекс сбалансированного дерева, порядок удаления строк, возраст которых превышает срок хранения, может не соблюдаться. В связи с этим *не включайте в приложения никакие зависимости от порядка очистки*.

Задача очистки для кластеризованного индекса columnstore удаляет полные [группы строк](https://msdn.microsoft.com/library/gg492088.aspx) за один раз (обычно они содержат по миллиону строк). Это очень эффективный механизм, особенно если исторические данные формируются с высокой скоростью.

![Кластеризованный период удержания columnstore](./media/sql-database-temporal-tables-retention-policy/cciretention.png)

Превосходное сжатие данных и эффективная очистка хранилища делают кластеризованный индекс columnstore наиболее подходящим для случаев, когда рабочая нагрузка вызывает быстрое образование большого количества исторических данных. Этот шаблон традиционно используется для интенсивных [рабочих нагрузок с обработкой транзакций, использующих темпоральные таблицы](https://msdn.microsoft.com/library/mt631669.aspx), позволяя отслеживать изменения, проводить аудит и анализ тенденций, а также принимать данные от систем Интернета вещей.

## <a name="index-considerations"></a>Рекомендации по выбору индекса

Задача очистки для таблиц с кластеризованным индексом rowstore требует, чтобы индекс начинался со столбца, соответствующего окончанию периода SYSTEM_TIME. Если такого индекса не существует, вы не сможете настроить хранение с ограниченным сроком.

*Сообщение 13765, уровень 16, состояние 1 <br> </br> . Установка конечного срока хранения завершилась сбоем в темпоральной таблице с версией системы "temporalstagetestdb. dbo. WebsiteUserInfo", так как таблица журнала "temporalstagetestdb. dbo. WebsiteUserInfoHistory" не содержит необходимый кластеризованный индекс. Рассмотрите возможность создания кластеризованного индекса columnstore или сбалансированного дерева, начинающегося со столбца, который соответствует концу SYSTEM_TIME периода, в таблице журнала.*

Важно заметить, что таблица исторических данных по умолчанию, созданная базой данных SQL Azure, уже включает кластеризованный индекс, совместимый с политикой хранения. При попытке удаления такого индекса для таблицы с ограниченным сроком хранения операция завершается следующей ошибкой:

*Сообщение 13766, уровень 16, состояние 1 <br> </br> не может удалить кластеризованный индекс "WebsiteUserInfoHistory. IX_WebsiteUserInfoHistory", так как он используется для автоматической очистки устаревших данных. Если необходимо удалить этот индекс, попробуйте задать для параметра HISTORY_RETENTION_PERIOD значение INFINITE в соответствующей темпоральной таблице с системным управлением версиями.*

Очистка в кластеризованном индексе columnstore работает лучше всего, если строки исторических данных вставляются в порядке возрастания (с сортировкой по столбцу окончания периода). Это условие выполняется всегда, если таблицы исторических данных заполняются исключительно с помощью механизма SYSTEM_VERSIONIOING. Если строки в исторической таблице не упорядочены по столбцу окончания периода (это возможно, если выполнялась миграция существующих исторических данных), нужно заново создать кластеризованный индекс columnstore. Для оптимальной производительности создавайте его поверх правильно отсортированного индекса сбалансированного дерева rowstore.

Старайтесь не перестраивать кластеризованный индекс columnstore для таблицы исторических данных с ограниченным сроком хранения, так как это может изменить порядок групп строк, естественным образом созданный в результате работы системы управления версиями. Если необходимо перестроить кластеризованный индекс columnstore для таблицы исторических данных, создавайте его поверх правильного индекса сбалансированного дерева, чтобы сохранить в группах строк порядок, необходимый для регулярной очистки данных. Аналогичный подход следует применять и при создании темпоральной таблицы из существующей таблицы исторических данных с кластеризованным индексом столбцов, но без гарантированного порядка данных:

```sql
/*Create B-tree ordered by the end of period column*/
CREATE CLUSTERED INDEX IX_WebsiteUserInfoHistory ON WebsiteUserInfoHistory (ValidTo)
WITH (DROP_EXISTING = ON);
GO
/*Re-create clustered columnstore index*/
CREATE CLUSTERED COLUMNSTORE INDEX IX_WebsiteUserInfoHistory ON WebsiteUserInfoHistory
WITH (DROP_EXISTING = ON);
```

Если вы настроите ограниченный срок хранения для таблицы исторических данных с кластеризованным индексом columnstore, вы не сможете создавать дополнительные некластеризованные индексы сбалансированного дерева для этой таблицы:

```sql
CREATE NONCLUSTERED INDEX IX_WebHistNCI ON WebsiteUserInfoHistory ([UserName])
```

Попытка выполнить приведенную выше инструкцию завершится следующей ошибкой.

*MSG 13772, уровень 16, состояние 1 <br> </br> не может создать некластеризованный индекс для темпоральной таблицы журнала "WebsiteUserInfoHistory", так как он содержит конечный срок хранения и определенный кластеризованный индекс columnstore.*

## <a name="querying-tables-with-retention-policy"></a>Запросы к таблицам с политикой хранения

Все запросы к темпоральным таблицам автоматически фильтруют строки исторических данных в соответствии с политикой ограниченного срока хранения. Это позволяет избежать непредсказуемости и несогласованности результатов, так как задача очистки может удалять устаревшие строки *в любой момент времени и в произвольном порядке*.

На следующем рисунке показан план для простого запроса.

```sql
SELECT * FROM dbo.WebsiteUserInfo FOR SYSTEM_TIME ALL;
```

План запроса содержит дополнительный фильтр, применяемый к столбцу окончания периода (ValidTo) в операторе "Clustered Index Scan" (Сканирование кластеризованного индекса) в таблице исторических данных (выделено). В этом примере предполагается, что для таблицы WebsiteUserInfo задан срок хранения "1 MONTH" (1 месяц).

![Фильтр для запроса хранения](./media/sql-database-temporal-tables-retention-policy/queryexecplanwithretention.png)

Но если вы будете запрашивать таблицы исторических данных напрямую, результат может включать строки старше указанного периода хранения. При этом нет никаких гарантий, что повторные запросы вернут такие же результаты. На следующем рисунке показан план выполнения для запроса в таблице исторических данных без применения дополнительных фильтров.

![Запрос по историческим данным без фильтра хранения](./media/sql-database-temporal-tables-retention-policy/queryexecplanhistorytable.png)

Не следует основывать бизнес-логику приложения на считывании таблицы исторических данных по окончании срока хранения. В таком случае вы можете получить несогласованные или непредвиденные результаты. Мы рекомендуем использовать для анализа данных в темпоральных таблицах только темпоральные запросы с предложением FOR SYSTEM_TIME.

## <a name="point-in-time-restore-considerations"></a>Рекомендации по восстановлению до точки во времени

При создании новой базы данных путем [восстановления базы данных до определенной точки во времени](sql-database-recovery-using-backups.md) темпоральное хранение отключается на уровне базы данных. (Флаг **is_temporal_history_retention_enabled** получает значение OFF.) Эта функция позволяет изучить все строки исторических данных после восстановления, не беспокоясь, что устаревшие строки будут удалены еще до отправки запроса к ним. Используйте этот режим для *изучения исторических данных по окончании установленного срока хранения*.

Предположим, что для темпоральной таблицы задан срок хранения в 1 месяц. Если база данных создана на уровне службы "Премиум", вы сможете создать копию базы данных с состоянием базы данных за последние 35 дней. Это фактически позволит вам анализировать строки исторических данных за период до 65 дней с помощью прямых запросов к таблице исторических данных.

Если вы хотите активировать очистку темпорального хранения, выполните следующую инструкцию Transact-SQL после восстановления до точки во времени:

```sql
ALTER DATABASE <myDB>
SET TEMPORAL_HISTORY_RETENTION  ON
```

## <a name="next-steps"></a>Дальнейшие действия

Чтобы узнать, как использовать временные таблицы в приложениях, изучите [Начало работы с временными таблицами в базе данных SQL Azure](sql-database-temporal-tables.md).

Посетите сайт Channel 9, чтобы услышать [историю успешного внедрения темпоральных решений реальным клиентом](https://channel9.msdn.com/Blogs/jsturtevant/Azure-SQL-Temporal-Tables-with-RockStep-Solutions) и просмотреть [наглядную демонстрацию темпоральных решений](https://channel9.msdn.com/Shows/Data-Exposed/Temporal-in-SQL-Server-2016).

Дополнительные сведения о темпоральных таблицах см. в [документации MSDN](https://msdn.microsoft.com/library/dn935015.aspx).
