---
title: Ссылка на схему для типов триггеров и действий
description: Справочное руководство по ссылкам на язык определения рабочего процесса для триггеров и типов действий в приложениях логики Azure
services: logic-apps
ms.suite: integration
ms.reviewer: klam, logicappspm
ms.topic: conceptual
ms.date: 01/19/2020
ms.openlocfilehash: 18e9c9d330ffb8cc4e284fc649cff0840ec2c82c
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79270372"
---
# <a name="schema-reference-guide-for-trigger-and-action-types-in-azure-logic-apps"></a>Справочник Schema для типов триггеров и действий в приложениях логики Azure

Эта ссылка описывает общие типы, используемые для определения триггеров и действий в базовом определении рабочего процесса приложения логики, которое описано и подтверждено [языком определения рабочего процесса.](../logic-apps/logic-apps-workflow-definition-language.md) Чтобы найти конкретные триггеры и действия разъема, которые можно использовать в логических приложениях, смотрите список под [обзором Connectors.](https://docs.microsoft.com/connectors/)

<a name="triggers-overview"></a>

## <a name="triggers-overview"></a>Общие сведения о триггерах

Каждый рабочий процесс включает в себя триггер, который определяет вызовы, которые мгновенно и начать рабочий процесс. Ниже приведены общие категории триггеров.

* *Опрашивающий* триггер проверяет конечную точку службы через равные промежутки времени.

* *Извещающий* триггер создает подписку на конечную точку и предоставляет *URL-адрес обратного вызова*, чтобы конечная точка могла уведомлять триггер, когда происходит указанное событие или стали доступны данные. Затем триггер ожидает ответа конечной точки, прежде чем сработать.

Триггеры имеют следующие основные элементы, хотя некоторые из них являются необязательными.  
  
```json
"<trigger-name>": {
   "type": "<trigger-type>",
   "inputs": { "<trigger-inputs>" },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "conditions": [ "<array-with-conditions>" ],
   "runtimeConfiguration": { "<runtime-config-options>" },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
},
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*триггер-имя*> | Строка | Имя триггера | 
| <*триггерный тип*> | Строка | Тип триггера, например Http или ApiConnection | 
| <*триггерные вводы*> | Объект JSON | Входные данные, определяющие режим работы триггера | 
| <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*массив-с-условиями*> | Array | Массив, содержащий одно или несколько [условий,](#trigger-conditions) определяющих, следует ли запускать рабочий процесс. Доступно только для триггеров. | 
| <*варианты выполнения-конфигурации*> | Объект JSON | Можно изменить поведение триггера во время выполнения, задав свойства `runtimeConfiguration`. Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options). | 
| <*сплитон-выражение*> | Строка | Для триггеров, возвращающих массив, можно указать выражение для обработки, которое [разделяет или *выполняет по отдельности*](#split-on-debatch) элементы массива на нескольких экземплярах рабочего процесса. | 
| <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

## <a name="trigger-types-list"></a>Список типов триггеров

Каждый тип триггера имеет свой интерфейс и свои входные данные, которые определяют его поведение. 

### <a name="built-in-triggers"></a>Встроенные триггеры

| Тип триггера | Описание | 
|--------------|-------------| 
| [**HTTP**](#http-trigger) | Проверяет или *опрашивает* любую конечную точку. Конечная точка должна соответствовать определенному условию триггера, используя шаблон асинхронных операций 202 или возвращая массив. | 
| [**HTTPWebhook**](#http-webhook-trigger) | Создает вызываемую конечную точку для приложения логики, но также вызывает указанный URL-адрес для регистрации или отмены регистрации. |
| [**Повторения**](#recurrence-trigger) | Активируется на основе определенного расписания. Можно задать дату и время в будущем для срабатывания триггера. На основе частоты можно также указать время и дни запуска рабочего процесса. | 
| [**Запрос**](#request-trigger)  | Создает вызываемую конечную точку для приложения логики, также называется "ручным" триггером. Например, ознакомьтесь со статьей [Вызовы, срабатывания триггеров и создание вложенных рабочих процессов в приложениях логики](../logic-apps/logic-apps-http-endpoint.md). | 
||| 

### <a name="managed-api-triggers"></a>Управляемые триггеры API

| Тип триггера | Описание | 
|--------------|-------------| 
| [**ApiConnection**](#apiconnection-trigger) | Проверяет или *опрашивает* конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md). | 
| [**ApiConnectionWebhook**](#apiconnectionwebhook-trigger) | Создает вызываемую конечную точку для приложения логики, вызывая [управляемые Майкрософт интерфейсы API](../connectors/apis-list.md), для подписки или отмены подписки. | 
||| 

## <a name="triggers---detailed-reference"></a>Триггеры. Подробная справочная информация

<a name="apiconnection-trigger"></a>

### <a name="apiconnection-trigger"></a>Триггер APIConnection  

Этот триггер проверяет или *опрашивает* конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md), поэтому параметры для этого триггера могут отличаться в зависимости от конечной точки. Многие разделы в этом определении триггера являются необязательными. Режим работы триггера зависит от того, включены ли разделы.

```json
"<APIConnection_trigger_name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": { "<retry-behavior>" },
      "queries": { "<query-parameters>" }
   },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
```

*Обязательно*

| Значение | Тип | Описание |
|-------|------|-------------|
| <*APIConnection_trigger_name*> | Строка | Имя триггера |
| <*имя соединения*> | Строка | Имя подключения к управляемому API, который используется рабочим процессом |
| <*тип метода*> | Строка | Метод HTTP для обмена данными с управляемым API: GET, PUT, POST, PATCH или DELETE |
| <*апи-операции*> | Строка | Операция API для вызова |
| <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" |
| <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. |
||||

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*параметры запроса-параметры*> | Объект JSON | Все параметры запроса для включения с помощью вызова API. Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*макс-запуски*> | Целое число | По умолчанию экземпляры рабочего процесса работают в одно и то же время (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-очередь*> | Целое число | Когда рабочий процесс уже работает с максимальным числом экземпляров, которые можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, любые новые запуски помещаются в эту очередь до предела по [умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*сплитон-выражение*> | Строка | Для триггеров, возвращающих массивы, это выражение ссылается на массив, который необходимо использовать, чтобы вы могли создать и запустить экземпляр рабочего процесса для каждого элемента массива, а не использовали цикл Foreach. <p>Например, следующее выражение представляет элемент массива, возвращенный внутри тела триггера: `@triggerbody()?['value']` |
| <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). |
||||

*Выходы*
 
| Элемент | Тип | Описание |
|---------|------|-------------|
| Заголовки | Объект JSON | Заголовки из ответа |
| текст | Объект JSON | Текст из ответа |
| Код состояния | Целое число | Код состояния из ответа |
|||| 

*Пример*

Следующее определение триггера каждый день проверяет электронную почту в папке "Входящие" для учетной записи Office 365 Outlook.

```json
"When_a_new_email_arrives": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "get",
      "path": "/Mail/OnNewEmail",
      "queries": {
          "fetchOnlyWithAttachment": false,
          "folderPath": "Inbox",
          "importance": "Any",
          "includeAttachments": false
      }
   },
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
```

<a name="apiconnectionwebhook-trigger"></a>

### <a name="apiconnectionwebhook-trigger"></a>Триггер ApiConnectionWebhook

Этот триггер отправляет запрос подписке в конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md), предоставляет *URL-адрес обратного вызова*, на который конечная точка может отправить ответ, и ожидает ответа конечной точки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

```json
"<ApiConnectionWebhook_trigger_name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
          "NotificationUrl": "@{listCallbackUrl()}"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "retryPolicy": { "<retry-behavior>" },
      "queries": "<query-parameters>"
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя соединения*> | Строка | Имя подключения к управляемому API, который используется рабочим процессом | 
| <*содержание тела*> | Объект JSON | Любое содержимое сообщения для отправки на управляемый API в качестве полезных данных | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*параметры запроса-параметры*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*макс-запуски*> | Целое число | По умолчанию экземпляры рабочего процесса работают в одно и то же время (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-очередь*> | Целое число | Когда рабочий процесс уже работает с максимальным числом экземпляров, которые можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, любые новые запуски помещаются в эту очередь до предела по [умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*сплитон-выражение*> | Строка | Для триггеров, возвращающих массивы, это выражение ссылается на массив, который необходимо использовать, чтобы вы могли создать и запустить экземпляр рабочего процесса для каждого элемента массива, а не использовали цикл Foreach. <p>Например, следующее выражение представляет элемент массива, возвращенный внутри тела триггера: `@triggerbody()?['value']` |
| <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример*

Это определение триггера подписывается на API Office 365 Outlook, предоставляет URL-адрес обратного вызова на конечную точку API и ожидает ответа конечной точки при получении нового электронного письма.

```json
"When_a_new_email_arrives_(webhook)": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
         "NotificationUrl": "@{listCallbackUrl()}" 
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "path": "/MailSubscription/$subscriptions",
      "queries": {
          "folderPath": "Inbox",
          "hasAttachment": "Any",
          "importance": "Any"
      }
   },
   "splitOn": "@triggerBody()?['value']"
}
```

<a name="http-trigger"></a>

### <a name="http-trigger"></a>Триггер HTTP

Этот триггер отправляет запрос в указанную конечную точку HTTP или HTTPS на основе указанного графика повторения. Затем триггер проверяет ответ, чтобы определить, выполняется ли рабочий процесс.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": "<query-parameters>",
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      }
   },
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательно*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `method` | <*тип метода*> | Строка | Метод использования для отправки исходящего запроса: "GET", "PUT", "POST", "PATCH" или "DELETE" |
| `uri` | <*HTTP-или-HTTPS-конечная точка-URL*> | Строка | URL-адрес HTTP или HTTPS, где требуется отправить исходящий запрос. Максимальный размер строки: 2 КБ. <p>Для службы или ресурса Azure этот синтаксис URI включает идентификатор ресурсов и путь к ресурсу, к которому вы хотите получить доступ. |
| `frequency` | <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" |
| `interval` | <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. |
|||||

*Необязательный*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `headers` | <*заголовок-контент*> | Объект JSON | Любые заголовки, которые необходимо учесть в запросе <p>Пример задания языка и типа. <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| `queries` | <*параметры запроса-параметры*> | Объект JSON | Любые параметры запроса, необходимые для использования в запросе <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к запросу. |
| `body` | <*содержание тела*> | Объект JSON | Содержимое сообщения для отправки в качестве полезных данных с запросом |
| `authentication` | <*значения аутентификации типа и свойства*> | Объект JSON | Модель проверки подлинности, которую использует запрос для проверки подлинности исходящих запросов. Для получения дополнительной информации [см. Добавить аутентификацию к исходящим вызовам.](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) Помимо планировщика поддерживается свойство `authority`. Если не указано значение `https://management.azure.com/`по умолчанию, но вы можете использовать другое значение. |
| `retryPolicy` > `type` | <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). |
| `runs` | <*макс-запуски*> | Целое число | По умолчанию экземпляры рабочего процесса работают в одно и то же время (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). |
| `maximumWaitingRuns` | <*max-runs-очередь*> | Целое число | Когда рабочий процесс уже работает с максимальным числом экземпляров, которые можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, любые новые запуски помещаются в эту очередь до предела по [умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). |
| `operationOptions` | <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). |
|||||

*Выходы*

| Элемент | Тип | Описание |
|---------|------|-------------| 
| Заголовки | Объект JSON | Заголовки из ответа | 
| текст | Объект JSON | Текст из ответа | 
| Код состояния | Целое число | Код состояния из ответа | 
|||| 

*Требования для входящих запросов*

Для качественной работы с приложением логики конечная точка должна соответствовать определенному шаблону или условию триггера и распознавать следующие свойства.  
  
| Ответ | Обязательно | Описание | 
|----------|----------|-------------| 
| Код состояния | Да | Код состояния "200 OK" инициирует запуск. Другие коды состояния — нет. | 
| Заголовок retry-after | нет | Количество секунд до тех пор, пока приложение логики снова не опроверчит конечную точку | 
| Заголовок Location | нет | URL-адрес для вызова во время следующего интервала опроса. Если не указан, используется исходный URL-адрес. | 
|||| 

*Пример поведения для различных запросов*

| Код состояния | Повтор через | Поведение | 
|-------------|-------------|----------|
| 200 | {нет} | Выполняется рабочий процесс, затем после определенного количества повторений снова проверяется, не добавились ли данные. | 
| 200 | 10 с | Выполняется рабочий процесс, затем через 10 секунд снова проверяется, не добавились ли данные. |  
| 202 | 60 секунд | Рабочий процесс не запускается. Следующая попытка происходит через одну минуту с учетом определенного повторения. Если определенное повторение составляет менее минуты, то приоритет имеет заголовок retry-after. В противном случае используется определенное повторение. | 
| 400 | {нет} | Недопустимый запрос, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
| 500 | {нет}| Ошибка сервера, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
|||| 

<a name="http-webhook-trigger"></a>

### <a name="httpwebhook-trigger"></a>Триггер httpWebhook  

Этот триггер делает приложение логики вызываемым, создавая конечную точку, которая может зарегистрировать подписку путем вызова URL-адреса указанной конечной точки. При создании этого триггера в рабочем процессе исходящий запрос выполняет вызов для регистрации подписки. Таким образом, триггер может запустить ожидание событий. Когда операция делает этот триггер недопустимым, исходящий запрос автоматически выполняет вызов для отмены подписки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

Можно также указать [ограничения асинхронных операций](#asynchronous-limits) на триггере **HTTPWebhook**. Поведение триггера зависит от разделов, которые используются или пропускаются.

```json
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<endpoint-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": { "<retry-behavior>" }
         },
      },
      "unsubscribe": {
         "method": "<method-type>",
         "url": "<endpoint-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" }
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

Некоторые значения, например <*method-type*>, доступны для объектов `"subscribe"` и `"unsubscribe"`.

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*тип метода*> | Строка | Метод HTTP, используемый для запроса подписки: "GET", "PUT", "POST", "PATCH" или "DELETE" | 
| <*конечная точка-подписка-URL*> | Строка | URL-адрес конечной точки для отправки запроса на подписку | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*тип метода*> | Строка | Метод HTTP, используемый для запроса отмены: GET, PUT, POST, PATCH или DELETE | 
| <*конечная точка-отписаться-URL*> | Строка | URL-адрес конечной точки для отправки запроса на отмену | 
| <*содержание тела*> | Строка | Любое содержимое сообщения для отправки в запросе на подписку или отмену | 
| <*тип аутентификации*> | Объект JSON | Модель проверки подлинности, которую использует запрос для проверки подлинности исходящих запросов. Для получения дополнительной информации [см. Добавить аутентификацию к исходящим вызовам.](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) |
| <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*макс-запуски*> | Целое число | По умолчанию экземпляры рабочего процесса работают одновременно (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-очередь*> | Целое число | Когда рабочий процесс уже работает с максимальным числом экземпляров, которые можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, любые новые запуски помещаются в эту очередь до предела по [умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Выходы* 

| Элемент | Тип | Описание |
|---------|------|-------------| 
| Заголовки | Объект JSON | Заголовки из ответа | 
| текст | Объект JSON | Текст из ответа | 
| Код состояния | Целое число | Код состояния из ответа | 
|||| 

*Пример*

Этот триггер создает подписку на указанную конечную точку, предоставляет уникальный URL-адрес обратного вызова и ожидает новых публикаций технологических статей.

```json
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "POST",
         "uri": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{listCallbackUrl()}",
            "hub.mode": "subscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         },
      },
      "unsubscribe": {
         "method": "POST",
         "url": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
            "hub.mode": "unsubscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         }
      }
   }
}
```

<a name="recurrence-trigger"></a>

### <a name="recurrence-trigger"></a>Триггер повторения  

Этот триггер выполняется на основе указанного расписания повторов и предоставляет простой способ создания регулярно запускающегося рабочего процесса.

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
      "startTime": "<start-date-time-with-format-YYYY-MM-DDThh:mm:ss>",
      "timeZone": "<time-zone>",
      "schedule": {
         // Applies only when frequency is Day or Week. Separate values with commas.
         "hours": [ <one-or-more-hour-marks> ], 
         // Applies only when frequency is Day or Week. Separate values with commas.
         "minutes": [ <one-or-more-minute-marks> ], 
         // Applies only when frequency is Week. Separate values with commas.
         "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
      }
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*дата старта-время-с-формат-YYYY-MM-DDThh:mm:ss*> | Строка | Дата и время начала в таком формате: <p>ГГГГ-ММ-ДДTчч:мм:сс, если указан часовой пояс, <p>-или- <p>ГГГГ-ММ-ДДTчч:мм:ссZ, если часовой пояс не указан. <p>Например, если требуется указать 18 сентября 2017 г. в 14:00, то используйте 2017-09-18T14:00:00 и укажите часовой пояс, такой как "Стандартное тихоокеанское время", или укажите "2017-09-18T14:00:00Z" без часового пояса. <p>**Примечание:** Это время начала имеет максимум 49 лет в будущем и должны следовать [спецификации времени даты ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) в [формате даты UTC,](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)но без [смещения UTC.](https://en.wikipedia.org/wiki/UTC_offset) Если не указать часовой пояс, то необходимо в конце добавить букву Z без пробелов. Эта буква Z ссылается на соответствующее [судовое время](https://en.wikipedia.org/wiki/Nautical_time). <p>В простых расписаниях время начала определяет первый случай выполнения задания, а в сложных расписаниях триггер срабатывает не раньше, чем наступит время начала. Дополнительные сведения о дате и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md). | 
| <*часовой пояс*> | Строка | Применяется только при указании времени начала, так как этот триггер не принимает [смещение от UTC](https://en.wikipedia.org/wiki/UTC_offset). Укажите часовой пояс, который необходимо применить. | 
| <*один или более-часовой знак*> | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 23, разделенных запятыми. В эти часы будет запускаться рабочий процесс. <p>Например, если указать 10, 12 и 14, вы получите часовые метки 10:00, 12:00 и 14:00. | 
| <*одна или более минутные отметки*> | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 59, разделенных запятыми. В эти минуты часа будет запускаться рабочий процесс. <p>Например, если указать 30 минут и использовать предыдущий пример для часов, то вы получите 10:30, 12:30 и 14:30. | 
| weekDays | Строка или массив строк | Если для параметра `frequency` задать значение Week, то можно указать один или несколько дней, разделенных запятыми. В эти дни будет запускаться рабочий процесс: Monday (Понедельник), Tuesday (Вторник), Wednesday (Среда), Thursday (Четверг), Friday (Пятница), Saturday (Суббота) и Sunday (Воскресенье). | 
| <*макс-запуски*> | Целое число | По умолчанию экземпляры рабочего процесса работают одновременно (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-очередь*> | Целое число | Когда рабочий процесс уже работает с максимальным числом экземпляров, которые можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, любые новые запуски помещаются в эту очередь до предела по [умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример 1*

Этот основной триггер повторения запускается ежедневно:

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
```

*Пример 2*

Вы можете задать дату и время, когда триггер будет срабатывать. Этот триггер повторения будет запущен в соответствии с указанной датой, а затем будет срабатывать ежедневно:

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1,
      "startTime": "2017-09-18T00:00:00Z"
   }
}
```

*Пример 3*

Этот триггер повторения был запущен 9 сентября 2017 года в 14:00 и запускался каждый понедельник в 10:30, 12:30 и 14:30 по тихоокеанскому времени:

``` json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Week",
      "interval": 1,
      "schedule": {
         "hours": [ 10, 12, 14 ],
         "minutes": [ 30 ],
         "weekDays": [ "Monday" ]
      },
      "startTime": "2017-09-07T14:00:00",
      "timeZone": "Pacific Standard Time"
   }
}
```

Дополнительные сведения, а также примеры это триггера см. в статье [Создание и планирование регулярно выполняющихся задач при помощи Azure Logic Apps](../connectors/connectors-native-recurrence.md).

<a name="request-trigger"></a>

### <a name="request-trigger"></a>Триггер запросов

Этот триггер делает приложение логики вызываемым, создавая конечную точку, которая может принимать входящие запросы. Предоставьте схему JSON для этого триггера, которая описывает и проверяет полезные или входные данные, которые триггер получает от входящего запроса. Схема также упрощает свойства триггеров для ссылки на следующие действия в рабочем процессе.

Чтобы вызвать этот триггер, необходимо использовать API `listCallbackUrl`, описанный в [REST API службы рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows). Чтобы узнать, как использовать этот триггер в качестве конечной точки HTTP, см. сведения в статье [Вызовы, срабатывания триггеров и создание вложенных рабочих процессов в приложениях логики](../logic-apps/logic-apps-http-endpoint.md).

```json
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "<method-type>",
      "relativePath": "<relative-path-for-accepted-parameter>",
      "schema": {
         "type": "object",
         "properties": { 
            "<property-name>": {
               "type": "<property-type>"
            }
         },
         "required": [ "<required-properties>" ]
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      },
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя собственности*> | Строка | Имя свойства в схеме JSON, которое описывает полезные данные | 
| <*типа собственности*> | Строка | Тип свойства | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*тип метода*> | Строка | Метод, который входящие запросы должны использовать для вызова приложения логики: GET, PUT, POST, PATCH или DELETE |
| <*относительный путь-для-принятого параметра*> | Строка | Относительный путь для параметра, который принимает URL-адрес конечной точки | 
| <*требуемые свойства*> | Array | Одно или несколько свойств, требующих значений | 
| <*макс-запуски*> | Целое число | По умолчанию экземпляры рабочего процесса работают одновременно (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*max-runs-очередь*> | Целое число | Когда рабочий процесс уже работает с максимальным числом экземпляров, которые можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, любые новые запуски помещаются в эту очередь до предела по [умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*операция-опция*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример*

Этот триггер указывает, что входящий запрос должен использовать HTTP-метод POST для вызова триггера, а также включать схему, проверяющую входные данные входящего запроса.

```json
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "POST",
      "schema": {
         "type": "object",
         "properties": {
            "customerName": {
               "type": "String"
            },
            "customerAddress": { 
               "type": "Object",
               "properties": {
                  "streetAddress": {
                     "type": "string"
                  },
                  "city": {
                     "type": "string"
                  }
               }
            }
         }
      }
   }
}
```

<a name="trigger-conditions"></a>

## <a name="trigger-conditions"></a>Условия триггера

Для любого триггера (или только для триггера) можно включить массив, содержащий одно или несколько выражений для условий, определяющих, следует ли запускать рабочий процесс. Чтобы добавить свойство `conditions` в триггер в рабочем процессе, откройте приложение логики в редакторе представления кода.

Например, можно указать, что триггер срабатывает, только если веб-сайт возвращает внутреннюю ошибку сервера, ссылаясь на код состояния триггера в свойстве `conditions`.

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Hour",
      "interval": 1
   },
   "conditions": [ {
      "expression": "@equals(triggers().code, 'InternalServerError')"
   } ]
}
```

По умолчанию триггер срабатывает только после получения ответа "200 OK". Если выражение ссылается на код состояния триггера, стандартный режим работы триггера изменяется. Таким образом, если требуется запуск триггера при более чем одном коде состояния, например "200" и "201", необходимо включить в качестве условия следующее выражение.

`@or(equals(triggers().code, 200),equals(triggers().code, 201))` 

<a name="split-on-debatch"></a>

## <a name="trigger-multiple-runs"></a>Множественные запуски триггера

Если триггер возвращает массив для обработки приложением логики, цикл for each может занять слишком много времени для обработки каждого элемента массива. Вместо этого можно использовать свойство **SplitOn** в триггере, чтобы выполнить *индивидуальную обработку* массива. Debatching разделяет элементы массива и запускает новый экземпляр рабочего процесса, который выполняется для каждого элемента массива. Такой подход является эффективным, например, если нужно опросить конечную точку, которая может вернуть несколько новых элементов между интервалами опроса. Максимальное число элементов массива, которое свойство **SplitOn** позволяет обработать в одном приложении логики, см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). 

> [!NOTE]
> Нельзя использовать свойство **SplitOn** с шаблоном синхронного отклика. Любой рабочий процесс, который использует свойство **SplitOn** и содержит действие ответа, выполняется асинхронно и сразу же отправляет ответ `202 ACCEPTED`.
>
> При включении триггерного параллелизма [лимит SplitOn](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) значительно снижается. Если количество элементов превышает этот предел, возможность SplitOn отключена.
 
Если в файле триггера Swagger описаны полезные данные, составляющие массив, **SplitOn** автоматически добавляется в триггер. В противном случае добавьте это свойство в полезные данные ответа, содержащий массив, который нужно обработать индивидуально.

*Пример*

Допустим, что имеется API, который возвращает следующий ответ. 
  
```json
{
   "Status": "Succeeded",
   "Rows": [ 
      { 
         "id": 938109380,
         "name": "customer-name-one"
      },
      {
         "id": 938109381,
         "name": "customer-name-two"
      }
   ]
}
```

Приложению логики требуется только содержимое массива `Rows`, поэтому можно создать триггер, как в следующем примере.

``` json
"HTTP_Debatch": {
   "type": "Http",
    "inputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
   "recurrence": {
      "frequency": "Second",
      "interval": 1
    },
    "splitOn": "@triggerBody()?.Rows"
}
```

> [!NOTE]
> Если используется команда `SplitOn`, получить свойства, которые находятся за пределами массива, невозможно. В нашем примере получить свойство `status` в ответе, возвращенном из API, невозможно.
> 
> Чтобы избежать ошибок, если отсутствует свойство `Rows`, в этом примере используется оператор `?`.

Теперь в определении рабочего процесса можно использовать `@triggerBody().name`, чтобы получить значения `name`, которые являются значениями `"customer-name-one"` при первом выполнении и `"customer-name-two"` при втором выполнении. Выходные данные триггера выглядят так:

```json
{
   "body": {
      "id": 938109380,
      "name": "customer-name-one"
   }
}
```

```json
{
   "body": {
      "id": 938109381,
      "name": "customer-name-two"
   }
}
```

<a name="actions-overview"></a>

## <a name="actions-overview"></a>Общие сведения о действиях

Azure Logic Apps предоставляет различные типы действий. Каждый из них имеет различные входные данные, которые определяют уникальный режим работы действия. Действия включают следующие основные элементы, хотя некоторые из них являются необязательными.

```json
"<action-name>": {
   "type": "<action-type>",
   "inputs": { 
      "<input-name>": { "<input-value>" },
      "retryPolicy": "<retry-behavior>" 
   },
   "runAfter": { "<previous-trigger-or-action-status>" },
   "runtimeConfiguration": { "<runtime-config-options>" },
   "operationOptions": "<operation-option>"
},
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------|
| <*имя действия*> | Строка | Имя действия | 
| <*действия типа*> | Строка | Тип действия, например Http или ApiConnection| 
| <*имя ввода*> | Строка | Имя для входа, определяющее поведение действия | 
| <*вхотозатная стоимость*> | Различные | Входное значение, которое может быть строкой, целым числом, объектом JSON и т. д. | 
| <*предыдущий триггер-или-статус действия*> | Объект JSON | Имя и итоговое состояние для триггера или действия, которое должно выполняться немедленно перед запуском текущего действия | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------|
| <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе "Политики повтора". | 
| <*варианты выполнения-конфигурации*> | Объект JSON | Режим работы некоторых действий во время выполнения можно изменить, задав свойство `runtimeConfiguration`. Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options). | 
| <*операция-опция*> | Строка | Режим работы по умолчанию некоторых действий можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

## <a name="action-types-list"></a>Список типов действий

Некоторые часто используемые типы действий. 

* [Встроенные типы действий](#built-in-actions), такие как нижеприведенные примеры и многое другое. 

  * [**HTTP**](#http-action) для вызова конечных точек через HTTP или HTTPS

  * [**Ответ**](#response-action) для реагирования на запросы

  * [**Выполнение кода JavaScript**](#run-javascript-code) для запуска фрагментов кода JavaScript

  * [**Функция**](#function-action) для вызова службы "Функции Azure"

  * Действия обработки данных, такие как [**Соединить**](#join-action), [**Создать**](#compose-action), [**Таблица**](#table-action), [**Выбрать**](#select-action) и другие, которые создают или преобразовывают данные из различных входов

  * [**Рабочий процесс**](#workflow-action) для вызова рабочего процесса другого приложения логики

* [Типы действий управляемых API](#managed-api-actions), такие как [**ApiConnection**](#apiconnection-action) и [**ApiConnectionWebHook**](#apiconnectionwebhook-action), которые вызывают различные соединители и управляемые Майкрософт интерфейсы API, например Служебная шина Azure, Office 365 Outlook, Power BI, хранилище BLOB-объектов Azure, OneDrive, GitHub и т. д.

* [Типы действий рабочего процесса управления](#control-workflow-actions), такие как [**If**](#if-action), [**Foreach**](#foreach-action), [**Switch**](#switch-action), [**Scope**](#scope-action) и [**Until**](#until-action), которые содержат другие действия и помогают организовать выполнение рабочего процесса

<a name="built-in-actions"></a>

### <a name="built-in-actions"></a>Встроенные действия

| Тип действия | Описание | 
|-------------|-------------| 
| [**Создать**](#compose-action) | Создает один выход из входных данных, который может иметь различные типы. | 
| [**Выполнение кода JavaScript**](#run-javascript-code) | Выполнить фрагменты кода JavaScript, которые соответствуют определенным критериям. Для требований к коду и дополнительной информации [см.](../logic-apps/logic-apps-add-run-inline-code.md) |
| [**Функции**](#function-action) | Вызывает функцию Azure. | 
| [**HTTP**](#http-action) | Вызывает конечную точку HTTP. | 
| [**Join**](#join-action) | Создает строку из всех элементов в массиве и разделяет эти элементы определенным символом разделителя. | 
| [**Анализ JSON**](#parse-json-action) | Создает понятные токены из свойств в содержимом JSON. Затем можно ссылаться на эти свойства, включая токены в приложение логики. | 
| [**Запроса**](#query-action) | Создает массив из элементов другого массива на основании условия или фильтра. | 
| [**Ответ**](#response-action) | Создает ответ на входящий вызов или запрос. | 
| [**Выберите**](#select-action) | Создает массив объектов JSON, преобразуя элементы другого массива на основе указанной карты. | 
| [**Таблице**](#table-action) | Создает таблицу CSV или HTML из массива. | 
| [**Завершить**](#terminate-action) | Останавливает активное выполнение рабочего процесса. | 
| [**Подожди**](#wait-action) | Приостанавливает рабочий процесс на заданный срок или до указанной даты и времени. | 
| [**Рабочего процесса**](#workflow-action) | Создает вложенный рабочий процесс внутри другого рабочего процесса. | 
||| 

<a name="managed-api-actions"></a>

### <a name="managed-api-actions"></a>Действия управляемых API

| Тип действия | Описание | 
|-------------|-------------|  
| [**ApiConnection**](#apiconnection-action) | Вызывает конечную точку HTTP, используя [управляемый Майкрософт интерфейс API](../connectors/apis-list.md). | 
| [**ApiConnectionWebhook**](#apiconnectionwebhook-action) | Работает как веб-перехватчик HTTP, но использует [интерфейс API, управляемый Майкрософт](../connectors/apis-list.md). | 
||| 

<a name="control-workflow-actions"></a>

### <a name="control-workflow-actions"></a>Действия рабочего процесса управления

Эти действия позволяют управлять выполнением рабочего процесса и включают в себя другие действия. За пределами действия рабочего процесса управления можно непосредственно ссылаться на действия внутри него. Например, если имеется действие `Http` внутри области, можно ссылаться на выражение `@body('Http')` из любой точки в рабочем процессе. В то же время действия, которые существуют внутри действия рабочего процесса управления, могут "привязываться" только к другим действиям, которые находятся в той же структуре рабочего процесса управления.

| Тип действия | Описание | 
|-------------|-------------| 
| [**Foreach**](#foreach-action) | Выполняет те же действия в цикле для каждого элемента массива. | 
| [**Если**](#if-action) | Выполняет действия в зависимости от того, имеет ли заданное условие значение true или false. | 
| [**Область**](#scope-action) | Выполняет действия из набора действий на основе состояния группы. | 
| [**Переключатель**](#switch-action) | Выполняет действия, организованные в случаях, когда значения из выражений, объектов или токенов соответствуют значениям, указанным для каждого случая. | 
| [**До**](#until-action) | Выполняет действия в цикле до тех пор, пока указанное условие не будет иметь значение true. | 
|||  

## <a name="actions---detailed-reference"></a>Действия. Подробная справочная информация

<a name="apiconnection-action"></a>

### <a name="apiconnection-action"></a>Действие APIConnection

Это действие отправляет HTTP-запрос для [управляемого Microsoft интерфейса API](../connectors/apis-list.md) и требует сведения об API и параметрах, а также ссылку на действительное соединение. 

``` json
"<action-name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<api-name>']['connectionId']"
         },
         "<other-action-specific-input-properties>"        
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": "<retry-behavior>",
      "queries": { "<query-parameters>" },
      "<other-action-specific-properties>"
    },
    "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя действия*> | Строка | Имя действия, предоставляемого соединителем | 
| <*апи-имя*> | Строка | Имя управляемого Майкрософт интерфейса API, используемого для подключения | 
| <*тип метода*> | Строка | Метод HTTP для вызова API: GET, PUT, POST, PATCH или DELETE | 
| <*апи-операции*> | Строка | Операция API для вызова | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*другие действия-специфические входные свойства*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*параметры запроса-параметры*> | Объект JSON | Все параметры запроса для включения с помощью вызова API. <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*другие действия-специфические свойства*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

*Пример*

Это определение описывает действие **Отправить по электронной почте** для соединителя Outlook Office 365, который является управляемым Майкрософт интерфейсом API. 

```json
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "Thank you for your membership!",
         "Subject": "Hello and welcome!",
         "To": "Sophie.Owen@contoso.com"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "POST",
      "path": "/Mail"
    },
    "runAfter": {}
}
```

<a name="apiconnection-webhook-action"></a>

### <a name="apiconnectionwebhook-action"></a>Действие APIConnectionWebhook

Это действие отправляет запрос на подписку через HTTP в конечную точку с помощью [управляемого Майкрософт интерфейсом API](../connectors/apis-list.md), предоставляет *URL-адрес обратного вызова*, на который конечная точка может отправить ответ, и ожидает ответа конечной точки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

```json
"<action-name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<api-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": "<retry-behavior>",
         "queries": { "<query-parameters>" },
         "<other-action-specific-input-properties>"
      },
      "unsubscribe": {
         "method": "<method-type>",
         "uri": "<api-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "<other-action-specific-properties>"
      },
   },
   "runAfter": {}
}
```

Некоторые значения, например <*method-type*>, доступны для объектов `"subscribe"` и `"unsubscribe"`.

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя действия*> | Строка | Имя действия, предоставляемого соединителем | 
| <*тип метода*> | Строка | Метод HTTP для подписки или отмены подписки на конечную точку: GET, PUT, POST, PATCH или DELETE | 
| <*api-подписка-URL*> | Строка | Универсальный код ресурса (URI), используемый для подписки на API | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*api-отписаться-URL*> | Строка | Универсальный код ресурса (URI), используемый для отмены подписки на API | 
| <*заголовок-контент*> | Объект JSON | Все заголовки для отправки в запрос <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*содержание тела*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*тип аутентификации*> | Объект JSON | Модель проверки подлинности, которую использует запрос для проверки подлинности исходящих запросов. Для получения дополнительной информации [см. Добавить аутентификацию к исходящим вызовам.](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) |
| <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*параметры запроса-параметры*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*другие действия-специфические входные свойства*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*другие действия-специфические свойства*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

Также можно указать ограничения для действий **ApiConnectionWebhook** так же, как [ограничения асинхронных операций HTTP](#asynchronous-limits).

<a name="compose-action"></a>

### <a name="compose-action"></a>Действие compose

Это действие создает один вывод из нескольких входных данных, включая выражения. Оба входа и выхода могут иметь любой тип, поддерживаемый Azure Logic Apps, например массивы, объекты JSON, язык XML и двоичные объекты. Затем можно использовать выходные данные действия в других действиях. 

```json
"Compose": {
   "type": "Compose",
   "inputs": "<inputs-to-compose>",
   "runAfter": {}
},
```

*Обязательно* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*входные данные к сочинению*> | Любой | Входные данные для создания единых выходных данных | 
|||| 

*Пример 1*

<!-- markdownlint-disable MD038 -->
Это определение действия объединяет `abcdefg ` с конечным пространством и значением `1234`.
<!-- markdownlint-enable MD038 -->

```json
"Compose": {
   "type": "Compose",
   "inputs": "abcdefg 1234",
   "runAfter": {}
},
```

Результат, который создает это действие.

`abcdefg 1234`

*Пример 2*

Это определение действия объединяет строковую переменную, содержащую `abcdefg` и целочисленную переменную, которая содержит `1234`.

```json
"Compose": {
   "type": "Compose",
   "inputs": "@{variables('myString')}@{variables('myInteger')}",
   "runAfter": {}
},
```

Результат, который создает это действие.

`"abcdefg1234"`

<a name="run-javascript-code"></a>

### <a name="execute-javascript-code-action"></a>Выполнение действий кода JavaScript

Это действие выполняет фрагмент кода JavaScript и возвращает `Result` результаты через маркер, на который можно ссылаться позже.

```json
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "<JavaScript-code-snippet>",
      "explicitDependencies": {
         "actions": [ <previous-actions> ],
         "includeTrigger": true
      }
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание |
|-------|------|-------------|
| <*Фрагмент кода JavaScript*> | Различается | Код JavaScript, который вы хотите запустить. Для требований к коду и дополнительной информации [см.](../logic-apps/logic-apps-add-run-inline-code.md) <p>В `code` атрибуте фрагмент кода может использовать объект `workflowContext` только для чтения в качестве ввода. Этот объект имеет субсвойства, которые дают коду доступ к результатам триггера и предыдущих действий в рабочем процессе. Для получения дополнительной `workflowContext` информации об объекте см. триггер [справки и результаты действий в коде.](../logic-apps/logic-apps-add-run-inline-code.md#workflowcontext) |
||||

*Требуется в некоторых случаях*

Атрибут `explicitDependencies` указывает, что необходимо явно включить результаты триггера, предыдущие действия или оба в качестве зависимостей для фрагмента кода. Для получения дополнительной информации о добавлении этих зависимостей [см.](../logic-apps/logic-apps-add-run-inline-code.md#add-parameters) 

Для `includeTrigger` атрибута можно `true` указать или `false` значения.

| Значение | Тип | Описание |
|-------|------|-------------|
| <*предыдущие действия*> | Массив строк | Массив с указанными именами действий. Используйте имена действий, которые отображаются в определении рабочего процесса, где используются имена действий, подчеркивающие (я), а не пробелы (««»). |
||||

*Пример 1*

Это действие запускает код, который получает имя приложения логики \<и возвращает текст "Привет мир из логики-приложение-имя>", как результат. В этом примере код ссылается на имя рабочего `workflowContext.workflow.name` процесса, применяя доступ к объекту только для чтения. `workflowContext` Для получения дополнительной `workflowContext` информации об использовании объекта см. триггер [и результаты действий в коде.](../logic-apps/logic-apps-add-run-inline-code.md#workflowcontext)

```json
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var text = \"Hello world from \" + workflowContext.workflow.name;\r\n\r\nreturn text;"
   },
   "runAfter": {}
}
```

*Пример 2*

Это действие запускает код в логическом приложении, которое запускается при попаске нового письма в учетную запись Office 365 Outlook. Приложение логики также использует действие электронной почты отправки утверждения, которое перенаправляет содержимое из полученного письма вместе с запросом на утверждение.

Код извлекает адреса электронной почты `Body` из свойства триггера `SelectedOption` и возвращает адреса вместе с значением свойства из действия утверждения. Действие явно включает в себя действие отправки утверждения `explicitDependencies`  >  `actions` электронной почты в качестве зависимости в атрибуте.

```json
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var re = /(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/g;\r\n\r\nvar email = workflowContext.trigger.outputs.body.Body;\r\n\r\nvar reply = workflowContext.actions.Send_approval_email_.outputs.body.SelectedOption;\r\n\r\nreturn email.match(re) + \" - \" + reply;\r\n;",
      "explicitDependencies": {
         "actions": [
            "Send_approval_email_"
         ]
      }
   },
   "runAfter": {}
}
```



<a name="function-action"></a>

### <a name="function-action"></a>Действие функции

Это действие вызывает ранее созданный объект [Функция Azure](../azure-functions/functions-create-first-azure-function.md).

```json
"<Azure-function-name>": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "<Azure-function-ID>"
      },
      "method": "<method-type>",
      "headers": { "<header-content>" },
      "body": { "<body-content>" },
      "queries": { "<query-parameters>" } 
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*Идентификатор Azure-функция-ID*> | Строка | Идентификатор ресурса для функции Azure, которую требуется вызвать. Формат для этого значения:<p>"/subscriptions/<*Azure-subscription-ID*>/resourceGroups/<*Azure-resource-group*>/providers/Microsoft.Web/sites/<*Azure-function-app-name*>/functions/<*Azure-function-name*>" | 
| <*тип метода*> | Строка | Метод HTTP, используемый для вызова функции: GET, PUT, POST, PATCH или DELETE <p>Если метод не указан, то по умолчанию используется метод POST. | 
||||

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*заголовок-контент*> | Объект JSON | Все заголовки для отправки с вызовом <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*содержание тела*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*параметры запроса-параметры*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*другие действия-специфические входные свойства*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*другие действия-специфические свойства*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
||||

При сохранении приложения логики модуль Logic Apps выполняет эти проверки указанной функции.

* У рабочего процесса должен быть доступ к функции.

* Рабочий процесс может использовать только стандартный триггер HTTP или универсальный триггер веб-перехватчика в формате JSON. 

  Модуль Logic Apps получает и кэширует URL-адрес триггера, используемый в среде выполнения. Тем не менее, если какая-либо операция делает недействительным кэшированный URL-адрес, то в среде выполнения действие **Функция** заканчивается сбоем. Чтобы устранить эту проблему, повторно сохраните приложение логики, чтобы оно снова загрузило URL-адрес триггера.

* Функция не может иметь какой-либо определенный маршрут.

* Можно использовать только авторизацию с помощью функции и анонимную авторизацию. 

*Пример*

Это определение действия вызывает ранее созданную функцию GetProductID.

```json
"GetProductID": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "/subscriptions/<XXXXXXXXXXXXXXXXXXXX>/resourceGroups/myLogicAppResourceGroup/providers/Microsoft.Web/sites/InventoryChecker/functions/GetProductID"
      },
      "method": "POST",
      "headers": { 
          "x-ms-date": "@utcnow()"
       },
      "body": { 
          "Product_ID": "@variables('ProductID')"
      }
   },
   "runAfter": {}
}
```

<a name="http-action"></a>

### <a name="http-action"></a>Действие HTTP

Это действие отправляет запрос в указанную конечную точку HTTP или HTTPS и проверяет ответ, чтобы определить, выполняется ли рабочий процесс.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": { "<query-parameters>" },
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      },
   },
   "runAfter": {}
}
```

*Обязательно*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `method` | <*тип метода*> | Строка | Метод использования для отправки исходящего запроса: "GET", "PUT", "POST", "PATCH" или "DELETE" |
| `uri` | <*HTTP-или-HTTPS-конечная точка-URL*> | Строка | URL-адрес HTTP или HTTPS, где требуется отправить исходящий запрос. Максимальный размер строки: 2 КБ. <p>Для службы или ресурса Azure этот синтаксис URI включает идентификатор ресурсов и путь к ресурсу, к которому вы хотите получить доступ. |
|||||

*Необязательный*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `headers` | <*заголовок-контент*> | Объект JSON | Любые заголовки, которые необходимо учесть в запросе <p>Пример задания языка и типа. <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| `queries` | <*параметры запроса-параметры*> | Объект JSON | Любые параметры запроса, необходимые для использования в запросе <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. |
| `body` | <*содержание тела*> | Объект JSON | Содержимое сообщения для отправки в качестве полезных данных с запросом |
| `authentication` | <*значения аутентификации типа и свойства*> | Объект JSON | Модель проверки подлинности, которую использует запрос для проверки подлинности исходящих запросов. Для получения дополнительной информации [см. Добавить аутентификацию к исходящим вызовам.](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) Помимо планировщика поддерживается свойство `authority`. Если не указано значение `https://management.azure.com/`по умолчанию, но вы можете использовать другое значение. |
| `retryPolicy` > `type` | <*повторная попытка-поведение*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). |
| <*другие действия-специфические входные свойства*> | <*входная собственность*> | Объект JSON | Все входные свойства, которые применяются к указанному действию |
| <*другие действия-специфические свойства*> | <*имущественное значение*> | Объект JSON | Все другие свойства, которые применяются к указанному действию |
|||||

*Пример*

Это определение действия получает последние новости, отправив запрос на указанную конечную точку.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest"
   }
}
```

<a name="join-action"></a>

### <a name="join-action"></a>Действие "Соединить"

Это действие создает строку из всех элементов в массиве и разделяет эти элементы определенным символом разделителя. 

```json
"Join": {
   "type": "Join",
   "inputs": {
      "from": <array>,
      "joinWith": "<delimiter>"
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Массива*> | Array | Массив или выражение, которое предоставляет исходные элементы. Если задано выражение, заключите его в двойные кавычки. | 
| <*Разделитель*> | Единая строка символов | Символ, разделяющий каждый элемент в строке | 
|||| 

*Пример*

Предположим, что у вас есть ранее созданная переменная myIntegerArray, содержащая этот массив целых чисел. 

`[1,2,3,4]` 

Это определение действия получает значения из переменной с помощью функции `variables()` в выражении и создает эту строку с теми значениями, которые разделяются запятыми: `"1,2,3,4"`.

```json
"Join": {
   "type": "Join",
   "inputs": {
      "from": "@variables('myIntegerArray')",
      "joinWith": ","
   },
   "runAfter": {}
}
```

<a name="parse-json-action"></a>

### <a name="parse-json-action"></a>Действие "Анализ JSON"

Это действие создает удобные пользовательские поля или *токены* из свойств в содержимом JSON. Затем можно получить доступ к этим свойствам в своем приложении логики, используя вместо этого токены. Например, если необходимо использовать выходные данные JSON таких служб как Служебная шина Azure и Azure Cosmos DB, можно включить это действие в своем приложении логики, чтобы иметь возможность легче ссылаться на выходные данные.

```json
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": "<JSON-source>",
         "schema": { "<JSON-schema>" }
      },
      "runAfter": {}
},
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*JSON-источник*> | Объект JSON | Содержимое JSON, которое необходимо анализировать | 
| <*JSON-схема*> | Объект JSON | Схема JSON, описывающая основное содержимое JSON, которое использует действие для анализа исходного содержимого JSON. <p>**Совет**. В Конструкторе Logic Apps можно указать схему или предоставить пример полезных данных, чтобы действие могло создать схему. | 
|||| 

*Пример*

Это определение действия создает эти маркеры, которые можно использовать в рабочем процессе, но только в действиях, которые выполняется после действия **Parse JSON:**

`FirstName`, `LastName` и `Email`.

```json
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": {
         "Member": {
            "Email": "Sophie.Owen@contoso.com",
            "FirstName": "Sophie",
            "LastName": "Owen"
         }
      },
      "schema": {
         "type": "object",
         "properties": {
            "Member": {
               "type": "object",
               "properties": {
                  "Email": {
                     "type": "string"
                  },
                  "FirstName": {
                     "type": "string"
                  },
                  "LastName": {
                     "type": "string"
                  }
               }
            }
         }
      }
   },
   "runAfter": { }
},
```

В этом примере свойство content указывает содержимое JSON для анализа. Также можно предоставить это содержимое JSON как пример полезных данных для создания схемы.

```json
"content": {
   "Member": { 
      "FirstName": "Sophie",
      "LastName": "Owen",
      "Email": "Sophie.Owen@contoso.com"
   }
},
```

Свойство schema указывает схему JSON, используемую для описания содержимого JSON.

```json
"schema": {
   "type": "object",
   "properties": {
      "Member": {
         "type": "object",
         "properties": {
            "FirstName": {
               "type": "string"
            },
            "LastName": {
               "type": "string"
            },
            "Email": {
               "type": "string"
            }
         }
      }
   }
}
```

<a name="query-action"></a>

### <a name="query-action"></a>Действие запроса

Это действие создает массив из элементов другого массива на основании указанного условия или фильтра.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": <array>,
      "where": "<condition-or-filter>"
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Массива*> | Array | Массив или выражение, которое предоставляет исходные элементы. Если задано выражение, заключите его в двойные кавычки. |
| <*состояние или фильтр*> | Строка | Условие, используемое для фильтрации элементов в массиве источника <p>**Примечание**. Если нет значений, соответствующих условию, действие создает пустой массив. |
|||| 

*Пример*

Это определение действия создает массив, содержащий значения, превышающие указанное значение, которое равно двум.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": [ 1, 3, 0, 5, 4, 2 ],
      "where": "@greater(item(), 2)"
   }
}
```

<a name="response-action"></a>

### <a name="response-action"></a>Действие ответа  

Это действие создает полезные данные для ответа на запрос HTTP. 

```json
"Response" {
    "type": "Response",
    "kind": "http",
    "inputs": {
        "statusCode": 200,
        "headers": { <response-headers> },
        "body": { <response-body> }
    },
    "runAfter": {}
},
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*ответ-статус-код*> | Целое число | Код состояния HTTP, отправленный на входящий запрос. Код по умолчанию является "200 OK", но это может быть любой допустимый код состояния, который начинается с 2xx, 4xx или 5xx, но не с 3xxx. | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*ответные заголовки*> | Объект JSON | Один или несколько заголовков для включения в ответ | 
| <*ответ-тело*> | Различные | Текст ответа, который может быть строкой, объектом JSON или даже двоичным содержимым из предыдущего действия | 
|||| 

*Пример*

Это определение действия создает ответ на HTTP-запрос с заданным кодом статуса, текстом сообщения и заголовком сообщения.

```json
"Response": {
   "type": "Response",
   "inputs": {
      "statusCode": 200,
      "body": {
         "ProductID": 0,
         "Description": "Organic Apples"
      },
      "headers": {
         "x-ms-date": "@utcnow()",
         "content-type": "application/json"
      }
   },
   "runAfter": {}
}
```

*Ограничения*

В отличии от других, действие **Ответ** имеет специальные ограничения. 

* Рабочий процесс может использовать действие **Ответ** только тогда, когда он начинается с триггера запроса HTTP, это значит, что рабочий процесс должен запускаться HTTP-запросом.

* Рабочий процесс может использовать действие **Ответ** в любом месте, *кроме* как внутри циклов **Foreach**, **Until**, включая последовательные циклы и параллельные ветви. 

* Первоначальный HTTP-запрос получает ответ рабочего процесса только тогда, когда все действия, требуемые действием **Ответ**, завершены в [пределах времени ожидания HTTP-запроса](../logic-apps/logic-apps-limits-and-config.md#request-limits).

  Однако, если рабочий процесс вызывает другое приложение логики в качестве вложенного рабочего процесса, родительский рабочий процесс ожидает завершения вложенного рабочего процесса, независимо от того, сколько времени прошло до его завершения.

* Когда рабочий процесс использует действие **Ответ** и синхронный шаблон ответа, он не может использовать команду **splitOn** в определении триггера, потому что эта команда создает несколько запусков. Проверьте этот случай, когда используется метод PUT, и если значение равно true, вернется ответ "Недопустимый запрос".

  В противном случае, если рабочий процесс использует команду **splitOn** и действие **Ответ**, рабочий процесс выполняется асинхронно и немедленно возвращает ответ "202 ACCEPTED".

* Когда выполнение рабочего процесса достигает действия **Ответ**, но входящий запрос уже получил ответ, действие **Ответ** помечается как Failed (Сбой) из-за конфликта. И в результате выполнения приложения логики также отмечается состояние Failed (Сбой).

<a name="select-action"></a>

### <a name="select-action"></a>Выбор действия

Это действие создает массив с объектами JSON путем преобразования элементов из другого массива на основе указанного сопоставления. Выходной и исходный массив всегда имеет одинаковое количество элементов. Несмотря на то что невозможно изменить количество объектов в выходном массиве, можно добавлять или удалять свойства и их значения в этих объектах. Свойство `select` указывает по меньшей мере одну пару "ключ — значение", определяющую сопоставление для преобразования элементов в исходном массиве. Пара "ключ — значение" представляет свойство и его значение во всех объектах выходного массива.

```json
"Select": {
   "type": "Select",
   "inputs": {
      "from": <array>,
      "select": { 
          "<key-name>": "<expression>",
          "<key-name>": "<expression>"        
      }
   },
   "runAfter": {}
},
```

*Обязательно* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Массива*> | Array | Массив или выражение, которое предоставляет исходные элементы. Убедитесь, что выражение заключено в двойные кавычки. <p>**Примечание**. Если исходный массив пуст, это действие создает пустой массив. | 
| <*имя ключа*> | Строка | Имя свойства, присвоенное результату выражения *<*> <p>Чтобы добавить новое свойство во всех объектах в выходном массиве, предоставьте <*key-name*> для этого свойства и объект <*expression*> для значения свойства. <p>Чтобы удалить свойство из всех объектов в массиве, опустите <*key-name*> для этого свойства. | 
| <*Выражение*> | Строка | Выражение, преобразуя элемент в исходном массиве и присваиваваемое результатом <*имя ключа*> | 
|||| 

Действие **Выбрать** создает массив как вывод, поэтому любое действие, которое хочет использовать этот вывод, должно либо принимать массив, либо необходимо преобразовать массив в тип, который принимает действие пользователя. Например, чтобы преобразовать выходной массив в строку, передайте массив в действие **Создать**, а затем ссылайтесь на результат действия **Создать** в других действиях.

*Пример*

Это определение действия создает массив объектов JSON из массива целых чисел. Действие повторяется с исходным массивом, получает каждое целочисленное значение с помощью выражения `@item()` и присваивает каждому значению свойство "`number`" в каждом объекте JSON.

```json
"Select": {
   "type": "Select",
   "inputs": {
      "from": [ 1, 2, 3 ],
      "select": { 
         "number": "@item()" 
      }
   },
   "runAfter": {}
},
```

Массив, который создает это действие.

`[ { "number": 1 }, { "number": 2 }, { "number": 3 } ]`

Чтобы использовать этот массив выходных данных в других действиях, передайте этот результат в действие **Создать**.

```json
"Compose": {
   "type": "Compose",
   "inputs": "@body('Select')",
   "runAfter": {
      "Select": [ "Succeeded" ]
   }
},
```

Затем можно использовать вывод из действия **Создать** в других действиях, например **Office 365 Outlook: отправить по электронной почте**.

```json
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "@{outputs('Compose')}",
         "Subject": "Output array from Select and Compose actions",
         "To": "<your-email@domain>"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "post",
      "path": "/Mail"
   },
   "runAfter": {
      "Compose": [ "Succeeded" ]
   }
},
```

<a name="table-action"></a>

### <a name="table-action"></a>Действие таблицы

Это действие создает таблицу CSV или HTML из массива. Для массивов с объектами JSON это действие автоматически создает заголовки столбцов с именами свойств объектов. Для массивов с другими типами данных необходимо указать заголовки столбцов и значений. Например, этот массив содержит свойства ID и Product_Name, которые могут использовать это действие для заголовков столбцов.

`[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]` 

```json
"Create_<CSV | HTML>_table": {
   "type": "Table",
   "inputs": {
      "format": "<CSV | HTML>",
      "from": <array>,
      "columns": [ 
         {
            "header": "<column-name>",
            "value": "<column-value>"
         },
         {
            "header": "<column-name>",
            "value": "<column-value>"
         } 
      ]
   },
   "runAfter": {}
}
```

*Обязательно* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| \<CSV *или* HTML>| Строка | Формат таблицы, которую необходимо создать | 
| <*Массива*> | Array | Массив или выражение, которое предоставляет исходные элементы для таблицы <p>**Примечание**. Если исходный массив пуст, это действие создает пустую таблицу. | 
|||| 

*Необязательный*

Чтобы задать или настроить заголовки столбцов и значения, используйте массив `columns`. Когда пары `header-value` имеют одинаковое имя заголовка, их значения отображаются в том же столбце под этим заголовком. В противном случае каждый уникальный заголовок определяет уникальный столбец.

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*название столбца*> | Строка | Имя заголовка столбца | 
| <*столбец-значение*> | Любой | Значение в столбце | 
|||| 

*Пример 1*

Предположим, что имеется ранее созданная переменная myItemArray, содержащая в данный момент этот массив.

`[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]`

Это определение действия создает таблицу CSV из переменной myItemArray. Выражение, использующее свойство `from`, возвращает массив из myItemArray с помощью функции `variables()`.

```json
"Create_CSV_table": {
   "type": "Table",
   "inputs": {
      "format": "CSV",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
```

Таблица CSV, которая создает это действие. 

```
ID,Product_Name 
0,Apples 
1,Oranges 
```

*Пример 2*

Это определение действия создает таблицу HTML из переменной myItemArray. Выражение, использующее свойство `from`, возвращает массив из myItemArray с помощью функции `variables()`.

```json
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
```

Таблица HTML, которая создает это действие. 

<table><thead><tr><th>ID</th><th>Product_name</th></tr></thead><tbody><tr><td>0</td><td>Яблоки</td></tr><tr><td>1</td><td>Апельсины</td></tr></tbody></table>

*Пример 3*

Это определение действия создает таблицу HTML из переменной myItemArray. Однако этот пример переопределяет имена заголовков столбцов по умолчанию с помощью Stock_ID и Description и добавляет слово Organic к значениям в столбце Description.

```json
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')",
      "columns": [ 
         {
            "header": "Stock_ID",
            "value": "@item().ID"
         },
         {
            "header": "Description",
            "value": "@concat('Organic ', item().Product_Name)"
         }
      ]
    },
   "runAfter": {}
},
```

Таблица HTML, которая создает это действие. 

<table><thead><tr><th>Stock_ID</th><th>Описание</th></tr></thead><tbody><tr><td>0</td><td>Органические яблоки</td></tr><tr><td>1</td><td>Органические апельсины</td></tr></tbody></table>

<a name="terminate-action"></a>

### <a name="terminate-action"></a>Действие terminate

Это действие останавливает запуск экземпляра рабочего процесса, отменяет все текущие действия, пропускает все оставшиеся действия и возвращает указанный статус. Например, можно использовать действие **Завершить**, когда приложение логики должно полностью выйти из состояния ошибки. Это действие не влияет на уже выполненные действия и не может указываться в циклах **Foreach** и **Until**, включая последовательные циклы.

```json
"Terminate": {
   "type": "Terminate",
   "inputs": {
       "runStatus": "<status>",
       "runError": {
            "code": "<error-code-or-name>",
            "message": "<error-message>"
       }
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Статус*> | Строка | Состояние для возврата запуска: Failed (Сбой), Cancelled (Отменено) или Succeeded (Успешно) |
|||| 

*Необязательный*

Свойства для объекта runStatus применяются только в том случае, если свойству runStatus присвоено состояние Failed (Сбой).

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*ошибка-код-или-имя*> | Строка | Код или имя ошибки |
| <*сообщение об ошибке*> | Строка | Сообщение или текст, описывающий ошибку и любые действия, которые пользователь приложения может предпринять | 
|||| 

*Пример*

Это определение действия останавливает выполнение рабочего процесса, устанавливает статус запуска как Failed (Сбой) и возвращает состояние, код ошибки и сообщение об ошибке.

```json
"Terminate": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "Unexpected response",
            "message": "The service received an unexpected response. Please try again."
        }
   },
   "runAfter": {}
}
```

<a name="wait-action"></a>

### <a name="wait-action"></a>Действие wait

Это действие приостанавливает выполнение рабочего процесса на указанный период времени или до указанного времени, но не для обоих.

*Указанный интервал*

```json
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": <number-of-units>,
         "unit": "<interval>"
      }
   },
   "runAfter": {}
},
```

*Указанное время*

```json
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "<date-time-stamp>"
      }
   },
   "runAfter": {}
},
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*число единиц*> | Целое число | Число единиц ожидания для действия **Задержка** | 
| <*Интервал*> | Строка | Для действия **Задержка** период ожидания составляет: "секунда", "минута", "час", "день", "неделя", "месяц" | 
| <*дата-штамп*> | Строка | Дата и время возобновления исполнения для действия **Задержка до**. Для этого значения необходимо использовать [дату и время в формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). | 
|||| 

*Пример 1*

Это определение действия приостанавливает рабочий процесс на 15 минут.

```json
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": 15,
         "unit": "Minute"
      }
   },
   "runAfter": {}
},
```

*Пример 2*

Это определение действия приостанавливает рабочий процесс до указанного времени.

```json
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "2017-10-01T00:00:00Z"
      }
   },
   "runAfter": {}
},
```

<a name="workflow-action"></a>

### <a name="workflow-action"></a>Действие workflow

Это действие вызывает другое ранее созданное приложение логики, это значит, что можно включать и повторно использовать другие рабочие процессы приложений логики. Также можно использовать выходы из дочернего или *вложенного* приложения логики в действиях, следующих за вложенным приложением логики, при условии, что дочернее приложение логики возвращает ответ.

Модуль Logic Apps проверяет доступ к триггеру, который необходимо вызвать, поэтому убедитесь, что вы можете получить доступ к этому триггеру. Кроме того, вложенное приложение логики должно соответствовать следующим критериям.

* Триггер делает вложенное приложение логики вызываемым, наподобие триггеров [Запрос](#request-trigger) или [HTTP](#http-trigger)

* Та же подписка Azure, что и родительское приложение логики

* Чтобы использовать выходы из вложенного приложения логики в родительском приложении логики, вложенное приложение логики должно иметь действие [Ответ](#response-action)

```json
"<nested-logic-app-name>": {
   "type": "Workflow",
   "inputs": {
      "body": { "<body-content" },
      "headers": { "<header-content>" },
      "host": {
         "triggerName": "<trigger-name>",
         "workflow": {
            "id": "/subscriptions/<Azure-subscription-ID>/resourceGroups/<Azure-resource-group>/providers/Microsoft.Logic/<nested-logic-app-name>"
         }
      }
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*вложенные-логика-приложение-имя*> | Строка | Имя приложения логики, которое требуется вызвать | 
| <*триггер-имя*> | Строка | Имя триггера вложенного приложения логики, которое необходимо вызвать | 
| <*Идентификатор подписки Azure*> | Строка | Идентификатор подписки Azure вложенного приложения логики |
| <*Группа ресурсов Azure*> | Строка | Группа ресурсов Azure вложенного приложения логики |
| <*вложенные-логика-приложение-имя*> | Строка | Имя приложения логики, которое требуется вызвать |
||||

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*заголовок-контент*> | Объект JSON | Все заголовки для отправки с вызовом | 
| <*содержание тела*> | Объект JSON | Любое содержимое сообщения для отправки с вызовом | 
||||

*Выходы*

Выходные данные этого действия различаются в зависимости от действия "Ответ" вложенного приложения логики. Если вложенное приложение логики не включает действие "Ответ", выходные данные будут пустыми.

*Пример*

После успешного завершения действия Start_search это определение действия рабочего процесса вызывает другое приложение логики с именем Get_product_information, которое передается в заданные входы.

```json
"actions": {
   "Start_search": { <action-definition> },
   "Get_product_information": {
      "type": "Workflow",
      "inputs": {
         "body": {
            "ProductID": "24601",
         },
         "host": {
            "id": "/subscriptions/XXXXXXXXXXXXXXXXXXXXXXXXXX/resourceGroups/InventoryManager-RG/providers/Microsoft.Logic/Get_product_information",
            "triggerName": "Find_product"
         },
         "headers": {
            "content-type": "application/json"
         }
      },
      "runAfter": { 
         "Start_search": [ "Succeeded" ]
      }
   }
},
```

## <a name="control-workflow-action-details"></a>Сведения о действиях рабочего процесса управления

<a name="foreach-action"></a>

### <a name="foreach-action"></a>Действие foreach

Это циклическое действие выполняет итерацию по массиву и действия с каждым элементом массива. По умолчанию цикл Foreach выполняется в параллельном режиме, вплоть до максимального числа циклов. Для этого максимума [см.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) [Узнайте, как создать циклы "для каждого".](../logic-apps/logic-apps-control-flow-loops.md#foreach-loop)

```json
"For_each": {
   "type": "Foreach",
   "actions": { 
      "<action-1>": { "<action-definition-1>" },
      "<action-2>": { "<action-definition-2>" }
   },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": <count>
      }
    },
    "operationOptions": "<operation-option>"
}
```

*Обязательно* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*действие-1... N*> | Строка | Имена действий, выполняемых над каждым элементом массива | 
| <*действие-определение-1... N*> | Объект JSON | Определения действий, которые выполняются | 
| <*для каждого выражения*> | Строка | Выражение, которое ссылается на каждый элемент в указанном массиве | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Рассчитывать*> | Целое число | По умолчанию итерации цикла "для каждого" работают одновременно (одновременно или параллельно) до [предела по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма цикла Foreach](#change-for-each-concurrency). | 
| <*операция-опция*> | Строка | Чтобы запустить цикл Foreach последовательно, а не параллельно, задайте <*operation-option*> для `Sequential` или <*count*> для `1`, но не для обоих. Дополнительные сведения см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each). | 
|||| 

*Пример*

Этот цикл Foreach отправляет электронное письмо для каждого элемента массива, содержащего вложения из входящего письма. Цикл отправляет электронное письмо, включая вложение, пользователю, который рассматривает вложение.

```json
"For_each": {
   "type": "Foreach",
   "actions": {
      "Send_an_email": {
         "type": "ApiConnection",
         "inputs": {
            "body": {
               "Body": "@base64ToString(items('For_each')?['Content'])",
               "Subject": "Review attachment",
               "To": "Sophie.Owen@contoso.com"
                },
            "host": {
               "connection": {
                  "id": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {}
      }
   },
   "foreach": "@triggerBody()?['Attachments']",
   "runAfter": {}
}
```

Чтобы указать только массив, который передается в качестве выходных данных из триггера, это выражение получает массив <*array-name*> из текста триггера. Чтобы избежать ошибок при отсутствии массива, в этом выражении используется оператор `?`.

`@triggerBody()?['<array-name>']` 

<a name="if-action"></a>

### <a name="if-action"></a>Действие If

Это действие, которое является *условным оператором*, оценивает выражение, которое представляет условие и запускает другую ветвь, основанную на том, является ли условие истинным или ложным. Если условие истинное, ему будет присвоено состояние Succeeded (Успешно). Дополнительные сведения см. в разделе [Создание условных операторов, которые управляют действиями в рабочих процессах Azure Logic Apps](../logic-apps/logic-apps-control-flow-conditional-statement.md).

``` json
"Condition": {
   "type": "If",
   "expression": { "<condition>" },
   "actions": {
      "<action-1>": { "<action-definition>" }
   },
   "else": {
      "actions": {
        "<action-2>": { "<action-definition" }
      }
   },
   "runAfter": {}
}
```

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Состояние*> | Объект JSON | Условие, которое может быть выражением, для оценки | 
| <*действие-1*> | Объект JSON | Действие выполнится когда <*condition*> будет истинное | 
| <*определение действия*> | Объект JSON | Определение действия | 
| <*действие-2*> | Объект JSON | Действие выполнится когда <*condition*> будет ложным | 
|||| 

Действия в объектах `actions` или `else` получают следующие статусы.

* "Succeeded", если они запускаются и выполняются успешно;
* "Failed", если они запускаются, но завершаются ошибкой;
* "Skipped", если не запускается соответствующая ветвь.

*Пример*

Это условие указывает, что когда целочисленная переменная имеет значение больше нуля, рабочий процесс проверяет веб-сайт. Если переменная равна нулю или меньше, рабочий процесс проверяет другой веб-сайт.

```json
"Condition": {
   "type": "If",
   "expression": {
      "and": [ {
         "greater": [ "@variables('myIntegerVariable')", 0 ] 
      } ]
   },
   "actions": { 
      "HTTP - Check this website": {
         "type": "Http",
         "inputs": {
         "method": "GET",
            "uri": "http://this-url"
         },
         "runAfter": {}
      }
   },
   "else": {
      "actions": {
         "HTTP - Check this other website": {
            "type": "Http",
            "inputs": {
               "method": "GET",
               "uri": "http://this-other-url"
            },
            "runAfter": {}
         }
      }
   },
   "runAfter": {}
}
```  

#### <a name="how-conditions-use-expressions"></a>Использование выражений условиями

Ниже приведены некоторые примеры, показывающие, как можно использовать выражения в условиях.
  
| JSON | Результат | 
|------|--------| 
| expression: @parameters('<*hasSpecialAction*>') | Только для логических выражений условие передается для любого истинного значения. <p>Чтобы преобразовать другие типы в логический, используйте следующие функции: `empty()` или `equals()`. | 
| expression: @greater(actions('<*action*>').output.value, parameters('<*threshold*>')) | Для сравнения функций действие выполняется только тогда, когда результат <*action*> больше значения <*threshold*>. | 
| expression: @or(greater(actions('<*action*>').output.value, parameters('<*threshold*>')), less(actions('<*same-action*>').output.value, 100)) | Для логических функций и создания вложенных логических выражений действие выполняется, когда результат <*action*> больше значения <*threshold*> или меньше 100. | 
| expression: @equals(length(actions('<*action*>').outputs.errors), 0)) | Можно использовать функции массива для проверки того, имеет ли массив какие-либо элементы. Действие выполняется, если массив `errors` пустой. | 
||| 

<a name="scope-action"></a>

### <a name="scope-action"></a>Действие scope

Логические группы этого действия в *областях*, которые получают свое состояние после завершения действий в той области. Затем можно использовать статус области, чтобы определить, выполняются ли другие действия. Дополнительные сведения см. в разделе [Создание областей, которые выполняют действия рабочего процесса на основе состояния группы в Azure Logic Apps](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md).

```json
"Scope": {
   "type": "Scope",
   "actions": {
      "<inner-action-1>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<inner-action-2>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   }
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*внутреннее действие-1... N*> | Объект JSON | Одно или несколько действий, которые выполняются в области |
| <*экшн-входы*> | Объект JSON | Входные данные для каждого действия |
|||| 

<a name="switch-action"></a>

### <a name="switch-action"></a>Действие switch

Это действие, также известное как *оператор switch*, организует другие действия по *случаях* и присваивает значение каждому случаю, за исключением случая по умолчанию, если он существует. Когда выполняется рабочий процесс, действие **Переключить** сравнивает значение из выражения, объекта или токена со значениями, указанными для каждого случая. Если действие **Переключить** находит соответствующий вариант, рабочий процесс выполняет действия только для этого варианта. Каждый раз, когда действие **Переключить** запускается, существует только один подходящий случай или совпадений нет. Если совпадений не существует, действие **Переключить** выполняется по умолчанию. Дополнительные сведения см. в разделе [Создание операторов switch, которые запускают действия рабочего процесса на основе определенных значений в Azure Logic Apps](../logic-apps/logic-apps-control-flow-switch-statement.md).

``` json
"Switch": {
   "type": "Switch",
   "expression": "<expression-object-or-token>",
   "cases": {
      "Case": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      },
      "Case_2": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      }
   },
   "default": {
      "actions": {
         "<default-action-name>": { "<default-action-definition>" }
      }
   },
   "runAfter": {}
}
```

*Обязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*выражение-объект-или-токен*> | Различается | Выражение, объект JSON или маркер безопасности для оценки | 
| <*имя действия*> | Строка | Имя действия для запуска в случае соответствия | 
| <*определение действия*> | Объект JSON | Определение действия для запуска в случае соответствия | 
| <*сопоставление-значение*> | Различается | Значение для сравнения с результатом вычисления | 
|||| 

*Необязательный*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя действия по умолчанию*> | Строка | Имя действия по умолчанию для запуска, если не существует подходящего случая | 
| <*определение действий по умолчанию*> | Объект JSON | Определение действия по умолчанию для запуска, если не существует подходящего случая | 
|||| 

*Пример*

Это определение действия оценивает, выбирает ли пользователь в ответ на письмо с запросом вариант "Утвердить" или "Отклонить". Исходя из этого выбора, действие **Переключить** запускает действия для случая сопоставления, который должен отправить другое электронное сообщение ответчику, но с разными формулировками в каждом случае. 

``` json
"Switch": {
   "type": "Switch",
   "expression": "@body('Send_approval_email')?['SelectedOption']",
   "cases": {
      "Case": {
         "actions": {
            "Send_an_email": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your approval.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}
         },
         "case": "Approve"
      },
      "Case_2": {
         "actions": {
            "Send_an_email_2": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your response.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}     
         },
         "case": "Reject"
      }
   },
   "default": {
      "actions": { 
         "Send_an_email_3": { 
            "type": "ApiConnection",
            "inputs": {
               "Body": "Please respond with either 'Approve' or 'Reject'.",
               "Subject": "Please respond", 
               "To": "Sophie.Owen@contoso.com"
            },
            "host": {
               "connection": {
                  "name": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {} 
      }
   },
   "runAfter": {
      "Send_approval_email": [ 
         "Succeeded"
      ]
   }
}
```

<a name="until-action"></a>

### <a name="until-action"></a>Действие Until

Это действие цикла содержит действия, которые выполняются, пока указанное условие имеет истинное значение. После завершения работы всех других действий на последнем этапе цикл проверяет условие. Можно включить несколько действий в объект `"actions"`, и действие должно определить как минимум одно ограничение. Дополнительные сведения см. в разделе [Цикл until](../logic-apps/logic-apps-control-flow-loops.md#until-loop). 

```json
 "Until": {
   "type": "Until",
   "actions": {
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   },
   "expression": "<condition>",
   "limit": {
      "count": <loop-count>,
      "timeout": "<loop-timeout>"
   },
   "runAfter": {}
}
```

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя действия*> | Строка | Имя действия, которое необходимо выполнить внутри цикла | 
| <*действия типа*> | Строка | Тип действия, которое необходимо запустить | 
| <*экшн-входы*> | Различные | Входные данные для выполнения действия | 
| <*Состояние*> | Строка | Условие или выражение для оценки после всех действий в завершении цикла | 
| <*цикл-счет*> | Целое число | Предел максимального количества циклов, которое может выполнить действие. Для получения дополнительной информации о лимите по умолчанию и максимальном лимите [см.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) | 
| <*цикл тайм-аут*> | Строка | Предел времени работы цикла, в течение которого цикл может работать. Значение `timeout` по умолчанию равно `PT1H`, которое требует [формат ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). |
|||| 

*Пример*

Это определение действия цикла отправляет HTTP-запрос по указанному URL-адресу до тех пор, пока не будет выполнено одно из этих условий.

* Запрос возвращает ответ с состоянием кода "200 OK".
* Цикл выполнялся 60 раз.
* Цикл был выполнен в течение одного часа.

```json
 "Run_until_loop_succeeds_or_expires": {
    "type": "Until",
    "actions": {
        "HTTP": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('HTTP')['statusCode'], 200)",
    "limit": {
        "count": 60,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
```

<a name="subscribe-unsubscribe"></a>

## <a name="webhooks-and-subscriptions"></a>Веб-перехватчики и подписки

Триггеры и действия на основе веб-перехватчика не регулярно проверяют конечные точки, но ждут конкретных событий или данных на этих конечных точках. Эти триггеры и действия *подписываются* на конечные точки, предоставляя *URL-адрес обратного вызова*, куда конечная точка может отправлять ответы.

Вызов `subscribe` выполняется при любом изменении рабочего процесса, например когда происходит обновление учетных данных или изменяются входные параметры для триггера или действия. Этот вызов использует те же параметры, что и стандартные действия HTTP. 

Вызов `unsubscribe` выполняется автоматически, когда при выполнении операции триггер или действие становится недопустимым, например:

* удаление или отключение триггера; 
* удаление или отключение рабочего процесса; 
* удаление или отключение подписки. 

Для поддержки этих вызовов выражение `@listCallbackUrl()` возвращает уникальный "URL-адрес обратного вызова" для этого триггера или действия. Этот URL-адрес представляет собой уникальный идентификатор для конечных точек, использующих REST API службы. Параметры этой функции совпадают с параметрами триггера веб-перехватчика или действия.

<a name="asynchronous-limits"></a>

## <a name="change-asynchronous-duration"></a>Изменение асинхронной длительности

Для триггеров и действий можно ограничить длительность для асинхронного шаблона определенным интервалом времени, добавив свойство `limit.timeout`. Таким образом, если действие не закончилось, когда интервал истекает, статус действия помечается `Cancelled` с кодом `ActionTimedOut`. Свойство `timeout` использует [формат ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations).

``` json
"<trigger-or-action-name>": {
   "type": "Workflow | Webhook | Http | ApiConnectionWebhook | ApiConnection",
   "inputs": {},
   "limit": {
      "timeout": "PT10S"
   },
   "runAfter": {}
}
```

<a name="runtime-config-options"></a>

## <a name="runtime-configuration-settings"></a>Параметры конфигурации среды выполнения

Вы можете изменить поведение выполнения по умолчанию для `runtimeConfiguration` триггеров и действий, добавив эти свойства в определение триггера или действия.

| Свойство | Тип | Описание | Триггер или действие | 
|----------|------|-------------|-------------------| 
| `runtimeConfiguration.concurrency.runs` | Целое число | Измените [*лимит по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) на количество экземпляров рабочего процесса, которые могут работать одновременно (одновременно или параллельно). Корректировка этого значения может помочь ограничить количество запросов, которые получают системы бэкэнда. <p>Параметр свойства `runs`, равный `1`, работает так же, как параметр свойства `operationOptions`, равный `SingleInstance`. Можно установить любое свойство, но не оба сразу. <p>Дополнительные сведения об изменении предела по умолчанию см. в раздел об [изменении параллелизма триггера](#change-trigger-concurrency) или о [последовательном запуске экземпляров](#sequential-trigger). | Все триггеры | 
| `runtimeConfiguration.concurrency.maximumWaitingRuns` | Целое число | Измените [*лимит по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) на количество экземпляров рабочего процесса, которые необходимо ждать, чтобы запустить, когда приложение логики уже работает с максимальными одновременными экземплярами. <p>Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | Все триггеры | 
| `runtimeConfiguration.concurrency.repetitions` | Целое число | Измените [*лимит по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) на количество итераций цикла "для каждого", которые могут работать одновременно (одновременно или параллельно). <p>Параметр свойства `repetitions`, равный `1`, работает так же, как параметр свойства `operationOptions`, равный `SingleInstance`. Можно установить любое свойство, но не оба сразу. <p>Дополнительные сведения об изменении предела по умолчанию см. в разделе [Изменение параллелизма цикла Foreach](#change-for-each-concurrency) или [Последовательный запуск циклов Foreach](#sequential-for-each). | Действие: <p>[Foreach](#foreach-action) | 
| `runtimeConfiguration.paginationPolicy.minimumItemCount` | Целое число | Для конкретных действий, поддерживающих и поддерживающих pagination, это значение определяет *минимальное* количество результатов для получения. <p>Чтобы включить pagination, [см. Получить объемные данные, элементы или результаты с помощью pagination](../logic-apps/logic-apps-exceed-default-page-size-with-pagination.md) | Действие: Разнообразный |
| `runtimeConfiguration.secureData.properties` | Array | Во многих триггерах и действиях эти параметры скрывают входы, выходы или оба из истории выполнения приложения логики. <p>Чтобы узнать больше о защите этих данных, [см. Скрыть входы и выходы из истории выполнения](../logic-apps/logic-apps-securing-a-logic-app.md#secure-data-code-view). | Большинство триггеров и действий |
| `runtimeConfiguration.staticResult` | Объект JSON | Для действий, поддерживающих и включаемых [статического параметра результата,](../logic-apps/test-logic-apps-mock-data-static-results.md) `staticResult` объект имеет следующие атрибуты: <p>- `name`, который ссылается на статическое определение определения результата `staticResults` текущего действия, которое `definition` отображается внутри атрибута в атрибуте рабочего потока логики. Для получения дополнительной информации [см. Статические результаты - Ссылка на Schema для языка определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md#static-results). <p> - `staticResultOptions`, который определяет, являются ли `Enabled` статические результаты для текущего действия. <p>Чтобы включить статические результаты, смотрите [приложения логики теста с макетными данными, настраивая статические результаты](../logic-apps/test-logic-apps-mock-data-static-results.md) | Действие: Разнообразный |
||||| 

<a name="operation-options"></a>

## <a name="operation-options"></a>Варианты операций

Можно изменить поведение по умолчанию для триггеров и действий со свойством `operationOptions` в триггере или определении действия.

| Параметр операции | Тип | Описание | Триггер или действие | 
|------------------|------|-------------|-------------------| 
| `DisableAsyncPattern` | Строка | Запускайте действия на основе HTTP синхронно, а не асинхронно. <p><p>Чтобы задать этот параметр, см. в разделе [Синхронное выполнение действия](#asynchronous-patterns). | Действия: <p>[ApiConnection](#apiconnection-action), <br>[HTTP](#http-action), <br>[Ответ](#response-action) | 
| `OptimizedForHighThroughput` | Строка | Изменение [предела по умолчанию](../logic-apps/logic-apps-limits-and-config.md#throughput-limits) количества выполненных действий за 5 минут до [максимального предела](../logic-apps/logic-apps-limits-and-config.md#throughput-limits). <p><p>Чтобы задать этот параметр, см. в разделе [Запуск в режиме высокой пропускной способности](#run-high-throughput-mode). | Все действия | 
| `Sequential` | Строка | Запускайте итерации цикла Foreach по одной, а не одновременно параллельно. <p>Этот параметр работает так же, как параметр свойства `runtimeConfiguration.concurrency.repetitions`, равный `1`. Можно установить любое свойство, но не оба сразу. <p><p>Дополнительные сведения о задании этого параметра см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each).| Действие: <p>[Foreach](#foreach-action) | 
| `SingleInstance` | Строка | Запустите триггер для каждого экземпляра приложения логики последовательно и дождитесь завершения предыдущего активного запуска, прежде чем запускать следующий экземпляр приложения логики. <p><p>Этот параметр работает так же, как параметр свойства `runtimeConfiguration.concurrency.runs`, равный `1`. Можно установить любое свойство, но не оба сразу. <p>Чтобы задать этот параметр, см. раздел [Последовательная активизация экземпляров](#sequential-trigger). | Все триггеры | 
||||

<a name="change-trigger-concurrency"></a>

### <a name="change-trigger-concurrency"></a>Изменение параллелизма триггера

По умолчанию экземпляры рабочего процесса логических приложений работают одновременно (одновременно или параллельно). Это поведение означает, что каждый триггерный экземпляр срабатывает до завершения работы ранее активного экземпляра рабочего процесса. Однако количество одновременно запущенных экземпляров имеет [предел по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Когда число одновременно запущенных экземпляров рабочего процесса достигает этого предела, любые другие новые экземпляры должны ждать выполнения. Это ограничение помогает контролировать количество запросов, которые получают серверные системы.

Чтобы изменить предел по умолчанию, можно использовать либо редактор просмотра кода, либо Конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора добавляет или обновляет свойство `runtimeConfiguration.concurrency.runs` в базовом определении триггера и наоборот. Это свойство контролирует максимальное количество экземпляров рабочего процесса, которые могут работать параллельно. Вот некоторые соображения, когда вы хотите включить контроль параллелизма:

* При включении параллелизма [лимит SplitOn](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) значительно снижается для [дебатинговых массивов.](#split-on-debatch) Если количество элементов превышает этот предел, возможность SplitOn отключена.

* В то время как параллелизм включен, длительный экземпляр приложения логики может привести к входе новых экземпляров приложения логики в состояние ожидания. Это состояние предотвращает создание новых экземпляров логики Azure Apps и происходит даже тогда, когда количество одновременных запусков меньше указанного максимального количества одновременных запусков.

  * Чтобы прервать это состояние, отмените самые ранние экземпляры, которые *все еще работают.*

    1. В меню приложения логики выберите **Обзор**.

    1. В разделе **История «Бега»** выберите самый ранний экземпляр, который все еще работает, например:

       ![Выберите самый ранний экземпляр](./media/logic-apps-workflow-actions-triggers/waiting-runs.png)

       > [!TIP]
       > Для просмотра только экземпляров, которые все еще работают, откройте **список «Все»** и выберите **«Запуск».**

    1. Под **логикой запуска приложения,** выберите **Отмена запуска**.

       ![Найти ранний экземпляр, работающий](./media/logic-apps-workflow-actions-triggers/cancel-run.png)

  * Чтобы обойти эту возможность, добавьте тайм-аут в любое действие, которое может задержать эти запуски. Если вы работаете в редакторе кода, [см.](#asynchronous-limits) В противном случае, если вы используете конструктор, выполните следующие действия:

    1. В приложении логики, на действии, где вы хотите добавить тайм-аут, в правом верхнем углу, выберите эллипсы **(...)** кнопку, а затем выберите **Настройки.**

       ![Открытие параметров действия](./media/logic-apps-workflow-actions-triggers/action-settings.png)

    1. В соответствии **с тайм-аутом**укажите продолжительность тайм-аута в [формате ISO 8601.](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations)

       ![Укажите продолжительность тайм-аута](./media/logic-apps-workflow-actions-triggers/timeout.png)

* Чтобы запустить приложение логики последовательно, установите параллелизм `1` триггера либо с помощью редактора представления кода, либо с помощью редактора представления кода. Убедитесь, что вы также не установить свойство триггера `operationOptions` `SingleInstance` в редактора представления кода. В противном случае возникнет ошибка проверки. Дополнительные сведения см. в разделе [Последовательная активизация экземпляров](#sequential-trigger).

#### <a name="edit-in-code-view"></a>Изменение в представлении кода 

В базовом определении триггера добавьте `runtimeConfiguration.concurrency.runs` свойство, которое `1` `50`может иметь значение, которое колеблется от .

Ниже приведен пример, который ограничивает параллельные выполнения до 10 экземпляров.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 10
      }
   }
}
```

Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options).

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В верхнем правом углу триггера выберите эллипсы **(...**) кнопку, а затем выберите **настройки.**

1. В разделе **Управление параллелизмом** установите для параметра **Ограничение** значение **Вкл.** 

1. Перетащите ползунок **Степень параллелизма** к необходимому значению. Чтобы выполнять приложение логики в последовательном режиме, перетащите ползунок до значения **1**.

<a name="change-for-each-concurrency"></a>

### <a name="change-for-each-concurrency"></a>Изменение параллелизма цикла Foreach

По умолчанию итерации цикла "для каждого" работают одновременно (одновременно или параллельно). Это поведение означает, что каждая итерация начинает работать до завершения предыдущей итерации. Однако количество одновременно работающих итераций имеет [предел по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Когда количество одновременно работающих итераций достигает этого предела, любые другие итерации должны ждать выполнения.

Чтобы изменить предел по умолчанию, можно использовать либо редактор просмотра кода, либо Конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора добавляет или обновляет свойство `runtimeConfiguration.concurrency.repetitions` в базовом определении действия Foreach и наоборот. Это свойство определяет максимальное число итераций, которые могут выполняться параллельно.

> [!NOTE] 
> Если вы установите действие Foreach для запуска последовательно с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` действия равное `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. Дополнительные сведения см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each).

#### <a name="edit-in-code-view"></a>Изменение в представлении кода 

В базовом определении "для каждого" `runtimeConfiguration.concurrency.repetitions` добавьте или обновите свойство, которое может иметь значение, которое варьируется от `1` и `50`.

Ниже приведен пример, который ограничивает параллельные выполнения до 10 итераций.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 10
      }
   }
}
```

Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options).

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В **для каждого** действия, из верхнего правого угла, выберите эллипсы **(...**) кнопку, а затем выберите **Настройки.**

1. В разделе **Управление параллелизмом** для параметра **Управление параллелизмом** задайте значение **Вкл.**

1. Перетащите ползунок **Степень параллелизма** к необходимому значению. Чтобы выполнять приложение логики в последовательном режиме, перетащите ползунок до значения **1**.

<a name="change-waiting-runs"></a>

### <a name="change-waiting-runs-limit"></a>Изменение предела ожидающих запусков

По умолчанию экземпляры рабочего процесса логических приложений работают одновременно (одновременно или параллельно). Это поведение означает, что каждый триггерный экземпляр срабатывает до завершения работы ранее активного экземпляра рабочего процесса. Однако количество одновременно запущенных экземпляров имеет [предел по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Когда число одновременно запущенных экземпляров рабочего процесса достигает этого предела, любые другие новые экземпляры должны ждать выполнения.

Количество ожидающих запусков также имеет [предел по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Когда количество ожидающих запусков достигает этого предела, движок Logic Apps больше не принимает новые запуски. Триггеры запроса и веб-перехватчика возвращают 429 ошибку, а повторяющиеся триггеры начинают пропускать попытки опроса.

Вы можете не только [изменить лимит по умолчанию на триггерном параллели,](#change-trigger-concurrency)но вы также можете изменить лимит по умолчанию при ожидании. В базовом определении триггера добавьте `runtimeConfiguration.concurrency.maximumWaitingRuns` свойство, которое `1` `100`может иметь значение, которое колеблется от .

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "maximumWaitingRuns": 50
      }
   }
}
```

Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options).

<a name="sequential-trigger"></a>

### <a name="trigger-instances-sequentially"></a>Последовательная активация экземпляров

Чтобы запустить каждый экземпляр рабочего процесса приложения логики только после завершения предыдущего экземпляра, установите триггер для последовательного выполнения. Вы можете использовать либо редактор просмотра кода, либо конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора также добавляет или обновляет свойство `runtimeConfiguration.concurrency.runs` в базовом определении триггера и наоборот.

> [!NOTE] 
> Если вы настроите триггер для последовательного запуска с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` триггера равное `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. 

#### <a name="edit-in-code-view"></a>Изменение в представлении кода

В определении триггера задайте одно из этих свойств, но не оба. 

Задайте для свойства `runtimeConfiguration.concurrency.runs` значение `1`.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 1
      }
   }
}
```

*-или-*

Задайте для свойства `operationOptions` значение `SingleInstance`.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "operationOptions": "SingleInstance"
}
```

Для получения дополнительной [информации](#runtime-config-options) см. [Operation options](#operation-options)

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В верхнем правом углу триггера выберите эллипсы **(...**) кнопку, а затем выберите **настройки.**

1. В разделе **Управление параллелизмом** установите для параметра **Ограничение** значение **Вкл.** 

1. Перетащите ползунок **Степень параллелизма** на номер `1`. 

<a name="sequential-for-each"></a>

### <a name="run-for-each-loops-sequentially"></a>Последовательный запуск циклов Foreach

Чтобы запустить итерацию цикла Foreach только после завершения предыдущей итерации, настройте последовательное выполнение каждого действия. Вы можете использовать либо редактор просмотра кода, либо конструктор Logic Apps, поскольку изменение действия параллелизма с помощью конструктора также добавляет или обновляет свойство `runtimeConfiguration.concurrency.repetitions` в базовом определении действия и наоборот.

> [!NOTE] 
> Если вы настроите последовательное выполнение действия Foreach для запуска с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` действия равным `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. 

#### <a name="edit-in-code-view"></a>Изменение в представлении кода

В определении действия задайте один из этих свойств, но не оба. 

Задайте для свойства `runtimeConfiguration.concurrency.repetitions` значение `1`.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 1
      }
   }
}
```

*-или-*

Задайте для свойства `operationOptions` значение `Sequential`.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "operationOptions": "Sequential"
}
```

Для получения дополнительной [информации](#runtime-config-options) см. [Operation options](#operation-options)

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В верхнем правом углу **каждого** действия выберите кнопку эллипсов **(...)** и выберите **настройки.**

1. В разделе **Управление параллелизмом** для параметра **Управление параллелизмом** задайте значение **Вкл.**

1. Перетащите ползунок **Степень параллелизма** на номер `1`.

<a name="asynchronous-patterns"></a>

### <a name="run-actions-synchronously"></a>Синхронное выполнение действий

По умолчанию все действия на основе HTTP следуют стандартной модели асинхронных операций. Этот шаблон указывает, что когда действие на основе HTTP отправляет запрос на указанную конечную точку, удаленный сервер отправляет ответ "202 ACCEPTED". Этот ответ означает, что сервер принял запрос на обработку. Модуль Logic Apps продолжает проверять URL, указанный в заголовке местоположения ответа до тех пор, пока обработка не прекратится, что является ответом, отличным от 202.

Тем не менее у запросов есть ограничение по времени ожидания, поэтому для длительных действий можно отключить асинхронное поведение, добавив и установив свойство `operationOptions` в `DisableAsyncPattern` под входами действия.

```json
"<some-long-running-action>": {
   "type": "Http",
   "inputs": { "<action-inputs>" },
   "operationOptions": "DisableAsyncPattern",
   "runAfter": {}
}
```

Дополнительные сведения см. в разделе [Варианты операций](#operation-options).

<a name="run-high-throughput-mode"></a>

### <a name="run-in-high-throughput-mode"></a>Запуск в режиме высокой пропускной способности

Для определения одного логического приложения количество действий, выполняемых каждые 5 минут, имеет [предел по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#throughput-limits) Чтобы повысить этот предел до [максимума](../logic-apps/logic-apps-limits-and-config.md#throughput-limits), установите для свойства `operationOptions` значение `OptimizedForHighThroughput`. Этот параметр помещает приложение логики в режим высокой пропускной способности.

> [!NOTE]
> Режим высокой пропускной способности доступен в предварительной версии. Вы можете также распределить рабочую нагрузку между несколькими приложениями логики.

```json
"<action-name>": {
   "type": "<action-type>",
   "inputs": { "<action-inputs>" },
   "operationOptions": "OptimizedForHighThroughput",
   "runAfter": {}
}
```

<a name="authenticate-triggers-actions"></a>

## <a name="authenticate-triggers-and-actions"></a>Аутентификации триггеров и действий

Конечные точки HTTP и HTTPS поддерживают различные виды аутентификации. На основе триггера или действия, которые используются для исходящих вызовов или запросов для доступа к этим конечным точкам, можно выбрать из различных диапазонов типов аутентификации. Для получения дополнительной информации [см. Добавить аутентификацию к исходящим вызовам.](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound)

## <a name="next-steps"></a>Дальнейшие действия

* См. дополнительные сведения о [языке определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md)
