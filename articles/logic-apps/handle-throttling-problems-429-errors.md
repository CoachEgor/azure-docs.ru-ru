---
title: Обработка проблем с регулированием, или '429 - Слишком много ошибок запросов'
description: Как обойти проблемы регулирования, или 'HTTP 429 Слишком много ошибок запросов' в приложениях логики Azure
services: logic-apps
ms.suite: integration
ms.reviewer: deli, logicappspm
ms.topic: conceptual
ms.date: 04/13/2020
ms.openlocfilehash: fbfd52065bc0522668488492de2181f252f86a4e
ms.sourcegitcommit: 530e2d56fc3b91c520d3714a7fe4e8e0b75480c8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81272684"
---
# <a name="handle-throttling-problems-429---too-many-requests-errors-in-azure-logic-apps"></a>Обработка проблем с регулированием (429 - "Слишком много запросов" ошибки) в Azure Logic Apps

В [приложениях Логики Azure](../logic-apps/logic-apps-overview.md)приложение логики возвращает [ошибку "HTTP 429 Too many requests"](https://developer.mozilla.org/docs/Web/HTTP/Status/429) при обработке, что происходит, когда количество запросов превышает скорость, с которой пункт назначения может обрабатываться в течение определенного периода времени. Регулирование может создать такие проблемы, как задержка обработки данных, снижение производительности и ошибки, такие как превышение указанной политики повтора.

![Задушить в разъеме сервера S'L](./media/handle-throttling-problems-429-errors/example-429-too-many-requests-error.png)

Вот некоторые распространенные типы регулирования, которые могут возникнуть в приложении логики:

* [Приложение логики](#logic-app-throttling)
* [Соединителя](#connector-throttling)
* [Служба назначения или система](#destination-throttling)

<a name="logic-app-throttling"></a>

## <a name="logic-app-throttling"></a>Логика приложение регулирования

Служба логических приложений Azure имеет свои собственные [ограничения пропускной способности.](../logic-apps/logic-apps-limits-and-config.md#throughput-limits) Таким образом, если приложение логики превышает эти пределы, ресурс приложения логики задушен, а не только в определенном экземпляре или запуске.

Чтобы найти события регулирования на этом уровне, проверьте панель **метрик** приложения логики на портале Azure.

1. На [портале Azure](https://portal.azure.com)откройте логическое приложение в Logic App Designer.

1. В меню приложения логики, под **мониторингом,** выберите **метрики**.

1. Под **заголовком диаграммы**выберите **Добавить метрику,** чтобы добавить еще одну метрику к существующей.

1. В первом метрическом баре из списка **METRIC** выберите **события Action Throttled Events.** Во втором метрическом баре из списка **METRIC** выберите **события триггера.**

Для обработки регулирования на этом уровне, у вас есть следующие варианты:

* Ограничьте количество экземпляров логических приложений, которые могут работать одновременно.

  По умолчанию, если условие триггера приложения логики выполняется более одного раза одновременно, несколько триггерных экземпляров для приложения логики выполняются одновременно или *параллельно.* Это поведение означает, что каждый триггерный экземпляр запускается до завершения предыдущего экземпляра рабочего процесса.

  Хотя число триггеров по умолчанию, которые могут одновременно запускаться, [не ограничено,](../logic-apps/logic-apps-limits-and-config.md#concurrency-looping-and-debatching-limits)вы можете ограничить это число, [включив настройку параллелизма триггера,](../logic-apps/logic-apps-workflow-actions-triggers.md#change-trigger-concurrency)и при необходимости выберите предел, отличный от значения по умолчанию.

* Включить режим высокой пропускной выхажей.

  Приложение логики имеет [ограничение по умолчанию для количества действий, которые могут работать в течение 5-минутного интервала.](../logic-apps/logic-apps-limits-and-config.md#throughput-limits) Чтобы увеличить этот лимит до максимального количества действий, включите [режим высокой пропускной способности](../logic-apps/logic-apps-workflow-actions-triggers.md#run-high-throughput-mode) в приложении логики.

* Отключить блок разграничивого ("разделить на") поведение в триггерах.

  Если триггер возвращает массив для остальных действий рабочего процесса для обработки, [ **сплит** ](../logic-apps/logic-apps-workflow-actions-triggers.md#split-on-debatch) триггера при настройке разделяет элементы массива и запускает экземпляр рабочего процесса для каждого элемента массива, эффективно запуская несколько одновременных запусков до [ **предела Split On.** ](../logic-apps/logic-apps-limits-and-config.md#concurrency-looping-and-debatching-limits) Чтобы контролировать регулирование, выключите поведение **Split On** и поверните приложение логики на весь массив с помощью одного вызова, а не обрабатывать один элемент на вызов.

* Рефакторные действия в более мелкие логические приложения.

  Как упоминалось ранее, логическое приложение ограничено [числом действий по умолчанию, которые могут работать в течение 5-минутного периода.](../logic-apps/logic-apps-limits-and-config.md#throughput-limits) Хотя этот лимит можно увеличить, включив [режим высокой пропускной способности,](../logic-apps/logic-apps-workflow-actions-triggers.md#run-high-throughput-mode)можно также рассмотреть вопрос о том, хотите ли вы разбить действия приложения логики на более мелкие логические приложения, чтобы количество действий, которые работают в каждом приложении логики, оставалось под пределом. Таким образом, вы снижаете нагрузку на один ресурс приложения логики и распределяете нагрузку по нескольким логическим приложениям. Это решение лучше работает для действий, которые обрабатывают большие наборы данных или вращаются так много одновременно запущенных действий, цикл итераций или действий внутри каждой итерации цикла, что они превышают предел выполнения действий.

  Например, это приложение логики выполняет всю работу, чтобы получить таблицы из базы данных сервера S'L и получает строки из каждой таблицы. **Для каждого** цикла одновременно итерирует через каждую таблицу так, что действие Get **строк возвращает** строки для каждой таблицы. На основе объемов данных в этих таблицах эти действия могут превышать лимит на выполнение действий.

  ![Логика приложение "до" рефакторинга](./media/handle-throttling-problems-429-errors/refactor-logic-app-before-version.png)

  После рефакторинга приложение логики теперь является приложением родительской и детской логики. Родитель получает таблицы от сервера S'L, а затем вызывает приложение логики ребенка для каждой таблицы, чтобы получить строки:

  ![Создание приложения логики для одного действия](./media/handle-throttling-problems-429-errors/refactor-logic-app-single-connection-1.png)

  Вот приложение логики ребенка, которое называется приложением родительской логики, чтобы получить строки для каждой таблицы:

  ![Создайте другое приложение логики для второго действия](./media/handle-throttling-problems-429-errors/refactor-logic-app-single-connection-2.png)

<a name="connector-throttling"></a>

## <a name="connector-throttling"></a>Регулирование соединения

Каждый разъем имеет свои собственные границы регулирования, которые вы можете найти на технической странице ссылки разъема. Например, [разъем Azure Service Bus](https://docs.microsoft.com/connectors/servicebus/) имеет ограничение на регулирование, которое позволяет до 6000 вызовов в минуту, в то время как разъем сервера S'L имеет [ограничения регулирования, которые варьируются в зависимости](https://docs.microsoft.com/connectors/sql/)от типа операции.

Некоторые триггеры и действия, такие как HTTP, имеют [«политику повторной работы»,](../logic-apps/logic-apps-exception-handling.md#retry-policies) которую можно настроить на основе [ограничений политики повторной попытки](../logic-apps/logic-apps-limits-and-config.md#retry-policy-limits) для реализации обработки исключений. Эта политика определяет, является ли и как часто триггер или действие повторно запрос, когда исходный запрос не удается или раз и приводит к 408, 429, или 5xx ответ. Таким образом, когда начинается регулирование и возвращается ошибка 429, Logic Apps следует политике повтора, где поддерживается.

Чтобы узнать, поддерживает ли триггер или действие политики повторной попытки, проверьте настройки триггера или действия. Чтобы просмотреть попытки повторной попытки триггера или действия, перейдите в историю выполнения приложения логики, выберите запуск, который вы хотите просмотреть, и расширьте этот триггер или действие для просмотра сведений о входных данных, выводах и любых повторах, например:

![Просмотр истории выполнения действий, повторов, входов и выводов](./media/handle-throttling-problems-429-errors/example-429-too-many-requests-retries.png)

Хотя история повторная попытка предоставляет информацию об ошибках, у вас могут возникнуть проблемы с дифференциацией между регулированием разъема и [регулированием назначения.](#destination-throttling) В этом случае возможно, вам придется просмотреть детали ответа или выполнить некоторые расчеты интервала регулирования, чтобы определить источник.

Для логических приложений в глобальной, мультитенантной службе Azure Logic Apps регулирование происходит на уровне *соединения.* Так, например, для логических приложений, работающих в [среде интеграционных служб (ISE),](../logic-apps/connect-virtual-network-vnet-isolated-environment-overview.md)регулирование по-прежнему происходит для подключений, не относяющихся к ISE, поскольку они работают в глобальной, мультитенантной службе логических приложений. Тем не менее, соединения ISE, которые создаются разъемами ISE, не задушены, потому что они работают в вашем ISE.

Для обработки регулирования на этом уровне, у вас есть следующие варианты:

* Настройте несколько соединений для одного действия, чтобы логическое приложение переделывало данные для обработки.

  Для этого параметра подумайте о том, можно ли распределить рабочую нагрузку, разделив запросы действия на несколько соединений в один и тот же пункт назначения с помощью одних и тех же учетных данных.

  Например, предположим, что ваше приложение логики получает таблицы из базы данных сервера S'L Server, а затем получает строки из каждой таблицы. В зависимости от количества строк, которые необходимо обработать, можно использовать несколько соединений и несколько **для каждого** цикла, чтобы разделить общее количество строк на меньшие наборы для обработки. В этом сценарии используются два **для каждого** цикла, чтобы разделить общее количество строк пополам. В первом **для каждого** цикла используется выражение, которое получает первую половину. Другой **Для каждого** цикла использует другое выражение, которое получает вторую половину, например:<p>

    * Выражение 1: `take()` Функция получает переднюю часть коллекции. Для получения дополнительной [ **`take()`** информации](workflow-definition-language-functions-reference.md#take)см.

      `@take(collection-or-array-name, div(length(collection-or-array-name), 2))`

    * Выражение 2: `skip()` Функция удаляет переднюю часть коллекции и возвращает все остальные элементы. Для получения дополнительной [ **`skip()`** информации](workflow-definition-language-functions-reference.md#skip)см.

      `@skip(collection-or-array-name, div(length(collection-or-array-name), 2))`

    Вот наглядный пример, который показывает, как можно использовать эти выражения:

    ![Создание и использование нескольких соединений для одного действия](./media/handle-throttling-problems-429-errors/create-multiple-connections-per-action.png)

* Настройте другое соединение для каждого действия.

  Для этого параметра подумайте, можно ли распределить рабочую нагрузку, распространяя запросы каждого действия по их собственному подключению, даже если действия подключаются к одной и той же службе или системе и используют одни и те же учетные данные.

  Например, предположим, что ваше приложение логики получает таблицы из базы данных сервера S'L Server и получает каждую строку в каждой таблице. Можно использовать отдельные соединения, чтобы при получении таблиц использовалось одно соединение, в то время как в получении каждой строки использовалось другое соединение.

  ![Создание и использование различных соединений для каждого действия](./media/handle-throttling-problems-429-errors/create-connection-per-action.png)

* Измените параллелизм или параллелизм на [цикле "Для каждого".](../logic-apps/logic-apps-control-flow-loops.md#foreach-loop)

  По умолчанию итерации цикла "Для каждого" проходят в одно и то же время до [предела параллелизма.](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) Если у вас есть разъем, который задушил внутри цикла "Для каждого", можно уменьшить количество итераций цикла, которые работают параллельно. Дополнительные сведения см. в следующих статьях:
  
  * ["Для каждого" петли - изменение параллелизма или запустить последовательно](../logic-apps/logic-apps-control-flow-loops.md#sequential-foreach-loop)

  * [Схема определения языка рабочего процесса - Для каждого цикла](../logic-apps/logic-apps-workflow-actions-triggers.md#foreach-action)

  * [Схема языка определения рабочего процесса - Изменение параллелизма цикла "Для каждого"](../logic-apps/logic-apps-workflow-actions-triggers.md#change-for-each-concurrency)

  * [Схема определения языка рабочего процесса - Выполнить "Для каждого" циклы последовательно](../logic-apps/logic-apps-workflow-actions-triggers.md#sequential-for-each)

<a name="destination-throttling"></a>

## <a name="destination-service-or-system-throttling"></a>Служба назначения или регулирование системы

В то время как разъем имеет свои собственные пределы регулирования, служба назначения или система, которая называется разъемом, также могут иметь ограничения на регулирование. Например, некоторые AA в Microsoft Exchange Server имеют более строгие ограничения на регулирование, чем разъем Office 365 Outlook.

По умолчанию экземпляры приложения логики и любые циклы или ветви внутри этих экземпляров запускаемы *параллельно.* Такое поведение означает, что несколько экземпляров могут вызывать одну и ту же конечную точку одновременно. Каждый экземпляр не знает о существовании другого, поэтому попытки повторить неудачные действия могут создать [условия гонки,](https://en.wikipedia.org/wiki/Race_condition) в которых несколько вызовов пытаются выполнить в одно и то же время, но для успеха эти вызовы должны поступать в службу назначения или систему до начала задушения.

Например, предположим, что у вас есть массив, который имеет 100 элементов. Вы используете цикл "для каждого" для итерации через массив и включите параллелизирующий контроль цикла, чтобы можно было ограничить количество параллельных итераций до 20 или [текущего лимита по умолчанию.](../logic-apps/logic-apps-limits-and-config.md#concurrency-looping-and-debatching-limits) Внутри этого цикла действие вставляет элемент из массива в базу данных сервера S'L Server, которая разрешает только 15 вызовов в секунду. Этот сценарий приводит к проблеме регулирования, потому что отставание повторов накапряется и никогда не будет работать.

В этой таблице описывается шкала времени для того, что происходит в цикле, когда интервал повторной попытки действия составляет 1 секунду:

| На момент времени | Количество выполнения действий | Количество действий, которые терпят неудачу | Количество ожидающих повторов |
|---------------|----------------------------|-----------------------------|---------------------------|
| Т и 0 секунд | 20 вставок | 5 сбой, из-за лимита S'L | 5 повторений |
| Т 0,5 секунды | 15 вставок, из-за предыдущих 5 повторов ожидания | Все 15 неудачи, из-за предыдущего лимита S'L по-прежнему в силе в течение еще 0,5 секунд | 20 повторений <br>(предыдущие 5 и 15 новых) |
| Т - 1 секунда | 20 вставок | 5 неудачи плюс предыдущие 20 повторов, из-за лимита S'L | 25 повторений (предыдущие 20 и 5 новых)
|||||

Для обработки регулирования на этом уровне, у вас есть следующие варианты:

* Создавайте логические приложения таким образом, чтобы каждая из них обрабатывала одну операцию.

  * Продолжая сценарий«Сервера» в этом разделе, можно создать логическое приложение, которое помещает элементы массива в очередь, например [очередь в Azure Service Bus.](../connectors/connectors-create-api-servicebus.md) Затем вы создаете другое приложение логики, которое выполняет только операцию вставки для каждого элемента в этой очереди. Таким образом, в любое определенное время выполняется только один экземпляр приложения логики, который либо завершает операцию вставки и переходит к следующему элементу в очереди, либо экземпляр получает 429 ошибок, но не пытается непродуктивных повторов.

  * Создайте приложение родительской логики, которое вызывает приложение «ребенок» или вложенное приложение для каждого действия. Если родителю необходимо вызывать различные приложения для детей в зависимости от результата родителя, можно использовать действие условия или переключатель, которое определяет, какое приложение ребенка вызывать. Этот шаблон может помочь вам уменьшить количество вызовов или операций.

    Например, предположим, что у вас есть два логических приложения, каждое из которых имеет триггер опроса, который проверяет вашу учетную запись электронной почты каждую минуту для конкретного предмета, например "Успех" или "Неудача". Эта настройка приводит к 120 вызовам в час. Вместо этого, если вы создаете приложение логики одного родителя, которое опрашивает каждую минуту, но вызывает приложение детской логики, которое работает на основе того, является ли объект «Успех» или «Неудача», вы сократите количество проверок опроса до половины, или 60 в этом случае.

* Настройка пакетной обработки.

  Если служба назначения поддерживает пакетные операции, можно решить проблему регулирования путем обработки элементов группами или партиями, а не по отдельности. Для реализации решения для обработки пакетов создается логическое приложение "пакет-приемник" и логическое приложение "отправителя пакетов". Отправитель пакетов собирает сообщения или элементы до тех пор, пока не будут выполнены указанные критерии, а затем отправляет эти сообщения или элементы в одной группе. Пакетный приемник принимает эту группу и обрабатывает эти сообщения или элементы. Для получения дополнительной информации смотрите [сообщения обработки пакетов в группах.](../logic-apps/logic-apps-batch-process-send-receive-messages.md)

* Используйте версии webhook для триггеров и действий, а не для версий опроса.

  Почему? Триггер опроса продолжает проверять службу назначения или систему через определенные промежутки времени. Очень частый интервал, например, каждую секунду, может создать проблемы с регулированием. Тем не менее, триггер или действие webhook, такие как [HTTP Webhook](../connectors/connectors-native-webhook.md), создает только один вызов в службу назначения или систему, что происходит во время подписки и просит, чтобы пункт назначения уведомляет триггер или действие только в случае события. Таким образом, триггер или действие не должны постоянно проверять пункт назначения.
  
  Таким образом, если служба назначения или система поддерживает webhooks или предоставляет разъем, который имеет версию webhook, эта опция лучше, чем с помощью версии опроса. Чтобы определить триггеры и действия веб-крючка, подтвердите, что они имеют `ApiConnectionWebhook` тип или что они не требуют, чтобы вы указали повторение. Для получения дополнительной информации см. [APIConnectionWebhook action](../logic-apps/logic-apps-workflow-actions-triggers.md#apiconnectionwebhook-action) [APIConnectionWebhook trigger](../logic-apps/logic-apps-workflow-actions-triggers.md#apiconnectionwebhook-trigger)

## <a name="next-steps"></a>Дальнейшие действия

* Подробнее об [ограничениях и конфигурации приложений логики](../logic-apps/logic-apps-limits-and-config.md)
