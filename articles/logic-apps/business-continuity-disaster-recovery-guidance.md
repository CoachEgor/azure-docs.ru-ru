---
title: Непрерывность бизнес-процессов и аварийное восстановление
description: Разработайте стратегию защиты данных, быстрого восстановления после разрушительных событий, восстановления ресурсов, необходимых для критически важных бизнес-функций, и поддержания непрерывности бизнеса для приложений Azure Logic Apps
services: logic-apps
ms.suite: integration
ms.reviewer: klam, logicappspm
ms.topic: conceptual
ms.date: 03/31/2020
ms.openlocfilehash: 7bf71ce7c44229ccf19022e9cfb0162f9d77cd97
ms.sourcegitcommit: ced98c83ed25ad2062cc95bab3a666b99b92db58
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/31/2020
ms.locfileid: "80437703"
---
# <a name="business-continuity-and-disaster-recovery-for-azure-logic-apps"></a>Непрерывность бизнеса и аварийное восстановление для приложений логики Azure

Чтобы уменьшить влияние и влияние непредсказуемых событий на ваш бизнес и клиентов, убедитесь, что у вас есть аварийное [ *решение восстановления* (DR),](https://en.wikipedia.org/wiki/Disaster_recovery) чтобы вы могли защитить данные, быстро восстановить ресурсы, которые поддерживают критически важные бизнес-функции, и сохранить операции для поддержания [ *непрерывности бизнеса* (BC)](https://en.wikipedia.org/wiki/Business_continuity_planning). Например, сбои могут включать перебои, потери базовой инфраструктуры или компонентов, таких как хранение, сеть или вычислительные ресурсы, невосстановимые сбои приложений или даже полную потерю центра обработки данных. При готовя решение для непрерывности работы и аварийного восстановления (BCDR) ваше предприятие или организация может быстрее реагировать на перерывы, запланированные или незапланированные, а также сократить время простоя для клиентов.

В этой статье содержатся рекомендации и стратегии BCDR, которые можно применить при создании автоматизированных рабочих процессов с помощью [приложений Azure Logic Apps.](../logic-apps/logic-apps-overview.md) Рабочие процессы логических приложений помогают вам легче интегрировать и организовывать данные между приложениями, облачными службами и системами, уменьшая объем кода, который нужно написать. Планируйте BCDR, убедитесь, что вы рассматриваете не только свои логические приложения, но и ресурсы Azure, которые используются с помощью логических приложений:

* [Соединения,](../connectors/apis-list.md) создаваемые из логических приложений и других приложений, служб и систем. Для получения дополнительной информации [см.](#resource-connections)

* [На территории шлюзов данных,](../logic-apps/logic-apps-gateway-connection.md) которые являются ресурсами Azure, которые вы создаете и используете в своих логических приложениях для доступа к данным в специальных системах. Каждый ресурс шлюза представляет собой отдельную [установку шлюза данных](../logic-apps/logic-apps-gateway-install.md) на локальном компьютере. Для получения дополнительной информации смотрите [шлюзы данных On-premises](#on-premises-data-gateways) позже в этой теме.

* [Учетные записи интеграции,](../logic-apps/logic-apps-enterprise-integration-create-integration-account.md) в которых вы определяете и храните артефакты, которые логические приложения используют для сценариев [интеграции предприятий для бизнеса (B2B).](../logic-apps/logic-apps-enterprise-integration-overview.md) Например, можно [настроить межрегиональные аварийные восстановления для учетных записей интеграции.](../logic-apps/logic-apps-enterprise-integration-b2b-business-continuity.md)

* [Среды служб интеграции (ISEs),](../logic-apps/connect-virtual-network-vnet-isolated-environment-overview.md) где создаются логические приложения, запускаемые в изолированном экземпляре времени выполнения логических приложений в виртуальной сети Azure. Эти логические приложения могут затем получить доступ к ресурсам, которые защищены за брандмауэром в этой виртуальной сети.

<a name="primary-secondary-locations"></a>

## <a name="primary-and-secondary-locations"></a>Первичные и вторичные места

Каждое приложение логики должно указать местоположение, которое вы хотите использовать для развертывания. Это место является либо общедоступным регионом в глобальной мультитенантной Azure, например «West US», либо средой служб интеграции (ISE), которую вы ранее создали и развернули в виртуальной сети Azure. Запуск логических приложений в ISE аналогичен запуску логических приложений в глобальном регионе Azure, что означает, что стратегия аварийного восстановления может применяться к обоим сценариям. Однако у ИСЕ есть и другие соображения, такие, как настройка доступа к ресурсам, которые доступны только для ИС.

> [!NOTE]
> Если приложение логики также работает с артефактами B2B, такими как торговые партнеры, соглашения, схемы, карты и сертификаты, которые хранятся в интеграционном счете, как учетная запись интеграции, так и логические приложения должны указать одно и то же местоположение.

Эта стратегия аварийного восстановления фокусируется на настройке основного приложения логики для [*отказа*](https://en.wikipedia.org/wiki/Failover) в приложении логики ожидания или резервного копирования в другом месте, где также доступны приложения Azure Logic Apps. Таким образом, если первичные терпит потери, сбои или сбои, вторичные могут взять на себя работу. Эта стратегия требует, чтобы ваше вторичное приложение логики и зависимые ресурсы уже были развернуты и готовы в альтернативном месте.

Если вы выполняете хорошие методы DevOps, вы уже используете [шаблоны Azure Resource Manager](../azure-resource-manager/management/overview.md) для определения и развертывания логических приложений и зависимых ресурсов. Шаблоны менеджера ресурсов дают возможность использовать одно определение развертывания, а затем использовать файлы параметров для обеспечения значений конфигурации для использования для каждого пункта назначения развертывания. Эта возможность означает, что вы можете развернуть одно и то же приложение логики в различных средах, например, в разработке, тестировании и производстве. Можно также развернуть одно и то же приложение логики в различных регионах Azure или IsEs, которое поддерживает стратегии аварийного восстановления, которые используют [парные области.](../best-practices-availability-paired-regions.md)

Для стратегии неудачи ваши логические приложения и местоположения должны соответствовать этим требованиям:

* Вторичный экземпляр приложения логики имеет доступ к тем же приложениям, службам и системам, что и основной экземпляр приложения логики.

* Оба экземпляра приложения логики имеют один и тот же тип хоста. Таким образом, оба экземпляра развернуты в регионах глобального мультитенантного Azure, либо оба — в IsEs, что позволяет вашим логическим приложениям напрямую получать доступ к ресурсам в виртуальной сети Azure. Для рекомендаций и дополнительной информации о парных регионах bcDR [см.](../best-practices-availability-paired-regions.md)

  Например, как первичные, так и вторичные местоположения должны быть ISE, когда основное приложение логики работает в ISE и использует [разъемы версии ISE,](../connectors/apis-list.md#ise-connectors)действия HTTP для вызова ресурсов в виртуальной сети Azure или и то, и другое. В этом сценарии ваше вторичное логическое приложение должно также иметь аналогичную настройку во вторичном местоположении в качестве основного приложения логики.

  > [!NOTE]
  > Для более продвинутых сценариев можно смешивать как мультитенантный Azure, так и ISE в качестве местоположений. Однако убедитесь, что вы учитываете и понимаете различия между тем, [как логические приложения работают в ISE и мультитенантными Azure.](../logic-apps/connect-virtual-network-vnet-isolated-environment-overview.md#difference)

* Если вы используете ISEs, [убедитесь, что они масштабируются или имеют достаточную емкость](../logic-apps/ise-manage-integration-service-environment.md#add-capacity) для обработки нагрузки.

#### <a name="example-multi-tenant-azure"></a>Пример: Мультитенантный Azure

В этом примере показаны примеры первичных и вторичных логических приложений, которые развертываются в отдельных регионах глобального мультитенантного Azure для этого сценария. Единый [шаблон менеджера ресурсов](../logic-apps/logic-apps-azure-resource-manager-templates-overview.md) определяет как экземпляры логических приложений, так и зависимые ресурсы, требуемые этими логическими приложениями. Отдельные файлы параметров определяют значения конфигурации для использования для каждого местоположения развертывания:

![Основные и вторичные экземпляры приложений логики в отдельных местах](./media/business-continuity-disaster-recovery-guidance/primary-secondary-locations.png)

#### <a name="example-integration-service-environment"></a>Пример: Среда службы интеграции

В этом примере отображаются предыдущие экземпляры приложений первичной и вторичной логики, но развернутые для разделения isEs. Единый шаблон диспетчера ресурсов определяет как экземпляры приложения логики, зависимые ресурсы, требуемые этими логическими приложениями, так и isEs как местоположения развертывания. Отдельные параметры определяют значения конфигурации для развертывания в каждом месте:

![Первичные и вторичные логические приложения в разных местах](./media/business-continuity-disaster-recovery-guidance/primary-secondary-locations-ise.png)

<a name="resource-connections"></a>

## <a name="connections-to-resources"></a>Подключение к ресурсам

Azure Logic Apps предоставляет [встроенные триггеры и действия, а также сотни управляемых разъемов,](../connectors/apis-list.md) которые приложение логики может использовать для работы с другими приложениями, службами, системами и другими ресурсами, такими как учетные записи хранения azure, базы данных серверов S'L Server, учетные записи электронной почты Office 365 Outlook и так далее. Если приложению логики необходим доступ к этим ресурсам, вы создаете соединения, которые проверят подлинность доступа к этим ресурсам. Каждое соединение является отдельным ресурсом Azure, который существует в определенном месте и не может использоваться ресурсами в других местах.

Для стратегии аварийного восстановления следует учитывать места, где существуют зависимые ресурсы по отношению к экземплярам приложения логики:

* Ваш основной экземпляр и зависимые ресурсы существуют в разных местах. В этом случае ваш вторичный экземпляр может подключиться к тем же зависимым ресурсам или конечным точкам. Тем не менее, следует создавать соединения специально для вашего вторичного экземпляра. Таким образом, если ваше основное местоположение становится недоступным, соединения вашего вторичного не затрагиваются.

  Например, предположим, что основное приложение логики подключается к внешней службе, такой как Salesforce. Как правило, доступность и местоположение внешнего сервиса не зависят от доступности приложения логики. В этом случае ваш вторичный экземпляр может подключиться к той же службе, но должен иметь свое собственное соединение.

* В одном и том же месте существуют как основные экземпляры, так и зависимые ресурсы. В этом случае зависимые ресурсы должны иметь резервные или реплицированные версии в другом месте, чтобы ваш вторичный экземпляр мог получить доступ к этим ресурсам.

  Например, предположим, что основное приложение логики подключается к службе, найму в том же месте или регионе, например, к базе данных Azure S'L. Если весь этот регион становится недоступен, служба базы данных Azure S'L в этом регионе также, вероятно, недоступна. В этом случае необходимо, чтобы ваш вторичный экземпляр использовал реплицированную или резервную базу данных вместе с отдельным подключением к этой базе данных.

<a name="on-premises-data-gateways"></a>

## <a name="on-premises-data-gateways"></a>Локальные шлюзы данных

Если приложение логики работает в мультитенантном Azure и нуждается в доступе к локальным ресурсам, таким как базы данных S'L Server, необходимо установить [локальный шлюз данных](../logic-apps/logic-apps-gateway-install.md) на локальном компьютере. Затем можно создать ресурс шлюза данных на портале Azure, чтобы приложение логики мог использовать шлюз при создании подключения к ресурсу.

Ресурс шлюза данных связан с местоположением или областью Azure, как и ресурс приложения логики. В стратегии аварийного восстановления убедитесь, что шлюз данных остается доступным для использования приложения логики. Вы можете [включить высокую доступность для вашего шлюза,](../logic-apps/logic-apps-gateway-install.md#high-availability) когда у вас есть несколько установок шлюза.

> [!NOTE]
> Если приложение логики работает в среде служб интеграции (ISE) и использует только разъемы версий ISE для локтевых источников данных, вам не нужен шлюз данных, потому что разъемы ISE обеспечивают прямой доступ к ресурсу.
>
> Если разъем версии ISE не доступен для необходимого ресурса, приложение логики может создать соединение с помощью разъема, не связанного с ISE, который работает в глобальной мультитенантной Azure, а не в ISE. Однако для этого соединения требуется шлюз данных.

<a name="roles"></a>

## <a name="active-active-versus-active-passive-roles"></a>Активные и активные пассивные роли

Можно настроить основные и вторичные местоположения таким образом, чтобы экземпляры приложения логики в этих местах могли играть следующие роли:

| Роль первичной и вторичной | Описание |
|------------------------|-------------|
| *Активно-активный* | Примеры приложения первичной и вторичной логики в обоих местах активно обрабатывают запросы, следуя одному из этих шаблонов: <p><p>- *Баланс нагрузки*: Вы можете иметь оба экземпляра слушать конечную точку и трафик баланса нагрузки в каждом экземпляре по мере необходимости. <p>- *Конкурирующие потребители*: Вы можете иметь оба экземпляра выступать в качестве конкурирующих потребителей, так что экземпляры конкурируют за сообщения из очереди. Если один экземпляр выходит из строя, другой экземпляр берет на себя рабочую нагрузку. |
| *Активно-пассивный* | Пример основного приложения логики активно обрабатывает всю рабочую нагрузку, в то время как вторичный экземпляр является пассивным (отключенным или неактивным). Вторичный ждет сигнала о том, что основной недоступен или не работает из-за сбоя или сбоя, и берет на себя рабочую нагрузку в качестве активного экземпляра. |
| Сочетание | Некоторые логические приложения играют активную активную роль, в то время как другие логические приложения играют активную пассивную роль. |
|||

<a name="active-active-examples"></a>

### <a name="active-active-examples"></a>Активно-активные примеры

Эти примеры показывают активную установку, где оба экземпляра логических приложений активно обрабатывают запросы или сообщения. Некоторые другие системы или службы распределяет запросы или сообщения между экземплярами, например, один из этих вариантов:

* "Физический" балансизатор нагрузки, например, аппаратура, которая направляет трафик

* "Мягкий" балансосиватор нагрузки, такой как [Балансер загрузки Azure](../load-balancer/load-balancer-overview.md) или [управление API Azure.](../api-management/api-management-key-concepts.md) С помощью API Management можно указать политики, определяющие, как загрузить баланс входящего трафика. Или можно использовать службу поддержки государственного отслеживания, [например, Azure Service Bus.](../service-bus-messaging/service-bus-messaging-overview.md)

  Хотя в этом примере в основном показан балансовик загрузки Azure, можно использовать опцию, которая наилучшим образом соответствует потребностям вашего сценария:

  !["Активная" настройка, используюая балансомер нагрузки или службу состояния](./media/business-continuity-disaster-recovery-guidance/active-active-setup-load-balancer.png)

* Каждый экземпляр приложения логики выступает в качестве потребителя и имеет в обоих случаях конкурировать за сообщения из очереди:

  !["Активная" установка, использующая "конкурирующих потребителей"](./media/business-continuity-disaster-recovery-guidance/active-active-competing-consumers-pattern.png)

<a name="active-passive-examples"></a>

### <a name="active-passive-examples"></a>Примеры активного пассивного действия

Этот пример показывает активную пассивную настройку, где пример основного приложения логики активен в одном месте, в то время как вторичный экземпляр остается неактивным в другом месте. При сбое в работе основного элемента можно запустить оператору скрипт, который активирует вторичный, чтобы взять на себя рабочую нагрузку.

!["Активно-пассивная" установка, использующая "конкурирующих потребителей"](./media/business-continuity-disaster-recovery-guidance/active-passive-setup.png)

<a name="active-active-active-passive-examples"></a>

### <a name="combination-with-active-active-and-active-passive"></a>Комбинация с активно-активным и активно-пассивным

Этот пример показывает комбинированную настройку, где основное местоположение имеет оба экземпляра приложения активной логики, в то время как вторичное местоположение имеет примеры приложения с активной пассивной логикой. Если в основном местоположении происходит сбой или сбой, приложение active logic во вторичном месте, которое уже обрабатывает частичную рабочую нагрузку, может взять на себя всю рабочую нагрузку.

* В основном местоположении приложение active logic прослушивает очередь Azure Service Bus для сообщений, в то время как другое приложение с активной логикой проверяет электронные письма с помощью триггера опроса Office 365 Outlook.

* Во вторичном месте приложение active logic работает с приложением логики в основном месте, слушая и конкурируя за сообщения из той же очереди Service Bus. Между тем, пассивное неактивное приложение логики ждет в режиме ожидания, чтобы проверить сообщения электронной почты, когда основное местоположение становится недоступным, но *отключено,* чтобы избежать перечитывания сообщений электронной почты.

!["Активно-пассивная" и "активно-пассивная" комбинация, использующая триггеры Recurrence](./media/business-continuity-disaster-recovery-guidance/combo-active-active-active-passive-setup.png)

<a name="state-history"></a>

## <a name="logic-app-state-and-history"></a>Состояние и история приложения логики

Когда приложение логики запускается и запускается, состояние приложения хранится в том же месте, где приложение запущено, и не передаваемое в другое место. При сбое или сбое происходит отказ, любые незавершенные экземпляры рабочего процесса отброшены. При настройке основных и вторичных местоположений в вторичном месте начинают работать новые экземпляры рабочего процесса во вторичном местоположении.

<a name="reduce-abandoned-in-progress"></a>

### <a name="reduce-abandoned-in-progress-instances"></a>Сокращение заброшенных незавершенных экземпляров

Чтобы свести к минимуму количество заброшенных экземпляров рабочего процесса, можно выбрать из различных шаблонов сообщений, которые можно реализовать, например:

* [Фиксированный шаблон скольжения по скольжению по схеме сонна](https://docs.microsoft.com/biztalk/esb-toolkit/message-routing-patterns#routing-slip)

  Этот шаблон корпоративных сообщений, который разделяет бизнес-процесс на более мелкие этапы. На каждом этапе вы настраиваете логическое приложение, которое обрабатывает рабочую нагрузку для этого этапа. Для связи с ними приложения логики используют асинхронный протокол обмена сообщениями, например очереди или темы Azure Service Bus. При разделении процесса на более мелкие этапы уменьшается количество бизнес-процессов, которые могут застрять в неисправном экземпляре приложения логики. Более подробную информацию об этом шаблоне можно узнать в [шаблонах интеграции Enterprise - Routing slip.](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RoutingTable.html)

  В этом примере показан шаблон скольжения, в котором каждое приложение логики представляет этап и использует очередь Service Bus для связи со следующим приложением логики в процессе.

  ![Разделение бизнес-процесса на этапы, представленные логическими приложениями, которые взаимодействуют друг с другом с помощью очередей Azure Service Bus](./media/business-continuity-disaster-recovery-guidance/fixed-routing-slip-pattern.png)

  Если примеры приложений как основной, так и вторичной логики следуют тому же шаблону скольжения в своих местах, можно реализовать [шаблон конкурирующих потребителей,](https://docs.microsoft.com/azure/architecture/patterns/competing-consumers) установив [активные активные роли](#roles) для этих экземпляров.

* [Схема менеджера процесса (брокер)](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html)

* [Peek-lock без шаблона тайм-аута](https://social.technet.microsoft.com/wiki/contents/articles/50022.azure-service-bus-how-to-peek-lock-a-message-from-queue-using-azure-logic-apps.aspx)

<a name="access-trigger-runs-history"></a>

### <a name="access-to-trigger-and-runs-history"></a>Доступ к триггеру и запуску истории

Чтобы получить больше информации о прошлых выполнениях рабочего процесса вашего приложения, можно просмотреть триггер приложения и запустить историю. История выполнения приложения логики хранится в том же месте или регионе, где работает это приложение логики, что означает, что вы не можете перенести эту историю в другое место. Если основной экземпляр не справляется со второстепенным экземпляром, вы можете получить доступ к триггеру каждого экземпляра и запустить историю в соответствующих местах, где эти экземпляры запущены. Тем не менее, вы можете получить информацию об истории приложения логики, настроив логические приложения для отправки диагностических событий в рабочее пространство Azure Log Analytics. Затем можно просмотреть работоспособность и историю в логических приложениях, которые работают в нескольких местах.

<a name="trigger-types-guidance"></a>

## <a name="trigger-type-guidance"></a>Руководство по типу триггера

Тип триггера, используемый в логических приложениях, определяет параметры того, как можно настроить логические приложения в разных местах в стратегии аварийного восстановления. Ниже приведены доступные типы триггеров, которые можно использовать в логических приложениях:

* [Триггер повторения](#recurrence-trigger)
* [Опрашивающий триггер](#polling-trigger)
* [Триггер запросов](#request-trigger)
* [Триггер веб-перехватчика](#webhook-trigger)

<a name="recurrence-trigger"></a>

### <a name="recurrence-trigger"></a>Триггер повторения

Триггер **Recurrence** не зависит от какой-либо конкретной службы или конечной точки, и пожары основаны исключительно на определенном графике и никаких других критериев, например:

* Фиксированная частота и интервал, например, каждые 10 минут
* Более продвинутый график, например, последний понедельник каждого месяца в 17:00

Когда приложение логики начинается с триггера Recurrence, необходимо настроить основные и вторичные экземпляры приложения логики с [активно-пассивными ролями.](#roles) Чтобы уменьшить *время восстановления* (RTO), которая относится к целевой продолжительности для восстановления бизнес-процесса после сбоя или сбоя, можно настроить экземпляры приложения логики с сочетанием [активно-пассивных ролей](#roles) и [пассивно-активных ролей.](#roles) В этой настройке вы делите расписание на разных местоположений.

Например, предположим, что у вас есть логическое приложение, которое должно работать каждые 10 минут. Вы можете настроить логические приложения и местоположения так, чтобы, если основное местоположение стало недоступным, вторичное местоположение может взять на себя работу:

!["Активно-пассивная" и "пассивно-активная" комбинация, использующая триггеры Recurrence](./media/business-continuity-disaster-recovery-guidance/combo-active-passive-passive-active-setup.png)

* В основном месте нависли [активные пассивные роли](#roles) для следующих логических приложений:

  * Для *приложения с активной* включенной логикой установите триггер Recurrence, чтобы начать в верхней части часа и повторять каждые 20 минут, например, 9:00 AM, 9:20 AM и так далее.

  * Для *приложения с пассивной* отключенной логикой установите триггер Recurrence в том же графике, но начните с 10 минут после часа и повторите каждые 20 минут, например, 9:10 AM, 9:30 AM и так далее.

* Во вторичном месте нависли [пассивно-активные](#roles) для следующих логических приложений:

  * Для *приложения с пассивной* отключенной логикой установите триггер Recurrence в том же графике, что и приложение active logic в основном месте, которое находится в верхней части часа и повторяется каждые 20 минут, например, в 9:00, 9:10 am и так далее.

  * Для *приложения с активной* включенной логикой установите триггер Recurrence в том же графике, что и приложение пассивной логики в основном месте, которое начинается в 10 минут за часи и повторять каждые 20 минут, например, 9:10 AM, 9:20 AM и так далее.

Теперь, если разрушительное событие происходит в основном месте, активируйте приложение пассивной логики в другом месте. Таким образом, если поиск сбоя занимает время, эта настройка ограничивает количество пропущенных повторений во время этой задержки.

<a name="polling-trigger"></a>

### <a name="polling-trigger"></a>Опрашивающий триггер

Чтобы регулярно проверять, доступны ли новые данные для обработки из определенной службы или конечных точек, приложение логики может использовать триггер *опроса,* который неоднократно вызывает службу или конечную точку на основе фиксированного графика повторения. Данные, которые предоставляет служба или конечная точка, могут иметь любой из этих типов:

* Статические данные, описывающие данные, которые всегда доступны для чтения
* Неустойчивые данные, описывающие данные, которые больше не доступны после прочтения

Чтобы избежать повторного чтения одних и тех же данных, приложению логики необходимо помнить, какие данные были ранее прочитаны, поддерживая состояние либо на стороне клиента, либо на стороне сервера, службы или системы.

* Логические приложения, которые работают с клиентами-со стороны государства использовать триггеры, которые могут поддерживать состояние.

  Например, триггер, считывающий новое сообщение из почтового ящика, требует, чтобы триггер мог запомнить последнее прочитанное сообщение. Таким образом, триггер запускает приложение логики только тогда, когда приходит следующее непрочитаное сообщение.

* Логические приложения, работающие с состоянием сервера, службы или системы, используют значения свойств или настройки, находящегося на стороне сервера, службы или системы.

  Например, триггер на основе запроса, считывающий строку `isRead` из базы данных, требует, чтобы строка была настроена на `FALSE` Каждый раз, когда триггер читает строку, приложение `isRead` логики `FALSE` `TRUE`обновляет эту строку, изменяя столбец с .

  Этот подход на стороне сервера работает аналогично для очередей или тем, которые стоят в очередях семантики, где триггер может прочитать и заблокировать сообщение, в то время как приложение логики обрабатывает сообщение. Когда приложение логики завершает обработку, триггер удаляет сообщение из очереди или темы.

С точки зрения аварийного восстановления при настройке основных и вторичных экземпляров приложения логики убедитесь, что вы учитываете эти поведения в зависимости от того, отслеживает ли приложение логики состояние на стороне клиента или на стороне сервера:

* Для приложения логики, работая с состоянием клиента, убедитесь, что приложение логики не читает одно и то же сообщение более одного раза. Только одно место может иметь экземпляр приложения активной логики в любое определенное время. Убедитесь, что экземпляр приложения логики в альтернативном местоположении неактивен или отключен до тех пор, пока основной экземпляр не выйдет из строя в альтернативном местоположении.

  Например, триггер Office 365 Outlook поддерживает состояние клиентской стороны и отслеживает отметку времени для самой недавно прочитанных электронной почты, чтобы избежать прочтения дубликата.

* Для приложения логики, работая с состоянием сервера, можно настроить экземпляры приложения логики для воспроизведения либо [активных активных ролей,](#roles) в которых они работают в качестве конкурирующих потребителей, либо [активно-пассивных ролей,](#roles) где альтернативный экземпляр ждет, пока основной экземпляр не перейдется в альтернативное местоположение.

  Например, чтение из очереди сообщений, например в очереди Azure Service Bus, использует состояние сервера, поскольку служба очередей поддерживает блокировки сообщений, чтобы другие клиенты не читали одни и те же сообщения.

  > [!NOTE]
  > Если приложению логики необходимо читать сообщения в определенном порядке, например, из очереди Service Bus, вы можете использовать конкурирующий шаблон потребителя, но только в сочетании с сеансами Service Bus, который также известен как [последовательный шаблон *конвоя.* ](https://docs.microsoft.com/azure/architecture/patterns/sequential-convoy) В противном случае необходимо настроить экземпляры приложения логики с активно-пассивными ролями.

<a name="request-trigger"></a>

### <a name="request-trigger"></a>Триггер запросов

Триггер **Запроса** делает ваше логическое приложение вызываемым из других приложений, служб и систем и обычно используется для предоставления следующих возможностей:

* Прямой REST API для вашего приложения логики, которое другие могут вызвать

  Например, используйте триггер Запроса, чтобы запустить приложение логики, чтобы другие логические приложения могли вызвать триггер с помощью **рабочего процесса Call - Logic Apps.**

* Механизм [веб-крючка](#webhook-trigger) или обратного вызова для приложения логики

* Способ, которым можно вручную выполнять пользовательские операции или процедуры для вызова приложения логики, например, с помощью сценария PowerShell, выполняющих определенную задачу

С точки зрения аварийного восстановления триггер Запрос является пассивным приемником, поскольку приложение логики не делает никакой работы и ждет, пока какая-либо другая служба или система явно не вызовет триггер. В качестве пассивной конечной точки можно настроить основные и вторичные экземпляры следующим образом:

* [Активно-активный](#roles): Оба экземпляра активно обрабатывают запросы или вызовы. Вызыватель или маршрутизатор балансирует или распределяет трафик между этими экземплярами.

* [Активно-пассивный](#roles): Только основная instance активна и обрабатывает всю работу, в то время как вторичный экземпляр ждет, пока основная проблема не сработает или сбой. Звонящее или маршрутизатор определяет, когда вызывать вторичную инстанцию.

В рекомендуемой архитектуре можно использовать Управление API Azure в качестве прокси для логических приложений, использовавававшее триггеры Запроса. API Management обеспечивает [встроенную межрегиональную устойчивость и возможность маршрутизации трафика через несколько конечных точек.](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)

<a name="webhook-trigger"></a>

### <a name="webhook-trigger"></a>Триггер веб-перехватчика

Триггер *Webhook* предоставляет возможность для вашего приложения логики подписаться на службу, передавая *URL-адрес обратного вызова* этой службе. Приложение логики может затем слушать и ждать определенного события в этой точке обслуживания. Когда событие происходит, служба вызывает триггер webhook с помощью URL-адреса обратного вызова, который затем запускает приложение логики. При включении триггер айму веб-крючка подписывается на службу. При отключении триггер отключается от службы.

С точки зрения аварийного восстановления настраивайте первичные и вторичные экземпляры, в которых используются триггеры webhook для воспроизведения активных пассивных ролей, поскольку только один экземпляр должен получать события или сообщения из подписной конечной точки.

## <a name="assess-primary-instance-health"></a>Оценка здоровья первичного экземпляра

Для того чтобы стратегия аварийного восстановления работала, вашему решению нужны способы выполнения следующих задач:

* [Проверка доступности первичной инстанции](#check-primary-availability)
* [Мониторинг здоровья первичной инстанции](#monitor-primary-health)
* [Активировать вторичный экземпляр](#activate-secondary)

В этом разделе описывается одно решение, которое можно использовать прямо или в качестве основы для собственного дизайна. Вот визуальный обзор высокого уровня для этого решения:

![Создание приложения логики сторожевой собаки, которое отслеживает логическое приложение проверки работоспособности в основном местоположении](./media/business-continuity-disaster-recovery-guidance/check-location-health-watchdog.png)

<a name="check-primary-availability"></a>

### <a name="check-primary-instance-availability"></a>Проверка доступности первичного экземпляра

Чтобы определить, доступна ли основная мизанта, работает и способна работать, можно создать логическое приложение "Проверка работоспособности", которое находится в том же месте, что и основной экземпляр. Затем вы можете вызвать это приложение проверки работоспособности из другого места. Если приложение проверки работоспособности успешно отвечает, базовая инфраструктура службы Azure Logic Apps в этом регионе доступна и работает. Если приложение проверки работоспособности не отвечает, можно предположить, что местоположение больше не является здоровым.

Для этой задачи создайте базовое логическое приложение проверки работоспособности, которое выполняет следующие задачи:

1. Получает звонок от приложения сторожевой собаки с помощью триггера Запроса.

1. Ответьте статусом, указывающим, работает ли проверенное приложение логики с помощью действия Response.

   > [!IMPORTANT]
   > Приложение логики проверки работоспособности должно использовать действие Response, чтобы приложение отвечало синхронно, а не синхронно.

1. Дополнительно, чтобы дополнительно определить, является ли основное местоположение здоровым, вы можете учитывать работоспособность любых других служб, которые взаимодействуют с приложением целевой логики в этом месте. Просто расширьте логическое приложение проверки работоспособности, чтобы оценить состояние здоровья и для этих других служб.

<a name="monitor-primary-health"></a>

### <a name="create-a-watchdog-logic-app"></a>Создание приложения логики сторожевого пса

Чтобы следить за работоспособностью основной министы и вызывать логическое приложение проверки работоспособности, создайте логическое приложение «сторожевой пес» в *другом месте.* Например, можно настроить приложение логики watchdog, чтобы при сбое вызова логики проверки работоспособности сторожевой пес мог отправить предупреждение вашей команде операций, чтобы они могли исследовать сбой и почему основная инстанция не отвечает.

> [!IMPORTANT]
> Убедитесь, что ваше приложение логики сторожевой собаки находится в *месте, которое отличается от основного местоположения.* Если служба Logic Apps в основном местоположении испытывает проблемы, приложение логики сторожевой собаки может не работать.

Для этой задачи во вторичном месте создайте логическое приложение watchdog, которое выполняет следующие задачи:

1. Запуск на основе фиксированного или запланированного повторения с помощью триггера Recurrence.

   Вы можете установить повторение к значению, которое ниже уровня толерантности для вашей цели времени восстановления (RTO).

1. Например, позвоните в логическое приложение «Логика проверки работоспособности» в основном месте, используя действие HTTP:

<a name="activate-secondary"></a>

### <a name="activate-your-secondary-instance"></a>Активировать вторичный экземпляр

Чтобы автоматически активировать вторичный экземпляр, можно создать логическое приложение, которое вызывает API управления, например [разъем управления ресурсами Azure,](https://docs.microsoft.com/connectors/arm/) чтобы активировать соответствующие логические приложения во вторичном месте. Вы можете расширить приложение watchdog для вызова этого приложения логики активации после определенного количества сбоев.

<a name="collect-diagnostic-data"></a>

## <a name="collect-diagnostic-data"></a>Сбор диагностических сведений

Можно настроить журнал для запуска приложения логики и отправить полученные диагностические данные в такие службы, как Azure Storage, Azure Event Hubs и Azure Log Analytics для дальнейшей обработки и обработки.

* Если вы хотите использовать эти данные с помощью аналитики журналов Azure, вы можете сделать данные доступными как для первичных, так и для вторичных мест, настроив **настройки диагностических настроек** приложения логики и отправку данных в несколько рабочих областей log Analytics. Для получения дополнительной информации [см. Найдите журналы Azure Monitor и соберите данные диагностики для приложений Azure Logic Apps.](../logic-apps/monitor-logic-apps-log-analytics.md)

* Если вы хотите отправить данные в концентраторы хранения данных Azure или Azure Event Hubs, можно сделать данные доступными как для первичных, так и для вторичных мест, настроив геоизбыточность. Дополнительные сведения вы найдете в следующих статьях:<p>

  * [Восстановление аварийного управления хранилищаAzн Blob и сбой в счете](../storage/common/storage-disaster-recovery-guidance.md)
  * [Восстановление геоаварий Azure Event Hubs](../event-hubs/event-hubs-geo-dr.md)

## <a name="next-steps"></a>Следующие шаги

* [Обзор устойчивости для Azure](https://docs.microsoft.com/azure/architecture/framework/resiliency/overview)
* [Контрольный список для обеспечения устойчивости конкретных служб Azure](https://docs.microsoft.com/azure/architecture/checklist/resiliency-per-service)
* [Управление данными для устойчивости в Azure](https://docs.microsoft.com/azure/architecture/framework/resiliency/data-management)
* [Резервное копирование и аварийное восстановление для приложений Azure](https://docs.microsoft.com/azure/architecture/framework/resiliency/backup-and-recovery)
* [Восстановление после прерывания работы служб во всем регионе](https://docs.microsoft.com/azure/architecture/resiliency/recovery-loss-azure-region)
* [Соглашения об уровне службы Майкрософт (SLAs) для служб Azure](https://azure.microsoft.com/support/legal/sla/)
