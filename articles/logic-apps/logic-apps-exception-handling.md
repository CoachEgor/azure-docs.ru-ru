---
title: Обработка ошибок и исключений — Azure Logic Apps
description: Шаблоны обработки ошибок и исключений в Azure Logic Apps
services: logic-apps
ms.service: logic-apps
ms.suite: integration
author: dereklee
ms.author: deli
ms.reviewer: klam, estfan, LADocs
ms.date: 01/31/2018
ms.topic: article
ms.openlocfilehash: 828bea50a66b90f35843901ae2d7c703ffa58f2d
ms.sourcegitcommit: 5f67772dac6a402bbaa8eb261f653a34b8672c3a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/01/2019
ms.locfileid: "70208171"
---
# <a name="handle-errors-and-exceptions-in-azure-logic-apps"></a>Обработка ошибок и исключений в Azure Logic Apps

Способ, которым любая архитектура интеграции должным образом обрабатывает время простоя или проблемы, вызванные зависимыми системами, может создать проблему. Чтобы помочь вам создать надежную и устойчивую интеграцию, корректно обрабатывающую проблемы и сбои, Logic Apps предоставляет эффективные возможности обработки ошибок и исключений. 

<a name="retry-policies"></a>

## <a name="retry-policies"></a>Политики повтора

Для самой простой обработки исключений и ошибок можно использовать *политику повторов* для любого действия или триггера, в котором она поддерживается. Политика повторов указывает, каким образом и повторяет ли действие или триггер запрос, когда истекает время ожидания первоначального запроса или запрос завершается ошибкой, т.е. на запрос дается ответ 408, 429 или 5xx. Если политика повтора не задана, используется политика по умолчанию. 

Ниже приведены типы политик повтора. 

| Тип | Описание | 
|------|-------------| 
| **Default** | Эта политика отправляет до четырех повторных попыток в *экспоненциально увеличивающихся* интервалах, которые масштабируются с шагом в 7,5 секунд, но ограничены между 5 и 45 секундами. | 
| **Экспоненциальный интервал**  | Перед отправкой следующего запроса эта политика ожидает случайного интервала, выбранного из экспоненциально растущего диапазона. | 
| **Фиксированный интервал**  | Эта политика ожидает определенный интервал времени перед отправкой следующего запроса. | 
| **None**  | Повторная отправка запроса не происходит. | 
||| 

Дополнительные сведения об ограничениях политики повтора см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md#request-limits). 

### <a name="change-retry-policy"></a>Изменение политики повтора

Чтобы выбрать другую политику повтора, выполните следующие действия. 

1. Создание приложения логики в Конструкторе приложений логики. 

2. Откройте **Параметры** для действия или триггера.

3. Если действие или триггер поддерживает политику повтора, в разделе **Политика повтора**, выберите нужный тип. 

Или можно вручную задать политику повтора в разделе `inputs` для действия или триггера, который поддерживает политику повтора. Если не указать политику повтора, действие использует политику по умолчанию.

```json
"<action-name>": {
   "type": "<action-type>", 
   "inputs": {
      "<action-specific-inputs>",
      "retryPolicy": {
         "type": "<retry-policy-type>",
         "interval": "<retry-interval>",
         "count": <retry-attempts>,
         "minimumInterval": "<minimum-interval>",
         "maximumInterval": "<maximun-interval>"
      },
      "<other-action-specific-inputs>"
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | Тип | Описание |
|-------|------|-------------|
| <*retry-policy-type*> | String | Необходимый тип политики повтора: `default`, `none`, `fixed` или `exponential` | 
| <*retry-interval*> | String | Интервал повторных попыток, значение которого используется в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Минимальный интервал по умолчанию составляет `PT5S`, а максимальный интервал — `PT1D`. При использовании политики экспоненциального интервала можно указать разные минимальное и максимальное значения. | 
| <*retry-attempts*> | Integer | Количество повторных попыток. Значение должно находиться в диапазоне от 1 до 90. | 
||||

*Необязательный*

| Значение | Type | Описание |
|-------|------|-------------|
| <*minimum-interval*> | String | Минимальный интервал политики экспоненциального интервала для случайно выбранного интервала в [ формате ISO 8601 ](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) | 
| <*maximum-interval*> | String | Максимальный интервал политики экспоненциального интервала для случайно выбранного интервала в [ формате ISO 8601 ](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) | 
|||| 

Ниже приведены дополнительные сведения о различных типах политик.

<a name="default-retry"></a>

### <a name="default"></a>Значение по умолчанию

Если не будет указана политика повтора, действие использует политику по умолчанию, которая на самом деле представляет собой [политику экспоненциального интервала](#exponential-interval), которая отправляет до четырех повторных попыток с экспоненциально растущим интервалом с шагом в 7,5 секунд. Диапазон составляет от 5 до 45 секунд. 

Хотя это явно не определено в действии или триггере, ниже представлена политика по умолчанию на примере действия HTTP.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "http://myAPIendpoint/api/action",
      "retryPolicy" : {
         "type": "exponential",
         "interval": "PT7S",
         "count": 4,
         "minimumInterval": "PT5S",
         "maximumInterval": "PT1H"
      }
   },
   "runAfter": {}
}
```

### <a name="none"></a>Отсутствуют

Чтобы указать, что действие или триггер не повторяет неудавшиеся запросы, задайте параметру <*retry-policy-type*> значение `none`.

### <a name="fixed-interval"></a>Фиксированный интервал

Чтобы указать, что действие или триггер ждет указанного интервала перед отправкой следующего запроса, задайте параметру <*retry-policy-type*> значение `fixed`.

*Пример*

Эта политика повтора пытается два раза получить последние новости после первого сбоя запроса с 30-секундной задержкой между попытками.

```json
"Get_latest_news": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest",
      "retryPolicy": {
         "type": "fixed",
         "interval": "PT30S",
         "count": 2
      }
   }
}
```

<a name="exponential-interval"></a>

### <a name="exponential-interval"></a>Экспоненциальный интервал

Чтобы указать, что действие или триггер ждет случайного интервала перед отправкой следующего запроса, задайте параметру <*retry-policy-type*> значение `exponential`. Случайный интервал выбирается из экспоненциально растущего диапазона. Минимальный и максимальный интервалы по умолчанию также можно переопределить, указав собственные минимальный и максимальный интервалы.

**Диапазон случайных переменных**

В этой таблице показано, как Logic Apps создает универсальную случайную переменную в указанном диапазоне для каждой попытки повтора, включая число повторных попыток.

| Число повторных попыток | Минимальный интервал | Максимальный интервал |
|--------------|------------------|------------------|
| 1 | max(0, <*minimum-interval*>) | min(interval, <*maximum-interval*>) |
| 2 | max(interval, <*minimum-interval*>) | min(2 * interval, <*maximum-interval*>) |
| 3 | max(2 * interval, <*minimum-interval*>) | min(4 * interval, <*maximum-interval*>) |
| 4 | max(4 * interval, <*minimum-interval*>) | min(8 * interval, <*maximum-interval*>) |
| .... | .... | .... | 
|||| 

## <a name="catch-and-handle-failures-with-the-runafter-property"></a>Перехват и обработка ошибок с помощью свойства RunAfter

Каждое действие приложения логики объявляет действия, которые должны завершаться перед началом этого действия. Это похоже на упорядочение действий рабочего процесса. В определении действия этот порядок определяет свойство **runAfter**, которое является объектом, описывающим, какие действия и состояния действий необходимы для выполнения определенного действия.

По умолчанию все действия, добавленные в конструктор приложений логики, выполняются после предыдущего шага, если тот завершился **успешно**. Однако значение **runAfter** можно изменить таким образом, чтобы действия срабатывали, если предыдущие действия получали состояния **Failed** (Сбой), **Skipped** (Пропущено) или оба. Например, чтобы добавить элемент в указанный раздел служебной шины после сбоя определенного действия **Insert_Row**, можно использовать следующий пример определения **runAfter**:

```json
"Send_message": {
    "inputs": {
        "body": {
            "ContentData": "@{encodeBase64(body('Insert_Row'))}",
            "ContentType": "{ \"content-type\" : \"application/json\" }"
        },
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-westus.azure-apim.net/apim/servicebus"
            },
            "connection": {
                "name": "@parameters('$connections')['servicebus']['connectionId']"
            }
        },
        "method": "post",
        "path": "/@{encodeURIComponent('failures')}/messages"
    },
    "runAfter": {
        "Insert_Row": [
            "Failed"
        ]
    }
}
```

Свойство **runAfter** выполняется, если состояние действия **Insert_Row** — **Failed** (Сбой). Чтобы выполнить действие, если состояние действия **Succeeded**, **Failed** или **Skipped**, используйте такой синтаксис:

```json
"runAfter": {
        "Insert_Row": [
            "Failed", "Succeeded", "Skipped"
        ]
    }
```

> [!TIP]
> Действия, успешно завершенные после сбоя предыдущего действия, будут помечены как **Succeeded** (Успешно). Таким образом, если перехватить все ошибки в рабочем процессе, само выполнение помечается как **Succeeded** (Успешно).

<a name="scopes"></a>

## <a name="evaluate-actions-with-scopes-and-their-results"></a>Оценка действия с помощью областей и их результатов

Вы можете сгруппировать действия внутри [области](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md), аналогично тому, как выполняются отдельные действия с помощью свойства **runAfter**. Области позволяют логически группировать действия, получать доступ к общему состоянию области и выполнять действия на основе состояния. После завершения выполнения всех действий в области, она получает собственное состояние. 

Чтобы проверить состояние области, можно использовать те же критерии, что и для проверки состояния выполнения приложения логики, например **Succeeded** (Успешно), **Failed** (Сбой) и т. д. 

По умолчанию, когда все действия области будут выполнены, для состояния области устанавливается значение **Succeeded** (Успешно). Если состояние последнего действия в области — **Failed** (Сбой) или **Aborted** (Прервано), для состояния области устанавливается значение **Failed** (Сбой). 

Для перехвата исключений в области с состоянием **Failed** (Сбой) и выполнения действий, которые обрабатывают эти ошибки, можно использовать свойство **runAfter** для области с состоянием **Failed** (Сбой). Таким образом можно создать отдельное действие для перехвата ошибок, в случае если *какое-либо* действие в области завершилось сбоем и для этой области используется свойство **runAfter**.

Сведения об ограничениях в областях см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md).

<a name="get-results-from-failures"></a>

### <a name="get-context-and-results-for-failures"></a>Получение контекста и результатов ошибок

Хотя перехват ошибок в области очень эффективен, вам также может понадобиться контекст, чтобы понять, какие действия завершились сбоем, и узнать возвращенные ошибки и коды состояния.

[`result()`](../logic-apps/workflow-definition-language-functions-reference.md#result) Функция предоставляет контекст для результатов всех действий в области. `result()` Функция принимает один параметр, который является именем области, и возвращает массив, содержащий все результаты действия из этой области. Эти объекты действий включают те же атрибуты, что `@actions()` и объект, например время начала действия, время окончания, состояние, входы, идентификаторы корреляции и выходные данные. Чтобы отправить контекст для любых действий, завершившихся сбоем в области, можно легко связать `@result()` выражение `runAfter` со свойством.

Чтобы выполнить действие для каждого действия в области с неудачным результатом , а также для фильтрации массива результатов по невыполненным действиям, можно связать `@result()` выражение с действием [**Фильтрация массива**](../connectors/connectors-native-query.md) и цикл [**по каждому**](../logic-apps/logic-apps-control-flow-loops.md) элементу. Можно настроить выполнение действия для каждой ошибки в отфильтрованном массиве результатов, используя цикл **Foreach**.

Вот пример с подробным объяснением, которое отправляет HTTP-запрос POST, для которого будут возвращены завершившиеся сбоем действия в области My_Scope.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": "@result('My_Scope')",
      "where": "@equals(item()['status'], 'Failed')"
   },
   "runAfter": {
      "My_Scope": [
         "Failed"
      ]
    }
},
"For_each": {
   "type": "foreach",
   "actions": {
      "Log_exception": {
         "type": "Http",
         "inputs": {
            "method": "POST",
            "body": "@item()['outputs']['body']",
            "headers": {
               "x-failed-action-name": "@item()['name']",
               "x-failed-tracking-id": "@item()['clientTrackingId']"
            },
            "uri": "http://requestb.in/"
         },
         "runAfter": {}
      }
   },
   "foreach": "@body('Filter_array')",
   "runAfter": {
      "Filter_array": [
         "Succeeded"
      ]
   }
}
```

Подробно рассмотрим приведенный выше пример.

1. Для получения результатов из всех действий в области My_Scope, действие **Filter_array** использует выражение фильтра `@result('My_Scope')`.

2. Условием отбора для действия **Filter_array** является любой элемент `@result()` с состоянием **Failed** (Сбой). Это условие фильтрует массив, который имеет все результаты действия от My_Scope до массива только с неудачными результатами.

3. Выполните действия цикла**Foreach** на выходных данных *фильтра массива*. Этот шаг выполняет действие для каждого неудавшегося результата действия, который был ранее отфильтрован.

   Если определенное действие в области завершилось сбоем, действия в цикле **Foreach** выполняются только один раз. 
   Многие завершившиеся сбоем действия приведут к выполнению только одного действия на сбой.

4. Затем отправляется HTTP-запрос POST для текста ответа элемента **Foreach**, который является выражением `@item()['outputs']['body']`. 

   Формат элемента `@result()` совпадает с форматом `@actions()` и может быть проанализирован одинаково.

5. В код выше включены два пользовательских заголовка с именем завершившегося сбоем действия (`@item()['name']`) и идентификатором отслеживания клиента выполнения со сбоем `@item()['clientTrackingId']`.

Для справки: вот пример одного элемента `@result()`, отображающего свойства **name**, **body** и **clientTrackingId**, которые проанализированы в примере выше. За пределами цикла **Foreach** действие `@result()` возвращает массив этих объектов.

```json
{
   "name": "Example_Action_That_Failed",
   "inputs": {
      "uri": "https://myfailedaction.azurewebsites.net",
      "method": "POST"
   },
   "outputs": {
      "statusCode": 404,
      "headers": {
         "Date": "Thu, 11 Aug 2016 03:18:18 GMT",
         "Server": "Microsoft-IIS/8.0",
         "X-Powered-By": "ASP.NET",
         "Content-Length": "68",
         "Content-Type": "application/json"
      },
      "body": {
         "code": "ResourceNotFound",
         "message": "/docs/folder-name/resource-name does not exist"
      }
   },
   "startTime": "2016-08-11T03:18:19.7755341Z",
   "endTime": "2016-08-11T03:18:20.2598835Z",
   "trackingId": "bdd82e28-ba2c-4160-a700-e3a8f1a38e22",
   "clientTrackingId": "08587307213861835591296330354",
   "code": "NotFound",
   "status": "Failed"
}
```

Выражения, описанные в этой статье, можно использовать для выполнения различных шаблонов обработки исключений. Вы можете настроить выполнение одного действия обработки исключений вне области, которое принимает весь отфильтрованный массив сбоев, и удалить действие **Foreach**. Можно также включить другие полезные свойства из  **\@ответа Result ()** , как описано выше.

## <a name="azure-diagnostics-and-metrics"></a>Диагностика и метрики Azure

Приведенные выше шаблоны — эффективный способ обработки ошибок и исключений в выполнении. Однако можно также обнаруживать отдельные ошибки и реагировать на них независимо от выполнения. 
[Система диагностики Azure](../logic-apps/logic-apps-monitor-your-logic-apps.md) предоставляет простой способ отправки всех событий рабочего процесса, включая все состояния выполнений и действий, в учетную запись хранения Azure или в концентратор событий, созданный в службе "Центры событий Azure". 

Вы можете отслеживать журналы и метрики или публиковать их в любом средстве мониторинга для оценки состояния выполнения. К примеру, можно направлять поток всех событий через Центры событий в [Azure Stream Analytics](https://azure.microsoft.com/services/stream-analytics/). В Stream Analytics можно написать активные запросы для получения сведений об отклонении на основе средних показателей или сбоев из журналов диагностики. Stream Analytics можно использовать для отправки информации в другие источники данных, такие как очереди, разделы, SQL, Azure Cosmos DB или Power BI.

## <a name="next-steps"></a>Следующие шаги

* [Сценарий обработки исключений и ведения журнала ошибок для приложений логики](../logic-apps/logic-apps-scenario-error-and-exception-handling.md)
* [Примеры использования Logic Apps и распространенные сценарии](../logic-apps/logic-apps-examples-and-scenarios.md)

<!-- References -->
[retryPolicyMSDN]: https://docs.microsoft.com/rest/api/logic/actions-and-triggers#Anchor_9
