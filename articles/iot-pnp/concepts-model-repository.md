---
title: Основные понятия репозитория модели устройств | Документация Майкрософт
description: Как разработчику решения или ИТ-специалисту вы узнаете об основных понятиях репозитория модели устройств.
author: rido-min
ms.author: rmpablos
ms.date: 09/30/2020
ms.topic: conceptual
ms.service: iot-pnp
services: iot-pnp
ms.openlocfilehash: 78accf9009e532b4f254bf1b96c9fe269815b8af
ms.sourcegitcommit: 2c586a0fbec6968205f3dc2af20e89e01f1b74b5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/14/2020
ms.locfileid: "92019177"
---
# <a name="device-model-repository"></a>Хранилище моделей устройств

Хранилище моделей устройств (ДМР) позволяет построителям устройств управлять моделями устройств IoT Plug and Play и предоставлять к ним общий доступ. Модели устройств — это документы JSON LD, определенные с помощью [языка двойников моделирования Digital (дтдл)](https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md).

ДМР определяет шаблон для хранения интерфейсов ДТДЛ в структуре папок на основе идентификатора модели двойникаа устройства (ДТМИ). Для поиска интерфейса в ДМР можно преобразовать ДТМИ в относительный путь. Например, `dtmi:com:example:Thermostat;1` дтми преобразуется в `/dtmi/com/example/thermostat-1.json` .

## <a name="public-device-model-repository"></a>Хранилище общих моделей устройств

Корпорация Майкрософт размещает общедоступный ДМР со следующими характеристиками:

- Проверенные модели. Корпорация Майкрософт изучает и утверждает все доступные интерфейсы с помощью открытого рабочего процесса по проверке запросов на GitHub.
- Неизменяемости.  После публикации интерфейс не может быть обновлен.
- Масштабирование на основе Hyper-Scale. Корпорация Майкрософт предоставляет всю необходимую инфраструктуру для создания безопасной и высокой масштабируемой конечной точки.

## <a name="custom-device-model-repository"></a>Хранилище настраиваемых моделей устройств

Один и тот же шаблон ДМР можно использовать на любых носителях, таких как локальная файловая система или пользовательские веб-серверы HTTP, для создания настраиваемого ДМР. Модели из пользовательского ДМР можно получить так же, как и из общедоступной DRM, просто изменив базовый URL-адрес, используемый для доступа к ДМР.

> [!NOTE]
> Средства, используемые для проверки моделей в общедоступной ДМР, можно повторно использовать в пользовательских репозиториях.

## <a name="public-models"></a>Открытые модели

Общедоступные модели Digital двойника, хранящиеся в репозитории модели, доступны всем пользователям для использования и интеграции в своих приложениях. Общедоступные модели позволяют разработчикам устройств и сборщикам решений совместно использовать и повторно использовать свои модели устройств IoT Plug and Play.

Инструкции по публикации модели в репозитории модели, чтобы сделать ее общедоступной, см. в разделе [Публикация модели](#publish-a-model) .

Пользователи могут просматривать, искать и просматривать открытые интерфейсы из официального [репозитория GitHub](https://github.com/Azure/iot-plugandplay-models).

Все интерфейсы в `dtmi` папках также доступны из общедоступной конечной точки. [https://devicemodels.azure.com](https://devicemodels.azure.com)

### <a name="resolve-models"></a>Разрешение моделей

Для программного доступа к этим интерфейсам необходимо преобразовать дтми в относительный путь, который можно использовать для запроса общедоступной конечной точки. В следующем примере кода показано, как это сделать:

Чтобы преобразовать ДТМИ в абсолютный путь, мы используем `DtmiToPath` функцию с `IsValidDtmi` :

```cs
static string DtmiToPath(string dtmi)
{
    if (!IsValidDtmi(dtmi))
    {
        return null;
    }
    // dtmi:com:example:Thermostat;1 -> dtmi/com/example/thermostat-1.json
    return $"/{dtmi.ToLowerInvariant().Replace(":", "/").Replace(";", "-")}.json";
}

static bool IsValidDtmi(string dtmi)
{
    // Regex defined at https://github.com/Azure/digital-twin-model-identifier#validation-regular-expressions
    Regex rx = new Regex(@"^dtmi:[A-Za-z](?:[A-Za-z0-9_]*[A-Za-z0-9])?(?::[A-Za-z](?:[A-Za-z0-9_]*[A-Za-z0-9])?)*;[1-9][0-9]{0,8}$");
    return rx.IsMatch(dtmi);
}
```

С результирующим путем и базовым URL-адресом для репозитория можно получить интерфейс:

```cs
const string _repositoryEndpoint = "https://devicemodels.azure.com";

string dtmiPath = DtmiToPath(dtmi.ToString());
string fullyQualifiedPath = $"{_repositoryEndpoint}{dtmiPath}";
string modelContent = await _httpClient.GetStringAsync(fullyQualifiedPath);
```

## <a name="publish-a-model"></a>Публикация модели

> [!Important]
> Для отправки моделей в общедоступную ДМР необходимо иметь учетную запись GitHub.

1. Разветвление общедоступного репозитория GitHub: [https://github.com/Azure/iot-plugandplay-models](https://github.com/Azure/iot-plugandplay-models) .
1. Клонировать разветвленный репозиторий. При необходимости создайте новую ветвь, чтобы изменения были изолированы от `main` ветви.
1. Добавьте новые интерфейсы в папку, `dtmi` используя соглашение о папках и именах файлов. См. раздел средство [добавления модели](#add-model) .
1. Проверьте модели локально с помощью раздела [скрипты для проверки изменений](#validate-files) .
1. Зафиксируйте изменения локально и отправьте их в вилку.
1. В вилке создайте запрос на включение внесенных изменений в `main` ветвь. См. статью создание документации по [вопросу или запросу на вытягивание](https://docs.github.com/free-pro-team@latest/desktop/contributing-and-collaborating-using-github-desktop/creating-an-issue-or-pull-request) .
1. Проверьте [требования к пр](https://github.com/Azure/iot-plugandplay-models/blob/main/pr-reqs.md).

Запрос на включение внесенных изменений инициирует ряд действий GitHub, которые будут проверять новые отправленные интерфейсы, и убедитесь, что запрос на вытягивание удовлетворяет всем проверкам.

Корпорация Майкрософт ответит на запрос на включение внесенных изменений в течение трех рабочих дней.

### <a name="add-model"></a>Добавление модели

В следующих шагах показано, как сценарий add-model.js помогает добавить новый интерфейс. Для выполнения этого скрипта требуется Node.js:

1. В командной строке перейдите в локальный репозиторий Git.
1. Выполнить `npm install`
1. Выполнить `npm run add-model <path-to-file-to-add>`

Просмотрите выходные данные консоли для любых сообщений об ошибках.

### <a name="local-validation"></a>Локальная проверка

Вы можете выполнять одни и те же проверки локально перед отправкой запроса на вытягивание, чтобы помочь заранее диагностировать проблемы.

#### <a name="validate-files"></a>Validate-Files

`npm run validate-files <file1.json> <file2.json>` проверяет, соответствует ли путь к файлу ожидаемым именам папок и файлов.

#### <a name="validate-ids"></a>Проверка идентификаторов

`npm run validate-ids <file1.json> <file2.json>` проверяет, что все идентификаторы, определенные в документе, используют тот же корень, что и основной идентификатор.

#### <a name="validate-deps"></a>Validate-Deps

`npm run validate-deps <file1.json> <file2.json>` проверяет, доступны ли все зависимости в `dtmi` папке.

#### <a name="validate-models"></a>Validate-Models

Вы можете запустить [образец проверки дтдл](https://github.com/Azure-Samples/DTDL-Validator) для локальной проверки моделей.

## <a name="next-steps"></a>Дальнейшие действия

Следующим шагом является проверка [архитектуры Plug and Play IOT](concepts-architecture.md).
