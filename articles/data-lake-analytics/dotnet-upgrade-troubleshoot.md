---
title: Как устранить неполадки в работе Azure Data Lake Analytics U-S'L из-за обновления .NET Framework 4.7.2
description: Неуборная работа U-S'L из-за обновления до .NET Framework 4.7.2.
services: data-lake-analytics
author: guyhay
ms.author: guyhay
ms.reviewer: jasonwhowell
ms.service: data-lake-analytics
ms.topic: troubleshooting
ms.workload: big-data
ms.date: 10/11/2019
ms.openlocfilehash: f909419810cbd837e57b19a13b2df6ae9ad2ee97
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79213586"
---
# <a name="azure-data-lake-analytics-is-upgrading-to-the-net-framework-v472"></a>Аналитика Azure Data Lake обновляется до рамочной системы .NET v4.7.2

Время выполнения Azure Data Lake Analytics по умолчанию обновляется с .NET Framework v4.5.2 до .NET Framework v4.7.2. Это изменение создает небольшой риск нарушения изменений, если ваш код U-S'L использует пользовательские сборки, а в этих пользовательских сборках используются библиотеки .NET.

Это обновление с .NET Framework 4.5.2 до версии 4.7.2 означает, что рамочная программа .NET, развернутая в времени выполнения U-S'L (время выполнения по умолчанию), теперь всегда будет 4.7.2. Для версий .NET Framework нет опции.NET.

После завершения обновления до .NET Framework 4.7.2 управляемый код системы будет работать как версия 4.7.2, пользовательские библиотеки, такие как пользовательские сборки U-S'L, будут работать в режиме обратного совместимость, соответствующем версии, которую сборка была генерируется для.

- Если сборка DLL сгенерирована для версии 4.5.2, развернутая инфраструктура будет рассматривать их как библиотеки 4.5.2, обеспечивая (за некоторыми исключениями) 4.5.2 семантики.
- Теперь можно использовать пользовательские сборки U-S'SL, которые используют функции версии 4.7.2, если вы нацелите на рамку .NET 4.7.2.

Из-за этого обновления до .NET Framework 4.7.2, есть потенциал, чтобы внести изменения в u-S'L рабочих мест, которые используют .NET пользовательских сборок. Мы предлагаем вам проверить на наличие проблем обратной совместимости, используя процедуру ниже.

## <a name="how-to-check-for-backwards-compatibility-issues"></a>Как проверить наличие проблем обратной совместимости

Проверьте возможность проблем с обратной совместимости, запустив проверку совместимости .NET на коде .NET в пользовательских сборках U-S'L.

> [!Note]
> Инструмент не обнаруживает фактических изменений. он определяет только называемые AIS .NET, которые могут (для определенных входов) вызвать проблемы. Если вас уведомят о проблеме, ваш код все равно может быть в порядке, однако вам следует проверить более подробную информацию.

1. Запустите проверку обратной совместимости на вашем .NET DLLs либо путем
   1. Использование расширения визуальной студии на [.NET Portability Analyzer Visual Studio Extension](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)
   1. Загрузка и использование автономного инструмента от [GitHub dotnetapiport](https://github.com/microsoft/dotnet-apiport). Инструкции для запуска автономного инструмента находятся на [GitHub dotnetapiport нарушение изменений](https://github.com/microsoft/dotnet-apiport/blob/dev/docs/HowTo/BreakingChanges.md)
   1. За 4.7.2. совместимости, `read isRetargeting == True` определяет возможные проблемы.
2. Если инструмент указывает, если ваш код может быть затронут какой-либо из возможных назад-несовместимости (некоторые общие примеры несовместимости перечислены ниже), вы можете дополнительно проверить
   1. Анализ кода и определение того, передается ли ваш код значениям воздействию AIS
   1. Выполните проверку времени выполнения. Развертывание времени выполнения не выполняется бок о бок в ADLA. Вы можете выполнить проверку времени выполнения перед обновлением, используя локальный запуск VisualStudio с локальной рамкой .NET 4.7.2 против репрезентативного набора данных.
3. Если на вас действительно влияет несовместимость назад, примите необходимые меры для ее устранения (например, исправление данных или логика кода).

В большинстве случаев на вас не должна влиять обратная несовместимость.

## <a name="timeline"></a>Временная шкала

Вы можете проверить развертывание нового времени выполнения здесь [Runtime устранения неполадок](runtime-troubleshoot.md), и, глядя на любой предыдущей успешной работы.

### <a name="what-if-i-cant-get-my-code-reviewed-in-time"></a>Что делать, если я не могу вовремя просмотреть код

Вы можете отправить задание в соответствии со старой версией времени выполнения (которая построена ориентиром 4.5.2), однако из-за отсутствия бок о бок возможностей .NET Framework она будет работать только в режиме совместимости 4.5.2. Из-за такого поведения вы все еще можете столкнуться с некоторыми проблемами совместимости назад.

### <a name="what-are-the-most-common-backwards-compatibility-issues-you-may-encounter"></a>Каковы наиболее распространенные проблемы обратной совместимости, с которыми вы можете столкнуться

Наиболее распространенные назад-несовместимости, что шашка, скорее всего, определить являются (мы создали этот список, запустив шашку на наших собственных внутренних заданий ADLA), какие библиотеки затронуты (обратите внимание: что вы можете назвать библиотеки только косвенно, поэтому важно принять необходимые меры #1, чтобы проверить, если ваши рабочие места затронуты), и возможные действия для исправления. Примечание: Почти во всех случаях для нашей собственной работы, предупреждения оказались ложными срабатываниями из-за узкой природы большинства нарушений изменений.

- Чтобы результирующая задача завершилась, реализация свойства IAsyncResult.CompletedSynchronously должна быть правильной
  - При вызове TaskFactory.FromAsync реализация свойства IAsyncResult.CompletedSynchronously должна быть правильной, чтобы результирующая задача завершилась. То есть свойство должно возвращать значение true, если (и только если) реализация завершилась синхронно. Раньше свойство не проверялось.
  - Затронутые библиотеки: mscorlib, System.Threading.Tasks
  - Предлагаемые действия: Обеспечить TaskFactory.FromAsync возвращается верно правильно

- DataObject.GetData теперь получает данные в кодировке UTF-8
  - Для приложений, предназначенных для NET Framework 4, а также для выполняющихся в .NET Framework 4.5.1 или более ранних версиях, DataObject.GetData получает HTML-данные в виде строки ASCII. В результате символы, не являющиеся ASCII (символы, чьи коды ASCII больше 0x7F) представлены двумя случайными символами.#N #N »Для приложений, которые нацелены `DataObject.GetData` на .NET Framework 4.5 или более поздний срок и работают на .NET Framework 4.5.2, извлекают HTML-форматированные данные как UTF-8, который представляет символы больше, чем 0x7F правильно.
  - Затронутые библиотеки: Glo
  - Предлагаемые действия: Обеспечить получение данных — это формат, который вы хотите

- XmlWriter вызывает недействительные суррогатные пары
  - Для приложений с целевой платформой .NET Framework 4.5.2 или предыдущих версий запись недействительной суррогатной пары с помощью обработки резервного исключения не всегда вызывает исключение. Для приложений с целевой платформой .NET Framework 4.6 попытка записи недействительной суррогатной пары вызывает исключение `ArgumentException`.
  - Затронутые библиотеки: System.Xml, System.Xml.ReaderWriter
  - Предлагаемые действия: Убедитесь, что вы не пишете недействительную суррогатную пару, которая вызовет исключение аргумента

- HtmlTextWriter неправильно отображает элемент `<br/>`
  - Начиная с .NET Framework 4.6, при вызове `HtmlTextWriter.RenderBeginTag()` и `HtmlTextWriter.RenderEndTag()` с элементом `<BR />` правильно вставляется только один `<BR />` (вместо двух).
  - Затронутые библиотеки: System.Web
  - Предлагаемые действия: Убедитесь, что `<BR />` вы вставляете количество вы ожидаете увидеть так не случайное поведение рассматривается в производственной работе

- Был изменен вызов метода CreateDefaultAuthorizationContext с аргументом NULL
  - В .NET Framework 4.6 изменилась реализация AuthorizationContext, возвращаемая вызовом `CreateDefaultAuthorizationContext(IList<IAuthorizationPolicy>)` с нулевым аргументом authorizationPolicies.
  - Затронутые библиотеки: System.IdentityModel
  - Предлагаемые действия: Убедитесь, что вы обрабатываете новое ожидаемое поведение при наличии политики авторизации с нулевым и стойло
  
- RSACng теперь правильно загружает ключи RSA нестандартного размера
  - В версиях .NET Framework до 4.6.2 клиенты с нестандартным размером ключа для сертификатов RSA не могли получить доступ к этим ключам через методы расширения `GetRSAPublicKey()` и `GetRSAPrivateKey()`. A `CryptographicException` с сообщением "Запрошенный размер ключа не поддерживается" брошен. С помощью .NET Framework 4.6.2 эта проблема была исправлена. Аналогичным `RSA.ImportParameters()` образом, и `RSACng.ImportParameters()` теперь работать с `CryptographicException`нестандартными размерами ключов, не бросая 'ы.
  - Затронутые библиотеки: mscorlib, System.Core
  - Предлагаемые действия: Убедитесь, что ключи RSA работают в том виде, в каком они ожидалось

- Более строгие проверки двоеточий в пути
  - В .NET Framework 4.6.2 выполнен ряд изменений для поддержки ранее не поддерживаемых путей (по длине и формату). Исправлены проверки надлежащего синтаксиса разделителя диска (двоеточие), в результате появился побочный эффект в виде блокировки некоторых путей универсального кода ресурса (URI) в некоторых API-интерфейсах пути, где раньше это допускалось.
  - Затронутые библиотеки: mscorlib, System.Runtime.Extensions
  - Предлагаемые действия:

- Вызовы к конструкторам ClaimsIdentity
  - Начиная с .NET Framework 4.6.2 конструкторы `T:System.Security.Claims.ClaimsIdentity` с параметром `T:System.Security.Principal.IIdentity` иначе задают свойство `P:System.Security.Claims.ClaimsIdentify.Actor`. Если аргумент `T:System.Security.Principal.IIdentity` является объектом `T:System.Security.Claims.ClaimsIdentity`, а свойство `P:System.Security.Claims.ClaimsIdentify.Actor` этого объекта `T:System.Security.Claims.ClaimsIdentity` не равно `null`, свойство `P:System.Security.Claims.ClaimsIdentify.Actor` присоединяется с помощью метода `M:System.Security.Claims.ClaimsIdentity.Clone`. В Рамочной 4.6.1 и `P:System.Security.Claims.ClaimsIdentify.Actor` более ранних версиях свойство прикрепляется в качестве существующей ссылки. Из-за этого изменения, начиная с .NET Framework `P:System.Security.Claims.ClaimsIdentify.Actor` 4.6.2, свойство `T:System.Security.Claims.ClaimsIdentity` `P:System.Security.Claims.ClaimsIdentify.Actor` нового объекта не равно `T:System.Security.Principal.IIdentity` свойству аргумента конструктора. В .NET Framework 4.6.1 и более ранних версиях они равны.
  - Затронутые библиотеки: mscorlib
  - Предлагаемые действия: Обеспечить claimsIdentity работает, как ожидалось на новое время выполнения

- Сериализация управляющих символов с помощью DataContractJsonSerializer теперь совместима с ECMAScript версии 6 и 8
  - В рамках .NET 4.6.2 и более ранних версиях DataContractJsonSerializer не выпускал некоторые специальные символы управления, такие как qb, qf и t, таким образом, чтобы это было совместимо со стандартами ECMAScript V6 и V8. Начиная с .NET Framework 4.7 сериализация таких управляющих символов совместима с ECMAScript версий 6 и 8.
  - Затронутые библиотеки: System.Runtime.Serialization.Json
  - Предлагаемые действия: Обеспечить такое же поведение с DataContractJsonSerializer
