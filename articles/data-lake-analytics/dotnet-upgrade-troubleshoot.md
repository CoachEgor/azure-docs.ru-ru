---
title: Устранение неполадок в работе Azure Data Lake Analytics сбоев заданий U-SQL из-за обновления .NET 4.7.2
description: Устранение ошибок заданий U-SQL из-за обновления до .NET 4.7.2.
services: data-lake-analytics
author: guyhay
ms.author: guyhay
ms.reviewer: jasonwhowell
ms.service: data-lake-analytics
ms.topic: troubleshooting
ms.workload: big-data
ms.date: 10/11/2019
ms.openlocfilehash: 851a405e5143ea5bb3a26de76f713914aa4bb569
ms.sourcegitcommit: 359930a9387dd3d15d39abd97ad2b8cb69b8c18b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/06/2019
ms.locfileid: "73648523"
---
# <a name="azure-data-lake-analytics-is-upgrading-to-the-net-framework-v472"></a>Azure Data Lake Analytics выполняется обновление до .NET Framework v 4.7.2

Среда выполнения по умолчанию Azure Data Lake Analytics обновляется с .NET Framework v 4.5.2 до .NET Framework v 4.7.2. Это изменение создает небольшой риск критических изменений, если в коде U-SQL используются пользовательские сборки, и эти пользовательские сборки используют библиотеки .NET.

Это обновление с .NET Framework 4.5.2 до версии 4.7.2 означает, что .NET Framework, развернутые в среде выполнения U-SQL (среда выполнения по умолчанию), теперь всегда будет 4.7.2. Для .NET Framework версий не существует параллельного варианта.

После завершения этого обновления до .NET 4.7.2 управляемый код системы будет работать как версия 4.7.2. пользовательские библиотеки, такие как настраиваемые сборки U-SQL, будут работать в режиме обратной совместимости, подходящем для версии, которая была создана сборкой. предмет.

- Если библиотеки DLL сборки созданы для версии 4.5.2, развернутая платформа будет рассматривать их как библиотеки 4.5.2, предоставляя (с некоторыми исключениями) семантику 4.5.2.
- Теперь вы можете использовать пользовательские сборки U-SQL, которые используют функции версии 4.7.2, если вы нацелены на .NET Framework 4.7.2.

В связи с этим обновлением до .NET 4.7.2 существует возможность внести критические изменения в задания U-SQL, использующие пользовательские сборки .NET. Мы рекомендуем проверить наличие проблем обратной совместимости, используя приведенную ниже процедуру.

## <a name="how-to-check-for-backwards-compatibility-issues"></a>Проверка на наличие проблем обратной совместимости

Проверьте потенциальные проблемы, связанные с обратной совместимостью, выполнив проверки совместимости .NET для кода .NET в пользовательских сборках U-SQL.

> [!Note]
> Средство не обнаруживает фактические критические изменения. Он только определяет вызванные API-интерфейсы .NET, которые могут вызывать проблемы (для определенных входных данных). Если вы получите оповещение о возникшей ошибке, код может быть по-прежнему подойдет, но вы должны просмотреть дополнительные сведения.

1. Запустите средство проверки обратной совместимости для DLL-библиотек .NET с помощью
   1. Использование расширения Visual Studio в [расширении Visual Studio для анализатора переносимости .NET](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)
   1. Загрузка и использование автономного средства из [GitHub дотнетапипорт](https://github.com/microsoft/dotnet-apiport). Инструкции по запуску автономного средства находятся на сайте [GitHub дотнетапипорт критические изменения](https://github.com/microsoft/dotnet-apiport/blob/dev/docs/HowTo/BreakingChanges.md)
   1. Для 4.7.2. совместимость Read Исретаржетинг = = true — это критические изменения.
2. Если средство указывает, может ли код влиять на возможную обратную несовместимость (некоторые распространенные примеры несовместимости перечислены ниже), можно дополнительно проверить
   1. Анализ кода и определение, передает ли ваш код значения затронутым API
   1. Выполните проверку времени выполнения. Развертывание среды выполнения не выполняется параллельно в ADLA. Перед обновлением можно выполнить проверку среды выполнения, используя локальный запуск VisualStudio с локальной .NET Framework 4.7.2 с репрезентативным набором данных.
3. Если вы действительно оказываете влияние на обратную несовместимость, выполните необходимые действия для ее исправления (например, для исправления логики данных или кода).

В большинстве случаев не следует повлиять на обратную несовместимость.

## <a name="timeline"></a>Временная шкала

Вы можете проверить развертывание новой среды выполнения в статье [Устранение неполадок среды выполнения](runtime-troubleshoot.md), а также просмотреть все предыдущие выполненные задания.

### <a name="what-if-i-cant-get-my-code-reviewed-in-time"></a>Что делать, если я не могу просмотреть код вовремя

Вы можете отправить задание относительно старой версии среды выполнения (созданной для 4.5.2), однако из-за отсутствия .NET Framework параллельных возможностей она все равно будет работать только в режиме совместимости 4.5.2. По-прежнему могут возникать некоторые проблемы обратной совместимости из-за такого поведения.

### <a name="what-are-the-most-common-backwards-compatibility-issues-you-may-encounter"></a>Каковы наиболее распространенные проблемы обратной совместимости, которые могут возникнуть

Наиболее распространенная обратная совместимость, которая, вероятно, будет выявлена средством проверки (мы создали этот список, запустив средство проверки на основе собственных внутренних заданий ADLA), на которые повлияли библиотеки (Обратите внимание, что библиотеки можно вызывать только косвенно, поэтому важно, чтобы предпринять необходимые действия #1, чтобы проверить, влияют ли ваши задания), и возможные действия для их устранения. Примечание. почти во всех случаях для собственных заданий предупреждения выдавали ложные срабатывания из-за узких особенностей наиболее критических изменений.

- Свойство IAsyncResult. CompletedSynchronously должно быть правильным для выполнения результирующей задачи
  - При вызове TaskFactory. FromAsync реализация свойства IAsyncResult. CompletedSynchronously должна быть правильной для выполнения результирующей задачи. Это значит, что свойство должно возвращать значение true только в том случае, если реализация завершена синхронно. Ранее свойство не проверялось.
  - Затронутые библиотеки: mscorlib, System. Threading. Tasks
  - Предлагаемое действие: Убедитесь, что TaskFactory. FromAsync правильно возвращает значение true

- DataObject. GetData теперь получает данные в кодировке UTF-8.
  - Для приложений, предназначенных для .NET Framework 4 или работающих на .NET Framework 4.5.1 или более ранних версиях, объект DataObject. GetData получает данные в формате HTML в виде строки ASCII. В результате символы, не входящие в набор ASCII (символы, коды ASCII которых больше 0x7F), представляются двумя случайными символами. #N # #N # для приложений, предназначенных для .NET Framework 4,5 или более поздней версии и выполняемых на .NET Framework 4.5.2, `DataObject.GetData` извлекает данные в формате HTML в формате UTF-8, который правильно представляет символы, превышающие 0x7F.
  - Затронутые библиотеки: гло
  - Предлагаемое действие. Убедитесь, что извлекаемые данные имеют нужный формат.

- XmlWriter вызывает недопустимые суррогатные пары
  - Для приложений, предназначенных для .NET Framework 4.5.2 или предыдущих версий, написание недопустимой суррогатной пары с помощью обработки резервных исключений не всегда приводит к созданию исключения. Для приложений, предназначенных для .NET Framework 4,6, попытка записи недопустимой суррогатной пары вызывает `ArgumentException`.
  - Затронутые библиотеки: System. XML, System. XML. блокировки
  - Предлагаемое действие: Убедитесь, что вы не пишете недопустимую суррогатную пару, которая приведет к исключению аргумента

- HtmlTextWriter неправильно обрабатывает элемент `<br/>`
  - Начиная с .NET Framework 4,6, вызов `HtmlTextWriter.RenderBeginTag()` и `HtmlTextWriter.RenderEndTag()` с элементом `<BR />` будет правильно вставлять только один `<BR />` (а не два).
  - Затронутые библиотеки: System. Web
  - Предлагаемое действие. Убедитесь, что вы вставляете предполагаемый объем `<BR />`, чтобы случайное поведение не проявлялось в рабочем задании.

- Вызов метода createdefaultauthorizationcontext с аргументом null был изменен
  - Реализация AuthorizationContext, возвращенная вызовом `CreateDefaultAuthorizationContext(IList<IAuthorizationPolicy>)` с аргументом нулевым authorizationpolicies с нулевым значением, изменила свою реализацию в .NET Framework 4,6.
  - Затронутые библиотеки: System. IdentityModel
  - Предлагаемое действие: Убедитесь, что вы обрабатываете новое ожидаемое поведение при наличии политики авторизации, имеющей значение null.
  
- RSACng теперь правильно загружает ключи RSA для нестандартного размера ключа
  - В .NET Framework версиях до 4.6.2 Клиенты с нестандартными размерами ключей для сертификатов RSA не могут получить доступ к этим ключам с помощью методов расширения `GetRSAPublicKey()` и `GetRSAPrivateKey()`. Создается `CryptographicException` с сообщением "запрошенный размер ключа не поддерживается". С .NET Framework 4.6.2 Эта проблема исправлена. Аналогично, `RSA.ImportParameters()` и `RSACng.ImportParameters()` теперь работают с нестандартными размерами ключей, не вызывая `CryptographicException`.
  - Затронутые библиотеки: mscorlib, System. Core
  - Предлагаемое действие: Убедитесь, что ключи RSA работают должным образом.

- Проверки двоеточия в пути являются более четкими
  - В .NET Framework 4.6.2 было внесено несколько изменений для поддержки ранее неподдерживаемых путей (как в длине, так и в формате). Проверки правильности синтаксиса разделителя дисков (двоеточие) были сделаны более правильными, в результате чего некоторые пути URI в некоторых API-интерфейсах выбора пути, где они допускают, блокируются, имеют побочный результат.
  - Затронутые библиотеки: mscorlib, System. Runtime. Extensions
  - Предлагаемое действие:

- Вызовы к конструкторам ClaimsIdentity
  - Начиная с .NET Framework 4.6.2, существует изменение того, как `T:System.Security.Claims.ClaimsIdentity` конструкторы с параметром `T:System.Security.Principal.IIdentity` задают свойство `P:System.Security.Claims.ClaimsIdentify.Actor`. Если аргумент `T:System.Security.Principal.IIdentity` является `T:System.Security.Claims.ClaimsIdentity`ным объектом, а свойство `P:System.Security.Claims.ClaimsIdentify.Actor` этого объекта `T:System.Security.Claims.ClaimsIdentity` не `null`, то свойство `P:System.Security.Claims.ClaimsIdentify.Actor` присоединяется с помощью метода `M:System.Security.Claims.ClaimsIdentity.Clone`. В 4.6.1 Framework и более ранних версиях свойство `P:System.Security.Claims.ClaimsIdentify.Actor` присоединяется как существующая ссылка. Из-за этого изменения, начиная с .NET Framework 4.6.2, свойство `P:System.Security.Claims.ClaimsIdentify.Actor` нового объекта `T:System.Security.Claims.ClaimsIdentity` не равно свойству `P:System.Security.Claims.ClaimsIdentify.Actor` аргумента `T:System.Security.Principal.IIdentity` конструктора. В .NET Framework 4.6.1 и более ранних версиях он равен.
  - Затронутые библиотеки: mscorlib
  - Предлагаемое действие: Убедитесь, что ClaimsIdentity работает должным образом в новой среде выполнения

- Сериализация управляющих символов с помощью DataContractJsonSerializer теперь совместима с ECMAScript версии 6 и V8
  - В .NET Framework 4.6.2 и более ранних версиях DataContractJsonSerializer не выполнял сериализацию некоторых специальных управляющих символов, таких как \b, \f и \t, так, как это было совместимо с стандартами ECMAScript версии 6 и V8. Начиная с .NET Framework 4,7 сериализация этих управляющих символов совместима с ECMAScript V6 и V8.
  - Затронутые библиотеки: System. Runtime. Serialization. JSON
  - Предлагаемое действие: обеспечить то же поведение с DataContractJsonSerializer
