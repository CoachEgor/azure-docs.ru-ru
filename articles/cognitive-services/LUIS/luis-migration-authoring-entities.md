---
title: Переход на 3-ролевое сущность, занятая компьютером
titleSuffix: Azure Cognitive Services
description: Разработка версии 3 предоставляет один новый тип сущности, разработанный компьютером объект, а также возможность добавлять связи в сущность, занятую компьютером, и другие сущности или функции приложения.
services: cognitive-services
author: diberry
manager: nitinme
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 12/30/2019
ms.author: diberry
ms.openlocfilehash: b5dbcd9033d9a41e43ea907d043e0c0486b236db
ms.sourcegitcommit: 5925df3bcc362c8463b76af3f57c254148ac63e3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/31/2019
ms.locfileid: "75563837"
---
# <a name="migrate-to-v3-authoring-entity"></a>Переход на v3 Authoring Entity

Разработка версии 3 предоставляет один новый тип сущности, разработанный компьютером объект, а также возможность добавлять связи в сущность, занятую компьютером, и другие сущности или функции приложения.

## <a name="entities-are-decomposable-in-v3"></a>Сущности делимыми в версии 3

Сущности, созданные с помощью API-интерфейсов для создания версии 3, с использованием [API](https://westeurope.dev.cognitive.microsoft.com/docs/services/luis-programmatic-apis-v3-0-preview) или [портала предварительного просмотра](https://preview.luis.ai/)позволяют создавать многоуровневые модели сущностей с родительскими и дочерними элементами. Этот родительский элемент известен как объект, предназначенный для **компьютера** , а дочерние элементы называются **подкомпонентами** сущности, полученной от компьютера.

Каждый подкомпонент — это также сущность, занятая компьютером, но с добавленными параметрами конфигурации ограничений и дескрипторов.

* **Ограничения** — это правила точного соответствия текста, которые гарантируют, что сущность будет извлечена, когда она соответствует правилу. Правило определяется с помощью точной сущности, совпадающей с текстом, в настоящее время: предварительно [созданной сущности](luis-reference-prebuilt-entities.md), [сущности регулярного выражения](reference-entity-regular-expression.md)или [сущности списка](reference-entity-list.md).
* **Дескрипторы** — это [функции](luis-concept-feature.md), такие как списки фраз или сущности, которые используются для строгого обозначения сущности.

Разработка версии 3 предоставляет один новый тип сущности, разработанный компьютером объект, а также возможность добавлять связи в сущность, занятую компьютером, и другие сущности или функции приложения.

## <a name="how-do-these-new-relationships-compare-to-v2-authoring"></a>Как эти новые связи сравниваются с созданием версии 2

Создание иерархических и составных сущностей, а также ролей и функций для выполнения этой же задачи. Поскольку сущности, функции и роли не были явно связаны друг с другом, было сложно понять, как LUIS подразумеваемые связи во время прогнозирования.

В версии 3 связь является явной и спроектирована авторами приложения. Это позволяет разработчику приложения:

* Визуально посмотрите, как LUIS прогнозирует эти связи, в примере фразы продолжительностью
* Проверьте эти связи либо с помощью [интерактивной области теста](luis-interactive-test.md) , либо в конечной точке.
* Использование этих связей в клиентском приложении с помощью хорошо структурированного именованного объекта с именем Nested [. JSON](reference-entity-machine-learned-entity.md)

## <a name="planning"></a>Планирование

Во время миграции учитывайте следующее в плане миграции.

* Создайте резервную копию приложения LUIS и выполните миграцию в отдельном приложении. Одновременное использование приложения V2 и V3 позволяет проверить необходимые изменения и влияние на результаты прогноза.
* Фиксировать текущие метрики успешности прогноза
* Запись текущей информации информационной панели в виде моментального снимка состояния приложения
* Проверка существующих целей, сущностей, списков фраз, шаблонов и пакетных тестов
* Следующие элементы могут быть перенесены **без изменений**.
    * Намерения
    * Сущности
        * Сущность регулярного выражения
        * Сущность списка
    * Возможности
        * Список фраз
* Следующие элементы необходимо перенести **с изменениями**:
    * Сущности
        * Иерархическая сущность
        * Составная сущность
    * Роли — роли можно применять только к сущности, наученной (родительской). Роли нельзя применять к подкомпонентам
    * Пакетные тесты и шаблоны, использующие иерархические и составные сущности

При проектировании плана миграции оставьте время для просмотра окончательных сущностей, полученных после переноса всех иерархических и составных сущностей. Несмотря на то, что после внесения изменений и просмотра результатов пакетного тестирования и прогнозирования JSON, более унифицированный формат JSON может привести к внесению изменений, в то время как прямая миграция будет выполнена по-разному. Это похоже на рефакторинг кода и должен рассматриваться в том же процессе проверки, что и ваша организация.

Если у вас нет пакетных тестов для вашей модели v2 и миграция пакетных тестов в модель v3 в рамках миграции, вы не сможете проверить, как миграция будет влиять на результаты прогнозирования конечных точек.

## <a name="migrating-from-v2-entities"></a>Миграция с сущностей v2

При переходе к модели разработки версии 3 следует подумать о том, как перейти к сущности, в которой были получены компьютеры, и ее подкомпонентам, включая ограничения и дескрипторы.

В следующей таблице перечислены сущности, которые необходимо перенести из v2 в структуру сущностей v3.

|Тип сущности для создания версии 2|V3 создание типа сущности|Пример|
|--|--|--|
|Составная сущность|Сущность, занятая компьютером|[Подробнее](#migrate-v2-composite-entity)|
|Иерархическая сущность|Роль сущности, изученной компьютером|[Подробнее](#migrate-v2-hierarchical-entity)|

## <a name="migrate-v2-composite-entity"></a>Миграция составной сущности v2

Каждый дочерний элемент составного элемента v2 должен быть представлен подкомпонентом сущности, занятой компьютером v3. Если составной дочерний элемент является предварительно созданным, регулярным выражением или сущностью списка, его следует применять как **ограничение** для подкомпонента, представляющего дочерний элемент.

Рекомендации по планированию миграции составной сущности в сущность, занятую компьютером:
* Дочерние сущности нельзя использовать в шаблонах
* Дочерние сущности больше не используются
* Дочерние сущности должны быть помечены, если они не изучены компьютером

### <a name="existing-descriptors"></a>Существующие дескрипторы

Любой список фраз, используемый для увеличения слов в составной сущности, должен применяться в качестве дескриптора для сущности, предназначенной для машинного (родительского), подкомпонента (дочернего) или намерения (если список фраз применим только к одному намерению). Запланируйте Добавление дескриптора в сущность, который он должен значительно увеличить. Не добавляйте дескриптор, который является универсальным для компьютера (родительского), если он будет значительно увеличивать прогноз подкомпонента (дочернего элемента).

### <a name="new-descriptors"></a>Новые дескрипторы

В версии 3 добавьте шаг планирования для вычисления сущностей в качестве возможных дескрипторов для всех сущностей и целей.

### <a name="example-entity"></a>Пример сущности

Эта сущность является только примером. Перенос собственных сущностей может потребовать других рекомендаций.

Рассмотрим составной элемент v2 для изменения `order` пиццы, в котором используется:
* предварительно созданные datetimeV2 для времени доставки
* список фраз для ускорения таких слов, как пицца, круговая диаграмма, круст и перерезание
* список сущностей для обнаружения нагрибы, оливковый, пепперони.

Пример utterance для этой сущности:

`Change the toppings on my pie to mushrooms and delivery it 30 minutes later`

В следующей таблице показана миграция.

|Модели версии 2|Версии 3 модели|
|--|--|
|Сущность родительского компонента с именем `Order`|Сущность, полученная от родительского компьютера с именем `Order`|
|Дочерняя — предварительно созданная datetimeV2|* Перенос предварительно созданной сущности в новое приложение.<br>* Добавьте ограничение на родительский элемент для предварительно созданной datetimeV2.|
|Дочерний объект-список для перекрывающегося списка|* Перенос сущности списка в новое приложение.<br>* Добавьте ограничение на родительский объект для сущности списка.|


## <a name="migrate-v2-hierarchical-entity"></a>Миграция иерархического объекта версии 2

В разработке v2 иерархическая сущность была предоставлена до ролей, существующих в LUIS. Оба объекта обрабатывают одну и ту же цель извлечения сущностей на основе контекста использования. При наличии иерархических сущностей их можно представить как простые сущности с ролями.

В версии 3:
* Роль можно применить к сущности, известной как компьютерная (родительская).
* Роль нельзя применить к каким-либо подкомпонентам.

Эта сущность является только примером. Перенос собственных сущностей может потребовать других рекомендаций.

Рассмотрим иерархическую сущность v2 для изменения `order`пиццы:
* где каждый дочерний элемент определяет изначальное или конечное значение.

Пример utterance для этой сущности:

`Change the topping from mushrooms to olives`

В следующей таблице показана миграция.

|Модели версии 2|Версии 3 модели|
|--|--|
|Сущность родительского компонента с именем `Order`|Сущность, полученная от родительского компьютера с именем `Order`|
|Дочерний элемент иерархии с исходной и окончательной наведением пиццы|* Добавьте роль в `Order` для каждой переустановки.|

## <a name="next-steps"></a>Дальнейшие действия

* [Ресурсы для разработчиков](developer-reference-resource.md)
