---
title: Миграция в машино-изученную сущность V3
titleSuffix: Azure Cognitive Services
description: Авторство V3 предоставляет один новый тип сущности, машино-изученную сущность, наряду с возможностью добавления отношений к машино-изученной сущности и другим объектам или функциям приложения.
services: cognitive-services
author: diberry
manager: nitinme
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 12/30/2019
ms.author: diberry
ms.openlocfilehash: b5dbcd9033d9a41e43ea907d043e0c0486b236db
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "75563837"
---
# <a name="migrate-to-v3-authoring-entity"></a>Миграция в объект V3 Authoring

Авторство V3 предоставляет один новый тип сущности, машино-изученную сущность, наряду с возможностью добавления отношений к машино-изученной сущности и другим объектам или функциям приложения.

## <a name="entities-are-decomposable-in-v3"></a>Сущности разлагаются в V3

Сущности, созданные с помощью AI V3, либо с помощью [AI,](https://westeurope.dev.cognitive.microsoft.com/docs/services/luis-programmatic-apis-v3-0-preview) либо с [помощью портала предварительного просмотра,](https://preview.luis.ai/)позволяют создавать многоуровневую модель сущности с родителем и детьми. Родительский объект известен как **объект, изученный машиной,** а дети — как **подкомпоненты** изученной сущности машины.

Каждый подкомпонент также является машино-изученным объектом, но с дополнительными конфигурациями ограничений и дескрипторов.

* **Ограничения** — это точные правила сопоставления текста, гарантирующие извлечение сущности, когда оно соответствует правилу. Правило определяется точной сущностью, соответствующей тексту, в настоящее время: [заранее построенная сущность,](luis-reference-prebuilt-entities.md) [объект регулярного выражения](reference-entity-regular-expression.md)или [объект списка.](reference-entity-list.md)
* **Дескрипторы** — это [объекты,](luis-concept-feature.md)такие как списки фраз или сущности, которые используются для сильного указания сущности.

Авторство V3 предоставляет один новый тип сущности, машино-изученную сущность, наряду с возможностью добавления отношений к машино-изученной сущности и другим объектам или функциям приложения.

## <a name="how-do-these-new-relationships-compare-to-v2-authoring"></a>Как эти новые отношения по сравнению с V2 авторство

Для выполнения этой же задачи авторство V2 обеспечивало иерархические и составные сущности, а также роли и функции. Поскольку сущности, функции и роли не были явно связаны друг с другом, было трудно понять, как LUIS подразумевал отношения во время предсказания.

С V3, отношения являются явными и разработаны авторами приложения. Это позволяет, как автору приложения,:

* Визуально увидеть, как LUIS предсказывает эти отношения, в примере высказывания
* Тест для этих отношений либо с [интерактивным тестом панели](luis-interactive-test.md) или в конечном пункте
* Используйте эти отношения в клиентском приложении через хорошо структурированный, названный, вложенный [объект .json](reference-entity-machine-learned-entity.md)

## <a name="planning"></a>Планирование

При миграции в плане миграции следует следующее:

* Резервное копирование приложения LUIS и выполнение миграции в отдельном приложении. Доступное приложение V2 и V3 одновременно позволяет проверить требуемые изменения и влияние на результаты прогнозирования.
* Захват текущих показателей успеха прогнозирования
* Захват текущей панели мониторинга как моментальный снимок состояния приложения
* Просмотр существующих намерений, сущностей, списков фраз, шаблонов и пакетных тестов
* Следующие элементы могут быть перенесены **без изменений:**
    * Намерения
    * Сущности
        * Сущность регулярного выражения
        * Сущность списка
    * Компоненты
        * Список фраз
* Следующие элементы должны быть перенесены **с изменениями:**
    * Сущности
        * Иерархическая сущность
        * Составная сущность
    * Роли - роли могут быть применены только к машинно-изученной (родительской) сущности. Роли не могут быть применены к подкомпонентам
    * Пакетные тесты и шаблоны, в которых используются иерархические и составные сущности

При разработке плана миграции оставьте время для проверки конечных объектов, извлеченных из машин, после того, как все иерархические и составные сущности были перенесены. В то время как прямая миграция будет работать, после внесения изменений и просмотра результатов пакетных тестов и прогнозирования JSON, более унифицированный JSON может привести вас к внесению изменений, чтобы окончательная информация, доставленная в приложение на стороне клиента, была организована по-другому. Это похоже на рефакторинг кода и должно рассматриваться с тем же процессом проверки, который есть у вашей организации.

Если для модели V2 не будут назначены пакетные тесты и переносите пакетные тесты на модель V3 в рамках миграции, вы не сможете проверить, как миграция повлияет на результаты прогнозирования конечных точек.

## <a name="migrating-from-v2-entities"></a>Миграция из V2 субъектов

При переходе к модели авторизации V3 следует подумать о том, как перейти к объекту, извлеченной из машины, и к ее подкомпонентам, включая ограничения и дескрипторы.

В следующей таблице отмечается, какие сущности должны перейти от V2 к конструкции сущности V3.

|Тип сущности авторов V2|Тип сущности авторов V3|Пример|
|--|--|--|
|Составная сущность|Машинная ученая сущность|[Подробнее](#migrate-v2-composite-entity)|
|Иерархическая сущность|Роль объектной организации, извлеченной из машин,|[Подробнее](#migrate-v2-hierarchical-entity)|

## <a name="migrate-v2-composite-entity"></a>Мигрировать V2 Композитная сущность

Каждый ребенок композита V2 должен быть представлен подкомпонентом машино-изученного v3 объекта. Если составной ребенок является заранее построенным, регулярным выражением или сущностью списка, это должно применяться в качестве **ограничения** для подкомпонента, представляющего ребенка.

Рассмотрение при планировании переноса композитной сущности в объект, изучаемый машиной:
* Детские сущности не могут быть использованы в шаблонах
* Сущности детей больше не являются общими
* Детские сущности должны быть помечены, если они раньше были немашинно-изученными

### <a name="existing-descriptors"></a>Существующие дескрипторы

Любой список фраз, используемый для повышения слов в составной сущности, должен применяться в качестве дескриптора либо к машинно-изученной (родительской) сущности, ни к сущности субкомпонента (ребенка), либо к намерениям (если список фраз применяется только к одному умыслу). Планируйте добавить дескриптор к объекту, который он должен увеличить наиболее значительно. Не добавляйте дескриптор в общий объем к машино-изученной (родительской) сущности, если он наиболее значительно повысит прогноз субкомпонента (ребенка).

### <a name="new-descriptors"></a>Новые дескрипторы

В авторстве V3 добавьте шаг планирования для оценки сущностей как возможных дескрипторов для всех сущностей и намерений.

### <a name="example-entity"></a>Пример сущности

Эта сущность является только примером. Миграция собственных сущностей может потребовать других соображений.

Рассмотрим композит V2 для `order` изменения пиццы, которая использует:
* предварительно построенный datetimeV2 для времени поставки
* список фраз, чтобы повысить определенные слова, такие как пицца, пирог, коры, и долива
* список сущности для обнаружения начинки, такие как грибы, оливки, пепперони.

Примером высказывания для этой сущности является:

`Change the toppings on my pie to mushrooms and delivery it 30 minutes later`

В следующей таблице показана миграция:

|Модели V2|Модели V3|
|--|--|
|Родитель - Компонентная сущность под названием`Order`|Родитель - Машино-изученная сущность под названием`Order`|
|Ребенок - Заранее построенный datetimeV2|- Мигрировать заранее построенную сущность в новое приложение.<br>- Добавить ограничение на родительский для заранее построенного datetimeV2.|
|Ребенок - список сущности для начинки|- Мигрировать объект списка в новое приложение.<br>Затем добавьте ограничение на родительский объект для сущности списка.|


## <a name="migrate-v2-hierarchical-entity"></a>Мигрировать V2 Иерархическая сущность

В авторе V2 иерархическая сущность была предоставлена до того, как в LUIS существовали роли. Оба служили одной и той же цели извлечения сущностей на основе использования контекста. Если у вас есть иерархические сущности, вы можете думать о них как о простых сущностях с ролями.

В авторе V3:
* Роль может быть применена к машинообразному (родительскому) объекту.
* Роль не может быть применена к каким-либо подкомпонентам.

Эта сущность является только примером. Миграция собственных сущностей может потребовать других соображений.

Рассмотрим иерархическую сущность V2 `order`для изменения пиццы:
* где каждый ребенок определяет либо оригинальную начинку, либо окончательную начинку

Примером высказывания для этой сущности является:

`Change the topping from mushrooms to olives`

В следующей таблице показана миграция:

|Модели V2|Модели V3|
|--|--|
|Родитель - Компонентная сущность под названием`Order`|Родитель - Машино-изученная сущность под названием`Order`|
|Ребенок - Иерархическая сущность с оригинальной и окончательной пиццы долива|Добавляйте роль `Order` для каждой начинки.|

## <a name="next-steps"></a>Дальнейшие действия

* [Ресурсы разработчика](developer-reference-resource.md)
