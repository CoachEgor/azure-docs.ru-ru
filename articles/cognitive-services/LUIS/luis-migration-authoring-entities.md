---
title: Переход на 3-ролевое сущность, занятая компьютером
description: Разработка версии 3 предоставляет один новый тип сущности, разработанный компьютером объект, а также возможность добавлять связи в сущность, занятую компьютером, и другие сущности или функции приложения.
ms.topic: how-to
ms.date: 05/08/2020
ms.openlocfilehash: 79fbe261f597f55ca6caff468d4d5c154a273c42
ms.sourcegitcommit: bb0afd0df5563cc53f76a642fd8fc709e366568b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2020
ms.locfileid: "83593228"
---
# <a name="migrate-to-v3-authoring-entity"></a>Переход на v3 Authoring Entity

Разработка версии 3 предоставляет один новый тип сущности, разработанный компьютером объект, а также возможность добавлять связи в сущность, занятую компьютером, и другие сущности или функции приложения.

## <a name="entities-are-decomposable-in-v3"></a>Сущности делимыми в версии 3

Сущности, созданные с помощью API-интерфейсов для создания версии 3, с использованием [API](https://westeurope.dev.cognitive.microsoft.com/docs/services/luis-programmatic-apis-v3-0-preview) или портала, позволяют создавать многоуровневые модели сущностей с родительскими и дочерними элементами. Этот родительский элемент известен как **сущность** , известная как компьютер, а дочерние элементы называются **подсущностями** сущности, полученной от компьютера.

Каждая подсущность также представляет собой сущность, предназначенную для компьютера, но с дополнительными параметрами конфигурации функций.

* **Обязательные функции** — это правила, которые гарантируют, что сущность извлекается, когда она соответствует функции. Правило определяется требуемой функцией для модели:
    * [Предварительно созданная сущность](luis-reference-prebuilt-entities.md)
    * [Сущность регулярного выражения](reference-entity-regular-expression.md)
    * [Список сущностей](reference-entity-list.md).

## <a name="how-do-these-new-relationships-compare-to-v2-authoring"></a>Как эти новые связи сравниваются с созданием версии 2

Создание иерархических и составных сущностей, а также ролей и функций для выполнения этой же задачи. Поскольку сущности, функции и роли не были явно связаны друг с другом, было сложно понять, как LUIS подразумеваемые связи во время прогнозирования.

В версии 3 связь является явной и спроектирована авторами приложения. Это позволяет разработчику приложения:

* Визуально посмотрите, как LUIS прогнозирует эти связи, в примере фразы продолжительностью
* Проверьте эти связи либо с помощью [интерактивной области теста](luis-interactive-test.md) , либо в конечной точке.
* Использование этих связей в клиентском приложении с помощью хорошо структурированного именованного объекта с именем Nested [. JSON](reference-entity-machine-learned-entity.md)

## <a name="planning"></a>Планирование

Во время миграции учитывайте следующее в плане миграции.

* Создайте резервную копию приложения LUIS и выполните миграцию в отдельном приложении. Одновременное использование приложения V2 и V3 позволяет проверить необходимые изменения и влияние на результаты прогноза.
* Фиксировать текущие метрики успешности прогноза
* Запись текущей информации информационной панели в виде моментального снимка состояния приложения
* Проверка существующих целей, сущностей, списков фраз, шаблонов и пакетных тестов
* Следующие элементы могут быть перенесены **без изменений**.
    * Намерения
    * Сущности
        * Сущность регулярного выражения
        * Сущность списка
    * Компоненты
        * Список фраз
* Следующие элементы необходимо перенести **с изменениями**:
    * Сущности
        * Иерархическая сущность
        * Составная сущность
    * Роли — роли можно применять только к сущности, наученной (родительской). Роли нельзя применять к вложенным сущностям
    * Пакетные тесты и шаблоны, использующие иерархические и составные сущности

При проектировании плана миграции оставьте время для просмотра окончательных сущностей, полученных после переноса всех иерархических и составных сущностей. Несмотря на то, что после внесения изменений и просмотра результатов пакетного тестирования и прогнозирования JSON, более унифицированный формат JSON может привести к внесению изменений, в то время как прямая миграция будет выполнена по-разному. Это похоже на рефакторинг кода и должен рассматриваться в том же процессе проверки, что и ваша организация.

Если у вас нет пакетных тестов для вашей модели v2 и миграция пакетных тестов в модель v3 в рамках миграции, вы не сможете проверить, как миграция будет влиять на результаты прогнозирования конечных точек.

## <a name="migrating-from-v2-entities"></a>Миграция с сущностей v2

При переходе к модели разработки версии 3 следует подумать о том, как перейти к сущности, которая была занята компьютером, а также ее подсущностям и функциям.

В следующей таблице перечислены сущности, которые необходимо перенести из v2 в структуру сущностей v3.

|Тип сущности для создания версии 2|V3 создание типа сущности|Пример|
|--|--|--|
|Составная сущность|Сущность, занятая компьютером|[Подробнее](#migrate-v2-composite-entity)|
|Иерархическая сущность|Роль сущности, изученной компьютером|[Подробнее](#migrate-v2-hierarchical-entity)|

## <a name="migrate-v2-composite-entity"></a>Миграция составной сущности v2

Каждый дочерний элемент составного элемента v2 должен быть представлен подсущностью сущности, занятой компьютером v3. Если составной дочерний элемент является предварительно созданным, регулярным выражением или сущностью списка, его следует применять в качестве обязательной функции для подсущности.

Рекомендации по планированию миграции составной сущности в сущность, занятую компьютером:
* Дочерние сущности нельзя использовать в шаблонах
* Дочерние сущности больше не используются
* Дочерние сущности должны быть помечены, если они не изучены компьютером

### <a name="existing-features"></a>Существующие компоненты

Любой список фраз, используемый для повышения слов в составной сущности, должен применяться как компонент для сущности, предназначенной для организации (родительской), сущности (дочерней) или намерение (если список фраз применим только к одному намерению). Запланируйте Добавление компонента в сущность, где она должна существенно повыситься. Не добавляйте функцию в универсальную (родительскую) сущность, если она будет значительно увеличивать прогноз подсущности (дочерней).

### <a name="new-features"></a>Новые функции

В версии 3 добавьте шаг планирования для вычисления сущностей в качестве возможных функций для всех сущностей и целей.

### <a name="example-entity"></a>Пример сущности

Эта сущность является только примером. Перенос собственных сущностей может потребовать других рекомендаций.

Рассмотрим составной элемент v2 для изменения пиццы `order` , использующей:
* предварительно созданные datetimeV2 для времени доставки
* список фраз для ускорения таких слов, как пицца, круговая диаграмма, круст и перерезание
* список сущностей для обнаружения нагрибы, оливковый, пепперони.

Пример utterance для этой сущности:

`Change the toppings on my pie to mushrooms and delivery it 30 minutes later`

В следующей таблице показана миграция.

|Модели версии 2|Версии 3 модели|
|--|--|
|Сущность родительского компонента с именем`Order`|Сущность, полученная от родительского компьютера с именем`Order`|
|Дочерняя — предварительно созданная datetimeV2|* Перенос предварительно созданной сущности в новое приложение.<br>* Добавьте необходимый компонент на родительский элемент для предварительно созданной datetimeV2.|
|Дочерний объект-список для перекрывающегося списка|* Перенос сущности списка в новое приложение.<br>* Затем добавьте необходимый компонент в родительский объект для сущности списка.|


## <a name="migrate-v2-hierarchical-entity"></a>Миграция иерархического объекта версии 2

В разработке v2 иерархическая сущность была предоставлена до ролей, существующих в LUIS. Оба объекта обрабатывают одну и ту же цель извлечения сущностей на основе контекста использования. При наличии иерархических сущностей их можно представить как простые сущности с ролями.

В версии 3:
* Роль можно применить к сущности, известной как компьютерная (родительская).
* Роль нельзя применить к любым вложенным сущностям.

Эта сущность является только примером. Перенос собственных сущностей может потребовать других рекомендаций.

Рассмотрим иерархическую сущность v2 для изменения пиццы `order` :
* где каждый дочерний элемент определяет изначальное или конечное значение.

Пример utterance для этой сущности:

`Change the topping from mushrooms to olives`

В следующей таблице показана миграция.

|Модели версии 2|Версии 3 модели|
|--|--|
|Сущность родительского компонента с именем`Order`|Сущность, полученная от родительского компьютера с именем`Order`|
|Дочерний элемент иерархии с исходной и окончательной наведением пиццы|* Добавьте роль для `Order` каждой переустановки.|

## <a name="api-change-constraint-replaced-with-required-feature"></a>Ограничение на изменение API заменено требуемой функцией

Это изменение было внесено в мае 2020 на Конференции//Build и относится только к API-интерфейсам разработки версии 3, где приложение использует ограниченную функцию. Если выполняется миграция с создания версии 2 на v3 или не используются ограниченные функции v3, пропустите этот раздел.

**Функциональность** — возможность требовать существующую сущность в качестве функции для другой модели и извлекать эту модель только при обнаружении сущности. Функциональность не изменилась, но API и терминология изменились.

|Предыдущая терминология|Новая терминология|
|--|--|
|`constrained feature`<br>`constraint`<br>`instanceOf`|`required feature`<br>`isRequired`|

#### <a name="automatic-migration"></a>Автоматическая миграция

Начиная с **19 2020 июня**вы не сможете создавать ограничения программным способом с помощью предыдущего API-интерфейса, который предоставлял эту функциональность.

Все существующие функции ограничений будут автоматически перенесены на обязательный флаг компонента. Программные изменения не требуются для API-интерфейса прогнозирования, и в результате не изменяется качество точности прогноза.

#### <a name="luis-portal-changes"></a>Изменения на портале LUIS

На портале предварительной версии LUIS эта функция указана как **ограничение**. Текущий портал LUIS назначает эту функцию **обязательной**.

#### <a name="previous-authoring-api"></a>Предыдущий API разработки

Эта функция была применена в предварительном просмотре **[Создание дочернего API](https://westus.dev.cognitive.microsoft.com/docs/services/luis-programmatic-apis-v3-0-preview/operations/5d86cf3c6a25a45529767d77)** в качестве части определения сущности с помощью `instanceOf` свойства дочернего объекта сущности:

```json
{
    "name" : "dayOfWeek",
    "instanceOf": "datetimeV2",
    "children": [
        {
           "name": "dayNumber",
           "instanceOf": "number",
           "children": []
        }
    ]
}
```

#### <a name="new-authoring-api"></a>Новый API разработки

Теперь эта функция применяется с **[API связи возможностей добавления сущностей](https://westus.dev.cognitive.microsoft.com/docs/services/luis-programmatic-apis-v3-0-preview/operations/5d9dc1781e38aaec1c375f26)** с помощью `featureName` свойств и `isRequired` . Значением `featureName` свойства является имя модели.

```json
{
    "featureName": "YOUR-MODEL-NAME-HERE",
    "isRequired" : true
}
```


## <a name="next-steps"></a>Дальнейшие действия

* [Ресурсы для разработчиков](developer-reference-resource.md)
