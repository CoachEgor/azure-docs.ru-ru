---
title: Проектирование с моделями — LUIS
titleSuffix: Azure Cognitive Services
description: Понимание языка предоставляет несколько типов моделей. Некоторые модели могут использоваться несколькими способами.
services: cognitive-services
author: diberry
manager: nitinme
ms.custom: seodec18
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 10/25/2019
ms.author: diberry
ms.openlocfilehash: 4cbca96ed95167615f3ff2876e27e546d08d92f5
ms.sourcegitcommit: c22327552d62f88aeaa321189f9b9a631525027c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/04/2019
ms.locfileid: "73507718"
---
# <a name="design-with-intent-and-entity-models"></a>Проектирование с намерениями и моделями сущностей 

Понимание языка предоставляет несколько типов моделей. Некоторые модели могут использоваться несколькими способами. 

## <a name="v3-authoring-uses-machine-teaching"></a>3\. Разработка с использованием машинного обучения

LUIS позволяет людям легко обучать концепцию для компьютера. Затем компьютер может создавать модели (функциональные приближения концепций, такие как классификаторы и средства извлечения), которые можно использовать для интеллектуальных приложений. Хотя LUIS работает на базе машинного обучения, знание машинного обучения необязательно для использования. Вместо этого преподаватели машин обмениваются концепциями с LUIS, отображая положительные и отрицательные примеры концепции и объясняя, как концепция должна моделироваться с помощью других связанных концепций. Преподаватели также могут улучшить модель LUIS в интерактивном режиме, определяя и исправляя ошибки прогнозирования. 

## <a name="v3-authoring-model-decomposition"></a>V3. декомпозиция модели разработки

LUIS поддерживает _декомпозицию модели_ с помощью API-интерфейсов разработки v3, разбивая модель на более мелкие части. Это позволяет создавать модели с уверенностью в том, как создаются и прогнозируется различные части.

Декомпозиция модели состоит из следующих частей.

* [Intents](#intents-classify-utterances)
    * [дескрипторы](#descriptors-are-features) , предоставляемые компонентами
* [сущности, изученные компьютером](#machine-learned-entities)
    * [подкомпоненты](#entity-subcomponents-help-extract-data) (также сущности, изученные компьютером)
        * [дескрипторы](#descriptors-are-features) , предоставляемые компонентами 
        * [ограничения](#constraints-are-text-rules) , предоставляемые неизвестными для компьютера сущностями, такими как (регулярные выражения и списки)

## <a name="v2-authoring-models"></a>Модели разработки версии 2

LUIS поддерживает составные сущности с помощью API-интерфейсов создания v2. Это обеспечивает подобную декомпозицию модели, но не то же самое, что декомпозиция модели v3. Рекомендуемой архитектурой модели является переход к декомпозиции модели в API-интерфейсах разработки версии 3. 

## <a name="intents-classify-utterances"></a>Фразы продолжительностью классификация

Цель классифицирует пример фразы продолжительностью, чтобы обучить LUIS о намерениях. Пример фразы продолжительностью в намерении используется как положительные примеры utterance. Эти же фразы продолжительностью используются как отрицательные примеры во всех других случаях.

Рассмотрим приложение, которое должно определить намерение пользователя заказать книгу и приложение, которому требуется адрес доставки для клиента. Это приложение имеет два целей: `OrderBook` и `ShippingLocation`.

Следующий utterance является **положительным примером** для `OrderBook` намерения и **отрицательного примера** для `ShippingLocation` и `None`ных целей: 

`Buy the top-rated book on bot architecture.`

Результат хорошо спроектированных целей с примером фразы продолжительностью — это прогноз с высоким смыслом. 

## <a name="entities-extract-data"></a>Сущности, извлекают данные

Сущность представляет собой единицу данных, которые необходимо извлечь из utterance. 

### <a name="machine-learned-entities"></a>Сущности, изученные компьютером

Сущность, занятая компьютером, — это сущность верхнего уровня, содержащая подкомпоненты, которые также являются сущностями, предназначенными для компьютера. 

**Использовать сущность, занятую компьютером**:

* Если для клиентского приложения требуются подкомпоненты
* чтобы помочь алгоритму машинного обучения разбивать сущности

Каждый вспомогательный компонент может иметь следующее:

* вспомогательных компонентов
* ограничения (сущность или сущность со списком регулярных выражений)
* дескрипторы (такие функции, как список фраз) 

Примером сущности, занятой компьютером, является заказ на самолет. По сути, это одна транзакция с несколькими меньшими единицами данных, такими как дата, время, количество рабочих мест, тип рабочего места, например первый класс или обучение, расположение источника, целевое расположение и вариант еды.


### <a name="entity-subcomponents-help-extract-data"></a>Подкомпоненты сущности помогают извлекать данные

Подкомпонент — это Дочерняя сущность, предназначенная для компьютера в рамках родительской сущности, занятой компьютером. 

**Используйте подкомпонент для**:

* разложения частей сущности, занятой компьютером (родительской сущности).

Ниже приведена сущность, занятая компьютером, со всеми этими отдельными фрагментами данных:

* Травелордер (сущность, занятая компьютером)
    * DateTime (предварительно созданный datetimeV2)
    * Расположение (сущность, занятое компьютером)
        * Источник (роль найдена в контексте, например `from`)
        * Назначение (роль найдено в контексте, например `to`)
    * Участников (сущность, занятая компьютером)
        * Количество (предварительно построенный номер)
        * Качество (сущность, занятая компьютером с дескриптором списка фраз)
    * Питание (сущность, занятое компьютером, с ограничением сущности List в качестве вариантов продуктов)

Некоторые из этих данных, такие как исходное расположение и целевое расположение, должны быть получены из контекста utterance, например, с такими словами, как `from` и `to`. Другие части данных можно извлечь с помощью точных совпадений строк (`Vegan`) или предварительно созданных сущностей (geographyV2 `Seattle` и `Cairo`). 

Вы разрабатываете, как данные сопоставляются и извлекаются с помощью выбранных моделей и их настройки.

### <a name="constraints-are-text-rules"></a>Ограничения — текстовые правила

Ограничение — это правило сопоставления текста, предоставляемое не используемым компьютером объектом, например сущность регулярного выражения или сущность списка. Ограничение применяется во время прогнозирования, чтобы ограничить прогноз и предоставить разрешение сущности, необходимое клиентскому приложению. Эти правила определяются при создании подкомпонента. 

**Использовать ограничение**:
* Если вы точно узнаете точный текст для извлечения.

К ограничениям относятся:

* сущности [регулярных выражений](reference-entity-regular-expression.md)
* [список](reference-entity-list.md) сущностей 
* предварительно [созданные](luis-reference-prebuilt-entities.md) сущности

Продолжая работу с примером билета плоскости, коды аэропорта могут находиться в сущности списка для точного совпадения текста. 

Для списка аэропорта запись списка для Сиэтл — это название города, `Seattle`, а синонимы для Сиэтл включают код аэропорта для Сиэтле вместе с окружающими городам и городами:

|`Seattle` список синонимов сущностей|
|--|
|`Sea`|
|`seatac`|
|`Bellevue`|

Если вы хотите распознать только 3 буквенных кода для кодов аэропорта, используйте в качестве ограничения регулярное выражение. 

`/^[A-Z]{3}$/`

## <a name="intents-versus-entities"></a>Целей и сущностей

Намерением является желаемый результат _всей_ utterance, а сущности — фрагменты данных, извлеченных из utterance. Обычно способы работы связаны с действиями, которые должно предпринять клиентское приложение, а сущности — информацией, необходимой для выполнения этого действия. С точки зрения программирования, цель вызывала вызов метода, а сущности будут использоваться в качестве параметров для вызова этого метода.

Эта utterance _должна_ иметь намерение и _может_ иметь сущности:

`Buy a airline ticket from Seattle to Cairo`

У этого utterance одна цель:

* Приобретение билета на плоскость

Этот utterance _может_ иметь несколько сущностей:

* Расположения в Сиэтле (источник) и Каиро (назначение)
* Количество одного билета

## <a name="descriptors-are-features"></a>Дескрипторы — это функции

Дескриптор — это функция, применяемая к модели во время обучения, включая списки фраз и сущности. 

**Используйте дескриптор, если хотите**:

* увеличение значимости слов и фраз, определяемых дескриптором
* LUIS рекомендовать новый текст или фразы, чтобы рекомендовать этот дескриптор
* Исправление ошибки для обучающих данных

## <a name="next-steps"></a>Дальнейшие действия

* Понимание [целей](luis-concept-intent.md) и [сущностей](luis-concept-entity-types.md). 