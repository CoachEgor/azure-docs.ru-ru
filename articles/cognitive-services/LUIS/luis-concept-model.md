---
title: Дизайн с моделями - LUIS
titleSuffix: Azure Cognitive Services
description: Понимание языка обеспечивает несколько типов моделей. Некоторые модели могут быть использованы более чем одним способом.
services: cognitive-services
author: diberry
manager: nitinme
ms.custom: seodec18
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 10/25/2019
ms.author: diberry
ms.openlocfilehash: d721ceb25b3ce2408563a0bed16457d05affe7b4
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79219998"
---
# <a name="design-with-intent-and-entity-models"></a>Дизайн с моделями намерения и сущности 

Понимание языка обеспечивает несколько типов моделей. Некоторые модели могут быть использованы более чем одним способом. 

## <a name="v3-authoring-uses-machine-teaching"></a>V3 Авторинг использует машинное обучение

LUIS позволяет людям легко учить концепции машины. Затем машина может создавать модели (функциональные приближения таких понятий, как классификаторы и экстракторы), которые могут быть использованы для питания интеллектуальных приложений. В то время как LUIS питается от машинного обучения, понимание машинного обучения не является необходимым для его использования. Вместо этого учителя машин сообщают концепции LUIS, показывая положительные и отрицательные примеры концепции и объясняя, как концепция должна быть смоделирована с использованием других связанных понятий. Преподаватели также могут улучшить модель LUIS в интерактивном режиме, выявляя и исправляя ошибки прогнозирования. 

## <a name="v3-authoring-model-decomposition"></a>Разложение модели V3

LUIS поддерживает _разложение модели_ с помощью AI V3, разбивая модель на более мелкие части. Это позволяет строить модели с уверенностью в том, как различные части построены и предсказаны.

Разложение модели имеет следующие части:

* [Намерений](#intents-classify-utterances)
    * [дескрипторы,](#descriptors-are-features) предоставляемые функциями
* [машино-изученных сущностей](#machine-learned-entities)
    * [подкомпоненты](#entity-subcomponents-help-extract-data) (также машино-изученные сущности)
        * [дескрипторы,](#descriptors-are-features) предоставляемые функциями 
        * [ограничения,](#constraints-are-text-rules) предоставляемые немашино-изученных сущностей, таких как регулярные выражения и списки

## <a name="v2-authoring-models"></a>V2 Авторинговые модели

LUIS поддерживает композитные сущности с помощью AA- иАЗА V2. Это обеспечивает аналогичное разложение модели, но не то же самое, что разложение модели V3. Рекомендуемая архитектура модели заключается в переходе к разложению модели в AI- авторах V3. 

## <a name="intents-classify-utterances"></a>Намерения классифицируют высказывания

Намерение классифицирует пример высказываний, чтобы научить LUIS о намерениях. Примеры высказываний в пределах намерения используются в качестве положительных примеров высказывания. Эти же высказывания используются в качестве негативных примеров во всех других намерениях.

Рассмотрим приложение, которое должно определить намерение пользователя заказать книгу и приложение, которое нуждается в адресе доставки для клиента. Это приложение имеет два `OrderBook` `ShippingLocation`намерения: и .

Следующее высказывание является положительным `OrderBook` **примером** для намерения и `None` **негативным примером** для намерений и намерений: `ShippingLocation` 

`Buy the top-rated book on bot architecture.`

Результатом хорошо продуманных намерений, с их примером высказываний, является предсказание высокого намерения. 

## <a name="entities-extract-data"></a>Сущности извлекают данные

Сущность представляет единицу данных, которые вы хотите извлечь из высказывания. 

### <a name="machine-learned-entities"></a>Машино-изученные образования

Машино-изученная сущность — это сущность верхнего уровня, содержащая подкомпоненты, которые также являются машино-изученным сущностями. 

**Используйте машино-выученную сущность:**

* когда подкомпоненты необходимы клиентским приложением
* помочь алгоритму машинного обучения разложить сущности

Каждый подкомпонент может иметь:

* Подкомпоненты
* ограничения (обычное сущность выражения или объект списка)
* дескрипторы (такие функции, как список фраз) 

Примером объекта, изученного машиной, является заказ на билет на самолет. Концептуально это одна сделка со многими меньшими единицами данных, такими как дата, время, количество мест, тип места, такие как первый класс или тренер, место происхождения, место назначения и выбор еды.


### <a name="entity-subcomponents-help-extract-data"></a>Подкомпоненты сущности помогают извлекать данные

Подкомпонент — это объект, обученный машиной, в рамках компонента, извлеченного из машины. 

**Используйте подкомпонент для:**

* разложить части машино-изученной сущности (родительской сущности).

Ниже представляет собой машино-изученный объект со всеми этими отдельными частями данных:

* TravelOrder (машино-изученная сущность)
    * DateTime (предварительно построенная датаV2)
    * Местоположение (машино-изученная сущность)
        * Происхождение (роль, найденная `from`через контекст, такой как)
        * Направление (роль, найденная `to`через контекст, такой как)
    * Сидения (машино-изученная сущность)
        * Количество (предварительно построенное число)
        * Качество (машинно-изученная сущность с дескриптором списка фраз)
    * Питание (машино-изученная сущность с ограничением сущности списка как выбор продуктов питания)

Некоторые из этих данных, такие как местоположение происхождения и место назначения, следует извлечь из `from` `to`контекста высказывания, возможно, с такой формулировкой, как и . Другие части данных могут быть извлечены с точными совпадениястроки ( )`Vegan`или заранее построенных объектов (географияV2 `Seattle` и `Cairo`). 

Вы проектируете, как данные сопоставляются и извлекаются по тем моделям, которые вы выбираете и как их настраивают.

### <a name="constraints-are-text-rules"></a>Ограничения - это текстовые правила

Ограничение — это правило сопоставления текста, предоставляемое немашинно-изученной сущностью, такой как объект регулярного выражения или сущность списка. Ограничение применяется во время прогнозирования для ограничения прогнозирования и обеспечения разрешения сущности, необходимого клиенту. Эти правила определяются при авторизации подкомпонента. 

**Используйте ограничение:**
* когда вы знаете точный текст для извлечения.

Ограничения включают в себя:

* [регулярные сущности выражения](reference-entity-regular-expression.md)
* [список](reference-entity-list.md) объектов 
* [предварительно построенных](luis-reference-prebuilt-entities.md) объектов

Продолжая пример билета на самолет, коды аэропорта могут быть в сущности списка для точных текстовых совпадений. 

Для списка аэропортов, список вступления в `Seattle` Сиэтле название города, и синонимы Сиэтл включают код аэропорта для Сиэтла наряду с окружающими городами:

|`Seattle`Синонимы сущности списка|
|--|
|`Sea`|
|`seatac`|
|`Bellevue`|

Если вы хотите распознать только 3 буквенные коды для кодов аэропортов, используйте обычное выражение в качестве ограничения. 

`/^[A-Z]{3}$/`

## <a name="intents-versus-entities"></a>Намерения против сущностей

Намерение является желаемым результатом _всего_ высказывания, в то время как сущности являются частями данных, извлеченных из высказывания. Обычно намерения связаны с действиями, которые должно предпринять клиентское приложение, и сущностями являются сведения, необходимые для выполнения этого действия. С точки зрения программирования намерение вызовет вызов метода, а сущности будут использоваться в качестве параметров для вызова этого метода.

Это высказывание _должно_ иметь намерение и _может_ иметь сущности:

`Buy an airline ticket from Seattle to Cairo`

Это высказывание имеет одно намерение:

* Покупка билета на самолет

Это высказывание _может_ иметь несколько сущностей:

* Расположение Сиэтла (происхождение) и Каир (направление)
* Количество одного билета

## <a name="descriptors-are-features"></a>Дескрипторы - это особенности

Дескриптор — это функция, применяемая к модели во время обучения, включая списки фраз и сущности. 

**Используйте дескриптор, когда вы хотите:**

* повысить значимость слов и фраз, определенных дескриптором
* имеют LUIS рекомендовать новый текст или фразы, чтобы рекомендовать для дескриптора
* исправить ошибку на обучаемых данных

## <a name="next-steps"></a>Дальнейшие действия

* Понимание [намерений](luis-concept-intent.md) и [сущностей](luis-concept-entity-types.md). 