---
title: Расширить приложение во время выполнения - LUIS
description: ''
ms.topic: conceptual
ms.date: 04/14/2020
ms.openlocfilehash: c0f9d71f5d89d73d9cdce2a2f646859d8eba3adc
ms.sourcegitcommit: 31ef5e4d21aa889756fa72b857ca173db727f2c3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81538581"
---
# <a name="extend-app-at-prediction-runtime"></a>Расширить приложение во время выполнения прогноза

Схема приложения (модели и функции) обучается и публикуется до конца прогноза. Эта опубликованная модель используется во времени выполнения прогноза. Вы можете передать новую информацию вместе с высказыванием пользователя в время выполнения прогноза, чтобы увеличить прогноз.

Два изменения схемы выполнения прогноза включают в себя:
* [Внешние субъекты](#external-entities)
* [Динамические списки](#dynamic-lists)

<a name="external-entities-passed-in-at-prediction-time"></a>

## <a name="external-entities"></a>Внешние субъекты

Внешние сущности дают приложению LUIS возможность идентифицировать и маркировать объекты во время выполнения, которые могут быть использованы в качестве функций для существующих объектов. Это позволяет использовать ваши собственные отдельные и пользовательские экстракторы сущности перед отправкой запросов в конечную точку прогнозирования. Поскольку это делается в конечном пункте прогнозирования запроса, вам не нужно переучиваться и публиковать модель.

Клиент-приложение предоставляет свой собственный экстрактор сущности, управляя сущностью, сопрягающей и определяющей местоположение в пределах высказывания этого соответствующего объекта, а затем отправляя эту информацию с запросом.

Внешние сущности — это механизм расширения любого типа сущности, при этом используемый в качестве сигналов для других моделей.

Это полезно для сущности, которая имеет данные, доступные только во время выполнения запроса прогноза. Примерами такого типа данных являются постоянно меняющиеся данные или конкретные данные для пользователя. Можно расширить контактную сущность LUIS с внешней информацией из списка контактов пользователя.

Внешние сущности являются частью API авторства V3. Подробнее о [переходе](luis-migration-api-v3.md) на эту версию.

### <a name="entity-already-exists-in-app"></a>Сущность уже существует в приложении

Значение `entityName` для внешнего объекта, передаваемых в конце майн-запросpost, должно уже существовать в подготовленном и опубликованном приложении на момент выполнения запроса. Тип сущности не имеет значения, все типы поддерживаются.

### <a name="first-turn-in-conversation"></a>Первый поворот в разговоре

Рассмотрим первое высказывание в разговоре с чат-ботом, где пользователь вводит следующую неполную информацию:

`Send Hazem a new message`

Запрос от чат-бота к LUIS может передаваться `Hazem` в информации в органе POST о так он непосредственно соответствует как один из контактов пользователя.

```json
    "externalEntities": [
        {
            "entityName":"contacts",
            "startIndex": 5,
            "entityLength": 5,
            "resolution": {
                "employeeID": "05013",
                "preferredContactType": "TeamsChat"
            }
        }
    ]
```

Ответ прогнозирования включает в себя внешнюю сущность, со всеми другими прогнозируемыми сущностями, потому что она определена в запросе.

### <a name="second-turn-in-conversation"></a>Второй поворот в разговоре

Следующее высказывание пользователя в чат-бот использует более расплывчатый термин:

`Send him a calendar reminder for the party.`

В этом повороте разговора, высказывание использует `him` `Hazem`в качестве ссылки на . Разговорный чат-бот, в теле POST, может сопоставить `him` значение сущности, `Hazem`извлеченное из первого высказывания, .

```json
    "externalEntities": [
        {
            "entityName":"contacts",
            "startIndex": 5,
            "entityLength": 3,
            "resolution": {
                "employeeID": "05013",
                "preferredContactType": "TeamsChat"
            }
        }
    ]
```

Ответ прогнозирования включает в себя внешнюю сущность, со всеми другими прогнозируемыми сущностями, потому что она определена в запросе.

### <a name="override-existing-model-predictions"></a>Переопределение существующих прогнозов моделей

Свойство `preferExternalEntities` опций определяет, что если пользователь отправляет внешнюю сущность, которая перекрывается с предсказанной сущностью с тем же именем, LUIS выбирает сущность, передаваемую в модели, или сущность, существующую в модели.

В качестве примера рассмотрим запрос `today I'm free`. LUIS обнаруживает `today` как datetimeV2 со следующим ответом:

```JSON
"datetimeV2": [
    {
        "type": "date",
        "values": [
            {
                "timex": "2019-06-21",
                "value": "2019-06-21"
            }
        ]
    }
]
```

Если пользователь отправляет внешнюю сущность:

```JSON
{
    "entityName": "datetimeV2",
    "startIndex": 0,
    "entityLength": 5,
    "resolution": {
        "date": "2019-06-21"
    }
}
```

Если `preferExternalEntities` настроен `false`на , LUIS возвращает ответ, как если бы внешний объект не был отправлен.

```JSON
"datetimeV2": [
    {
        "type": "date",
        "values": [
            {
                "timex": "2019-06-21",
                "value": "2019-06-21"
            }
        ]
    }
]
```

Если `preferExternalEntities` настроен `true`на, LUIS возвращает ответ, включая:

```JSON
"datetimeV2": [
    {
        "date": "2019-06-21"
    }
]
```



#### <a name="resolution"></a>Решение

_Дополнительное_ `resolution` свойство возвращается в ответ на прогнозирование, что позволяет передавать метаданные, связанные с внешним объектом, а затем получить его обратно в ответ.

Основная цель заключается в расширении заранее построенных сущностей, но она не ограничивается этим типом сущности.

Свойством `resolution` может быть число, строка, объект или массив:

* "Даллас"
* "текст": "значение"
* 12345
* ["a", "b", "c"]

<a name="dynamic-lists-passed-in-at-prediction-time"></a>

## <a name="dynamic-lists"></a>Динамические списки

Динамические списки позволяют расширить существующую обучаемую и опубликованную сущность списка, уже в приложении LUIS.

Используйте эту функцию, когда значения сущности списка должны периодически меняться. Эта функция позволяет расширить уже обученный и опубликованный список сущности:

* Во время запроса конечной точки прогнозирования запроса запроса запроса.
* Для одного запроса.

Сущность списка может быть пустой в приложении LUIS, но она должна существовать. Сущность списка в приложении LUIS не изменяется, но способность прогнозирования в конечной точке расширена и включает до 2 списков с примерно 1000 элементами.

### <a name="dynamic-list-json-request-body"></a>Динамический список JSON запрос тела

Отправить в следующем органе JSON, чтобы добавить новый подсписок с синонимами в `LUIS`список, и предсказать сущность списка для текста, с запросом `POST` прогнозирования запроса:

```JSON
{
    "query": "Send Hazem a message to add an item to the meeting agenda about LUIS.",
    "options":{
        "timezoneOffset": "-8:00"
    },
    "dynamicLists": [
        {
            "listEntity*":"ProductList",
            "requestLists":[
                {
                    "name": "Azure Cognitive Services",
                    "canonicalForm": "Azure-Cognitive-Services",
                    "synonyms":[
                        "language understanding",
                        "luis",
                        "qna maker"
                    ]
                }
            ]
        }
    ]
}
```

Ответ прогнозирования включает в себя сущность этого списка со всеми другими прогнозируемыми сущностями, поскольку он определен в запросе.

## <a name="next-steps"></a>Следующие шаги

* [Оценка прогнозирования](luis-concept-prediction-score.md)
* [Автор изменения API V3](luis-migration-api-v3.md)
