---
title: Типы сущностей
titleSuffix: Language Understanding - Azure Cognitive Services
description: 'Сущности извлекать данные из utterance. Типы сущностей дают предсказуемые извлечения данных. Существует два типа сущностей: результаты обучения компьютера и узнали без машин. Важно знать, какой тип сущности, вы работаете со фразы.'
services: cognitive-services
author: diberry
manager: nitinme
ms.custom: seodec18
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 04/01/2019
ms.author: diberry
ms.openlocfilehash: 7fd9ae3ab1f50dc91118ba11bc357a0f6dc0e771
ms.sourcegitcommit: f6ba5c5a4b1ec4e35c41a4e799fb669ad5099522
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65141042"
---
# <a name="entity-types-and-their-purposes-in-luis"></a>Типы сущностей и их задачи в LUIS

Сущности извлекать данные из utterance. Типы сущностей дают предсказуемые извлечения данных. Существует два типа сущностей: результаты обучения компьютера и узнали без машин. Важно знать, какой тип сущности, вы работаете со фразы. 

## <a name="entity-compared-to-intent"></a>Сущность по сравнению с намерением

Сущность представляет подлежащее извлечению слово или фразу в высказывании. Фраза может содержать много сущностей или вообще ни одной. Клиентское приложение может потребоваться сущности для выполнения своей задачи или используйте в качестве руководства из нескольких вариантов для представления пользователю. 

Сущность:

* Представляет класс, включая коллекцию схожие объекты (места, вещи, людьми, события или концепции). 
* Описывает сведения, относящиеся к объекту intent


Например, в приложение для поиска новостей могут входить такие сущности, как "topic", "source", "keyword" и "publishing date", которые являются ключевыми данными для поиска новостей. В приложении для путешествий с функциями бронирования сущности location, date, airline, travel class и tickets представляют собой ключевые данные для бронирования авиабилетов (связанные с намерением Book flight).

Если сравнивать, намерение представляет предсказание всего высказывания. 

## <a name="entities-help-with-data-extraction-only"></a>Сущности полезны только при извлечении данных.

Сущности помечаются только для извлечения данных, они не используются для прогнозирования намерений.

## <a name="entities-represent-data"></a>Сущности представляют данные

Сущности — это данные, которые требуется извлечь из высказывания. Это может быть имя, дата, название продукта или любая группа слов. 

|Фраза|Сущность|Данные|
|--|--|--|
|Купить 3 билета в Нью-Йорк|Предварительно созданная сущность number<br>Location.Destination|3<br>Нью-Йорк|
|Купить билет из Нью-Йорка в Лондон на 5 марта|Location.Origin<br>Location.Destination<br>Предварительно созданная сущность datetimeV2|Нью-Йорк<br>Лондон<br>5 марта 2018 г.|

## <a name="entities-are-optional-but-highly-recommended"></a>Сущности являются необязательными, но настоятельно рекомендуемыми к использованию

Тогда как намерения являются обязательными, использовать сущности необязательно. Не нужно создавать сущности для каждого понятия в приложении — они требуются только для тех, которые требуются для работы клиентского приложения. 

Если высказывания не содержат сведения, необходимые боту для продолжения, добавлять их не нужно. Их можно добавить позднее по мере развития приложения. 

Если вы не знаете, как будете использовать данные, добавьте несколько общих предварительно созданных сущностей, таких как [datetimeV2](luis-reference-prebuilt-datetimev2.md), [порядковый номер](luis-reference-prebuilt-ordinal.md), [адрес электронной почты](luis-reference-prebuilt-email.md) и [номер телефона](luis-reference-prebuilt-phonenumber.md).

## <a name="label-for-word-meaning"></a>Пометка для значения слова

Если выбор или расположение слов одинаковы, но имеют разное значение, их не нужно помечать с помощью сущности. 

В следующих высказываниях слово `fair` является омографом. Оно пишется одинаково, но имеет другое значение:

|Фраза|
|--|
|Какие ярмарки проходят неподалеку от Сиэтла этим летом?|
|Справедлива ли эта оценка за обзор Сиэтла?|

Если требуется, чтобы сущность события находила все данные события, пометьте слово `fair` в первом высказывании, а не во втором.

## <a name="entities-are-shared-across-intents"></a>Сущности являются общими в намерениях

Сущности являются общими в намерениях. Они не принадлежат отдельному намерению. Намерения и сущности могут быть семантически связаны, но эта связь не является исключительной.

Во фразе Book me a ticket to Paris (Забронировать билет в Париж) Paris (Париж) — это сущность, связанная с расположением. Распознавая сущности, которые упоминаются во фразе пользователя, LUIS помогает клиентскому приложению выбирать конкретные действия, выполняемые для удовлетворения запроса пользователя.

## <a name="mark-entities-in-none-intent"></a>Пометка сущностей в намерении None

Все намерения, включая намерение **None**, должны при возможности иметь помеченные сущности. В этом случае LUIS хорошо известно о месте расположения сущностей в высказываниях и какие слова находятся вокруг сущностей. 

## <a name="entity-status-for-predictions"></a>Состояние сущности для прогнозирования

На портале LUIS вы всегда можете узнать, когда сущность в примере высказывания отличается от помеченной сущности или слишком близка к другой сущности (и поэтому является неясной). Такое различие визуально представлено с помощью красного подчеркивания в примере высказывания. 

Дополнительные сведения см. в разделе [Прогнозирование состояния сущности](luis-how-to-add-example-utterances.md#entity-status-predictions). 

## <a name="types-of-entities"></a>Типы сущностей

LUIS предлагает множество типов сущностей. Выберите сущность на основе способа извлечения данных и их представления после извлечения.

Сущности могут быть извлечены с помощью машинного обучения, что позволяет LUIS продолжать обучение отображению сущности в высказывании. Сущности могут быть извлечены без использования машинного обучения — за счет точного совпадения с текстом или регулярным выражением. Сущности в шаблонах можно извлекать с помощью смешанных реализации. 

После извлечения сущности ее данные можно представить в виде единицы информации либо в сочетании с другими сущностями для формирования единицы информации, используемой в клиентском приложении.

|Прошедшая машинное обучение|Можно пометить|Учебник|Пример<br>Отклик|Тип сущности|Назначение|
|--|--|--|--|--|--|
|✔|✔|[✔](luis-tutorial-composite-entity.md)|[✔](luis-concept-data-extraction.md#composite-entity-data)|[**Составная**](#composite-entity)|Группа сущностей независимо от типа сущности.|
|||[✔](luis-quickstart-intent-and-list-entity.md)|[✔](luis-concept-data-extraction.md#list-entity-data)|[**Список**](#list-entity)|Список элементов и их синонимов, извлеченных в результате поиска точных совпадений.|
|Смешанная||[✔](luis-tutorial-pattern.md)|[✔](luis-concept-data-extraction.md#patternany-entity-data)|[**Pattern.any**](#patternany-entity)|Сущность, конец которой определить довольно сложно.|
|||[✔](luis-tutorial-prebuilt-intents-entities.md)|[✔](luis-concept-data-extraction.md#prebuilt-entity-data)|[**Предварительно созданная**](#prebuilt-entity)|Уже обученная для извлечения различных видов данных.|
|||[✔](luis-quickstart-intents-regex-entity.md)|[✔](luis-concept-data-extraction.md#regular-expression-entity-data)|[**Регулярное выражение**](#regular-expression-entity)|Использует регулярное выражение для сравнения текста.|
|✔|✔|[✔](luis-quickstart-primary-and-secondary-data.md)|[✔](luis-concept-data-extraction.md#simple-entity-data)|[**Простая**](#simple-entity)|Содержит единое понятие в слове или фразе.|

Только результаты обучения компьютера сущности должны быть отмечены в примере фразы. Прошедшие машинное обучение сущности лучше всего работают после тестирования с помощью [запросов конечной точки](luis-concept-test.md#endpoint-testing) и [проверки высказываний конечной точки](luis-how-to-review-endoint-utt.md). 

Сущности Pattern.Any необходимо помечать в примерах [шаблонов](luis-how-to-model-intent-pattern.md), а не в примерах намерений пользователя. 

Смешанные сущности используют сочетание методов обнаружения сущности.

## <a name="composite-entity"></a>Составная сущность

Составной сущности состоит из других сущностей, таких как предварительно созданных сущностей простой, регулярное выражение и список сущностей. Эти отдельные сущности формируют единую сущность. 

Эта сущность оптимальна для данных в таких случаях.

* данные связаны между собой; 
* Связаны между собой в контексте фразы.
* для них используются различные типы сущностей;
* должны быть сгруппированы и обработаны клиентским приложением в качестве единицы информации;
* имеют различные высказывания пользователей, которые требуют машинного обучения.

![составная сущность](./media/luis-concept-entities/composite-entity.png)

[Руководство](luis-tutorial-composite-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#composite-entity-data)<br>

## <a name="list-entity"></a>Сущность списка

Сущности списка представляют фиксированный, закрытый набор связанных слов вместе с их синонимами. LUIS не обнаруживает дополнительные значения для сущностей списка. Посмотреть предложения для новых слов на основе текущего списка можно с помощью функции **Рекомендовать**. Если имеется несколько сущностей списка с одним и тем же значением, в запросе конечной точки возвращается каждая сущность. 

Сущность оптимальна для данных в таких случаях.

* Значения данных являются известным набором.
* Набор не превышает максимальные [ограничения](luis-boundaries.md) LUIS для этого типа сущности.
* Текст в высказывании в точности совпадает с синонимом или каноническим именем. LUIS не использует список вне точных текстовых совпадений. Сущность списка не используется для разрешения выделения корней, множественных форм и других вариантов. Для управления вариантами рекомендуется применять [шаблон](luis-concept-patterns.md#syntax-to-mark-optional-text-in-a-template-utterance) с синтаксисом, имеющим необязательный текст.

![сущность списка](./media/luis-concept-entities/list-entity.png)

[Руководство](luis-quickstart-intent-and-list-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#list-entity-data)

## <a name="patternany-entity"></a>Сущность Pattern.any

Patterns.any — это местозаполнитель переменной длины, используемый только в высказывании шаблона для пометки начала и окончания сущности.  

Сущность оптимальна для данных в таких случаях.

* Конечную часть сущности можно спутать с оставшимся текстом высказывания. 
[Руководство](luis-tutorial-pattern.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#patternany-entity-data)

**Пример**  
В клиентском приложении для поиска книг по названию сущность pattern.any извлекает полное название. Высказывание шаблона, использующее сущность pattern.any для поиска книги, — `Was {BookTitle} written by an American this year[?]`. 

В следующей таблице каждая строка имеет две версии высказывания. Верхнее высказывание — то, каким образом LUIS сначала увидит высказывание, из которого непонятно, как начинается и заканчивается название книги. Нижнее высказывание — то, как LUIS определит название книги при наличии шаблона для извлечения. 

|Фраза|
|--|
|"Был Man кто Mistook его жена Hat и другие клинических страшные, написанной American за этот год?<br>Книга **The Man Who Mistook His Wife for a Hat and Other Clinical Tales (Человек, который принял жену за шляпу, и другие истории из врачебной практики)** была написана американским автором в этом году?|
|`Was Half Asleep in Frog Pajamas written by an American this year?`<br>`Was **Half Asleep in Frog Pajamas** written by an American this year?`|
|`Was The Particular Sadness of Lemon Cake: A Novel written by an American this year?`<br>`Was **The Particular Sadness of Lemon Cake: A Novel** written by an American this year?`|
|`Was There's A Wocket In My Pocket! written by an American this year?`<br>`Was **There's A Wocket In My Pocket!** written by an American this year?`|

## <a name="prebuilt-entity"></a>Предварительно созданная сущность

Предварительно созданные сущности являются встроенными типами, которые представляют общие понятия, такие как адрес электронной почты, URL-адрес и номер телефона. Имена предварительно созданных сущностей являются зарезервированными. [Все предварительно созданные сущности](luis-prebuilt-entities.md), добавленные в приложение, возвращаются в запросе прогнозирования конечной точки, если они были найдены в высказывании. 

Сущность оптимальна для данных в таких случаях.

* Данные соответствуют распространенному варианту использования, поддерживаемому предварительно созданными сущностями для вашего языка и региональных параметров. 

Предварительно созданные сущности можно добавлять и удалять в любое время.

![Предварительно созданная сущность Number](./media/luis-concept-entities/number-entity.png)

[Руководство](luis-tutorial-prebuilt-intents-entities.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#prebuilt-entity-data)

Некоторые из этих предварительно созданных сущностей определены в проекте [Recognizers-Text](https://github.com/Microsoft/Recognizers-Text) с открытым исходным кодом. Если в настоящее время определенный язык и региональные параметры или сущность не поддерживается, примите участие в добавлении материалов в проект. 

### <a name="troubleshooting-prebuilt-entities"></a>Устранение неполадок предварительно созданных сущностей

На портале LUIS если предварительно созданные сущности можно определить по значку вместо вашей настраиваемой сущности доступно несколько вариантов того, как устранить эту проблему.

Предварительно созданные сущности, добавленные в приложение будет _всегда_ возвращаться, даже если utterance следует извлечь настраиваемые сущности тот же текст. 

#### <a name="change-tagged-entity-in-example-utterance"></a>Изменить сущность с тегами в примере utterance

Если предварительно созданные сущность является один и тот же текст или маркеры как настраиваемую сущность, выделите текст в примере utterance и измените utterance с тегами. 

Если предварительно созданные сущности обозначен цифрой дополнительные текст или маркеры, чем пользовательские сущности, у вас есть несколько вариантов использования устранить эту проблему:

* [Удалить utterance пример](#remove-example-utterance-to-fix-tagging) метод
* [Удалить сущность, предварительно созданные](#remove-prebuilt-entity-to-fix-tagging) метод

#### <a name="remove-example-utterance-to-fix-tagging"></a>Удалить utterance пример, чтобы исправить добавления тегов 

В первую очередь необходимо удалить utterance пример. 

1. Удалите utterance пример.
1. Повторное обучение приложения. 
1. Добавьте обратно только слово или фразу, сущностью, которая помечена как предварительно созданные сущности, как utterance полный пример. Слово или фразу, по-прежнему будет иметь предварительно созданные сущности, помеченной как. 
1. Выберите сущность в примере utterance на **намерение** странице и изменить в настраиваемую сущность снова обучения. Это должно предотвратить LUIS Пометка предварительно созданные сущности в любой пример фразы, которую этот точный текст. 
1. Добавьте весь исходный пример utterance цель. Настраиваемой сущности должны продолжать отмечаться вместо готовых сущностей. Если не отмечен настраиваемой сущности, необходимо добавить дополнительные примеры этот текст в фразы.

#### <a name="remove-prebuilt-entity-to-fix-tagging"></a>Удалить сущность, готовых для исправления тегов

1. Удалите предварительно созданные сущности из приложения. 
1. На **намерение** странице, пометьте настраиваемой сущности в примере utterance.
1. Обучите приложение.
1. Добавление предварительно созданные сущности в приложение и выполните обучение приложения. Это исправление предполагается, что предварительно созданные сущности не является частью составного сущности.

## <a name="regular-expression-entity"></a>Сущность регулярного выражения 

Регулярное выражение является оптимальным вариантом при использовании необработанного текста высказывания. Оно не учитывает регистр и игнорирует региональный алфавит.  Сопоставление регулярных выражений применяется на уровне символов, а не на уровне маркеров, после внесения изменений при проверке орфографии. Если регулярное выражение слишком сложное, например в нем используется много квадратных скобок, вы не сможете добавить выражение в модель. Использует часть, но не все [регулярных выражений .NET](https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions) библиотеки. 

Сущность оптимальна для данных в таких случаях.

* Данные согласованно отформатированы с любыми также согласованными вариантами.
* У регулярного выражения может быть не более двух уровней вложенности. 

![Сущность регулярного выражения](./media/luis-concept-entities/regex-entity.png)

[Руководство](luis-quickstart-intents-regex-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#regular-expression-entity-data)<br>

## <a name="simple-entity"></a>Простая сущность 

Простая сущность — это универсальная сущность, описывающая одно понятие и обучаемая на основе контекста машинного обучения. Так как простые сущности обычно являются именами, например названиями компаний, продуктов или другими категориями имен, добавьте [список фраз](luis-concept-feature.md) для выделения используемых имен. 

Сущность оптимальна для данных в таких случаях.

* У данных отсутствует согласованное форматирование, но они означают одно и то же. 

![простая сущность](./media/luis-concept-entities/simple-entity.png)

[Руководство](luis-quickstart-primary-and-secondary-data.md)<br/>
[Пример ответа для сущности](luis-concept-data-extraction.md#simple-entity-data)<br/>

## <a name="entity-limits"></a>Ограничения сущностей

Ознакомьтесь с [ограничениями](luis-boundaries.md#model-boundaries), чтобы понять, сколько сущностей каждого типа можно добавить в модель.

## <a name="if-you-need-more-than-the-maximum-number-of-entities"></a>Если требуется количество сущностей, превышающее максимальное значение 

Может потребоваться использовать составной сущности в сочетании с ролями сущности.

Составные сущности представляют части целого. Например, у составной сущности PlaneTicketOrder могут быть дочерние сущности Airline, Destination, DepartureCity, DepartureDate и PlaneTicketClass.

LUIS также предоставляет тип сущности списка, который не прошел машинное обучение, но позволяет приложению LUIS указывать фиксированный список значений. Ограничения для типа сущности списка см. в статье [Границы LUIS](luis-boundaries.md). 

Если вы считается эти сущности и больше, чем ограничение по-прежнему нужен, обратитесь в службу поддержки. Для этого соберите подробные сведения о системе, откройте веб-сайт [LUIS](luis-reference-regions.md#luis-website), а затем выберите элемент **Поддержка**. Если ваша подписка Azure включает службы поддержки, обратитесь в службу [технической поддержки Azure](https://azure.microsoft.com/support/options/). 

## <a name="next-steps"></a>Дальнейшие действия

Ознакомьтесь с подходящими [высказываниями](luis-concept-utterance.md). 

Дополнительные сведения о добавлении сущностей в приложение LUIS см. в статье [Добавление сущностей](luis-how-to-add-entities.md).
