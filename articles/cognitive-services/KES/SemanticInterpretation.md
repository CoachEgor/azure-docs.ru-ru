---
title: Семантическая интерпретация — API службы поиска и распознавания данных
titlesuffix: Azure Cognitive Services
description: Узнайте, как использовать семантическую интерпретацию в API службы поиска и распознавания данных (KES).
services: cognitive-services
author: bojunehsu
manager: nitinme
ms.service: cognitive-services
ms.subservice: knowledge-exploration
ms.topic: conceptual
ms.date: 03/26/2016
ms.author: paulhsu
ms.openlocfilehash: 26f8d885f8cf85ab849ba221392df206e492aac4
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "60814472"
---
# <a name="semantic-interpretation"></a>Семантическая интерпретация

Семантическая интерпретация позволяет связать семантические выходные данные с каждым интерпретируемым путем с помощью грамматики.  В частности, эта служба оценивает последовательность операторов в элементах `tag`, проверяемых при интерпретации для вычисления конечного результата.  

Инструкция может быть назначением литерала или переменной к другой переменной.  Она также может назначать переменной выходные данные функции с 0 или большим числом параметров.  Каждый параметр функции можно указать с помощью литерала или переменной.  Если функция не возвращает никаких выходных данных, то назначение пропускается.

```xml
<tag>x = 1; y = x;</tag>
<tag>q = All(); q = And(q, q2);</tag>
<tag>AssertEquals(x, 1);</tag>
```

Переменная задается с помощью идентификатора имени, который начинается с буквы и содержит только буквы (A-Z), цифры (0-9) и символ подчеркивания (\_).  Ее тип неявно выводится на основании литерала или назначенного выходного значения функции. 

Ниже приведен текущий список поддерживаемых типов данных.

|type|Описание|Примеры|
|----|----|----|
|String|Последовательность, содержащая 0 или более знаков.|"Hello World!"<br/>""|
|Логический|Логическое значение.|Да<br/>false|
|Int32|32-разрядное целое число со знаком.  –2,1e9…2,1e9|123<br/>–321|
|Int64|64-разрядное целое число со знаком. -9,2e18 и 9,2e18|9 876 543 210|
|Double|Число с плавающей запятой двойной точности. 1,7e+/-308 (15 разрядов)|123,456789<br/>1,23456789e2|
|Guid|Глобальный уникальный идентификатор|"602DD052-CC47-4B23-A16A-26B52D30C05B"|
|Запрос|Выражение запроса, которое определяет подмножество объектов данных в индексе.|All()<br/>And(*q1*, *q2*)|

## <a name="semantic-functions"></a>Семантические функции

Имеется набор встроенных семантических функций.  Они позволяют создавать сложные запросы и предоставляют контекстное управление интерпретациями грамматики.

### <a name="and-function"></a>Функция And

`query = And(query1, query2);`

Возвращает запрос, содержащий область пересечения двух входных запросов.

### <a name="or-function"></a>Функция Or

`query = Or(query1, query2);`

Возвращает запрос, содержащий область объединения двух входных запросов.

### <a name="all-function"></a>Функция All

`query = All();`

Возвращает запрос, включающий в себя все объекты данных.

В следующем примере функция All() используется для итеративного создания запроса на основании области пересечения 1 или нескольких ключевых слов.

```
<tag>query = All();</tag>
<item repeat="1-">
  <attrref uri="academic#Keyword" name="keyword">
  <tag>query = And(query, keyword);</tag>
</item>
```

### <a name="none-function"></a>Функция None

`query = None();`

Возвращает запрос, не включающий в себя объекты данных.

В следующем примере функция None() используется для итеративного создания запроса на основании области объединения 1 или нескольких ключевых слов.

```
<tag>query = None();</tag>
<item repeat="1-">
  <attrref uri="academic#Keyword" name="keyword">
  <tag>query = Or(query, keyword);</tag>
</item>
```

### <a name="query-function"></a>Функция Query

```
query = Query(attrName, value)
query = Query(attrName, value, op)
```

Возвращает запрос, включающий в себя только объекты данных, атрибут *attrName* которых соответствует значению *value* в соответствии с указанной операцией *op*, которой по умолчанию является операция "eq".  Как правило, элемент `attrref` используется для создания запроса на основе соответствующей строки входного запроса.  Если значение задано или получено другим способом, функция Query() может использоваться для создания запроса, соответствующего этому значению.

В следующем примере функция Query() используется, чтобы реализовать поддержку указания научных публикаций за определенное десятилетие.

```xml
written in the 90s
<tag>
  beginYear = Query("academic#Year", 1990, "ge");
  endYear = Query("academic#Year", 2000, "lt");
  year = And(beginYear, endYear);
</tag>
```

### <a name="composite-function"></a>Функция Composite

`query = Composite(innerQuery);`

Возвращает запрос, который инкапсулирует запрос *innerQuery*, состоящий соответствующих вложенных атрибутов общего составного атрибута *attr*.  Для инкапсуляции требуется, чтобы составной атрибут *attr* любого соответствующего объекта данных имел по крайней мере одно значение, которое удовлетворяет внутреннему запросу *innerQuery*.  Обратите внимание на то, что запрос вложенных атрибутов составного атрибута должно быть инкапсулировано с помощью функции Composite(), прежде чем его можно будет объединить с другими запросами.

Например, следующий запрос возвращает научные публикации Гарри Шама (Harry Shum) за период, когда он работал в корпорации Майкрософт.
```
Composite(And(Query("academic#Author.Name", "harry shum"), 
              Query("academic#Author.Affiliation", "microsoft")));
```

С другой стороны, приведенный ниже запрос возвращает научные публикации, одним из авторов которых является Гарри Шам (Harry Shum) и которые относятся к корпорации Майкрософт.
```
And(Composite(Query("academic#Author.Name", "harry shum"), 
    Composite(Query("academic#Author.Affiliation", "microsoft")));
```

### <a name="getvariable-function"></a>Функция GetVariable

`value = GetVariable(name, scope);`

Возвращает значение переменной *name*, определенной в указанной области *scope*.  Параметр *name* — это идентификатор, который начинается с буквы и содержит только буквы (A-Z), цифры (0-9) и символ подчеркивания (_).  Параметру *scope* можно присвоить значение "request" или "system".  Обратите внимание на то, что переменные, определенные в разных областях, отличны друг от друга, включая переменные, определенные посредством выходных данных семантических функций.

Переменные области запроса являются общими для всех интерпретаций в текущем запросе interpret.  Их можно использовать для управления поиском интерпретаций в грамматике.

Системные переменные предопределены службой и могут использоваться для получения различных статистических данных о текущем состоянии системы.  Ниже приведен набор поддерживаемых системных переменных.

|Name|Тип|Описание|
|----|----|----|
|IsAtEndOfQuery|Логический|Имеет значение true, если достигнут конец входного запроса для текущего поиска интерпретаций.|
|IsBeyondEndOfQuery|Логический|Имеет значение true, если для текущего поиска интерпретаций предложены варианты завершения, выходящие за пределы текста входного запроса.|

### <a name="setvariable-function"></a>Функция SetVariable

`SetVariable(name, value, scope);`

Назначает значение *value* переменной *name* в указанной области *область*.  Параметр *name* — это идентификатор, который начинается с буквы и содержит только буквы (A-Z), цифры (0-9) и символ подчеркивания (_).  В настоящее время для *scope* поддерживается только значение "request".  Системные переменные, которые можно задать, отсутствуют.

Переменные области запроса являются общими для всех интерпретаций в текущем запросе interpret.  Их можно использовать для управления поиском интерпретаций в грамматике.

### <a name="assertequals-function"></a>Функция AssertEquals

`AssertEquals(value1, value2);`

Если значения *value1* и *value1* равны, выполнение функции завершается успешно и не имеет побочных эффектов.  В противном случае функция завершается ошибкой и отклоняет интерпретацию.

### <a name="assertnotequals-function"></a>Функция AssertNotEquals

`AssertNotEquals(value1, value2);`

Если значения *value1* и *value1* не равны, выполнение функции завершается успешно и не имеет побочных эффектов.  В противном случае функция завершается ошибкой и отклоняет интерпретацию.


