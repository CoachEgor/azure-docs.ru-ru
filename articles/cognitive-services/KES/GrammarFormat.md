---
title: Формат грамматики — API службы поиска и распознавания данных
titlesuffix: Azure Cognitive Services
description: Сведения о формате грамматики в API службы поиска и распознавания данных (KES).
services: cognitive-services
author: bojunehsu
manager: nitinme
ms.service: cognitive-services
ms.subservice: knowledge-exploration
ms.topic: conceptual
ms.date: 03/26/2016
ms.author: paulhsu
ms.openlocfilehash: 844bd9a88c52fd398fc66c71e59da513c0d7d90d
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "60814872"
---
# <a name="grammar-format"></a>Формат грамматики

Грамматика — это XML-файл, который задает взвешенный набор запросов на естественном языке, которые служба может интерпретировать, а также определяет, как эти запросы преобразуются в выражения семантических запросов.  Синтаксис грамматики основан на [SRGS](https://www.w3.org/TR/speech-grammar/) — стандарте консорциума W3C для грамматик распознавания речи — с расширениями для поддержки интеграции индекса данных и семантических функций.

Ниже описан каждый синтаксический элемент, который можно использовать в грамматике.  В [этом примере](#example) показан полный файл грамматики и демонстрируется, как эти элементы используются в контексте.

### <a name="grammar-element"></a>Элемент grammar

Элемент `grammar` занимает верхний уровень в XML-файле спецификации грамматики.  Обязательный атрибут `root` задает имя корневого правила, которое определяет начальную точку грамматики.

```xml
<grammar root="GetPapers">
```

### <a name="import-element"></a>Элемент import

Элемент `import` импортирует определение схемы из внешнего файла, чтобы включить ссылки на атрибуты. Этот элемент должен быть дочерним элементом по отношению к элементу верхнего уровня `grammar` и предшествовать любым элементам `attrref`. Обязательный атрибут `schema` задает имя файла схемы, расположенного в одном каталоге с XML-файлом грамматики. Обязательный элемент `name` задает псевдоним схемы, который последующие элементы `attrref` используют при ссылке на атрибуты, определенные в этой схеме.

```xml
  <import schema="academic.schema" name="academic"/>
```

### <a name="rule-element"></a>Элемент rule

Элемент `rule` определяет грамматическое правило, структурную единицу, задающую набор выражений запросов, которые система может интерпретировать.  Этот элемент должен быть дочерним элементом по отношению к элементу верхнего уровня `grammar`.  Обязательный атрибут `id` задает имя правила, на которое ссылаются элементы `grammar` или `ruleref`.

Элемент `rule` определяет набор юридических расширений.  Текстовые токены сопоставляются непосредственно с входным запросом.  Элементы `item` указывают повторы и изменяют вероятности интерпретации.  Элементы `one-of` указывают альтернативные варианты.  Элементы `ruleref` позволяют конструировать более сложные расширения из более простых.  Элементы `attrref` позволяют выполнять сопоставление со значениями атрибутов из индекса.  Элементы `tag` задают семантику интерпретации и могут изменять вероятность интерпретации.

```xml
<rule id="GetPapers">...</rule>
```

### <a name="example-element"></a>Элемент example

Необязательный элемент `example` задает примеры фраз, которые могут приниматься определением, содержащим элемент `rule`.  Это может использоваться для документации и (или) автоматического тестирования.

```xml
<example>papers about machine learning by michael jordan</example>
```

### <a name="item-element"></a>Элемент item

Элемент `item` группирует последовательность грамматических конструкций.  Он может использоваться для определения повторений последовательности расширений или для указания альтернативных вариантов в сочетании с элементом `one-of`.

Если элемент `item` не является дочерним по отношению к элементу `one-of`, то он может указать повторение закрытой последовательности, назначив в качестве значения атрибута `repeat` число повторов.  Число повторов "*n*" (где *n* — целое число) означает, что последовательность будет выполнена ровно *n* раз.  Число повторов "*m*-*n*" позволяет последовательности выполняться от *m* до *n* раз включительно.  Значение "*m*-" указывает, что последовательность должна выполняться не менее *m* раз.  Необязательный атрибут `repeat-logprob` может использоваться, чтобы изменить вероятность интерпретации для каждого дополнительного повтора сверх минимального значения.

```xml
<item repeat="1-" repeat-logprob="-10">...</item>
```

Когда элементы `item` являются дочерними по отношению к элементу `one-of`, они определяют набор альтернативных расширений.  При таком использовании необязательный атрибут `logprob` задает относительную логарифмическую вероятность среди различных вариантов.  Если задать вероятность *p* от 0 до 1, то соответствующую логарифмическую вероятность можно вычислить как log(*p*), где log() — функция натурального логарифма.  Если атрибут `logprob` не задан, то по умолчанию он равен 0, что не приводит к изменению вероятности интерпретации.  Обратите внимание, что логарифмическая вероятность — это всегда отрицательное значение с плавающей запятой или 0.

```xml
<one-of>
  <item>by</item>
  <item logprob="-0.5">written by</item>
  <item logprob="-1">authored by</item>
</one-of>
```

### <a name="one-of-element"></a>Элемент one-of

Элемент `one-of` задает альтернативные расширения с возможностью выбора одного из дочерних элементов `item`.  Внутри элемента `one-of` могут быть только элементы `item`.  Значения относительной вероятности для различных вариантов можно указать с помощью атрибута `logprob` в каждом дочернем элементе `item`.

```xml
<one-of>
  <item>by</item>
  <item logprob="-0.5">written by</item>
  <item logprob="-1">authored by</item>
</one-of>
```

### <a name="ruleref-element"></a>Элемент ruleref

Элемент `ruleref` задает допустимые расширения посредством ссылок на другой элемент `rule`.  Используя элементы `ruleref`, из простых правил можно создать более сложные выражения.  Обязательный атрибут `uri` указывает имя заданного ссылкой элемента `rule`, используя синтаксис "#*rulename*".  Для отслеживания выходных данных семантики заданного ссылкой правила используйте необязательный атрибут `name`, чтобы указать имя переменной, которой присваиваются семантические выходные данные.
 
```xml
<ruleref uri="#GetPaperYear" name="year"/>
```

### <a name="attrref-element"></a>Элемент attrref

Элемент `attrref` ссылается на атрибут индекса, позволяя выполнять сопоставление со значениями атрибутов, которые наблюдаются в индексе.  Обязательный атрибут `uri` задает имя схемы индексов и имя атрибута, используя синтаксис "*schemaName*#*attrName*".  Ему должен предшествовать элемент `import`, который импортирует схему с именем *schemaName*.  attrName — это имя того атрибута, который определен в соответствующей схеме.

Помимо сопоставления пользовательского ввода элемент `attrref` также возвращает в качестве выходных данных структурированный объект query, который выбирает подмножество объектов в индексе, соответствующее входному значению.  Используйте необязательный атрибут`name`, чтобы задать имя переменной, в которой должны храниться выходные данные объекта query.  Объект query может состоять из других объектов query, образуя более сложные выражения.  Дополнительные сведения см. в статье [Семантическая интерпретация](SemanticInterpretation.md).  

```xml
<attrref uri="academic#Keyword" name="keyword"/>
```

#### <a name="query-completion"></a>Выполнение запроса

Для поддержки выполнения запросов при интерпретации частичных запросов пользователей каждый атрибут, на который указывает ссылка, должен содержать значение "starts_with" в качестве операции в определении схемы.  Если задан префикс запроса пользователя, то `attrref` сопоставит все значения в индексе, совпадающие с этим префиксом, и вернет каждое полное значение как отдельную интерпретацию грамматики.  

Примеры:
* Сопоставление `<attrref uri="academic#Keyword" name="keyword"/>` с префиксом запроса "dat" создает одну интерпретацию для документов о базе данных (database), одну интерпретацию для документов об интеллектуальном анализе данных (data mining) и т. д.
* Сопоставление `<attrref uri="academic#Year" name="year"/>` с префиксом запроса "200" создает одну интерпретацию для документов за 2000 год, одну интерпретацию для документов за 2001 год и т. д.

#### <a name="matching-operations"></a>Операции сопоставления

Помимо точных совпадений некоторые типы атрибутов также поддерживают сопоставление префикса и проверку на неравенство с помощью необязательного атрибута `op`.  Если ни один из объектов в индексе не имеет соответствующего значения, то путь грамматики блокируется и служба не сможет сформировать ни одной интерпретации через этот путь грамматики.   По умолчанию атрибут `op` имеет значение "eq".

```xml
in <attrref uri="academic#Year" name="year"/>
before <attrref uri="academic#Year" op="lt" name="year"/
```

В приведенной ниже таблице перечислены поддерживаемые значения `op` для каждого типа атрибута.  Для их использования в определение атрибута схемы необходимо включить соответствующую операцию индекса.

| Тип атрибута | Значение op | Описание | Операция индекса
|----|----|----|----|
| String | eq | Точное совпадение строки | equals |
| String | starts_with | Совпадение префикса строки | starts_with |
| Int32, Int64, Double | eq |  Проверка на числовое равенство | equals |
| Int32, Int64, Double | lt, le, gt, ge | Проверка на числовое неравенство(<, <=, >, >=) | is_between |
| Int32, Int64, Double | starts_with | Совпадение префикса значения в десятичном представлении | starts_with |

Примеры:
* `<attrref uri="academic#Year" op="lt" name="year"/>` совпадает со входной строкой "2000" и возвращает все документы, опубликованные до 2000-го года.
* `<attrref uri="academic#Year" op="lt" name="year"/>` не совпадает со входной строкой "20", так как в индексе нет документов, опубликованных до 20-го года.
* `<attrref uri="academic#Keyword" op="starts_with" name="keyword"/>` совпадает с входной строкой "dat" и возвращает в одной интерпретации документы о базе данных (database), интеллектуальном анализе данных (data mining) и т. д.  Это редкий вариант использования.
* `<attrref uri="academic#Year" op="starts_with" name="year"/>` совпадает с входной строкой "20" и возвращает в одной интерпретации документы, опубликованные в 200–299 гг., 2000–2999 гг. и т. д.  Это редкий вариант использования.

### <a name="tag-element"></a>Элемент tag

Элемент `tag` определяет, как должен интерпретироваться путь через грамматику.  Он содержит последовательность инструкций, которые заканчиваются точкой с запятой.  Инструкция может быть назначением литерала или переменной к другой переменной.  Она также может назначать переменной выходные данные функции с 0 или большим числом параметров.  Каждый параметр функции можно указать с помощью литерала или переменной.  Если функция не возвращает никаких выходных данных, то назначение пропускается.  Область действия переменной является локальной для содержащего ее правила.

```xml
<tag>x = 1; y = x;</tag>
<tag>q = All(); q = And(q, q2);</tag>
<tag>AssertEquals(x, 1);</tag>
```

Каждый элемент `rule` в грамматике содержит предопределенную переменную с именем "out", которая представляет семантические выходные данные.  Ее значение вычисляется путем оценки всех семантических инструкций, проходящих по пути с применением правила `rule` и в соответствии с входными данными запроса пользователя.  Значение, присваиваемое переменной "out" в результате такой оценки, является семантическими выходными данными правила.  Семантические выходные данные интерпретации запроса пользователя на основе грамматики являются семантическими выходными данными корневого правила.

Некоторые инструкции могут изменять вероятность пути интерпретации путем введения дополнительного смещения логарифмической вероятности.  Некоторые инструкции могут полностью отклонить интерпретацию, если не удовлетворены указанные условия.

Список поддерживаемых семантических функций см. в разделе [Семантические функции](SemanticInterpretation.md#semantic-functions).

## <a name="interpretation-probability"></a>Вероятность интерпретации

Вероятность пути интерпретация через грамматику — это кумулятивная логарифмическая вероятность всех элементов `<item>` и семантических функций, выявленных по пути.  Она описывает относительную вероятность совпадения с определенной входной последовательностью.

Если задать вероятность *p* от 0 до 1, то соответствующую логарифмическую вероятность можно вычислить как log(*p*), где log() — функция натурального логарифма.  Использование логарифмических вероятностей позволяет системе накапливать суммарную вероятность пути интерпретации посредством простого сложения.  Она также позволяет избежать потери значимости при операциях с плавающей точкой, что часто случается при подобных расчетах суммарной вероятности.  Обратите внимание, что изначально логарифмическая вероятность — это всегда отрицательное значение с плавающей запятой или 0, и чем выше это значение, тем выше вероятность.

## <a name="example"></a>Пример

Ниже приведен пример XML-файла с домена научных публикаций, демонстрирующий различные элементы грамматики.

```xml
<grammar root="GetPapers">

  <!-- Import academic data schema-->
  <import schema="academic.schema" name="academic"/>
  
  <!-- Define root rule-->
  <rule id="GetPapers">
    <example>papers about machine learning by michael jordan</example>
    
    papers
    <tag>
      yearOnce = false;
      isBeyondEndOfQuery = false;
      query = All();
    </tag>
  
    <item repeat="1-" repeat-logprob="-10">
      <!-- Do not complete additional attributes beyond end of query -->
      <tag>AssertEquals(isBeyondEndOfQuery, false);</tag>
        
      <one-of>
        <!-- about <keyword> -->
        <item logprob="-0.5">
          about <attrref uri="academic#Keyword" name="keyword"/>
          <tag>query = And(query, keyword);</tag>
        </item>
        
        <!-- by <authorName> [while at <authorAffiliation>] -->
        <item logprob="-1">
          by <attrref uri="academic#Author.Name" name="authorName"/>
          <tag>authorQuery = authorName;</tag>
          <item repeat="0-1" repeat-logprob="-1.5">
            while at <attrref uri="academic#Author.Affiliation" name="authorAffiliation"/>
            <tag>authorQuery = And(authorQuery, authorAffiliation);</tag>
          </item>
          <tag>
            authorQuery = Composite(authorQuery);
            query = And(query, authorQuery);
          </tag>
        </item>
        
        <!-- written (in|before|after) <year> -->
        <item logprob="-1.5">
          <!-- Allow this grammar path to be traversed only once -->
          <tag>
            AssertEquals(yearOnce, false);
            yearOnce = true;
          </tag>
          <ruleref uri="#GetPaperYear" name="year"/>
          <tag>query = And(query, year);</tag>
        </item>
      </one-of>

      <!-- Determine if current parse position is beyond end of query -->
      <tag>isBeyondEndOfQuery = GetVariable("IsBeyondEndOfQuery", "system");</tag>
    </item>
    <tag>out = query;</tag>
  </rule>
  
  <rule id="GetPaperYear">
    <tag>year = All();</tag>
    written
    <one-of>
      <item>
        in <attrref uri="academic#Year" name="year"/>
      </item>
      <item>
        before
        <one-of>
          <item>[year]</item>
          <item><attrref uri="academic#Year" op="lt" name="year"/></item>
        </one-of>
      </item>
      <item>
        after
        <one-of>
          <item>[year]</item>
          <item><attrref uri="academic#Year" op="gt" name="year"/></item>
        </one-of>
      </item>
    </one-of>
    <tag>out = year;</tag>
  </rule>
</grammar>
```
