---
title: Как работает код с Azure Dev Spaces
services: azure-dev-spaces
ms.date: 03/24/2020
ms.topic: conceptual
description: Описывает процессы запуска кода в службе Azure Kubernetes с azure Dev Spaces
keywords: azds.yaml, Azure Dev Spaces, Dev Spaces, Docker, Kubernetes, Azure, AKS, Azure Kubernetes Service, контейнеры
ms.openlocfilehash: 6851c04ac0b72db1bd13c991875c16b0beadc573
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "80241365"
---
# <a name="how-running-your-code-with-azure-dev-spaces-works"></a>Как работает код с Azure Dev Spaces

Azure Dev Spaces предоставляет вам множество способов быстрой итерации и отладки приложений Kubernetes и совместной работы с вашей командой в кластере Azure Kubernetes Service (AKS). Как только ваш [проект будет подготовлен к запуску в пространстве разработчиков,][how-it-works-prep]вы можете использовать Dev Spaces для создания и запуска проекта в кластере AKS.

В этой статье описывается, что происходит запустить код в AKS с Dev Spaces.

## <a name="run-your-code"></a>Выполнение кода

Чтобы запустить код в пространстве разработчиков, выдайте `up` команду `azds.yaml` в том же каталоге, что и файл:

```cmd
azds up
```

Команда `up` загружает исходные файлы приложения и другие артефакты, необходимые для создания и запуска проекта в пространство разработчиков. Оттуда, контроллер в вашем пространстве разработчиков:

1. Создает объекты Kubernetes для развертывания приложения.
1. Создает контейнер для приложения.
1. Развертывает приложение в пространство разработчиков.
1. Создает общедоступное имя DNS для конечных точек приложения, если настроен.
1. Использует *порт-вперед* для обеспечения доступа http://localhostк конечная точка приложения с помощью.
1. Форварды stdout и stderr к клиенту стороне инструмента.


## <a name="starting-a-service"></a>Запуск службы

При запуске службы в пространстве разработчиков инструментарий и контроллер на стороне клиента работают в координации для синхронизации исходных файлов, создания контейнеров и объектов Kubernetes и запуска приложения.

На более гранулированном уровне, вот `azds up`что происходит, когда вы работаете:

1. [Файлы синхронизируются][sync-section] с компьютера пользователя в хранилище файлов Azure, которое является уникальным для кластера AKS пользователя. Загружаются исходный код, диаграмма helm и файлы конфигурации.
1. Контроллер создает запрос для запуска нового сеанса. Этот запрос содержит несколько свойств, включая уникальный идентификатор, имя пространства, путь к исходному коду и отладка флага.
1. Контроллер заменяет *заполнитель $(tag)* в диаграмме Helm уникальным идентификатором сеанса и устанавливает диаграмму Helm для вашего сервиса. Добавление ссылки на уникальный идентификатор сеанса в диаграмму Helm позволяет контейнеру, развернутому в кластере AKS для этой конкретной сессии, быть привязанным к запросу сеанса и связанной с ним информации.
1. Во время установки диаграммы Helm сервер приема веб-крючка Kubernetes добавляет дополнительные контейнеры в стручок приложения для приборов и доступа к исходному коду вашего проекта. Для обеспечения отслеживания HTTP и пространственной трассировки добавляются контейнеры devspaces-proxy-init. Контейнер для сборки devspaces добавляется для обеспечения стручка с доступом к экземпляру Docker и исходному коду проекта для создания контейнера приложения.
1. При начале запуска приложения для создания контейнера приложения для создания контейнера для создания приложения используются контейнер devspaces-build и контейнер devspaces-proxy-init. Затем запускаются контейнеры приложений и контейнеры для devspaces-proxy.
1. После запуска контейнера приложения функция клиентской стороны использует функцию порта Kubernetes *для* обеспечения доступа HTTP к http://localhostприложению. Этот порт-форвард соединяет компьютер разработки с службой в вашем пространстве разработчиков.
1. Когда все контейнеры в капсуле начали работу, служба работает. На этом этапе функциональность со стороны клиента начинает передавать следы HTTP, стдауии и стердер. Эта информация отображается функциональностью со стороны клиента для разработчика.

## <a name="updating-a-running-service"></a>Обновление работающего сервиса

Во время работы службы Azure Dev Spaces имеет возможность обновлять эту службу при изменении каких-либо файлов исходного кода проекта. Dev Spaces также обрабатывает обновление службы по-разному в зависимости от типа измененного файла. Существует три способа обновления службы Dev Spaces:

* Непосредственное обновление файла
* Восстановление и перезапуск процесса приложения внутри контейнера запущенного приложения
* Восстановление и передислокация контейнера приложения

![Синхронизация файлов Azure Dev Spaces](media/how-dev-spaces-works/file-sync.svg)

Некоторые файлы проекта, которые являются статическими активами, такие как html, css и cshtml, могут обновляться непосредственно в контейнере приложения без перезапуска. Если статическое изменение актива, новый файл синхронизируется с пространством разработчиков и затем используется запущенным контейнером.

Изменения в файлах, таких как исходный код или файлы конфигурации приложения, могут быть применены путем перезапуска процесса приложения в запущенном контейнере. После синхронизации этих файлов процесс приложения перезапускается в запущенном контейнере с помощью процесса *devhostagent.* При первоначальном создании контейнера приложения контроллер заменяет команду запуска приложения другим процессом, называемым *devhostagent.* Фактический процесс приложения затем запускается как процесс ребенка под *devhostagent*, и его выход выкладывается с использованием выходной *devhostagent'*. Процесс *devhostagent* также является частью Dev Spaces и может выполнять команды в запущенном контейнере от имени Dev Spaces. При выполнении перезагрузки, *devhostagent*:

* Остановка текущего процесса или процессов, связанных с приложением
* Перестраивает приложение
* Перезагрузка процесса или процессов, связанных с приложением

Способ *выполнения девоставийра* предыдущих шагов [настроен в `azds.yaml` ][azds-yaml-section].

Обновления файлов проектов, таких как Dockerfiles, csproj файлы, или любой части диаграммы хелмы требуют контейнера приложения для перестроения и передислокации. При синхронизации одного из этих файлов с пространством разработчиков контроллер выполняет команду [обновления руля,][helm-upgrade] а контейнер приложения перестраивается и перераспределяется.

## <a name="file-synchronization"></a>Синхронизация файлов

При первом запуска приложения в пространстве разработчиков все исходные файлы приложения загружаются. Во время запуска приложения и последующего перезапуска загружаются только измененные файлы. Для координации этого процесса используются два файла: файл на стороне клиента и файл на стороне контроллера.

Файл на стороне клиента хранится во временном каталоге и называется на основе хэша каталога проекта, который вы работаете в Dev Spaces. Например, на Windows у вас будет такой файл, как у *пользователей-userNAME-AppData-Local-Temp-1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef12345677890abcdef1234567890abcdef1234567890abcdef1234567890abcdef12345677890abcdef12345677890abcdef1234567789abcdef1234567890abcdef1234567890abcdef1234567890abcdef12334567890abcdef1234567890abcdef1234567789abcdef12* На Linux файл на стороне клиента хранится в каталоге */tmp.* Вы можете найти каталог на macOS, запустив `echo $TMPDIR` команду.

Этот файл находится в формате JSON и содержит:

* Запись для каждого файла проекта, синхронизированного с пространством разработчиков
* Идентификатор синхронизации
* Отметка времени последней операции синхронизации

Каждая запись файла проекта содержит путь к файлу и его отметку времени.

Файл на стороне контроллера хранится в кластере AKS. Он содержит идентификатор синхронизации и отметку времени последней синхронизации.

Синхронизация происходит, когда метки времени синхронизации не совпадают между файлами на стороне клиента и файлами на стороне контроллера. Во время синхронизации инструментирование на стороне клиента итерирует записи файлов в файле на стороне клиента. Если метка времени файла находится после метки времени синхронизации, этот файл синхронизируется с пространством разработчиков. После завершения синхронизации метки времени синхронизации обновляются как на клиентских, так и на файлах на стороне контроллера.

Все файлы проекта синхронизируются, если файл на стороне клиента не присутствует. Такое поведение позволяет заставить полную синхронизацию, удаляя файл на стороне клиента.

## <a name="how-running-your-code-is-configured"></a>Как настраивается код

Azure Dev Spaces `azds.yaml` использует файл для установки и настройки службы. Контроллер использует `install` свойство `azds.yaml` в файле для установки диаграммы Helm и создания объектов Kubernetes:

```yaml
...
install:
  chart: charts/webfrontend
  values:
  - values.dev.yaml?
  - secrets.dev.yaml?
  set:
    replicaCount: 1
    image:
      repository: webfrontend
      tag: $(tag)
      pullPolicy: Never
    ingress:
      annotations:
        kubernetes.io/ingress.class: traefik-azds
      hosts:
      # This expands to [space.s.][rootSpace.]webfrontend.<random suffix>.<region>.azds.io
      # Customize the public URL by changing the 'webfrontend' text between the $(rootSpacePrefix) and $(hostSuffix) tokens
      # For more information see https://aka.ms/devspaces/routing
      - $(spacePrefix)$(rootSpacePrefix)webfrontend$(hostSuffix)
...
```

По умолчанию `prep` команда будет генерировать диаграмму Хелм. Он также устанавливает свойство *install.chart* в каталог диаграммы Helm. Если вы хотите использовать диаграмму Helm в другом месте, вы можете обновить это свойство, чтобы использовать это местоположение.

При установке диаграмм хелтов пробелы Azure Dev предоставляют способ переопределения значений в диаграмме Хелм. Значения по умолчанию для диаграммы Helm находятся в `charts/APP_NAME/values.yaml`.

Используя свойство *install.values,* можно перечислить один или несколько файлов, определяющих значения, которые вы хотите заменить в диаграмме Helm. Например, если при запуске приложения в пространстве разработчиков требуется конфигурация хоста или базы данных, вы можете использовать эту функцию переопределения. Вы также можете *добавить?* в конце любого из имен файлов, чтобы установить его в качестве факультативного.

Свойство *install.set* позволяет настроить одно или несколько значений, которые вы хотите заменить в диаграмме Helm. Любые значения, настроенные в *install.set,* переопределяют значения, настроенные в файлах, перечисленных в *install.values.* Свойства *под install.set* зависят от значений в диаграмме Helm и могут отличаться в зависимости от сгенерированной диаграммы Helm.

В приведенном выше примере свойство *install.set.replicaCount* сообщает контроллеру, сколько экземпляров приложения будет работать в пространстве разработчиков. В зависимости от сценария это значение может увеличиться, но это повлияет на присоединение отладчика к стручке приложения. Для получения дополнительной информации смотрите [статью по устранению неполадок][troubleshooting].

В сгенерированной диаграмме Helm изображение контейнера настроено на *«. Значения.image.repository : . Значения.image.tag .* Файл `azds.yaml` определяет свойство *install.set.image.tag* как *$(тег)* по умолчанию, которое используется в качестве значения для *. Значения.image.tag .* Таким образом, установив свойство *install.set.image.tag,* оно позволяет определенным образом отмечать изображение контейнера для приложения при запуске Azure Dev Spaces. В этом конкретном случае изображение помечается как * \<значение от image.repository>:$(тег)*. Необходимо использовать переменную *$(тега)* в качестве значения *install.set.image.tag* для того, чтобы Dev Spaces распознать и найти контейнер в кластере AKS.

В приведенном `azds.yaml` выше примере определяется *install.set.inress.hosts*. Свойство *install.set.inress.hosts* определяет формат имени хоста для общедоступных конечных точек. Это свойство также использует *$(spacePrefix)*, *$(rootSpacePrefix)* и *$(hostSuffix)*, которые являются значениями, предоставляемыми контроллером.

*$(spacePrefix)* — это название пространства для разработчиков, которое принимает форму *SPACENAME.s*. *$(rootSpacePrefix)* — это название родительского пространства. Например, если *azureuser* является детским пространством *по умолчанию,* значение для *$(rootSpacePrefix)* по *умолчанию,* а значение *$(spacePrefix)* является *azureuser.s.* Если пространство не является детским пространством, *$(spacePrefix)* является пустым. Например, если пространство *по умолчанию* не имеет родительского пространства, значение для *$(rootSpacePrefix)* по *умолчанию,* а значение *$(spacePrefix)* пусто. *$(hostSuffix)* — это суффикс DNS, который указывает на контроллер Azure Dev Spaces Ingress Controller, который работает в кластере AKS. Этот суффикс DNS соответствует, например, * \*подстановочный знак DNS. RANDOM_VALUE.eus.azds.io*, который был создан при добавлении в кластер AKS контроллерAzр Dev Spaces.

В приведенном выше `azds.yaml` файле можно также обновить *install.set.inress.hosts,* чтобы изменить название приложения. Например, если вы хотите упростить хост-имя вашего приложения от *$(spacePrefix)$(rootSpacePrefix)webfrontend$(hostSuffix)* до *$(spacePrefix)$(rootSpacePrefix)web$(hostSuffix)*.

Для создания контейнера для приложения контроллер использует ниже `azds.yaml` приведенные разделы файла конфигурации:

```yaml
build:
  context: .
  dockerfile: Dockerfile
...
configurations:
  develop:
    build:
      dockerfile: Dockerfile.develop
      useGitIgnore: true
      args:
        BUILD_CONFIGURATION: ${BUILD_CONFIGURATION:-Debug}
...
```

Контроллер использует Dockerfile для создания и запуска приложения.

Свойство *build.context* перечисляет каталог, в котором существуют Dockerfiles. Свойство *build.dockerfile* определяет название Dockerfile для создания производственной версии приложения. Свойство *configurations.develop.build.dockerfile* настраивает название Dockerfile для версии разработки приложения.

Наличие различных Dockerfiles для разработки и производства позволяет включить определенные вещи во время разработки и отключить эти элементы для развертывания производства. Например, можно включить отладку или более многословную вырубку во время разработки и отключить их в производственной среде. Вы также можете обновить эти свойства, если ваши Dockerfiles названы по-разному или находятся в другом месте.

Чтобы помочь вам быстро итерировать сяоретизацию во время разработки, Azure Dev Spaces синхронизирует изменения с локального проекта и постепенно обновляет приложение. Ниже приведенный `azds.yaml` раздел в файле конфигурации используется для настройки синхронизации и обновления:

```yaml
...
configurations:
  develop:
    ...
    container:
      sync:
      - "**/Pages/**"
      - "**/Views/**"
      - "**/wwwroot/**"
      - "!**/*.{sln,csproj}"
      command: [dotnet, run, --no-restore, --no-build, --no-launch-profile, -c, "${BUILD_CONFIGURATION:-Debug}"]
      iterate:
        processesToKill: [dotnet, vsdbg]
        buildCommands:
        - [dotnet, build, --no-restore, -c, "${BUILD_CONFIGURATION:-Debug}"]
...
```

Файлы и каталоги, которые будут синхронизировать изменения, перечислены в свойстве *configurations.develop.container.sync.* Эти каталоги сначала синхронизируются `up` при запуске команды, а также при обнаружении изменений. Если есть дополнительные или различные каталоги, которые вы хотели бы синхронизировать с вашим пространством разработчиков, вы можете изменить это свойство.

Свойство *configurations.develop.container.iterate.buildCommands* определяет, как построить приложение в сценарии разработки. Свойство *configurations.develop.container.command* предоставляет команду для запуска приложения в сценарии разработки. Вы можете обновить любой из этих свойств, если есть дополнительные флаги сборки или время выполнения или параметры, которые вы хотели бы использовать во время разработки.

*Configurations.develop.container.iterate.processesToKill* перечисляет процессы, чтобы убить, чтобы остановить приложение. Возможно, вы захотите обновить это свойство, если вы хотите изменить поведение перезапуска приложения во время разработки. Например, если вы обновили *configurations.develop.container.iterate.buildCommands* или *configurations.develop.container.command* свойства изменить способ создания или запуска приложения, возможно, потребуется изменить, какие процессы остановлены.

При подготовке `--enable-ingress` кода `azds prep` с помощью команды у вас есть возможность добавить флаг. Добавление `--enable-ingress` флага создает общедоступный URL-адрес для вашего приложения. Если вы не упускаете этот флаг, приложение доступно только в кластере или с помощью туннеля localhost. После выполнения `azds prep` команды можно изменить эту настройку, изменяющую `charts/APPNAME/values.yaml`свойство *inress.enabled* в:

```yaml
ingress:
  enabled: true
```

## <a name="next-steps"></a>Дальнейшие действия

Чтобы узнать больше о сети и о том, как маршрутизируются запросы в пространствах Azure Dev, см., [как маршрутизирование работает с пространствами Azure Dev.][how-it-works-routing]

Чтобы узнать больше об использовании Azure Dev Spaces для быстрой итерации и разработки, см., [как работает подключение компьютера разработки к пространству разработчиков][how-it-works-connect] и как работает [удаленная отладка кода с azure Dev Spaces.][how-it-works-remote-debugging]

Для начала использования Azure Dev Spaces для запуска проекта смотрите следующие быстрые запуски:

* [Быстро итерировать и отладить с Visual Studio code и Java][quickstart-java]
* [Быстро итерировать и отладить с визуальным кодом студии и .NET][quickstart-netcore]
* [Быстро итерировать и отладить с визуальным кодом студии и Node.js][quickstart-node]
* [Быстро итерировать и отладить с Visual Studio и .NET Core][quickstart-vs]
* [Использование CLI для разработки приложения на Kubernetes][quickstart-cli]


[azds-yaml-section]: #how-running-your-code-is-configured
[helm-upgrade]: https://helm.sh/docs/intro/using_helm/#helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure
[how-it-works-connect]: how-dev-spaces-works-connect.md
[how-it-works-prep]: how-dev-spaces-works-prep.md
[how-it-works-remote-debugging]: how-dev-spaces-works-remote-debugging.md
[how-it-works-routing]: how-dev-spaces-works-routing.md
[quickstart-cli]: quickstart-cli.md
[quickstart-java]: quickstart-java.md
[quickstart-netcore]: quickstart-netcore.md
[quickstart-node]: quickstart-nodejs.md
[quickstart-vs]: quickstart-netcore-visualstudio.md
[sync-section]: #file-synchronization
[troubleshooting]: troubleshooting.md