---
title: Использование CI/CD в Azure Dev Spaces
titleSuffix: Azure Dev Spaces
services: azure-dev-spaces
ms.service: azure-dev-spaces
author: DrEsteban
ms.author: stevenry
ms.date: 12/17/2018
ms.topic: conceptual
manager: yuvalm
description: Быстрая разработка в Kubernetes с использованием контейнеров и микрослужб в Azure
keywords: Docker, Kubernetes, Azure, AKS, Azure Container Service, containers
ms.openlocfilehash: 983af0dd75e6ae62630c85d04ac3819c7e260439
ms.sourcegitcommit: 41ca82b5f95d2e07b0c7f9025b912daf0ab21909
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "60687373"
---
# <a name="use-cicd-with-azure-dev-spaces"></a>Использование CI/CD в Azure Dev Spaces

Из этой статьи вы узнаете, как настроить непрерывную интеграцию и непрерывное развертывание (CI/CD) для Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces. CI/CD для AKS позволяет автоматически развертывать обновления приложений при каждой отправке зафиксированного кода в исходный репозиторий. Благодаря CI/CD и поддержке Dev Spaces кластер сохраняет актуальность базовых показателей приложения, чтобы разработчики могли работать с ними.

![Пример схемы CI/CD](../media/common/ci-cd-simple.png)

В этой статье описывается использование Azure DevOps, но те же принципы применяются и к другим системам непрерывной интеграции и непрерывного развертывания, таким как Jenkins, TeamCity и т. д.

## <a name="prerequisites"></a>Технические условия
* [Кластер Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces](../get-started-netcore.md).
* [Установленный интерфейс командной строки Azure Dev Spaces](upgrade-tools.md).
* [Организация Azure DevOps с проектом](https://docs.microsoft.com/azure/devops/user-guide/sign-up-invite-teammates?view=vsts).
* [Реестр контейнеров Azure (ACR)](../../container-registry/container-registry-get-started-azure-cli.md).
    * Доступные данные [учетной записи администратора](../../container-registry/container-registry-authentication.md#admin-account) Реестра контейнеров Azure.
* [Кластер AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../container-registry/container-registry-auth-aks.md).

## <a name="download-sample-code"></a>Скачивание примера кода
Ради экономии времени создадим вилку примера кода из репозитория GitHub. Перейдите на страницу https://github.com/Azure/dev-spaces и щелкните **Fork** (Вилка). После создания вилки **клонируйте** версию вилки репозитория локально. По умолчанию будет извлечена ветвь _master_, но мы включили несколько изменений в ветвь _azds_updates_, которую также следует перенести во время создания вилки. Эти изменения позволят сэкономить время. Ветвь _azds_updates_ содержит обновления, которые следует внести вручную, как описано в разделах руководства по Dev Spaces, а также некоторые готовые файлы YAML и JSON для оптимизации развертывания системы CI/CD. С помощью команды `git checkout -b azds_updates origin/azds_updates` можно извлечь ветвь _azds_updates_ в локальном репозитории.

## <a name="dev-spaces-setup"></a>Настройка Dev Spaces
Создайте новое пространство с именем _dev_ с помощью команды `azds space select`. Ваш конвейер CI/CD будет использовать пространство _dev_ для передачи изменений кода. Также оно будет использоваться для создания _дочерних пространств_ на основе _dev_.

```cmd
azds space select -n dev
```

При появлении запроса на выбор родительского пространства выберите _\<none\>_ .

После создания модуля разработки, необходимо определить суффикс узла. Используйте `azds show-context` команду, чтобы показать суффикс узла контроллеру входящего трафика Azure Dev пробелы.

```cmd
$ azds show-context
Name   ResourceGroup    DevSpace  HostSuffix
-----  ---------------  --------  ----------------------
MyAKS  MyResourceGroup  dev       fedcba098.eus.azds.io
```

В приведенном выше примере используется суффикс узла _fedcba098.eus.azds.io_. Это значение используется позже при создании определения выпуска.

Пространство _dev_ всегда будет содержать последнее состояние репозитория — базовое значение. Таким образом, разработчики могут создавать _дочерние пространства_ на основе _dev_ для тестирования отдельных изменений в контексте приложения большего размера. Эта концепция более подробно описана в руководствах по Dev Spaces.

## <a name="creating-the-build-definition"></a>Создание определения сборки
Откройте командный проект Azure DevOps в веб-браузере и перейдите в раздел _Pipelines_ (Конвейеры). Сначала щелкните фотографию профиля в правом верхнем углу на сайте Azure DevOps, откройте панель предварительной версии функций и отключите параметр _Новый интерфейс для создания конвейеров YAML_:

![Панель предварительной версии функций](../media/common/preview-feature-open.png)

Отключение параметра:

![Параметр "Новый интерфейс для создания конвейеров YAML"](../media/common/yaml-pipeline-preview-feature.png)

> [!Note]
> Сейчас предварительная версия функции Azure DevOps _Новый интерфейс для создания конвейеров YAML_ конфликтует с созданием предварительно определенных конвейеров сборки. Прежде чем развернуть предварительно определенный конвейер сборки, необходимо отключить эту функцию.

Мы включили в ветвь _azds_updates_ простую схему [YAML конвейеров Azure](https://docs.microsoft.com/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema), которая определяет необходимые шаги для сборки *mywebapi* и *webfrontend*.

В зависимости от выбранного языка схема YAML конвейера извлекается в путь, схожий со следующим: `samples/dotnetcore/getting-started/azure-pipelines.dotnetcore.yml`

Чтобы создать конвейер из этого файла, сделайте следующее:
1. На главной странице проекта DevOps, перейдите к конвейеры > сборок.
1. Выберите параметр, чтобы создать **New** конвейера сборки.
1. Выберите **GitHub** как источник, авторизовать с помощью учетной записи GitHub в случае необходимости и выберите _azds_updates_ ветвь из версии разветвленного репозитория sampleapp разработки пробелы.
1. Выберите **конфигурация как код**, или **YAML**, как шаблон.
1. Теперь появится страница конфигурации для конвейера сборки. Как упоминалось выше, перейдите по пути для конкретного языка **путь к файлу YAML** с помощью **...**  кнопки. Например, `samples/dotnetcore/getting-started/azure-pipelines.dotnet.yml`.
1. Перейдите к **переменных** вкладки.
1. Вручную добавьте _dockerId_ в качестве переменной, которая является именем пользователя вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account) (см. предварительные требования в начале статьи).
1. Вручную добавьте _dockerPassword_ в качестве переменной, которая является паролем вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account). Не забудьте указать _dockerPassword_ в качестве секрета (щелкнув значок замка) в целях безопасности.
1. Выберите **сохранить и поместить в очередь**.

Теперь у вас есть решение непрерывной интеграции, которое автоматически выполняет сборку *mywebapi* и *webfrontend* для любого обновления, отправленного в ветвь _azds_updates_ вилки GitHub. Вы можете проверить, перейдя на портал Azure, выбрав реестр контейнеров Azure и просмотр отправленных образов Docker **репозиториев** вкладки. Он может занять несколько минут для образов для создания и отображаются в реестр контейнеров.

![Репозитории Реестра контейнеров Azure](../media/common/ci-cd-images-verify.png)

## <a name="creating-the-release-definition"></a>Создание определения выпуска

1. На главной странице проекта DevOps последовательно выберите Pipelines (Конвейеры) > Releases (Выпуски).
1. Если вы работаете в новом проекте DevOps, который еще не содержит определение выпуска, необходимо сначала создать пустое определение выпуска. Параметр "Импорт" не отображается в пользовательском интерфейсе, пока не появится существующее определение выпуска.
1. С левой стороны экрана щелкните **+ создать** кнопку, а затем щелкните **импорта конвейер**.
1. Нажмите кнопку **Обзор** и выберите `samples/release.json` из проекта.
1. Последовательно выберите **ОК**. Обратите внимание, что панель конвейера загрузилась со страницей редактирования определения выпуска. Также обратите внимание на красные значки предупреждения, указывающие на связанные с кластером сведения, которые должны быть настроены.
1. В левой части панели конвейера щелкните кружок **Добавить артефакт**.
1. В **источника** раскрывающийся список, выберите сборку конвейера, созданную ранее.
1. Для **версия по умолчанию**, выберите **последний из ветви по умолчанию конвейер сборки с тегами**.
1. Оставьте **теги** пустой.
1. Для параметра **Псевдоним источника** укажите `drop`. **Псевдоним источника** значение используется задачами предопределенные выпуска, поэтому его необходимо установить.
1. Щелкните **Добавить**.
1. Теперь щелкните значок молнии на только что созданном источнике артефакта `drop`, как показано ниже:

    ![Настройка непрерывного развертывания артефакта выпуска](../media/common/release-artifact-cd-setup.png)
1. Включить **триггер непрерывного развертывания**.
1. Наведите указатель мыши **задачи** вкладке рядом с полем **конвейера** и нажмите кнопку _разработки_ изменение _разработки_ этапа задачи.
1. Проверьте **Azure Resource Manager** выбранного в пункте **тип соединения.** и вы увидите три раскрывающихся списков, выделены красным цветом: ![Настройка определения выпуска](../media/common/release-setup-tasks.png)
1. Выберите подписку Azure, которую вы используете Azure Dev пробелов. Также может потребоваться щелкните **Authorize**.
1. Выберите группу ресурсов и кластера, которую вы используете Azure Dev пробелов.
1. Щелкните **задание агента**.
1. Выберите **размещенных Ubuntu 1604** под **пул агентов**.
1. Наведите указатель мыши **задачи** щелкните селектор в верхней, _prod_ изменение _prod_ этапа задачи.
1. Проверьте **Azure Resource Manager** выбранного в пункте **тип соединения.** и выберите подписку Azure, группу ресурсов и кластера, которую вы используете Azure Dev пробелов.
1. Щелкните **задание агента**.
1. Выберите **размещенных Ubuntu 1604** под **пул агентов**.
1. Нажмите кнопку **переменных** вкладку, чтобы обновить переменные для выпуска.
1. Обновите значение **DevSpacesHostSuffix** из **UPDATE_ME** суффиксу вашего узла. Суффикс узла отображается в том случае, если вы запустили `azds show-context` команды ранее.
1. Нажмите кнопку **Сохранить** в правом верхнем углу и кнопку **ОК**.
1. Щелкните **+ Выпуск** (рядом с кнопкой "Сохранить") и **Создать выпуск**.
1. В разделе **артефакты**, должен быть выбран последней сборки из конвейера сборки.
1. Нажмите кнопку **Создать**.

Теперь начнется процесс автоматического выпуска и развертывание диаграмм *mywebapi* и *webfrontend* в кластер Kubernetes в пространстве верхнего уровня _dev_. Можно отслеживать ход выполнения выпуска на веб-портале DevOps в Azure:

1. Перейдите к **выпуски** раздел **конвейеры**.
1. Щелкните конвейер выпуска для примера приложения.
1. Щелкните имя последней версии.
1. Наведите указатель мыши **разработки** поле в разделе **этапы** и нажмите кнопку **журналы**.

Выпуск выполняется после выполнения всех задач.

> [!TIP]
> Если выпуск завершается сбоем с сообщением об ошибке, например *UPGRADE FAILED: timed out waiting for the condition* (НЕ УДАЛОСЬ ОБНОВИТЬ: истекло время ожидания условия), проверьте объекты pod в кластере [с помощью панели мониторинга Kubernetes](../../aks/kubernetes-dashboard.md). Если возникают ошибки при запуске объектов pod, такие как *Failed to pull image "azdsexample.azurecr.io/mywebapi:122": rpc error: code = Unknown desc = Error response from daemon: Get https://azdsexample.azurecr.io/v2/mywebapi/manifests/122: unauthorized: authentication required*, возможно, ваш кластер не авторизован для извлечения данных из Реестра контейнеров Azure. Убедитесь, что предварительное требование о наличии [кластера AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../container-registry/container-registry-auth-aks.md) выполнено.

Теперь у вас есть полностью автоматизированный конвейер CI/CD для вилки GitHub примеров приложений Dev Spaces. Каждый раз при фиксации и отправке кода конвейер сборки будет создавать и отправлять образы *mywebapi* и *webfrontend* в ваш экземпляр ACR. Затем конвейер выпуска будет развертывать диаграмму Helm для каждого приложения в пространстве _dev_ кластера с поддержкой Dev Spaces.

## <a name="accessing-your-dev-services"></a>Доступ к службе _dev_
После развертывания доступ к _dev_-версии *webfrontend* может осуществляться с общедоступного URL-адреса, например `http://dev.webfrontend.fedcba098.eus.azds.io`. Этот URL-адрес можно найти, выполнив `azds list-uri` команды: 

```cmd
$ azds list-uris

Uri                                           Status
--------------------------------------------  ---------
http://dev.webfrontend.fedcba098.eus.azds.io  Available
```

## <a name="deploying-to-production"></a>Развертывание в рабочей среде

Чтобы вручную повысить уровень определенного выпуска до _prod_ в системе CI/CD, созданной в этом руководстве, выполните следующие действия:
1. Перейдите к **выпуски** раздел **конвейеры**.
1. Щелкните конвейер выпуска для примера приложения.
1. Щелкните имя последней версии.
1. Наведите указатель мыши **prod** поле в разделе **этапы** и нажмите кнопку **развернуть**.
    ![Распространение в рабочей среде](../media/common/prod-promote.png)
1. Наведите указатель мыши **prod** снова поле в разделе **этапы** и нажмите кнопку **журналы**.

Выпуск выполняется после выполнения всех задач.

_Prod_ этапа конвейера Непрерывной интеграции и используется балансировщик нагрузки вместо контроллера входящего трафика пробелы разработки для предоставления доступа к _prod_ служб. В развертывании служб _prod_ рабочей области доступны в виде IP-адреса вместо DNS-имен. В рабочей среде вы можете создать собственные контроллера входящего трафика для размещения служб на основе собственные конфигурации DNS.

Чтобы определить IP-адрес службы webfrontend, нажмите на **печати общедоступный IP-адрес webfrontend** шаг, чтобы развернуть выходные данные журнала. Использовать IP-адрес, отображаемый в журнале выходных данных для доступа к **webfrontend** приложения.

```cmd
...
2019-02-25T22:53:02.3237187Z webfrontend can be accessed at http://52.170.231.44
2019-02-25T22:53:02.3320366Z ##[section]Finishing: Print webfrontend public IP
...
```

## <a name="dev-spaces-instrumentation-in-production"></a>Инструментирование Dev Spaces в рабочей среде
Хотя инструментирование Dev Spaces создавалось, чтобы _не_ препятствовать нормальной работе вашего приложения, мы рекомендуем запускать рабочие нагрузки для рабочих сред в пространстве имен Kubernetes, которое не поддерживает Dev Spaces. С этим типом пространства имен Kubernetes вам следует либо создать пространство имен для рабочей среды с помощью интерфейса командной строки `kubectl`, либо разрешить системе CI/CD создать его при первом развертывании Helm. _Выбрав_ или создав пространство с помощью инструментов Dev Spaces, вы таким образом добавите инструментирование Dev Spaces в это пространство имен.

Ниже приведен пример структуры пространства имен, которая поддерживает разработку функций, среду "dev" _и_ рабочую среду в одном кластере Kubernetes:

![Пример структуры пространства имен](../media/common/cicd-namespaces.png)

> [!Tip]
> Если вы уже создали пространство `prod` и хотите исключить его из инструментирования Dev Spaces (но не удалять!), это можно сделать с помощью приведенной ниже команды в интерфейсе командной строки Dev Spaces:
>
> `azds space remove -n prod --no-delete`
>
> После этого может потребоваться удалить все объекты pod в пространстве имен `prod`, чтобы их можно было воссоздать без инструментирования Dev Spaces.

## <a name="next-steps"></a>Дальнейшие действия

> [!div class="nextstepaction"]
> [Сведения о коллективной разработке с помощью Azure Dev Spaces](../team-development-netcore.md)