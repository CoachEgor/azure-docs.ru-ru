---
title: Использование CI/CD в Azure Dev Spaces
services: azure-dev-spaces
author: DrEsteban
ms.author: stevenry
ms.date: 12/17/2018
ms.topic: conceptual
manager: gwallace
description: Узнайте, как настроить непрерывную интеграцию/непрерывное развертывание с помощью Azure DevOps с Azure Dev Spaces
keywords: Docker, Kubernetes, Azure, AKS, Azure Container Service, containers
ms.openlocfilehash: f2eb9449518b32ab74f2dbbca6b5489aed325db7
ms.sourcegitcommit: acb82fc770128234f2e9222939826e3ade3a2a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/21/2020
ms.locfileid: "81685638"
---
# <a name="use-cicd-with-azure-dev-spaces"></a>Использование CI/CD в Azure Dev Spaces

Из этой статьи вы узнаете, как настроить непрерывную интеграцию и непрерывное развертывание (CI/CD) для Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces. CI/CD для AKS позволяет автоматически развертывать обновления приложений при каждой отправке зафиксированного кода в исходный репозиторий. Благодаря CI/CD и поддержке Dev Spaces кластер сохраняет актуальность базовых показателей приложения, чтобы разработчики могли работать с ними.

![Пример схемы CI/CD](../media/common/ci-cd-simple.png)

В этой статье описывается использование Azure DevOps, но те же принципы применяются и к другим системам непрерывной интеграции и непрерывного развертывания, таким как Jenkins, TeamCity и т. д.

## <a name="prerequisites"></a>Предварительные требования
* [Кластер Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces](../get-started-netcore.md).
* [Установленный интерфейс командной строки Azure Dev Spaces](upgrade-tools.md).
* [Организация Azure DevOps с проектом](https://docs.microsoft.com/azure/devops/user-guide/sign-up-invite-teammates?view=vsts).
* [Реестр контейнеров Azure (ACR)](../../container-registry/container-registry-get-started-azure-cli.md).
    * Доступные данные [учетной записи администратора](../../container-registry/container-registry-authentication.md#admin-account) Реестра контейнеров Azure.
* [Кластер AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../aks/cluster-container-registry-integration.md).

## <a name="download-sample-code"></a>Скачивание примера кода
Ради экономии времени создадим вилку примера кода из репозитория GitHub. Перейдите на страницу https://github.com/Azure/dev-spaces и щелкните **Fork** (Вилка). После создания вилки **клонируйте** версию вилки репозитория локально. По умолчанию будет извлечена ветвь _master_, но мы включили несколько изменений в ветвь _azds_updates_, которую также следует перенести во время создания вилки. Эти изменения позволят сэкономить время. Ветвь _azds_updates_ содержит обновления, которые следует внести вручную, как описано в разделах руководства по Dev Spaces, а также некоторые готовые файлы YAML и JSON для оптимизации развертывания системы CI/CD. С помощью команды `git checkout -b azds_updates origin/azds_updates` можно извлечь ветвь _azds_updates_ в локальном репозитории.

## <a name="dev-spaces-setup"></a>Настройка Dev Spaces
Создайте новое пространство с именем _dev_ с помощью команды `azds space select`. Ваш конвейер CI/CD будет использовать пространство _dev_ для передачи изменений кода. Также оно будет использоваться для создания _дочерних пространств_ на основе _dev_.

```cmd
azds space select -n dev
```

При выборе пространства для родительских разработчиков выберите _ \<ни одного.\>_

После того, как ваше пространство dev было создано, вам нужно определить суффикс хозяина. Используйте `azds show-context` команду, чтобы показать суффикс хоста контроллера Azure Dev Spaces Ingress.

```cmd
$ azds show-context
Name   ResourceGroup    DevSpace  HostSuffix
-----  ---------------  --------  ----------------------
MyAKS  MyResourceGroup  dev       fedcba098.eus.azds.io
```

В приведенном выше примере суффикс хоста _fedcba098.eus.azds.io_. Это значение используется позже при создании определения выпуска.

Пространство _dev_ всегда будет содержать последнее состояние репозитория — базовое значение. Таким образом, разработчики могут создавать _дочерние пространства_ на основе _dev_ для тестирования отдельных изменений в контексте приложения большего размера. Эта концепция более подробно описана в руководствах по Dev Spaces.

## <a name="creating-the-build-definition"></a>Создание определения сборки
Откройте командный проект Azure DevOps в веб-браузере и перейдите в раздел _Pipelines_ (Конвейеры). Сначала щелкните фотографию профиля в правом верхнем углу на сайте Azure DevOps, откройте панель предварительной версии функций и отключите параметр _Новый интерфейс для создания конвейеров YAML_:

![Панель предварительной версии функций](../media/common/preview-feature-open.png)

Отключение параметра:

![Параметр "Новый интерфейс для создания конвейеров YAML"](../media/common/yaml-pipeline-preview-feature.png)

> [!Note]
> Сейчас предварительная версия функции Azure DevOps _Новый интерфейс для создания конвейеров YAML_ конфликтует с созданием предварительно определенных конвейеров сборки. Прежде чем развернуть предварительно определенный конвейер сборки, необходимо отключить эту функцию.

Мы включили в ветвь _azds_updates_ простую схему [YAML конвейеров Azure](https://docs.microsoft.com/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema), которая определяет необходимые шаги для сборки *mywebapi* и *webfrontend*.

В зависимости от выбранного языка схема YAML конвейера извлекается в путь, схожий со следующим: `samples/dotnetcore/getting-started/azure-pipelines.dotnetcore.yml`

Чтобы создать конвейер из этого файла, сделайте следующее:
1. На главной странице проекта DevOps перейдите на > сборки трубопроводов.
1. Выберите опцию для создания конвейера **новой** сборки.
1. Выберите **GitHub** в качестве источника, авторизуйте свою учетную запись GitHub, если это необходимо, и выберите _azds_updates_ ветку из разднельной версии репозитория образца _применения dev-spaces._
1. Выберите **Configuration в качестве кода,** или **YAML**, в качестве шаблона.
1. Теперь появится страница конфигурации для конвейера сборки. Как уже упоминалось выше, перейдите к конкретному пути для **файла YAML с** помощью **...** Например, `samples/dotnetcore/getting-started/azure-pipelines.dotnet.yml`.
1. Перейдите на вкладку **Переменные.**
1. Вручную добавьте _dockerId_ в качестве переменной, которая является именем пользователя вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account) (см. предварительные требования в начале статьи).
1. Вручную добавьте _dockerPassword_ в качестве переменной, которая является паролем вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account). Не забудьте указать _dockerPassword_ в качестве секрета (щелкнув значок замка) в целях безопасности.
1. Выберите **очередь Сохранить &.**

Теперь у вас есть решение непрерывной интеграции, которое автоматически выполняет сборку *mywebapi* и *webfrontend* для любого обновления, отправленного в ветвь _azds_updates_ вилки GitHub. Вы можете проверить, что изображения Докера были перемещены, перенаправившись на портал Azure, выбрав реестр контейнеров Azure и просмотр вкладки **Репозитории.** Создание изображений может занять несколько минут.

![Репозитории Реестра контейнеров Azure](../media/common/ci-cd-images-verify.png)

## <a name="creating-the-release-definition"></a>Создание определения выпуска

1. На главной странице проекта DevOps последовательно выберите Pipelines (Конвейеры) > Releases (Выпуски).
1. Если вы работаете в новом проекте DevOps, который еще не содержит определение выпуска, необходимо сначала создать пустое определение выпуска. Параметр "Импорт" не отображается в пользовательском интерфейсе, пока не появится существующее определение выпуска.
1. Слева щелкните **новую** кнопку **«Импорт».**
1. Нажмите **Просмотр** и выберите `samples/release.json` из вашего проекта.
1. Нажмите кнопку **ОК**. Обратите внимание, что панель конвейера загрузилась со страницей редактирования определения выпуска. Также обратите внимание на красные значки предупреждения, указывающие на связанные с кластером сведения, которые должны быть настроены.
1. В левой части панели конвейера щелкните кружок **Добавить артефакт**.
1. При выпадении **исхода** выберите созданный ранее конвейер сборки.
1. Для **версии по умолчанию**выберите **последнюю из ветки по умолчанию сборки с тегами.**
1. Оставьте **теги пустыми.**
1. Для параметра **Псевдоним источника** укажите `drop`. Значение **псевдонима Source** используется предопределенными задачами выпуска, поэтому оно должно быть установлено.
1. Нажмите кнопку **Добавить**.
1. Теперь щелкните значок молнии на только что созданном источнике артефакта `drop`, как показано ниже:

    ![Настройка непрерывного развертывания артефакта выпуска](../media/common/release-artifact-cd-setup.png)
1. Включить **триггер непрерывного развертывания.**
1. Нависните над вкладкой **«Задачи»** рядом с **Pipeline** и нажмите _«Дев»_ для отсеивании задач стадии _разработки._
1. Проверка **менеджера ресурсов Azure** выбрана в **типе подключения.** и вы видите три управления выпадения ![выделены красным цветом: Установка определения выпуска](../media/common/release-setup-tasks.png)
1. Выберите подписку Azure, используемую с помощью Azure Dev Spaces. Вам также может понадобиться нажать **Authorize.**
1. Выберите группу ресурсов и кластер, который вы используете с azure Dev Spaces.
1. Нажмите на **работу агента**.
1. Выберите **Hosted Ubuntu 1604** под **пулом Агента.**
1. Нависает над селекторами **задач** в верхней части, нажмите _prod,_ чтобы отсеить задачи _prod_ этапе.
1. Проверка **менеджера ресурсов Azure** выбрана в **типе подключения.** и выберите подписку Azure, группу ресурсов и кластер, который вы используете в Azure Dev Spaces.
1. Нажмите на **работу агента**.
1. Выберите **Hosted Ubuntu 1604** под **пулом Агента.**
1. Нажмите на вкладку **Переменные,** чтобы обновить переменные для выпуска.
1. Обновите значение **DevSpacesHostSuffix** от **UPDATE_ME** к вашему суффиксу хозяина. Суффикс хоста отображается при `azds show-context` предыдущем вымотке команды.
1. Нажмите кнопку **Сохранить** в правом верхнем углу и кнопку **ОК**.
1. Щелкните **+ Выпуск** (рядом с кнопкой "Сохранить") и **Создать выпуск**.
1. Под **Artifacts**проверьте выбранную последнюю сборку из конвейера сборки.
1. Нажмите кнопку **Создать**.

Теперь начнется процесс автоматического выпуска и развертывание диаграмм *mywebapi* и *webfrontend* в кластер Kubernetes в пространстве верхнего уровня _dev_. Вы можете следить за ходом выпуска на веб-портале Azure DevOps:

1. Перейдите к разделу **Релизы** под **трубопроводами**.
1. Нажмите на конвейер выпуска для примера приложения.
1. Нажмите на название последнего релиза.
1. Нависает над **коробкой для разработчиков** под **этапами** и щелкните **журналы**.

Выпуск выполняется, когда все задачи завершены.

> [!TIP]
> Если выпуск завершается сбоем с сообщением об ошибке, например *UPGRADE FAILED: timed out waiting for the condition* (НЕ УДАЛОСЬ ОБНОВИТЬ: истекло время ожидания условия), проверьте объекты pod в кластере [с помощью панели мониторинга Kubernetes](../../aks/kubernetes-dashboard.md). Если вы видите, что стручки не могут начаться с сообщений об ошибках, таких как *Failed to pull image "azdsexample.azurecr.io/mywebapi:122": ошибка rpc: код - неизвестный desc - Ответ на ошибку от daemon: Get https:\//azdsexample.azurecr.io/v2/mywebapi/manifests/122: несанкционированная: требуется аутентификация,* это может быть связано с тем, что ваш кластер не был уполномочен вытягивать из вашего реестра контейнеров Azure. Убедитесь, что предварительное требование о наличии [кластера AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../aks/cluster-container-registry-integration.md) выполнено.

Теперь у вас есть полностью автоматизированный конвейер CI/CD для вилки GitHub примеров приложений Dev Spaces. Каждый раз при фиксации и отправке кода конвейер сборки будет создавать и отправлять образы *mywebapi* и *webfrontend* в ваш экземпляр ACR. Затем конвейер выпуска будет развертывать диаграмму Helm для каждого приложения в пространстве _dev_ кластера с поддержкой Dev Spaces.

## <a name="accessing-your-_dev_-services"></a>Доступ к службе _dev_
После развертывания доступ к _dev_-версии *webfrontend* может осуществляться с общедоступного URL-адреса, например `http://dev.webfrontend.fedcba098.eus.azds.io`. Вы можете найти этот `azds list-uri` URL, запустив команду: 

```cmd
$ azds list-uris

Uri                                           Status
--------------------------------------------  ---------
http://dev.webfrontend.fedcba098.eus.azds.io  Available
```

## <a name="deploying-to-production"></a>Развертывание в рабочей среде

Чтобы вручную повысить уровень определенного выпуска до _prod_ в системе CI/CD, созданной в этом руководстве, выполните следующие действия:
1. Перейдите к разделу **Релизы** под **трубопроводами**.
1. Нажмите на конвейер выпуска для примера приложения.
1. Нажмите на название последнего релиза.
1. Навистенад над **prod** поле под **этапами** и нажмите **Развертывание**.
    ![Повышение уровня до рабочей среды](../media/common/prod-promote.png)
1. Нависает над **prod** поле снова под **этапы** и нажмите **журналы**.

Выпуск выполняется, когда все задачи завершены.

_Prod_ этап конвейера CI/CD использует балансировщик нагрузки вместо контроллера Dev Spaces Ingress для обеспечения доступа к _службам prod._ Службы, развернутые на этапе _prod,_ доступны в виде IP-адресов, а не имен DNS. В производственной среде вы можете создать свой собственный контроллер Ingress для размещения ваших служб на основе собственной конфигурации DNS.

Чтобы определить IP службы webfrontend, нажмите на шаг **публичного IP-адреса Print webfrontend,** чтобы расширить выход журнала. Используйте IP, отображаемый на выходе журнала, чтобы получить доступ к приложению **webfrontend.**

```cmd
...
2019-02-25T22:53:02.3237187Z webfrontend can be accessed at http://52.170.231.44
2019-02-25T22:53:02.3320366Z ##[section]Finishing: Print webfrontend public IP
...
```

## <a name="dev-spaces-instrumentation-in-production"></a>Инструментирование Dev Spaces в рабочей среде
Хотя инструментирование Dev Spaces создавалось, чтобы _не_ препятствовать нормальной работе вашего приложения, мы рекомендуем запускать рабочие нагрузки для рабочих сред в пространстве имен Kubernetes, которое не поддерживает Dev Spaces. С этим типом пространства имен Kubernetes вам следует либо создать пространство имен для рабочей среды с помощью интерфейса командной строки `kubectl`, либо разрешить системе CI/CD создать его при первом развертывании Helm. _Выбрав_ или создав пространство с помощью инструментов Dev Spaces, вы таким образом добавите инструментирование Dev Spaces в это пространство имен.

Ниже приведен пример структуры пространства имен, которая поддерживает разработку функций, среду "dev" _и_ рабочую среду в одном кластере Kubernetes:

![Пример структуры пространства имен](../media/common/cicd-namespaces.png)

> [!Tip]
> Если вы уже создали пространство `prod` и хотите исключить его из инструментирования Dev Spaces (но не удалять!), это можно сделать с помощью приведенной ниже команды в интерфейсе командной строки Dev Spaces:
>
> `azds space remove -n prod --no-delete`
>
> После этого может потребоваться удалить все объекты pod в пространстве имен `prod`, чтобы их можно было воссоздать без инструментирования Dev Spaces.

## <a name="next-steps"></a>Следующие шаги

> [!div class="nextstepaction"]
> [Сведения о коллективной разработке с помощью Azure Dev Spaces](../team-development-netcore.md)