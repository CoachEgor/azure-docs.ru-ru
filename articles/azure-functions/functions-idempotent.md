---
title: Проектирование функций Azure для идентичных входных данных
description: Создание идемпотентными функций Azure
author: craigshoemaker
ms.author: cshoe
ms.date: 9/12/2019
ms.topic: article
ms.service: azure-functions
manager: gwallace
ms.openlocfilehash: 39e785a1ca7a158ddb90a3e6ba914582c405612a
ms.sourcegitcommit: 1752581945226a748b3c7141bffeb1c0616ad720
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2019
ms.locfileid: "70997397"
---
# <a name="designing-azure-functions-for-identical-input"></a>Проектирование функций Azure для идентичных входных данных

Реальность, основанная на событиях и архитектуре на основе сообщений, определяет необходимость принятия идентичных запросов при сохранении целостности данных и стабильности системы.

Для иллюстрации рассмотрим кнопку лифтного вызова. По мере нажатия кнопки она высветится, и в этаж будет отправлен Лифт. Чуть позже, кто-то другой Присоединяйтесь к вам в зале ожидания. Этот человек имеет свое значение и нажимает кнопку с освещением во второй раз. Вы не захотите, чтобы вы чуккле, что команда для вызова лифта — идемпотентными.

Нажатие кнопки лифта в качестве второго, третьего или четвертого времени не повлияет на окончательный результат. При нажатии кнопки, независимо от числа раз, Лифт посылается в пол. Идемпотентными Systems, как в лифте, приводят к тому же результату независимо от того, сколько раз выдаются идентичные команды.

Когда дело доходит до создания приложений, учитывайте следующие сценарии.

- Что произойдет, если приложение управления запасами попытается удалить один и тот же продукт несколько раз?
- Как работает приложение-персонал, если существует несколько запросов на создание записи сотрудника для одного и того же человека?
- Где происходит возврат денег, если приложение банковской работы получает 100 запросов для получения того же изъятия?

Существует много контекстов, в которых запросы к функции могут принимать идентичные команды. Ниже перечислены некоторые ситуации.

- Политики повтора, отправляющие один и тот же запрос несколько раз
- Кэшированные команды, воспроизводимые в приложении
- Ошибки приложения при отправке нескольких идентичных запросов

Для защиты целостности данных и работоспособности системы приложение идемпотентными содержит логику, которая может содержать следующие варианты поведения:

- Проверка существования данных перед попыткой выполнить удаление
- Проверка наличия данных перед попыткой выполнить действие создания
- Согласование логики, которая создает окончательную согласованность данных
- Элементы управления параллелизмом
- Обнаружение дубликатов
- Проверка актуальности данных
- Логика защиты для проверки входных данных

В конечном итоге идемпотентности достигается путем обеспечения возможности выполнения определенного действия и выполняется только один раз.
