---
title: Проектирование функций Azure для идентичных входных
description: Создание функций Azure будет идемпотентным
author: craigshoemaker
ms.author: cshoe
ms.date: 9/12/2019
ms.topic: article
ms.openlocfilehash: 15af60ac5a862e6fb20e65ba6fbb92482420b7c0
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74226875"
---
# <a name="designing-azure-functions-for-identical-input"></a>Проектирование функций Azure для идентичных входных

Реальность архитектуры, основанной на событиях и основанных на сообщениях, диктует необходимость принятия идентичных запросов при сохранении целостности данных и стабильности системы.

Чтобы проиллюстрировать, рассмотрим кнопку вызова лифта. При нажатии кнопки она загорается и лифт отправляется на ваш этаж. Несколько мгновений спустя, кто-то другой присоединяется к вам в вестибюле. Этот человек улыбается вам и нажимает на освещенную кнопку во второй раз. Вы улыбаетесь в ответ и посмеиваться над собой, как вы напомнили, что команда позвонить лифт является идемпотент.

Нажатие кнопки вызова лифта второй, третий или четвертый раз не влияет на конечный результат. При нажатии кнопки, независимо от количества раз, лифт отправляется на ваш этаж. Интеллектуальные системы, такие как лифт, приводят к тому же результату независимо от того, сколько раз выдаются одинаковые команды.

Когда дело доходит до создания приложений, рассмотрим следующие сценарии:

- Что произойдет, если приложение управления запасами попытается удалить один и тот же продукт более одного раза?
- Как ведет себя ваше приложение для управления людскими ресурсами, если существует несколько запросов на создание записи сотрудника для одного и того же человека?
- Куда уходят деньги, если ваше банковское приложение получает 100 запросов, чтобы сделать тот же вывод?

Существует много контекстов, в которых запросы на функцию могут получать одинаковые команды. Некоторые ситуации включают в себя:

- Политики повторного выполнения одного и того же запроса много раз
- Кэшированные команды воспроизведены в приложении
- Ошибки приложения отправки нескольких идентичных запросов

Для защиты целостности данных и работоспособности системы приложение idempotent содержит логику, которая может содержать следующие поведения:

- Проверка наличия данных перед попыткой выполнить удаление
- Проверка того, существуют ли данные, перед попыткой выполнения действия create
- Согласование логики, которая создает конечную согласованность данных
- Контроль параллелизма
- Обнаружение дублирования
- Проверка свежести данных
- Логика защиты для проверки входных данных

В конечном счете, идемпотенция достигается путем обеспечения возможности того или иного действия и выполняется только один раз.
