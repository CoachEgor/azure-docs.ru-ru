---
title: Пользовательские обработчики функций Azure (Предварительная версия)
description: Узнайте, как использовать функции Azure с любым языком или версией среды выполнения.
author: craigshoemaker
ms.author: cshoe
ms.date: 3/18/2020
ms.topic: article
ms.openlocfilehash: 5abc216e182d7becd9d6f42e0f566ee96d09c2a5
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "79479258"
---
# <a name="azure-functions-custom-handlers-preview"></a>Пользовательские обработчики функций Azure (Предварительная версия)

Каждое приложение функций выполняется обработчиком конкретного языка. Хотя функции Azure поддерживают много [языковых обработчиков](./supported-languages.md) по умолчанию, в некоторых случаях может потребоваться дополнительный контроль над средой выполнения приложений. Пользовательские обработчики предоставляют этот дополнительный элемент управления.

Пользовательские обработчики — это упрощенные веб-серверы, которые получают события от узла функций. Любой язык, поддерживающий примитивы HTTP, может реализовать пользовательский обработчик.

Пользовательские обработчики лучше всего подходят для ситуаций, в которых вы хотите:

- Реализуйте приложение функций на языке, не превышающем официально поддерживаемые языки
- Реализация приложения-функции в языковой версии или во время выполнения не поддерживается по умолчанию
- Детальный контроль над средой выполнения приложений

С помощью пользовательских обработчиков все [триггеры и входные и выходные привязки](./functions-triggers-bindings.md) поддерживаются через [пакеты расширений](./functions-bindings-register.md).

## <a name="overview"></a>Обзор

На следующей схеме показана связь между узлом функций и веб-сервером, реализованным как пользовательский обработчик.

![Общие сведения о пользовательском обработчике функций Azure](./media/functions-custom-handlers/azure-functions-custom-handlers-overview.png)

- События запускают запрос, отправленный узлу функций. Событие содержит необработанные полезные данные HTTP (для функций, активируемых HTTP, без привязок) или полезную нагрузку, содержащую входные данные привязки для функции.
- Затем узел функций передает запрос на веб-сервер, выдавая [полезные данные запроса](#request-payload).
- Веб-сервер выполняет отдельную функцию и возвращает [полезные данные ответа](#response-payload) в узел функций.
- Узел функций передает ответ в качестве полезных данных выходной привязки в целевой объект.

Приложение функций Azure, реализованное как пользовательский обработчик, должно настраивать файлы *Host. JSON* и *Function. JSON* в соответствии с определенными соглашениями.

## <a name="application-structure"></a>Структура приложений

Для реализации пользовательского обработчика вам потребуются следующие аспекты приложения:

- Файл *Host. JSON* в корне приложения
- Файл *Function. JSON* для каждой функции (в папке, соответствующей имени функции).
- Команда, сценарий или исполняемый файл, который запускает веб-сервер.

На следующей схеме показано, как эти файлы выглядят в файловой системе для функции с именем "Order".

```bash
| /order
|   function.json
|
| host.json
```

### <a name="configuration"></a>Конфигурация

Приложение настраивается с помощью файла *Host. JSON* . Этот файл указывает узлу функций, куда отправляются запросы, указывая на веб-сервер, способный обрабатывать события HTTP.

Пользовательский обработчик определяется путем настройки файла *Host. JSON* с подробными сведениями о том, как запустить веб-сервер с `httpWorker` помощью раздела.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "server.exe"
        }
    }
}
```

`httpWorker` Раздел указывает на целевой объект, как определено в `defaultExecutablePath`. Целью выполнения может быть команда, исполняемый объект или файл, в котором реализован веб-сервер.

Для приложений, написанных `defaultExecutablePath` по сценарию, указывает на среду выполнения `defaultWorkerPath` языка скриптов и указывает на расположение файла скрипта. В следующем примере показано, как приложение JavaScript в Node. js настраивается в качестве пользовательского обработчика.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js"
        }
    }
}
```

Аргументы также можно передавать с помощью `arguments` массива:

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js",
            "arguments": [ "--argument1", "--argument2" ]
        }
    }
}
```

Аргументы необходимы для многих настроек отладки. Дополнительные сведения см. в разделе [Отладка](#debugging) .

> [!NOTE]
> Файл *Host. JSON* должен иметь тот же уровень структуры каталогов, что и выполняющийся веб-сервер. Некоторые языки и цепочек инструментов могут не размещать этот файл в корневом каталоге приложения по умолчанию.

#### <a name="bindings-support"></a>Поддержка привязок

Стандартные триггеры, а также входные и выходные привязки можно использовать для ссылок на [пакеты расширений](./functions-bindings-register.md) в файле *Host. JSON* .

### <a name="function-metadata"></a>Метаданные функции

При использовании с пользовательским обработчиком содержимое *Function. JSON* не отличается от способа определения функции в любом другом контексте. Единственное требование заключается в том, что файлы *Function. JSON* должны находиться в папке с именем, соответствующим имени функции.

### <a name="request-payload"></a>Полезные данные запроса

Полезные данные запроса для чистых функций HTTP — это необработанные полезные данные HTTP-запросов. Чистые функции HTTP определяются как функции без входных или выходных привязок, которые возвращают HTTP-ответ.

Любые другие типы функций, которые включают входные, выходные привязки или активируемые через источник событий, отличный от HTTP, имеют пользовательские полезные данные запроса.

Следующий код представляет пример полезных данных запроса. Полезные данные включают структуру JSON с двумя членами: `Data` и. `Metadata`

`Data` Член включает ключи, соответствующие входным и активируемым именам, как определено в массиве привязок в файле *Function. JSON* .

Элемент включает [метаданные, созданные из источника событий.](./functions-bindings-expressions-patterns.md#trigger-metadata) `Metadata`

С учетом привязок, определенных в следующем файле *Function. JSON* :

```json
{
  "bindings": [
    {
      "name": "myQueueItem",
      "type": "queueTrigger",
      "direction": "in",
      "queueName": "messages-incoming",
      "connection": "AzureWebJobsStorage"
    },
    {
      "name": "$return",
      "type": "queue",
      "direction": "out",
      "queueName": "messages-outgoing",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
```

Возвращаются полезные данные запроса, аналогичные следующему примеру:

```json
{
    "Data": {
        "myQueueItem": "{ message: \"Message sent\" }"
    },
    "Metadata": {
        "DequeueCount": 1,
        "ExpirationTime": "2019-10-16T17:58:31+00:00",
        "Id": "800ae4b3-bdd2-4c08-badd-f08e5a34b865",
        "InsertionTime": "2019-10-09T17:58:31+00:00",
        "NextVisibleTime": "2019-10-09T18:08:32+00:00",
        "PopReceipt": "AgAAAAMAAAAAAAAAAgtnj8x+1QE=",
        "sys": {
            "MethodName": "QueueTrigger",
            "UtcNow": "2019-10-09T17:58:32.2205399Z",
            "RandGuid": "24ad4c06-24ad-4e5b-8294-3da9714877e9"
        }
    }
}
```

### <a name="response-payload"></a>Полезные данные ответа

По соглашению ответы функций форматируются как пары "ключ-значение". Поддерживаются следующие ключи:

| <nobr>Ключ полезных данных</nobr>   | Тип данных | Remarks                                                      |
| ------------- | --------- | ------------------------------------------------------------ |
| `Outputs`     | JSON      | Содержит значения ответа в соответствии с определением `bindings` массива файла *Function. JSON* .<br /><br />Например, если для функции настроена выходная привязка хранилища BLOB-объектов с именем "BLOB", `Outputs` то содержит ключ с `blob`именем, для которого задано значение большого двоичного объекта. |
| `Logs`        | массиве     | Сообщения отображаются в журналах вызова функций.<br /><br />При работе в Azure сообщения отображаются в Application Insights. |
| `ReturnValue` | строка    | Используется для предоставления ответа при настройке выходных данных `$return` в файле *Function. JSON* . |

См. [пример для примера полезных данных](#bindings-implementation).

## <a name="examples"></a>Примеры

Пользовательские обработчики могут быть реализованы на любом языке, поддерживающем события HTTP. Хотя функции Azure [полностью поддерживают JavaScript и Node. js](./functions-reference-node.md), в следующих примерах показано, как реализовать пользовательский обработчик с помощью JavaScript в Node. js для целей инструкции.

> [!TIP]
> В качестве руководства по реализации пользовательского обработчика на других языках можно также использовать примеры на основе Node. js, которые могут быть полезны, если вы хотите запустить приложение функций в неподдерживаемой версии Node. js.

## <a name="http-only-function"></a>Функция "только HTTP"

В следующем примере показано, как настроить функцию, активируемую HTTP, без дополнительных привязок или выходов. Сценарий, реализованный в этом примере, поддерживает функцию `http` с именем, `GET` которая `POST` принимает или.

В следующем фрагменте кода представлен способ составления запроса к функции.

```http
POST http://127.0.0.1:7071/api/hello HTTP/1.1
content-type: application/json

{
  "message": "Hello World!"
}
```

<a id="hello-implementation" name="hello-implementation"></a>

### <a name="implementation"></a>Реализация

В папке с именем *http*файл *Function. JSON* настраивает функцию, активируемую HTTP.

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}
```

Функция настроена на прием запросов `GET` и `POST` , а результирующее значение предоставляется через аргумент с именем. `res`

В корне приложения файл *Host. JSON* настраивается для запуска Node. js и указывает на `server.js` файл.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js"
        }
    }
}
```

Файл файлового *сервера. js* реализует веб-сервер и функцию HTTP.

```javascript
const express = require("express");
const app = express();

app.use(express.json());

const PORT = process.env.FUNCTIONS_HTTPWORKER_PORT;

const server = app.listen(PORT, "localhost", () => {
  console.log(`Your port is ${PORT}`);
  const { address: host, port } = server.address();
  console.log(`Example app listening at http://${host}:${port}`);
});

app.get("/hello", (req, res) => {
  res.json("Hello World!");
});

app.post("/hello", (req, res) => {
  res.json({ value: req.body });
});
```

В этом примере Express используется для создания веб-сервера для обработки событий HTTP и настроен для прослушивания запросов через `FUNCTIONS_HTTPWORKER_PORT`.

Функция определена по пути `/hello`. `GET`запросы обрабатываются путем возвращения простого объекта JSON, а `POST` запросы имеют доступ к тексту запроса через `req.body`.

Маршрут для функции заказа здесь `/hello` не `/api/hello` так, потому что узел функций является прокси-сервером запроса к пользовательскому обработчику.

>[!NOTE]
>Не `FUNCTIONS_HTTPWORKER_PORT` является общедоступным портом, используемым для вызова функции. Этот порт используется узлом функций для вызова пользовательского обработчика.

## <a name="function-with-bindings"></a>Функция с привязками

Сценарий, реализованный в этом примере, использует функцию `order` с именем, `POST` которая принимает объект с полезной нагрузкой, представляющей заказ продукта. Когда в функцию отправляется заказ, создается сообщение хранилища очереди и возвращается ответ HTTP.

```http
POST http://127.0.0.1:7071/api/order HTTP/1.1
content-type: application/json

{
  "id": 1005,
  "quantity": 2,
  "color": "black"
}
```

<a id="bindings-implementation" name="bindings-implementation"></a>

### <a name="implementation"></a>Реализация

В папке с именем *Order*файл *Function. JSON* настраивает функцию, активируемую HTTP.

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "authLevel": "function",
      "direction": "in",
      "name": "req",
      "methods": ["post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "name": "message",
      "direction": "out",
      "queueName": "orders",
      "connection": "AzureWebJobsStorage"
    }
  ]
}

```

Эта функция определена как [функция, активируемая HTTP](./functions-bindings-http-webhook-trigger.md) и возвращающая [ответ HTTP](./functions-bindings-http-webhook-output.md) и выводит сообщение [хранилища очереди](./functions-bindings-storage-queue-output.md) .

В корне приложения файл *Host. JSON* настраивается для запуска Node. js и указывает на `server.js` файл.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js"
        }
    }
}
```

Файл файлового *сервера. js* реализует веб-сервер и функцию HTTP.

```javascript
const express = require("express");
const app = express();

app.use(express.json());

const PORT = process.env.FUNCTIONS_HTTPWORKER_PORT;

const server = app.listen(PORT, "localhost", () => {
  console.log(`Your port is ${PORT}`);
  const { address: host, port } = server.address();
  console.log(`Example app listening at http://${host}:${port}`);
});

app.post("/order", (req, res) => {
  const message = req.body.Data.req.Body;
  const response = {
    Outputs: {
      message: message,
      res: {
        statusCode: 200,
        body: "Order complete"
      }
    },
    Logs: ["order processed"]
  };
  res.json(response);
});
```

В этом примере Express используется для создания веб-сервера для обработки событий HTTP и настроен для прослушивания запросов через `FUNCTIONS_HTTPWORKER_PORT`.

Функция определена по пути `/order` .  Маршрут для функции заказа здесь `/order` не `/api/order` так, потому что узел функций является прокси-сервером запроса к пользовательскому обработчику.

По `POST` мере отправки запросов в эту функцию данные предоставляются через несколько точек:

- Текст запроса доступен через`req.body`
- Данные, отправленные в функцию, доступны через`req.body.Data.req.Body`

Ответ функции форматируется в пару "ключ-значение", где `Outputs` элемент содержит значение JSON, в котором ключи соответствуют выходным данным, как определено в файле *Function. JSON* .

Если установить `message` значение, равное сообщению, полученному из запроса, `res` и ожидаемому ответу HTTP, эта функция выводит сообщение в очередь и возвращает ответ HTTP.

## <a name="debugging"></a>Отладка

Чтобы выполнить отладку приложения пользовательского обработчика функций, необходимо добавить аргументы, подходящие для языка и среды выполнения, чтобы включить отладку.

Например, для отладки приложения Node. js `--inspect` флаг передается в качестве аргумента в файл *Host. JSON* .

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js",
            "arguments": [ "--inspect" ]
        }
    }
}
```

> [!NOTE]
> Конфигурация отладки является частью файла *Host. JSON* . Это означает, что перед развертыванием в рабочей среде может потребоваться удалить некоторые аргументы.

В этой конфигурации можно запустить ведущий процесс функции с помощью следующей команды:

```bash
func host start
```

После запуска процесса можно присоединить отладчик и точки останова.

### <a name="visual-studio-code"></a>Visual Studio Code

Ниже приведен пример конфигурации, демонстрирующий, как можно настроить файл *Launch. JSON* для подключения приложения к отладчику Visual Studio Code.

Этот пример предназначен для Node. js, поэтому может потребоваться изменить этот пример для других языков или сред выполнения.

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Attach to Node Functions",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "preLaunchTask": "func: host start"
    }
  ]
}
```

## <a name="deploying"></a>Развертывание

Пользовательский обработчик можно развернуть почти во всех параметрах размещения функций Azure (см. раздел [ограничения](#restrictions)). Если обработчику требуются пользовательские зависимости (например, языковая среда выполнения), может потребоваться использовать [пользовательский контейнер](./functions-create-function-linux-custom-image.md).

## <a name="restrictions"></a>Ограничения

- Пользовательские обработчики не поддерживаются в планах потребления Linux.
- Веб-сервер должен запускаться в течение 60 секунд.

## <a name="samples"></a>Примеры

Примеры реализации функций на различных языках см. в [репозитории примеров пользовательского обработчика GitHub](https://github.com/Azure-Samples/functions-custom-handlers) .
