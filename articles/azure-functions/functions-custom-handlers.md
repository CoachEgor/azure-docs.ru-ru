---
title: Пользовательские обработчики функций Azure (Предварительная версия)
description: Узнайте, как использовать функции Azure с любым языком или версией среды выполнения.
author: craigshoemaker
ms.author: cshoe
ms.date: 3/18/2020
ms.topic: article
ms.openlocfilehash: cdbb5bbde1e5efef9bef992a62a54f1525a16df7
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2020
ms.locfileid: "85052576"
---
# <a name="azure-functions-custom-handlers-preview"></a>Пользовательские обработчики функций Azure (Предварительная версия)

Каждое приложение функций выполняется обработчиком конкретного языка. Хотя функции Azure поддерживают много [языковых обработчиков](./supported-languages.md) по умолчанию, в некоторых случаях может потребоваться дополнительный контроль над средой выполнения приложений. Пользовательские обработчики предоставляют этот дополнительный элемент управления.

Пользовательские обработчики — это упрощенные веб-серверы, которые получают события от узла функций. Любой язык, поддерживающий примитивы HTTP, может реализовать пользовательский обработчик.

Пользовательские обработчики лучше всего подходят для ситуаций, в которых вы хотите:

- Реализуйте приложение-функцию на языке, который не поддерживается официально.
- Реализация приложения-функции в языковой версии или во время выполнения не поддерживается по умолчанию.
- Предоставьте более детализированный контроль над средой выполнения приложения функции.

С помощью пользовательских обработчиков все [триггеры и входные и выходные привязки](./functions-triggers-bindings.md) поддерживаются через [пакеты расширений](./functions-bindings-register.md).

## <a name="overview"></a>Обзор

На следующей схеме показана связь между узлом функций и веб-сервером, реализованным как пользовательский обработчик.

![Общие сведения о пользовательском обработчике функций Azure](./media/functions-custom-handlers/azure-functions-custom-handlers-overview.png)

- События запускают запрос, отправленный узлу функций. Событие содержит необработанные полезные данные HTTP (для функций, активируемых HTTP, без привязок) или полезную нагрузку, содержащую входные данные привязки для функции.
- Затем узел функций передает запрос на веб-сервер, выдавая [полезные данные запроса](#request-payload).
- Веб-сервер выполняет отдельную функцию и возвращает [полезные данные ответа](#response-payload) в узел функций.
- Узел функций передает ответ в качестве полезных данных выходной привязки в целевой объект.

Приложение функций Azure, реализованное как пользовательский обработчик, должно настраивать *host.jsна* файлах и *function.jsв* соответствии с определенными соглашениями.

## <a name="application-structure"></a>Структура приложений

Для реализации пользовательского обработчика вам потребуются следующие аспекты приложения:

- *host.js* файла в корне приложения
- *function.jsв* файле для каждой функции (в папке, соответствующей имени функции)
- Команда, сценарий или исполняемый файл, который запускает веб-сервер.

На следующей схеме показано, как эти файлы выглядят в файловой системе для функции с именем "Order".

```bash
| /order
|   function.json
|
| host.json
```

### <a name="configuration"></a>Параметр Configuration

Приложение настраивается с помощью *host.jsв* файле. Этот файл указывает узлу функций, куда отправляются запросы, указывая на веб-сервер, способный обрабатывать события HTTP.

Пользовательский обработчик определяется путем настройки *host.jsв* файле с подробными сведениями о том, как запускать веб-сервер с помощью `httpWorker` раздела.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "server.exe"
        }
    }
}
```

`httpWorker`Раздел указывает на целевой объект, как определено в `defaultExecutablePath` . Целью выполнения может быть команда, исполняемый объект или файл, в котором реализован веб-сервер.

Для приложений, написанных по сценарию, `defaultExecutablePath` указывает на среду выполнения языка скриптов и `defaultWorkerPath` указывает на расположение файла скрипта. В следующем примере показано, как приложение JavaScript в Node.js настроено в качестве пользовательского обработчика.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js"
        }
    }
}
```

Аргументы также можно передавать с помощью `arguments` массива:

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js",
            "arguments": [ "--argument1", "--argument2" ]
        }
    }
}
```

Аргументы необходимы для многих настроек отладки. Дополнительные сведения см. в разделе [Отладка](#debugging) .

> [!NOTE]
> *host.jsна* файл должен находиться на том же уровне в структуре каталогов, что и работающий веб-сервер. Некоторые языки и цепочек инструментов могут не размещать этот файл в корневом каталоге приложения по умолчанию.

#### <a name="bindings-support"></a>Поддержка привязок

Стандартные триггеры, а также входные и выходные привязки доступны для ссылок на [пакеты расширений](./functions-bindings-register.md) в *host.js* в файле.

### <a name="function-metadata"></a>Метаданные функции

При использовании с пользовательским обработчиком *function.js* в содержимом не отличается от того, как вы определите функцию в любом другом контексте. Единственное требование заключается в том, что *function.jsдля* файлов должны находиться в папке с именем, соответствующей имени функции.

### <a name="request-payload"></a>Полезные данные запроса

Полезные данные запроса для чистых функций HTTP — это необработанные полезные данные HTTP-запросов. Чистые функции HTTP определяются как функции без входных или выходных привязок, которые возвращают HTTP-ответ.

Любые другие типы функций, которые включают входные, выходные привязки или активируемые через источник событий, отличный от HTTP, имеют пользовательские полезные данные запроса.

Следующий код представляет пример полезных данных запроса. Полезные данные включают структуру JSON с двумя членами: `Data` и `Metadata` .

`Data`Член включает ключи, соответствующие входным и активируемым именам, как определено в массиве привязок в *function.js* в файле.

`Metadata`Элемент включает [метаданные, созданные из источника событий](./functions-bindings-expressions-patterns.md#trigger-metadata).

При наличии привязок, определенных в следующем *function.jsв* файле:

```json
{
  "bindings": [
    {
      "name": "myQueueItem",
      "type": "queueTrigger",
      "direction": "in",
      "queueName": "messages-incoming",
      "connection": "AzureWebJobsStorage"
    },
    {
      "name": "$return",
      "type": "queue",
      "direction": "out",
      "queueName": "messages-outgoing",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
```

Возвращаются полезные данные запроса, аналогичные следующему примеру:

```json
{
    "Data": {
        "myQueueItem": "{ message: \"Message sent\" }"
    },
    "Metadata": {
        "DequeueCount": 1,
        "ExpirationTime": "2019-10-16T17:58:31+00:00",
        "Id": "800ae4b3-bdd2-4c08-badd-f08e5a34b865",
        "InsertionTime": "2019-10-09T17:58:31+00:00",
        "NextVisibleTime": "2019-10-09T18:08:32+00:00",
        "PopReceipt": "AgAAAAMAAAAAAAAAAgtnj8x+1QE=",
        "sys": {
            "MethodName": "QueueTrigger",
            "UtcNow": "2019-10-09T17:58:32.2205399Z",
            "RandGuid": "24ad4c06-24ad-4e5b-8294-3da9714877e9"
        }
    }
}
```

### <a name="response-payload"></a>Полезные данные ответа

По соглашению ответы функций форматируются как пары "ключ-значение". Поддерживаются следующие ключи:

| <nobr>Ключ полезных данных</nobr>   | Тип данных | Комментарии                                                      |
| ------------- | --------- | ------------------------------------------------------------ |
| `Outputs`     | JSON      | Содержит значения ответа, определенные `bindings` массивом *function.jsв* файле.<br /><br />Например, если для функции настроена выходная привязка хранилища BLOB-объектов с именем "BLOB", то `Outputs` содержит ключ с именем `blob` , для которого задано значение большого двоичного объекта. |
| `Logs`        | массиве     | Сообщения отображаются в журналах вызова функций.<br /><br />При работе в Azure сообщения отображаются в Application Insights. |
| `ReturnValue` | string    | Используется для предоставления ответа, когда выходные данные настраиваются как `$return` в *function.js* в файле. |

См. [пример для примера полезных данных](#bindings-implementation).

## <a name="examples"></a>Примеры

Пользовательские обработчики могут быть реализованы на любом языке, поддерживающем события HTTP. Хотя функции Azure [полностью поддерживают JavaScript и Node.js](./functions-reference-node.md), в следующих примерах показано, как реализовать пользовательский обработчик с помощью javascript в Node.js в целях инструкции.

> [!TIP]
> В качестве руководства по реализации пользовательского обработчика на других языках можно также использовать примеры Node.js, приведенные здесь, если вы хотите запустить приложение функций в неподдерживаемой версии Node.js.

## <a name="http-only-function"></a>Функция "только HTTP"

В следующем примере показано, как настроить функцию, активируемую HTTP, без дополнительных привязок или выходов. Сценарий, реализованный в этом примере, поддерживает функцию с именем `http` , которая принимает `GET` или `POST` .

В следующем фрагменте кода представлен способ составления запроса к функции.

```http
POST http://127.0.0.1:7071/api/hello HTTP/1.1
content-type: application/json

{
  "message": "Hello World!"
}
```

<a id="hello-implementation" name="hello-implementation"></a>

### <a name="implementation"></a>Реализация

В папке с именем *http* *function.jsв* файле настраивает функцию, активируемую HTTP.

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}
```

Функция настроена на прием `GET` запросов и, `POST` а результирующее значение предоставляется через аргумент с именем `res` .

В корне приложения *host.jsв* файле настроен для запуска Node.js и указания `server.js` файла.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js"
        }
    }
}
```

Файл *server.js* файлов реализует веб-сервер и функцию HTTP.

```javascript
const express = require("express");
const app = express();

app.use(express.json());

const PORT = process.env.FUNCTIONS_HTTPWORKER_PORT;

const server = app.listen(PORT, "localhost", () => {
  console.log(`Your port is ${PORT}`);
  const { address: host, port } = server.address();
  console.log(`Example app listening at http://${host}:${port}`);
});

app.get("/hello", (req, res) => {
  res.json("Hello World!");
});

app.post("/hello", (req, res) => {
  res.json({ value: req.body });
});
```

В этом примере Express используется для создания веб-сервера для обработки событий HTTP и настроен для прослушивания запросов через `FUNCTIONS_HTTPWORKER_PORT` .

Функция определена по пути `/hello` . `GET`запросы обрабатываются путем возвращения простого объекта JSON, а `POST` запросы имеют доступ к тексту запроса через `req.body` .

Маршрут для функции заказа здесь не так, `/hello` `/api/hello` потому что узел функций является прокси-сервером запроса к пользовательскому обработчику.

>[!NOTE]
>`FUNCTIONS_HTTPWORKER_PORT`Не является общедоступным портом, используемым для вызова функции. Этот порт используется узлом функций для вызова пользовательского обработчика.

## <a name="function-with-bindings"></a>Функция с привязками

Сценарий, реализованный в этом примере, использует функцию с именем `order` , которая принимает объект с полезной нагрузкой, `POST` представляющей заказ продукта. Когда в функцию отправляется заказ, создается сообщение хранилища очереди и возвращается ответ HTTP.

```http
POST http://127.0.0.1:7071/api/order HTTP/1.1
content-type: application/json

{
  "id": 1005,
  "quantity": 2,
  "color": "black"
}
```

<a id="bindings-implementation" name="bindings-implementation"></a>

### <a name="implementation"></a>Реализация

В папке с именем *order* *function.js* File настраивает функцию, активируемую HTTP.

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "authLevel": "function",
      "direction": "in",
      "name": "req",
      "methods": ["post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "name": "message",
      "direction": "out",
      "queueName": "orders",
      "connection": "AzureWebJobsStorage"
    }
  ]
}

```

Эта функция определена как [функция, активируемая HTTP](./functions-bindings-http-webhook-trigger.md) и возвращающая [ответ HTTP](./functions-bindings-http-webhook-output.md) и выводит сообщение [хранилища очереди](./functions-bindings-storage-queue-output.md) .

В корне приложения *host.jsв* файле настроен для запуска Node.js и указания `server.js` файла.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js"
        }
    }
}
```

Файл *server.js* файлов реализует веб-сервер и функцию HTTP.

```javascript
const express = require("express");
const app = express();

app.use(express.json());

const PORT = process.env.FUNCTIONS_HTTPWORKER_PORT;

const server = app.listen(PORT, "localhost", () => {
  console.log(`Your port is ${PORT}`);
  const { address: host, port } = server.address();
  console.log(`Example app listening at http://${host}:${port}`);
});

app.post("/order", (req, res) => {
  const message = req.body.Data.req.Body;
  const response = {
    Outputs: {
      message: message,
      res: {
        statusCode: 200,
        body: "Order complete"
      }
    },
    Logs: ["order processed"]
  };
  res.json(response);
});
```

В этом примере Express используется для создания веб-сервера для обработки событий HTTP и настроен для прослушивания запросов через `FUNCTIONS_HTTPWORKER_PORT` .

Функция определена по пути `/order` .  Маршрут для функции заказа здесь не так, `/order` `/api/order` потому что узел функций является прокси-сервером запроса к пользовательскому обработчику.

По мере `POST` отправки запросов в эту функцию данные предоставляются через несколько точек:

- Текст запроса доступен через`req.body`
- Данные, отправленные в функцию, доступны через`req.body.Data.req.Body`

Ответ функции форматируется в пару "ключ-значение", где `Outputs` элемент содержит значение JSON, в котором ключи соответствуют выходам, указанным в *function.jsв* файле.

Если установить значение `message` , равное сообщению, полученному из запроса, и `res` ожидаемому ответу HTTP, эта функция выводит сообщение в очередь и ВОЗВРАЩАЕТ ответ HTTP.

## <a name="debugging"></a>Отладка

Чтобы выполнить отладку приложения пользовательского обработчика функций, необходимо добавить аргументы, подходящие для языка и среды выполнения, чтобы включить отладку.

Например, чтобы выполнить отладку Node.js приложения, `--inspect` флаг передается в качестве аргумента в *host.js* файла.

```json
{
    "version": "2.0",
    "httpWorker": {
        "description": {
            "defaultExecutablePath": "node",
            "defaultWorkerPath": "server.js",
            "arguments": [ "--inspect" ]
        }
    }
}
```

> [!NOTE]
> Конфигурация отладки является частью *host.js* файла. Это означает, что перед развертыванием в рабочей среде может потребоваться удалить некоторые аргументы.

В этой конфигурации можно запустить ведущий процесс функции с помощью следующей команды:

```bash
func host start
```

После запуска процесса можно присоединить отладчик и точки останова.

### <a name="visual-studio-code"></a>Visual Studio Code

Ниже приведен пример конфигурации, демонстрирующий, как можно настроить *launch.jsв* файле для подключения приложения к отладчику Visual Studio Code.

Этот пример предназначен для Node.js, поэтому может потребоваться изменить этот пример для других языков или сред выполнения.

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Attach to Node Functions",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "preLaunchTask": "func: host start"
    }
  ]
}
```

## <a name="deploying"></a>Развертывание

Пользовательский обработчик можно развернуть почти во всех параметрах размещения функций Azure (см. раздел [ограничения](#restrictions)). Если обработчику требуются пользовательские зависимости (например, языковая среда выполнения), может потребоваться использовать [пользовательский контейнер](./functions-create-function-linux-custom-image.md).

Чтобы развернуть приложение пользовательского обработчика с помощью Azure Functions Core Tools, выполните следующую команду.

```bash
func azure functionapp publish $functionAppName --no-build --force
```

## <a name="restrictions"></a>Ограничения

- Веб-сервер должен запускаться в течение 60 секунд.

## <a name="samples"></a>Примеры

Примеры реализации функций на различных языках см. в [репозитории примеров пользовательского обработчика GitHub](https://github.com/Azure-Samples/functions-custom-handlers) .
