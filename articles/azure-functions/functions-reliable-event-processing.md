---
title: Azure Функции надежной обработки событий
description: Избегайте пропуска сообщений концентратора событий в функциях Azure
author: craigshoemaker
ms.topic: conceptual
ms.date: 09/12/2019
ms.author: cshoe
ms.openlocfilehash: e4f35495d8a01146068cffb9159c29c46c3c0d29
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "75561873"
---
# <a name="azure-functions-reliable-event-processing"></a>Azure Функции надежной обработки событий

Обработка событий является одним из наиболее распространенных сценариев, связанных с архитектурой без серверов. В этой статье описывается, как создать надежный процессор сообщений с функциями Azure, чтобы избежать потери сообщений.

## <a name="challenges-of-event-streams-in-distributed-systems"></a>Проблемы потоков событий в распределенных системах

Рассмотрим систему, которая отправляет события с постоянной скоростью 100 событий в секунду. При таком темпе в течение нескольких минут несколько параллельных экземпляров функций могут потреблять входящие 100 событий каждую секунду.

Однако возможны любые из следующих менее оптимальных условий:

- Что делать, если издатель события отправляет поврежденное событие?
- Что делать, если экземпляр функций сталкивается с необработанными исключениями?
- Что делать, если система ниже по течению переходит в автономный режим?

Как вы справляетесь с этими ситуациями, сохраняя пропускную стоимость приложения?

С очередями, надежный обмен сообщениями приходит естественно. В паре с триггером функции функция создает блокировку сообщения очереди. Если обработка не удается, блокировка освобождается, чтобы позволить другому экземпляру повторить обработку. Обработка затем продолжается до тех пор, пока либо сообщение не будет успешно оценено, либо оно не будет добавлено в очередь яда.

Даже в то время как сообщение одной очереди может оставаться в цикле повторной попытки, другие параллельные выполнения продолжают выполняться до разграничива оставшихся сообщений. В результате общая пропускная часть остается в значительной степени не зависит от одного плохого сообщения. Однако очереди хранения не гарантируют заказ и не оптимизированы для высоких требований к пропускной памяти, требуемых концентраторами событий.

В отличие от этого, Azure Event Hubs не включает концепцию блокировки. Для того чтобы такие функции, как высокопроизводительные, несколько групп потребителей и способность к повтору, события событий Концентраторы ведут себя скорее как видеоплеер. События считываются из одной точки потока на раздел. Из указателя вы можете прочитать вперед или назад из этого места, но вы должны выбрать, чтобы переместить указатель для событий для обработки.

При возникновении ошибок в потоке, если вы решите сохранить указатель в том же месте, обработка событий блокируется до тех пор, пока указатель не будет расширен. Другими словами, если указатель остановлен для решения проблем обработки одного события, необработанные события начинают накапливаться.

Функции Azure избегают взаимоспулок, продвигая указатель потока независимо от успеха или неудачи. Поскольку указатель продолжает продвигаться, ваши функции должны иметь дело с сбоями надлежащим образом.

## <a name="how-azure-functions-consumes-event-hubs-events"></a>Как функции Azure потребляют события концентраторов событий

Функции Azure потребляют события концентратора событий во время езды на велосипеде по следующим шагам:

1. Указатель создается и сохраняется в хранилище Azure для каждого раздела концентратора событий.
2. При получении новых сообщений (в пакете по умолчанию) хост пытается запустить функцию пакетом сообщений.
3. Если функция завершает выполнение (с исключением или без исключения), указатель авансируется, и контрольный пункт сохраняется на счет хранения.
4. Если условия препятствуют завершению выполнения функции, универсает указатель. Если указатель не усовершенствован, то последующие проверки в конечном итоге обрабатывают те же сообщения.
5. Повторите шаги 2-4

Такое поведение показывает несколько важных моментов:

- *Необработанные исключения могут привести к потере сообщений.* Выполнение, приведащее к исключению, будет продолжать прогрессировать указатель.
- *Функции гарантируют доставку по крайней мере один раз.* Возможно, придется учитывать [тот факт, что одно и то же сообщение может быть получено дважды.](./functions-idempotent.md)

## <a name="handling-exceptions"></a>Обработка исключений

Как правило, каждая функция должна включать [блок try/catch](./functions-bindings-error-pages.md) на самом высоком уровне кода. В частности, все функции, потребляющие события событий, должны иметь `catch` блок. Таким образом, при поднятии исключения блок catch обрабатывает ошибку до выполнения указателя.

### <a name="retry-mechanisms-and-policies"></a>Механизмы и политика повторного отработки

Некоторые исключения носят временный характер и не появляются, когда операция снова пытается быть повторена несколько минут спустя. Вот почему первым шагом всегда является повторная попытка операции. Вы можете написать правила повторной обработки самостоятельно, но они настолько банные, что ряд инструментов доступны. Использование этих библиотек позволяет определить надежные политики повторной попытки, которые также могут помочь сохранить порядок обработки.

Внедрение библиотек обработки ошибок в свои функции позволяет определить как основные, так и продвинутые политики повторной работы. Например, можно реализовать политику, которая следует рабочему процессу, иллюстрированному следующими правилами:

- Попробуйте вставить сообщение три раза (потенциально с задержкой между повторами).
- Если конечным результатом всех повторов является сбой, затем добавьте сообщение в очередь, чтобы обработка могла продолжаться в потоке.
- Затем сообщения, поврежденные или необработанные, обрабатываются позже.

> [!NOTE]
> [Полли](https://github.com/App-vNext/Polly) является примером библиотеки устойчивости и переходных ошибок для приложений C.'

При работе с предварительно выполненными библиотеками класса C', [фильтры исключений](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/try-catch) позволяют запускать код всякий раз, когда происходит необработанное исключение.

Образцы, демонстрирующие, как использовать фильтры исключений, доступны в репо [Azure WebJobs SDK.](https://github.com/Azure/azure-webjobs-sdk/wiki)

## <a name="non-exception-errors"></a>Ошибки без исключения

Некоторые проблемы возникают даже при неявке. Например, рассмотрим сбой, который происходит в середине выполнения. В этом случае, если функция не завершает выполнение, офсетная закательга никогда не выполняется. Если указатель не продвигается вперед, то любой экземпляр, который выполняется после неудачного выполнения, продолжает читать одни и те же сообщения. Эта ситуация обеспечивает гарантию "по крайней мере один раз".

Гарантия того, что каждое сообщение обрабатывается по крайней мере один раз, подразумевает, что некоторые сообщения могут обрабатываться более одного раза. Ваши функциональные приложения должны быть осведомлены об этой возможности и должны быть построены на [принципах идемпотенции.](./functions-idempotent.md)

## <a name="stop-and-restart-execution"></a>Остановка и перезапуск выполнения

Хотя некоторые ошибки могут быть приемлемыми, что делать, если ваше приложение испытывает значительные сбои? Вы можете прекратить срабатывание событий до тех пор, пока система не достигнет здорового состояния. Возможность приостановить обработку часто достигается с помощью шаблона выключателя цепи. Шаблон выключателя цепи позволяет приложению "сломать цепь" процесса события и возобновить сядр на более позднее время.

Для реализации выключателя в процессе события требуется две части:

- Общее состояние во всех экземплярах для отслеживания и мониторинга работоспособности цепи
- Мастер-процесс, который может управлять состоянием контура (открытым или закрытым)

Детали реализации могут варьироваться, но для совместного опубликования между экземплярами необходим механизм хранения. Вы можете хранить состояние в Хранилище Azure, кэше Redis или любой другой учетной записи, доступной под набором функций.

[Приложения логики Azure](../logic-apps/logic-apps-overview.md) или [прочные сущности](./durable/durable-functions-overview.md) являются естественным исправляемым состоянием рабочего процесса и контура. Другие службы могут работать так же хорошо, но для этого примера используются логические приложения. Используя логические приложения, можно приостановить и перезапустить выполнение функции, что даст вам контроль, необходимый для реализации шаблона выключателя цепи.

### <a name="define-a-failure-threshold-across-instances"></a>Определение порога сбоя в экземплярах

Для учета нескольких моментов обработки событий одновременно необходимо сохранять общее внешнее состояние для мониторинга работоспособности цепи.

Правило, которое вы можете выбрать для реализации, может привести к применению:

- Если в течение 30 секунд во всех экземплярах происходит более 100 возможных сбоев, то нарушай схему и прекрати срабатывая новые сообщения.

Детали реализации будут варьироваться с учетом ваших потребностей, но в целом вы можете создать систему, которая:

1. Сбои в работе учетной записи хранилища (Azure Storage, Redis и т.д.)
1. При регистрации нового сбоя проинспектировать количество подвижного состава, чтобы увидеть, соблюдается ли порог (например, более 100 за последние 30 секунд).
1. При соблюдении порога испределите событие в Azure Event Grid, в котором система должна взломать цепь.

### <a name="managing-circuit-state-with-azure-logic-apps"></a>Управление состоянием контура с помощью приложений логики Azure

В следующем описании выделяется один из способов создания приложения Azure Logic App, чтобы остановить обработку приложения Функции.

Azure Logic Apps поставляется со встроенными разъемами для различных служб, имеет состояние оркестровки, и является естественным выбором для управления состоянием цепи. После обнаружения схемы необходимо сломать, можно создать логическое приложение для реализации следующего рабочего процесса:

1. Триггер рабочего процесса сетки событий и остановите функцию Azure (с разъемом ресурсов Azure)
1. Отправить электронное письмо с уведомлением, включавв в себя опцию перезагрузки рабочего процесса

Получатель электронной почты может исследовать работоспособность цепи и, при необходимости, перезапустить схему по ссылке в сообщении уведомления. По мере перезагрузки работы рабочего процесса сообщения обрабатываются с последней контрольной точки концентратора событий.

Используя этот подход, сообщения не теряются, все сообщения обрабатываются в порядке, и вы можете разорвать цепь до тех пор, как это необходимо.

## <a name="resources"></a>Ресурсы

- [Надежные образцы обработки событий](https://github.com/jeffhollan/functions-csharp-eventhub-ordered-processing)
- [Выключатель прочных функций Azure](https://github.com/jeffhollan/functions-durable-actor-circuitbreaker)

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения см. в следующих ресурсах:

- [Обработка ошибок службы "Функции Azure"](./functions-bindings-error-pages.md)
- [Автоматизация повторного размера загруженных изображений с помощью Event Grid](../event-grid/resize-images-on-storage-blob-upload-event.md?toc=%2Fazure%2Fazure-functions%2Ftoc.json&tabs=dotnet)
- [Создание функции, интегрируемой с Azure Logic Apps](./functions-twitter-email.md)
