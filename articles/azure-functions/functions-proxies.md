---
title: Работа с прокси в Функциях Azure | Документация Майкрософт
description: Общие сведения об использовании прокси Функций Azure
services: functions
author: alexkarcher-msft
manager: jeconnoc
ms.assetid: ''
ms.service: azure-functions
ms.topic: conceptual
ms.date: 01/22/2018
ms.author: alkarche
ms.openlocfilehash: e5f856bbd8f6fdec46d947a4c726024a08a2b6e9
ms.sourcegitcommit: 44e85b95baf7dfb9e92fb38f03c2a1bc31765415
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2019
ms.locfileid: "70096039"
---
# <a name="work-with-azure-functions-proxies"></a>Работа с функцией "Прокси-серверы Функций Azure"

В этой статье описано, как настроить прокси Функций Azure и работать с ними. Эта функция позволяет указать конечные точки в приложении-функции, реализуемые другим ресурсом. Эти прокси можно использовать для разбиения большого API-интерфейса на несколько приложений-функций (как в архитектуре микрослужб), сохраняя при этом единую область API для клиентов.

[!INCLUDE [intro](../../includes/functions-bindings-intro.md)]

> [!NOTE] 
> На выполнение прокси-сервера распространяется стандартная тарификация службы "Функции". Дополнительные сведения см. на странице [цен на Функции Azure](https://azure.microsoft.com/pricing/details/functions/).

## <a name="create"></a>Создание прокси-сервера

В этом разделе показано, как создать прокси-сервер на портале Функций.

1. Откройте [портал Azure] и перейдите к своему приложению-функции.
2. В левой области выберите **Создать прокси-сервер**.
3. Задайте имя прокси.
4. Настройте конечную точку в этом приложении-функции, указав **шаблон маршрута** и **методы HTTP**. Поведение этих параметров соответствует правилам для [Триггеры HTTP].
5. Задайте **URL-адрес внутреннего сервера** для другой конечной точки. Ею может быть функция в другом приложении-функции или другой API. Значение не обязательно должно быть статическим и может ссылаться на [параметры приложения] и [Параметры, установленные для исходного запроса клиента].
6. Нажмите кнопку **Создать**.

Прокси теперь существует в виде новой конечной точки в приложении-функции. С точки зрения клиента это аналогично HttpTrigger в Функциях Azure. Можно испытать новый прокси, скопировав URL-адрес прокси и протестировав его с помощью избранного клиента HTTP.

## <a name="modify-requests-responses"></a>Изменение запросов и ответов

Прокси-серверы Функций Azure позволяют изменять запросы и ответы из внутреннего сервера. При таком преобразовании используются переменные, указанные в разделе [Использование переменных].

### <a name="modify-backend-request"></a>Изменение запроса внутреннего сервера

По умолчанию запрос внутреннего сервера инициализируется в качестве копии исходного запроса. Кроме настройки URL-адреса внутреннего сервера вы также можете изменить метод, заголовки и параметры строки запроса HTTP. Измененные значения могут ссылаться на [параметры приложения] и [Параметры, установленные для исходного запроса клиента].

Запросы на серверной стороне можно изменить на портале, развернув раздел *Переопределение запроса* на странице со сведениями о прокси-сервере. 

### <a name="modify-response"></a>Изменение ответа

По умолчанию ответ клиента инициализируется в качестве копии ответа внутреннего сервера. Вы можете изменить код состояния, описание, заголовки и текст ответа. Измененные значения могут ссылаться на [параметры приложения], [Параметры, установленные для исходного запроса клиента] и [параметры ответа внутреннего сервера].

Запросы на серверной стороне можно изменить на портале, развернув раздел *Переопределение ответа* на странице со сведениями о прокси-сервере. 

## <a name="using-variables"></a>Использование переменных

Использовать статическую конфигурацию для прокси-сервера необязательно. Вы можете настроить для него использование переменных из исходного клиентского запроса, ответа внутреннего сервера или параметров приложения.

### <a name="reference-localhost"></a>Ссылки на локальные функции
Вы можете использовать `localhost` для прямой ссылки на функцию в одном и том же приложении-функции, не применяя запрос прокси-сервера для обмена данными.

`"backendurl": "https://localhost/api/httptriggerC#1"` будет ссылаться на локальную функцию, активируемую HTTP, на маршруте `/api/httptriggerC#1`.

 
>[!Note]  
>Если функция использует уровень авторизации *функции, администратора или системы*, вам нужно указать код и идентификатор клиента в соответствии с исходным URL-адресом функции. В этом случае ссылка будет выглядеть так: `"backendurl": "https://localhost/api/httptriggerC#1?code=<keyvalue>&clientId=<keyname>"`

### <a name="request-parameters"></a>Ссылки на параметры запроса

Параметры запроса можно использовать в качестве входных данных для свойства URL-адреса внутреннего сервера или в рамках изменения запросов и ответов. Некоторые параметры могут быть связаны с шаблоном маршрута, указанным в основной конфигурации прокси-сервера, тогда как другие задаются в соответствии со свойствами входящих запросов.

#### <a name="route-template-parameters"></a>Параметры шаблона маршрута
Параметры, используемые в шаблоне маршрута, указываются по именам, которые заключаются в фигурные скобки — {}.

Например, если прокси-сервер использует шаблон маршрута, подобный `/pets/{petId}`, URL-адрес внутреннего сервера может содержать значение `{petId}`, как в `https://<AnotherApp>.azurewebsites.net/api/pets/{petId}`. Если шаблон маршрута заканчивается подстановочным знаком, например `/api/{*restOfPath}`, значение `{restOfPath}` будет строковым представлением остальных сегментов пути входящего запроса.

#### <a name="additional-request-parameters"></a>Дополнительные параметры запроса
В дополнение к параметрам шаблона маршрута вы можете использовать следующие значения конфигурации:

* **{request.method}** . Метод HTTP, используемый в исходном запросе.
* **{request.headers.\<имя_заголовка\>}** . Заголовок, который можно считать из исходного запроса. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь считать. Если заголовок не включен в запрос, в качестве значения будет отображаться пустая строка.
* **{request.querystring.\<имя_параметра\>}** . Параметр строки запроса, который можно считать из исходного запроса. Замените *\<имя_параметра\>* именем параметра, который вы собираетесь считать. Если параметр не включен в запрос, в качестве значения будет отображаться пустая строка.

### <a name="response-parameters"></a>Ссылки на параметры ответа внутреннего сервера

Параметры ответа можно использовать при изменении ответов для клиента. Следующие значения можно использовать в качестве значений конфигурации:

* **{backend.response.statusCode}** . Код состояния HTTP, возвращаемый с ответом внутреннего сервера.
* **{backend.response.statusReason}** . Описание причины HTTP, возвращаемое с ответом внутреннего сервера.
* **{backend.response.headers.\<имя_заголовка\>}** . Заголовок, который можно считать из внутреннего сервера. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь считать. Если заголовок не включен в ответ, в качестве значения будет отображаться пустая строка.

### <a name="use-appsettings"></a>Ссылки на параметры приложения

Вы также можете ссылаться на [параметры приложения, определенные для приложения-функции](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings), поставив знаки процента (%) перед именем параметра и после него.

Например, в URL-адресе внутреннего сервера *https://%ORDER_PROCESSING_HOST%/api/orders* %ORDER_PROCESSING_HOST% будет заменено значением параметра ORDER_PROCESSING_HOST.

> [!TIP] 
> Используйте параметры приложения для внутренних узлов при наличии нескольких развертываний или тестовых сред. Таким образом, вы будете всегда обращаться к правильному внутреннему серверу в этой среде.

## <a name="debugProxies"></a>Устранение неполадок функции "Прокси-серверы"

Добавьте флаг `"debug":true` к любому прокси-серверу в `proxies.json`, чтобы включить ведение журнала отладки. Журналы хранятся в папке `D:\home\LogFiles\Application\Proxies\DetailedTrace`. К ним можно получить доступ с помощью дополнительных инструментов (Kudu). Каждый HTTP-ответ также будет содержать заголовок `Proxy-Trace-Location` с URL-адресом для доступа к файлу журнала.

Чтобы отладить прокси-сервер на стороне клиента, добавьте заголовок `Proxy-Trace-Enabled` с заданным значением `true`. При этом также будут записываться журналы трассировки в файловую систему и URL-адрес трассировки будет возвращаться в качестве заголовка в ответе.

### <a name="block-proxy-traces"></a>Блокирование трассировок прокси-сервера

В целях безопасности вы можете запретить всем пользователям вызывать службу для создания файлов трассировки. Пользователи не смогут получить доступ к содержимому трассировки без ваших учетных данных для входа. Но создание файлов трассировки связано с потреблением ресурсов и свидетельствует о том, что вы используете прокси-серверы Функций Azure.

Чтобы полностью отключить трассировку, добавьте `"debug":false` для конкретного прокси-сервера в `proxies.json`.

## <a name="advanced-configuration"></a>Расширенная настройка

Настроенные прокси-серверы хранятся в файле *proxies.json*, расположенном в корневом каталоге приложения-функции. Вы можете вручную изменить этот файл и развернуть его как часть приложения, используя любой из [методов развертывания](https://docs.microsoft.com/azure/azure-functions/functions-continuous-deployment), поддерживаемых Функциями. 

> [!TIP] 
> Если вы не настроили ни один из методов развертывания, вы можете сделать это в файле *proxies.json*. Перейдите к приложению-функции и выберите **Функции платформы**, а затем — **Редактор службы приложений**. Так вы сможете просмотреть всю структуру файла приложения-функции и внести изменения.

Файл *proxies.json* определяется объектом proxies, который состоит из именованных прокси-серверов и их определений. При необходимости для автозавершения кода можно ссылаться на [схему JSON](http://json.schemastore.org/proxies), если ваш редактор поддерживает такую возможность. Например, файл может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>"
        }
    }
}
```

Каждый прокси имеет понятное имя, как например *proxy1* в предыдущем примере. Соответствующий объект определения прокси определяется следующими свойствами:

* **matchCondition**. (Обязательное) объект, который определяет запросы, активирующие выполнение этого прокси-сервера. Он содержит два свойства, используемые совместно с [Триггеры HTTP]:
    * _methods_. Массив методов HTTP, на которые отвечает прокси-сервер. Если свойство не указано, прокси-сервер будет отвечать на все методы HTTP в маршруте.
    * _route_. (Обязательное) шаблон маршрута, определяющий URL-адреса запросов, на которые отвечает прокси-сервер. В отличие от триггеров HTTP значение по умолчанию отсутствует.
* **backendUri**. URL-адрес внутреннего ресурса, к которому должен быть отправлен запрос. Это значение может ссылаться на параметры приложения и параметры исходного запроса клиента. Если это свойство не включено, Функции Azure вернут ответ HTTP 200 OK.
* **requestOverrides**. Объект, определяющий преобразование запросов внутреннего сервера. Ознакомьтесь с разделом [Определение объекта requestOverrides].
* **responseOverrides**. Объект, определяющий преобразование ответа клиента. Ознакомьтесь с разделом [Определение объекта responseOverrides].

> [!NOTE] 
> Свойство *route* в функции "Прокси-серверы Функций Azure" не учитывает свойство *routePrefix* конфигурации узла приложения-функции. Если вы хотите включить префикс, например `/api`, он должен быть включен в свойство *route*.

### <a name="disableProxies"></a> Отключение отдельных прокси-серверов

Вы можете отключить отдельные прокси-серверы, добавив `"disabled": true` для прокси-сервера в файле `proxies.json`. В результате для всех запросов, соответствующих значению matchCondition, будет возвращаться ошибка 404.
```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "Root": {
            "disabled":true,
            "matchCondition": {
                "route": "/example"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>"
        }
    }
}
```

### <a name="applicationSettings"></a> Параметры приложения

Поведением прокси-сервера можно управлять с помощью нескольких параметров приложения. Сведения о них можно узнать из статьи [Справочник по параметрам приложений для Функций Azure](./functions-app-settings.md).

* [AZURE_FUNCTION_PROXY_DISABLE_LOCAL_CALL](./functions-app-settings.md#azure_function_proxy_disable_local_call)
* [AZURE_FUNCTION_PROXY_BACKEND_URL_DECODE_SLASHES](./functions-app-settings.md#azure_function_proxy_backend_url_decode_slashes)

### <a name="reservedChars"></a> Зарезервированные символы (форматирование строк)

Прокси-серверы считывают все строки из JSON-файла, используя \ как escape-символ. Кроме того, прокси-серверы интерпретируют фигурные скобки. См. полный список примеров ниже.

|Character|Экранируемый символ|Пример|
|-|-|-|
|{ или }|{{ или }}|`{{ example }}` --> `{ example }`
| \ | \\\\ | `example.com\\text.html` --> `example.com\text.html`
|"|\\\"| `\"example\"` --> `"example"`

### <a name="requestOverrides"></a>Определение объекта requestOverrides

Объект requestOverrides определяет изменения, внесенные в запрос во время вызова внутреннего ресурса. Объект определяется следующими свойствами:

* **backend.request.method**. Метод HTTP, используемый для вызова внутреннего сервера.
* **backend.request.querystring.\<имя_параметра\>** . Параметр строки запроса, который можно задать для вызова внутреннего сервера. Замените *\<имя_параметра\>* именем параметра, который вы собираетесь задать. Если указана пустая строка, параметр не включается в запрос внутреннего сервера.
* **backend.request.headers.\<имя_заголовка\>** . Заголовок, который можно задать вызову внутреннего сервера. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь задать. Если указана пустая строка, заголовок не включается в запрос внутреннего сервера.

Значения могут ссылаться на параметры приложения и параметры исходного запроса клиента.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>",
            "requestOverrides": {
                "backend.request.headers.Accept": "application/xml",
                "backend.request.headers.x-functions-key": "%ANOTHERAPP_API_KEY%"
            }
        }
    }
}
```

### <a name="responseOverrides"></a>Определение объекта responseOverrides

Объект requestOverrides определяет изменения, внесенные в ответ, который передается обратно к клиенту. Объект определяется следующими свойствами:

* **response.statusCode**. Код состояния HTTP, который будет возвращен клиенту.
* **response.statusReason**. Описание HTTP, которое будет возвращено клиенту.
* **response.body**. Строковое представление текста, который будет возвращен клиенту.
* **response.headers.\<имя_заголовка\>** . Заголовок, который можно задать ответу клиенту. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь задать. Если указана пустая строка, заголовок не включается в ответ.

Значения могут ссылаться на параметры приложения, параметры исходного запроса клиента и параметры ответа внутреннего сервера.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "responseOverrides": {
                "response.body": "Hello, {test}",
                "response.headers.Content-Type": "text/plain"
            }
        }
    }
}
```
> [!NOTE] 
> В этом примере текст ответа задается напрямую, поэтому задавать свойство `backendUri` не требуется. В примере показано, как можно использовать прокси-серверы Функций Azure для имитации API.

[портал Azure]: https://portal.azure.com
[Триггеры HTTP]: https://docs.microsoft.com/azure/azure-functions/functions-bindings-http-webhook
[Modify the back-end request]: #modify-backend-request
[Modify the response]: #modify-response
[Определение объекта requestOverrides]: #requestOverrides
[Определение объекта responseOverrides]: #responseOverrides
[Параметры приложения]: #use-appsettings
[Использование переменных]: #using-variables
[Параметры, установленные для исходного запроса клиента]: #request-parameters
[Параметры ответа внутреннего сервера]: #response-parameters
