---
title: Рекомендации по Функциям Azure | Документация Майкрософт
description: Ознакомьтесь с рекомендациями и шаблонами для Функций Azure.
author: ggailey777
manager: gwallace
ms.assetid: 9058fb2f-8a93-4036-a921-97a0772f503c
ms.service: azure-functions
ms.topic: conceptual
ms.date: 10/16/2017
ms.author: glenga
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: ad7bdfd3abc4d3b4b672f5471ea826d4cef0f3fc
ms.sourcegitcommit: b4f201a633775fee96c7e13e176946f6e0e5dd85
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2019
ms.locfileid: "72596887"
---
# <a name="optimize-the-performance-and-reliability-of-azure-functions"></a>Оптимизация производительности и надежности Функций Azure

В этой статье описано, как повысить производительность и надежность [бессерверных](https://azure.microsoft.com/solutions/serverless/) приложений-функций.  

## <a name="general-best-practices"></a>Общие рекомендации

Ниже приведены рекомендации по созданию и разработке бессерверных решений с помощью службы "Функции Azure".

### <a name="avoid-long-running-functions"></a>Избегайте длительных функций

Крупные длительные функции могут вызывать непредвиденные проблемы времени ожидания. Дополнительные сведения о времени ожидания для заданного плана размещения см. в разделе время [ожидания приложения-функции](functions-scale.md#timeout). 

Функция может стать крупной, если она содержит множество зависимостей Node.js. Импорт зависимостей может также привести к замедлению загрузки, что, в свою очередь, приводит к непредвиденным проблемам времени ожидания. Зависимости можно загрузить явно и неявно. Один модуль, загруженный в коде, может загрузить собственные дополнительные модули. 

По возможности выполняйте рефакторинг крупных функций и перерабатывайте их на более мелкие совместимые наборы функций, которые работают сообща и быстро возвращают ответ. Например, для функции веб-перехватчика или триггера HTTP может потребоваться подтверждение в течение ограниченного промежутка времени. Чаще всего для веб-перехватчиков требуется немедленный ответ. Полезные данные триггера HTTP можно передать в очередь для обработки с помощью функции триггера очереди. Такой подход позволяет отложить фактическую работу и сразу возвратить ответ.


### <a name="cross-function-communication"></a>Взаимодействие функций

[Устойчивые функции](durable/durable-functions-overview.md) и [Azure Logic Apps](../logic-apps/logic-apps-overview.md) используются для управления переходами состояний и обмена данными между несколькими функциями.

Если для интеграции нескольких функций не используются устойчивые функции или Logic Apps, для обмена данными между функциями лучше всего использовать очереди хранилища,  так как они дешевле и их гораздо проще подготовить к работе. 

Размер отдельных сообщений в очереди хранилища ограничен до 64 КБ. Если между функциями нужно передать сообщения большего размера, можно использовать очередь служебной шины Azure, которая поддерживает сообщения размером до 256 КБ на уровне "Стандартный" и 1 МБ на уровне "Премиум".

Если перед обработкой сообщений их нужно отфильтровать, ознакомьтесь со статьями о служебной шине.

Для поддержки обмена крупными сообщениями используются Центры событий.


### <a name="write-functions-to-be-stateless"></a>Создавайте функции без отслеживания состояния 

По возможности функции должны быть без отслеживания состояния и идемпотентными. Свяжите любые необходимые сведения о состоянии со своими данными. Например, с обрабатываемым заказом скорее всего будет связан элемент `state`. Функция может обработать заказ, основываясь на этом состоянии, но в ней самой при этом не отслеживается состояние. 

Идемпотентные функции рекомендуется использовать с триггерами таймера. Например, если какой-либо компонент нужно выполнять раз в день, пропишите его таким образом, чтобы он выполнялся в любое время в течение дня с тем же результатом. Функцию можно закрыть, если в определенный день ничего не нужно делать. Кроме того, если предыдущее выполнение завершилось ошибкой, следующее выполнение должно начаться с прерванного момента.


### <a name="write-defensive-functions"></a>Создавайте защищенные функции

Предположим, что в любое время в функции может возникнуть исключение. Реализуйте в функции возможность продолжения с предыдущей точки сбоя во время следующего выполнения. Давайте рассмотрим сценарий, в котором необходимо сделать следующее:

1. Запросить 10 000 строк в базе данных.
2. Создать сообщение очереди для каждой из этих строк для дальнейшей обработки.
 
В зависимости от того, насколько сложна система, у вас может быть: вовлечение подчиненных служб в неплохое поведение, сбои сети или достигнутые квоты и т. д. Все это может повлиять на вашу функцию в любое время. Функции необходимо подготавливать к таким проблемам.

Как отреагирует ваш код при сбое после вставки 5000 элементов в очередь для обработки? Отслеживайте элементы в наборе, работа с которым завершена. В противном случае их можно вставить позже. Это может серьезно повлиять на рабочий процесс. 

Если элемент очереди уже обработан, разрешите холостой цикл выполнения функции.

Воспользуйтесь предоставленными возможностями защиты для компонентов, используемых на платформе Функций Azure. Например, ознакомьтесь с разделом **Обработка подозрительных сообщений очереди** в документации по [триггерам и привязкам очереди службы хранилища Azure](functions-bindings-storage-queue.md#trigger---poison-messages). 

## <a name="scalability-best-practices"></a>Рекомендации по масштабируемости

То, как выполняется масштабирование экземпляров приложения-функции, зависит от нескольких факторов. Дополнительные сведения см. в документации по [масштабированию функций](functions-scale.md).  Ниже приведены рекомендации по оптимальному масштабированию приложения-функции.

### <a name="share-and-manage-connections"></a>Управление подключениями и общий доступ к ним

Повторно используйте подключения к внешним ресурсам, когда это возможно.  См. раздел [Способы управления подключениями в службе "Функции Azure"](./manage-connections.md).

### <a name="dont-mix-test-and-production-code-in-the-same-function-app"></a>Не используйте тестовый и рабочий код в одном приложении-функции

Функции в приложении-функции совместно используют ресурсы. Например, память. Если приложение-функция используется в рабочей среде, не добавляйте в нее тестовые функции и ресурсы. Это может вызвать непредвиденные затраты во время выполнения кода в рабочей среде.

Следите за тем, что вы загружаете в рабочие приложения-функции. Память усредняется для каждой функции в приложении.

Если у вас есть общая сборка, на которую имеется ссылка в нескольких функциях .NET, поставьте ее в общую общую папку. Создайте ссылку на сборку с помощью оператора, аналогичного следующему, если вы используете скрипты C# (CSX-файлы): 

    #r "..\Shared\MyAssembly.dll". 

В противном случае очень просто случайно развернуть несколько тестовых версий одного двоичного файла, которые действуют по-разному в разных функциях.

Не используйте подробное ведение журнала в рабочем коде. Это отрицательно сказывается на производительности.

### <a name="use-async-code-but-avoid-blocking-calls"></a>Использование асинхронного кода без блокирующих вызовов

Рекомендуется применять метод асинхронного программирования. Но никогда не используйте ссылки на свойство `Result` и не вызывайте метод `Wait` для экземпляра `Task`. Применение этого подхода может привести к нехватке потоков.

[!INCLUDE [HTTP client best practices](../../includes/functions-http-client-best-practices.md)]

### <a name="receive-messages-in-batch-whenever-possible"></a>По возможности получайте сообщения в пакетном режиме

Некоторые триггеры, например триггер концентратора событий, позволяют получать сообщения в пакетном режиме в рамках одного вызова.  Пакетная обработка сообщений обеспечивает более высокую производительность.  Вы можете настроить максимальный размер пакета в файле `host.json`, как описано в [справочной документации по host.json](functions-host-json.md).

При работе с C# тип функций можно изменить на строго типизированный массив.  Например, вместо `EventData sensorEvent` можно использовать сигнатуру метода `EventData[] sensorEvent`.  При работе с другими языками необходимо явно задать свойство кратности, указав в файле `function.json`значение `many`. Так вы включите пакетную обработку, [как показано здесь](https://github.com/Azure/azure-webjobs-sdk-templates/blob/df94e19484fea88fc2c68d9f032c9d18d860d5b5/Functions.Templates/Templates/EventHubTrigger-JavaScript/function.json#L10).

### <a name="configure-host-behaviors-to-better-handle-concurrency"></a>Настройте поведение узла для обеспечения оптимального параллелизма

Файл `host.json` в приложении-функции позволяет настраивать среду выполнения узла и поведение триггера.  Кроме настройки поведения пакетной обработки, вы можете управлять параллелизмом определенного числа триггеров.  Часто настройка этих параметров помогает масштабировать каждый экземпляр согласно требованиям вызванных функций.

Параметры в файле узлов применяются ко всем функциям приложения в пределах *одного экземпляра* функции. Например, если у вас есть приложение-функция с двумя функциями HTTP, настроенная на обработку 25 параллельных запросов, любой запрос к одному из триггеров HTTP будет считаться одним из общих 25 параллельных запросов.  Если это приложение-функция масштабировать до 10 экземпляров, две функции смогут эффективно обрабатывать 250 параллельных запросов (10 экземпляров х 25 параллельных запросов для каждой функции).

**Варианты параллелизма узла HTTP**

[!INCLUDE [functions-host-json-http](../../includes/functions-host-json-http.md)]

Другие параметры конфигурации узла см. в [документации по конфигурации узлов](functions-host-json.md).

## <a name="next-steps"></a>Дальнейшие действия

Для получения дополнительных сведений см. следующие ресурсы:

* [Способы управления подключениями в службе "Функции Azure"](manage-connections.md)
* [Рекомендации по использованию службы приложений Azure](../app-service/app-service-best-practices.md)
