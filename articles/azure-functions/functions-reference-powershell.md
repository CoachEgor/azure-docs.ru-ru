---
title: Ссылка разработчика PowerShell на функции Azure
description: Понять, как разрабатывать функции с помощью PowerShell.
author: eamonoreilly
ms.topic: conceptual
ms.date: 04/22/2019
ms.openlocfilehash: 41f977e7e7c23c2f49fd656461b7a3920802997e
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79276742"
---
# <a name="azure-functions-powershell-developer-guide"></a>Руководство разработчиков Azure Функции PowerShell

В этой статье приводится подробная информация о том, как вы пишете функции Azure с помощью PowerShell.

Функция PowerShell Azure (функция) представлена как скрипт PowerShell, выполняемый при срабатывании. Каждый скрипт `function.json` функции имеет связанный файл, который определяет, как функционирует функция, например, как она срабатывает и параметры ввода и вывода. Чтобы узнать больше, смотрите [триггеры и обязательные статьи](functions-triggers-bindings.md). 

Как и другие виды функций, функции сценария PowerShell входят в параметры, `function.json` которые соответствуют именам всех входных привязок, определенных в файле. Также `TriggerMetadata` передается параметр, содержащий дополнительную информацию о триггере, который запустил функцию.

В этой статье предполагается, что вы уже прочли [руководство для разработчиков по Функциям Azure](functions-reference.md). Вы также должны были завершить [функции quickstart для PowerShell,](functions-create-first-function-powershell.md) чтобы создать свою первую функцию PowerShell.

## <a name="folder-structure"></a>Структура папок

Требуемая структура папок для проекта PowerShell выглядит следующим образом. Это значение по умолчанию можно изменить. Дополнительные сведения см. в разделе о [scriptFile](#configure-function-scriptfile) ниже.

```
PSFunctionApp
 | - MyFirstFunction
 | | - run.ps1
 | | - function.json
 | - MySecondFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - myFirstHelperModule
 | | | - myFirstHelperModule.psd1
 | | | - myFirstHelperModule.psm1
 | | - mySecondHelperModule
 | | | - mySecondHelperModule.psd1
 | | | - mySecondHelperModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
 | - profile.ps1
 | - extensions.csproj
 | - bin
```

В основе проекта лежит общий [`host.json`](functions-host-json.md) файл, который можно использовать для настройки приложения функции. Каждая функция имеет папку со своим собственным файлом кода`function.json`(.ps1) и связывающим файлом конфигурации (). Название родительского каталога файла functionа functionа functionа functionа functionа function.json всегда имя вашей функции.

Некоторые привязки требуют `extensions.csproj` наличия файла. Обязательные расширения, [необходимые в версии 2.x и более поздних версиях](functions-versions.md) времени выполнения функций, определяются в `extensions.csproj` файле, а фактические файлы библиотеки — в папке. `bin` При локальной разработке необходимо [зарегистрировать расширения привязки](functions-bindings-register.md#extension-bundles). При разработке функций на портале Azure эта регистрация выполняется автоматически.

В функциях PowerShell приложения, вы `profile.ps1` можете дополнительно иметь который работает, когда функция приложение начинает работать (иначе знаю, как *[холодный старт](#cold-start)*. Для получения дополнительной [PowerShell profile](#powershell-profile)информации см.

## <a name="defining-a-powershell-script-as-a-function"></a>Определение скрипта PowerShell как функции

По умолчанию среда выполнения Функций ищет функцию в файле `run.ps1`, где `run.ps1` использует тот же родительский каталог, что и соответствующий файл `function.json`.

Ваш скрипт передается ряд аргументов по исполнению. Чтобы справиться с этими параметрами, добавьте `param` блок в верхней части скрипта, как в следующем примере:

```powershell
# $TriggerMetadata is optional here. If you don't need it, you can safely remove it from the param block
param($MyFirstInputBinding, $MySecondInputBinding, $TriggerMetadata)
```

### <a name="triggermetadata-parameter"></a>Параметр TriggerMetadata

Параметр `TriggerMetadata` используется для предоставления дополнительной информации о триггере. Дополнительные метаданные варьируются от привязки `sys` к привязке, но все они содержат свойство, содержащее следующие данные:

```powershell
$TriggerMetadata.sys
```

| Свойство   | Описание                                     | Тип     |
|------------|-------------------------------------------------|----------|
| UtcNow     | Когда в UTC функция была срабатына        | Дата и время |
| MethodName | Название функции, которая была срабатывана     | строка   |
| РэндГид   | уникальное руководство для этого исполнения функции | строка   |

Каждый тип триггера имеет свой набор метаданных. Например, `$TriggerMetadata` для `QueueTrigger` содержит `InsertionTime` `Id`, `DequeueCount`, среди прочего. Для получения дополнительной информации о метаданных триггера очереди перейдите в [официальную документацию для триггеров очереди.](functions-bindings-storage-queue-trigger.md#message-metadata) Проверьте документацию о [триггерах,](functions-triggers-bindings.md) с которыми вы работаете, чтобы увидеть, что входит в метаданные триггера.

## <a name="bindings"></a>Привязки

В PowerShell [привязки](functions-triggers-bindings.md) настроены и определяются в функции функции. Функции взаимодействуют с привязками несколькими способами.

### <a name="reading-trigger-and-input-data"></a>Чтение триггера и входных данных

Триггер и входные привязки считываются по параметрам, передаваемым вашей функции. Входные привязки имеют `direction` набор `in` в function.json. Свойство, `name` `function.json` определяемое в названии параметра, в блоке. `param` Поскольку PowerShell использует именованные параметры для связывания, порядок параметров не имеет значения. Тем не менее, это лучшая практика, чтобы следовать порядку привязки, определенные `function.json`в .

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)
```

### <a name="writing-output-data"></a>запись выходных данных;

В Функциях выходной `direction` привязка имеет набор `out` в function.json. Вы можете написать на выходную привязку с помощью `Push-OutputBinding` cmdlet, который доступен для выполнения функций. Во всех случаях `name` свойство переплета, как это определено в `function.json` соответствии с параметром `Name` `Push-OutputBinding` cmdlet.

Ниже показано, как `Push-OutputBinding` вызвать сценарий функции:

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Push-OutputBinding -Name myQueue -Value $myValue
```

Вы также можете передать значение для определенного связывания через конвейер.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Produce-MyOutputValue | Push-OutputBinding -Name myQueue
```

`Push-OutputBinding`ведет себя по-разному в `-Name`зависимости от значения, указанного для:

* Когда указанное имя не может быть устранено в допустимой привязке вывода, затем брошена ошибка.

* Когда связка вывода принимает набор значений, `Push-OutputBinding` можно вызвать несколько раз, чтобы нажать несколько значений.

* Когда связывание вывода принимает только значение `Push-OutputBinding` синглтона, вызов второго раза вызывает ошибку.

#### <a name="push-outputbinding-syntax"></a>Синтаксис `Push-OutputBinding`

Ниже приведены действительные `Push-OutputBinding`параметры для вызова:

| name | Тип | Положение | Описание |
| ---- | ---- |  -------- | ----------- |
| **`-Name`** | Строка | 1 | Название связывания вывода, которое необходимо установить. |
| **`-Value`** | Объект | 2 | Значение выходной привязки, которую вы хотите установить, которая принимается из конвейера ByValue. |
| **`-Clobber`** | SwitchParameter | именованная | (Необязательно) При указании, принуждает значение, необходимое для определенного выходного связывания. | 

Поддерживаются также следующие общие параметры: 
* `Verbose`
* `Debug`
* `ErrorAction`
* `ErrorVariable`
* `WarningAction`
* `WarningVariable`
* `OutBuffer`
* `PipelineVariable`
* `OutVariable` 

Для получения дополнительной [информации](https://go.microsoft.com/fwlink/?LinkID=113216)см.

#### <a name="push-outputbinding-example-http-responses"></a>Push-ВыходОбязательный пример: http ответы

Триггер HTTP возвращает ответ с помощью выходной привязки с именем. `response` В следующем примере выходная `response` привязка имеет значение "выходной #1":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #1"
})
```

Поскольку вывод до HTTP, который принимает только значение синглтона, ошибка выбрасывается, когда `Push-OutputBinding` называется во второй раз.

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #2"
})
```

Для выходов, которые принимают только значения синглтона, можно использовать `-Clobber` параметр для переопределения старого значения вместо того, чтобы добавлять в коллекцию. Следующий пример предполагает, что вы уже добавили значение. Используя `-Clobber`ответ из следующего примера, переопределяет существующее значение для возврата значения "выход#3":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #3"
}) -Clobber
```

#### <a name="push-outputbinding-example-queue-output-binding"></a>Пример Push-OutputBinding: связывание вывода очереди

`Push-OutputBinding`используется для отправки данных в выходные привязки, такие как [привязка к выходу хранилища Azure Queue.](functions-bindings-storage-queue-output.md) В следующем примере сообщение, написанное в очереди, имеет значение "выход #1":

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #1"
```

Выходная привязка для очереди хранения принимает несколько значений вывода. В этом случае, называя следующий пример после первого записывает в очередь список с двумя пунктами: "выход #1" и "выход #2".

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #2"
```

Следующий пример, когда называется после предыдущих двух, добавляет еще два значения для вывода коллекции:

```powershell
PS >Push-OutputBinding -Name outQueue -Value @("output #3", "output #4")
```

При написании в очереди сообщение содержит эти четыре значения: "выход #1", "выход #2", "выход #3" и "выход #4".

#### <a name="get-outputbinding-cmdlet"></a>Командлет `Get-OutputBinding`

Можно использовать `Get-OutputBinding` cmdlet для получения значений, установленных в настоящее время для выходных привязок. Это cmdlet извлекает хэштаблицу, которая содержит имена выходных привязок с их соответствующими значениями. 

Ниже приводится пример `Get-OutputBinding` использования для возвращения текущих обязательных значений:

```powershell
Get-OutputBinding
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
MyOtherQueue                   myData
```

`Get-OutputBinding`также содержит параметр, называемый `-Name`, который может быть использован для фильтрации возвращенной привязки, как в следующем примере:

```powershell
Get-OutputBinding -Name MyQ*
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
```

Wildcards (яп. `Get-OutputBinding`) поддерживаются в .

## <a name="logging"></a>Ведение журнала

Регистрация в функциях PowerShell работает как регулярные записи PowerShell. Для записи в каждый выходной поток можно использовать смдлеты для регистрации. Каждая карта cmdlet на уровне журнала, используемая Функциями.

| Уровень регистрации функций | Лесозаготовки cmdlet |
| ------------- | -------------- |
| Error | **`Write-Error`** |
| Предупреждение | **`Write-Warning`**  | 
| Сведения | **`Write-Information`** <br/> **`Write-Host`** <br /> **`Write-Output`**      | Сведения | Записывает _на_ информационный уровень регистрации. |
| Отладка | **`Write-Debug`** |
| Трассировка | **`Write-Progress`** <br /> **`Write-Verbose`** |

В дополнение к этим cmdlets, все, что `Information` написано на конвейер, перенаправляется на уровень журнала и отображается при форматировании PowerShell по умолчанию.

> [!IMPORTANT]
> Использование `Write-Verbose` или `Write-Debug` cmdlets не достаточно, чтобы увидеть многословные и отладки уровня лесозаготовок. Необходимо также настроить порог уровня журнала, который декларирует, какой уровень журналов вам действительно нёбо. Чтобы узнать больше, [см. Наверскакните уровень журнала приложения функции.](#configure-the-function-app-log-level)

### <a name="configure-the-function-app-log-level"></a>Настройка уровня журнала приложения функции

Функции Azure позволяют определить пороговый уровень, чтобы упростить управление тем, как функции записываемые в журналы. Чтобы установить порог для всех следов, `logging.logLevel.default` написанных на консоли, используйте свойство в [ `host.json` справке file][host.json.] Этот параметр применяется ко всем функциям в приложении-функции.

В следующем примере устанавливается пороговое значение для обеспечения многословной регистрации для `MyFunction`всех функций, но устанавливается порог, позволяющий отладить журнал для функции, названной:

```json
{
    "logging": {
        "logLevel": {
            "Function.MyFunction": "Debug",
            "default": "Trace"
        }
    }
}  
```

Дополнительные сведения см. в [справочной статье о host.json].

### <a name="viewing-the-logs"></a>Просмотр журналов

Если приложение функции работает в Azure, вы можете использовать Application Insights для его мониторинга. Дополнительные сведения о просмотре журналов функций и обращении к ним см. в статье [мониторинг Функций Azure](functions-monitoring.md).

Если вы работаете локально для разработки приложения функции, журналы по умолчанию в файловую систему. Чтобы увидеть журналы в консоли, установите переменную `AZURE_FUNCTIONS_ENVIRONMENT` среды `Development` перед запуском функции App.

## <a name="triggers-and-bindings-types"></a>Типы триггеров и привязок

Существует ряд триггеров и привязок, доступных для использования в приложении функции. Полный список триггеров и привязок [можно найти здесь](functions-triggers-bindings.md#supported-bindings).

Все триггеры и привязки представлены в коде как несколько реальных типов данных:

* Хэш-таблицы
* строка
* byte[]
* INT
* double
* HttpRequestContext
* HttpResponseContext

Первые пять типов в этом списке являются стандартными типами .NET. Последние два используются только [httptrigger триггера](#http-triggers-and-bindings).

Каждый параметр связывания в ваших функциях должен быть одним из этих типов.

### <a name="http-triggers-and-bindings"></a>Триггеры и привязки HTTP

Триггеры HTTP и webhook, а также привязки вывода HTTP используют объекты запроса и ответа для обмена сообщениями HTTP.

#### <a name="request-object"></a>Объект запроса

Объект запроса, который передается в скрипт, имеет тип, `HttpRequestContext`который имеет следующие свойства:

| Свойство  | Описание                                                    | Тип                      |
|-----------|----------------------------------------------------------------|---------------------------|
| **`Body`**    | Объект, содержащий текст запроса. `Body`сериализованв в лучший тип на основе данных. Например, если данные JSON, они передаются как хэшбит. Если данные строки, он передается в виде строки. | объект |
| **`Headers`** | Словарь, содержащий заголовки запросов.                | Словарь<строки, строки><sup>*</sup> |
| **`Method`** | Метод HTTP, используемый для запроса.                                | строка                    |
| **`Params`**  | Объект, содержащий параметры маршрутизации запроса. | Словарь<строки, строки><sup>*</sup> |
| **`Query`** | Объект, содержащий параметры запроса.                  | Словарь<строки, строки><sup>*</sup> |
| **`Url`** | URL-адрес запроса.                                        | строка                    |

<sup>*</sup>Все `Dictionary<string,string>` ключи нечувствительны.

#### <a name="response-object"></a>Объект ответа

Объект ответа, который следует отправить обратно, имеет тип, `HttpResponseContext`который имеет следующие свойства:

| Свойство      | Описание                                                 | Тип                      |
|---------------|-------------------------------------------------------------|---------------------------|
| **`Body`**  | Объект, содержащий текст ответа.           | объект                    |
| **`ContentType`** | Короткая рука для настройки типа содержимого для ответа. | строка                    |
| **`Headers`** | Объект, содержащий заголовок ответа.               | Словарь или hashtable   |
| **`StatusCode`**  | Код состояния HTTP ответа.                       | строка или целое число             |

#### <a name="accessing-the-request-and-response"></a>Доступ к запросу и ответу

При работе с триггерами HTTP можно получить доступ к запросу HTTP так же, как и с любым другим связыванием ввода. Он в квартале. `param`

Используйте `HttpResponseContext` объект для возврата ответа, как показано в следующем:

`function.json`

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "anonymous"
    },
    {
      "type": "http",
      "direction": "out"
    }
  ]
}
```

`run.ps1`

```powershell
param($req, $TriggerMetadata)

$name = $req.Query.Name

Push-OutputBinding -Name res -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "Hello $name!"
})
```

Результатом отзыва этой функции будет:

```
PS > irm http://localhost:5001?Name=Functions
Hello Functions!
```

### <a name="type-casting-for-triggers-and-bindings"></a>Тип-кастинг для триггеров и привязок

Для некоторых привязок, таких как привязка кабы, вы можете указать тип параметра.

Например, чтобы данные из хранилища Blob поставлялись в `param` виде строки, добавьте следующий тип, отлитый в мой блок:

```powershell
param([string] $myBlob)
```

## <a name="powershell-profile"></a>Профиль PowerShell

В PowerShell есть концепция профиля PowerShell. Если вы не знакомы с профилями PowerShell, [см.](/powershell/module/microsoft.powershell.core/about/about_profiles)

В функциях PowerShell скрипт профиля выполняется при запуске приложения функции. Функциональные приложения начинаются при первом развертывании и после прохожего[(холодный старт).](#cold-start)

При создании функционального приложения с использованием таких инструментов, как Visual `profile.ps1` Studio Code и Azure Functions Core Tools, для вас создается значение по умолчанию. Профиль по умолчанию сохраняется [в репозитории Основных инструментов GitHub](https://github.com/Azure/azure-functions-core-tools/blob/dev/src/Azure.Functions.Cli/StaticResources/profile.ps1) и содержит:

* Автоматическая аутентификация MSI в Azure.
* Возможность включить псевдонимAzs Azure `AzureRM` PowerShell PowerShell, если хотите.

## <a name="powershell-version"></a>Версия PowerShell

В следующей таблице показана версия PowerShell, используемая каждой основной версией времени выполнения функций:

| Версия службы "Функции" | Версия PowerShell                             |
|-------------------|------------------------------------------------|
| 1.x               | Windows PowerShell 5.1 (заблокирован временем выполнения) |
| 2.x               | Ядро PowerShell 6                              |

Текущую версию можно `$PSVersionTable` увидеть по любой функции.

## <a name="dependency-management"></a>Управление зависимостями

Функции позволяют использовать [галерею PowerShell](https://www.powershellgallery.com) для управления зависимостями. При включении управления зависимостями файл requirements.psd1 используется для автоматической загрузки требуемых модулей. Это поведение позволяет включить, установив `managedDependency` свойство `true` в корне [файла host.json,](functions-host-json.md)как в следующем примере:

```json
{
  "managedDependency": {
          "enabled": true
       }
}
```

При создании нового проекта функций PowerShell управление зависимостями включается по умолчанию, включая [ `Az` модуль](/powershell/azure/new-azureps-module-az) Azure. Максимальное количество поддерживаемых модулей в настоящее время составляет 10. Поддерживаемый синтаксис — это _`MajorNumber`_ `.*` или точная версия модуля, показанная в следующем примере requirements.psd1:

```powershell
@{
    Az = '1.*'
    SqlServer = '21.1.18147'
}
```

При обновлении файла requirements.psd1 после перезагрузки устанавливаются обновленные модули.

> [!NOTE]
> Управляемые зависимости требуют доступа к www.powershellgallery.com для загрузки модулей. При локальном запуске убедитесь, что время выполнения может получить доступ к этому URL, добавив все необходимые правила брандмауэра. 

Следующие настройки приложения могут быть использованы для изменения загрузки и установки управляемых зависимостей. Обновление приложения начинается в пределах, `MDMaxBackgroundUpgradePeriod`и процесс `MDNewSnapshotCheckPeriod`обновления завершается примерно в пределах .

| Настройка приложения функции              | Значение по умолчанию             | Описание                                         |
|   -----------------------------   |   -------------------     |  -----------------------------------------------    |
| **`MDMaxBackgroundUpgradePeriod`**      | `7.00:00:00`(7 дней)     | Каждый рабочий процесс PowerShell инициирует проверку обновления модулей в галерее PowerShell при запуске процесса и каждый `MDMaxBackgroundUpgradePeriod` после этого. Когда новая версия модуля доступна в галерее PowerShell, она устанавливается в файловую систему и становится доступной для работников PowerShell. Уменьшение этого значения позволяет приложению функции быстрее получать новые версии модулей, но это также увеличивает использование ресурсов приложения (сетевой виолончей, процессор, хранилище). Увеличение этого значения уменьшает использование ресурсов приложения, но это также может задержать доставку новых версий модулей в приложение. | 
| **`MDNewSnapshotCheckPeriod`**         | `01:00:00`(1 час)       | После установки новых версий модуля в файловую систему необходимо перезапустить каждый рабочий процесс PowerShell. Перезапуск сотрудников PowerShell влияет на доступность приложения, так как может прервать выполнение текущей функции. До тех пор, пока все рабочие процессы PowerShell не будут перезапущены, вызовы функций могут использовать либо старые, либо новые версии модуля. Перезапуск всех работников `MDNewSnapshotCheckPeriod`PowerShell завершен в пределах . Увеличение этого значения уменьшает частоту перерывов, но может также увеличить период времени, когда вызовы функции используют либо старые, либо новые версии модуля недетерминированно. |
| **`MDMinBackgroundUpgradePeriod`**      | `1.00:00:00`(1 день)     | Чтобы избежать чрезмерного обновления модуля при частых перезагрузках Worker, проверка обновления модуля `MDMinBackgroundUpgradePeriod`не выполняется, когда какой-либо сотрудник уже инициировал эту проверку в последнем. |

Использование собственных модулей немного отличается от того, как вы бы это обычно делали.

На локальном компьютере модуль устанавливается в одну из общедоступных папок в вашем `$env:PSModulePath`компьютере. При работе в Azure у вас нет доступа к модулям, установленным на машине. Это означает, `$env:PSModulePath` что приложение функции PowerShell отличается от `$env:PSModulePath` обычного скрипта PowerShell.

В Функциях `PSModulePath` содержится два пути:

* Папка, `Modules` которая существует в корне приложения функции.
* Путь к `Modules` папке, которая контролируется работником языка PowerShell.

### <a name="function-app-level-modules-folder"></a>Папка уровня `Modules` функции

Для использования пользовательских модулей можно разместить модули, от которых зависят функции, в папке. `Modules` Из этой папки модули автоматически доступны для выполнения функций. Любая функция в приложении функции может использовать эти модули. 

> [!NOTE]
> Модули, указанные в файле requirements.psd1, автоматически загружаются и включаются в путь, поэтому вам не нужно включать их в папку модулей. Они хранятся локально `$env:LOCALAPPDATA/AzureFunctions` в папке `/data/ManagedDependencies` и в папке при запуске в облаке.

Чтобы воспользоваться функцией пользовательского `Modules` модуля, создайте папку в корне приложения функции. Копируйте модули, которые вы хотите использовать в своих функциях, в этом месте.

```powershell
mkdir ./Modules
Copy-Item -Path /mymodules/mycustommodule -Destination ./Modules -Recurse
```

С `Modules` папкой приложение функции должно иметь следующую структуру папки:

```
PSFunctionApp
 | - MyFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - MyCustomModule
 | | - MyOtherCustomModule
 | | - MySpecialModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
```

При запуске приложения функции сотрудник языка `Modules` PowerShell добавляет `$env:PSModulePath` эту папку в папку так, чтобы вы могли полагаться на автозагрузку модулей так же, как в обычном скрипте PowerShell.

### <a name="language-worker-level-modules-folder"></a>Папка `Modules` уровня работника языка

Несколько модулей обычно используются работником языка PowerShell. Эти модули определяются в `PSModulePath`последней позиции . 

Текущий список модулей:

* [Microsoft.PowerShell.Archive](https://www.powershellgallery.com/packages/Microsoft.PowerShell.Archive): модуль, используемый для `.zip` `.nupkg`работы с архивами, как , и другие.
* **ThreadJob**: Реализация AAP задания PowerShell на основе потоков.

По умолчанию функции используют самую позднюю версию этих модулей. Чтобы использовать конкретную версию модуля, поместите эту конкретную версию в `Modules` папку приложения функции.

## <a name="environment-variables"></a>Переменные среды

В Функциях [параметры приложения](functions-app-settings.md), такие как строки подключения службы, доступны в виде переменных среды во время выполнения. Вы можете получить доступ `$env:NAME_OF_ENV_VAR`к этим параметрам, используя, как показано в следующем примере:

```powershell
param($myTimer)

Write-Host "PowerShell timer trigger function ran! $(Get-Date)"
Write-Host $env:AzureWebJobsStorage
Write-Host $env:WEBSITE_SITE_NAME
```

[!INCLUDE [Function app settings](../../includes/functions-app-settings.md)]

При локальном запуске приложения параметры считываются из файла проекта [local.settings.json](functions-run-local.md#local-settings-file).

## <a name="concurrency"></a>параллелизм

По умолчанию время выполнения функций PowerShell может обрабатываться только одним вызовом функции за один раз. Однако этого уровня параллелизма может оказаться недостаточно в следующих ситуациях:

* При одновременной обработке большого количества вызовов.
* Если у вас есть функции, которые вызывают другие функции внутри той же функции приложения.

Это поведение можно изменить, установив следующую переменную среды на цельное значение:

```
PSWorkerInProcConcurrencyUpperBound
```

Вы устанавливаете эту переменную среды в [настройках приложения](functions-app-settings.md) вашего приложения.

### <a name="considerations-for-using-concurrency"></a>Рассмотрение вопроса об использовании параллелизма

PowerShell — это _единый язык резьбовых_ сценариев по умолчанию. Тем не менее, параллелизм может быть добавлен с помощью нескольких беговых пространств PowerShell в одном и том же процессе. Количество созданных беговых пространств будет соответствовать настройкам приложения PSWorkerInProccurrencyUpperBound. Пропускная стоимость будет влиять на количество процессора и памяти, доступных в выбранном плане.

Azure PowerShell использует некоторые контексты и состояния _на уровне процессов,_ чтобы избавить вас от избыточного ввода. Однако, если вы включите параллелизм в приложении функции и вызываете действия, изменяющие состояние, вы можете столкнуться с условиями гонки. Эти расовые условия трудно отладить, потому что один вызов опирается на определенное состояние, а другой вызов изменил состояние.

С Azure PowerShell существует огромное значение, так как некоторые операции могут занять значительное количество времени. Тем не менее, вы должны действовать с осторожностью. Если вы подозреваете, что испытываете состояние гонки, установите настройку `1` приложения PSWorkerInProConcurrencyUpperBound и вместо этого используйте [изоляцию уровня процесса языкового рабочего](functions-app-settings.md#functions_worker_process_count) для параллелизма.

## <a name="configure-function-scriptfile"></a>Функция настройки`scriptFile`

По умолчанию функция PowerShell выполняется из `run.ps1`файла, который разделяет тот `function.json`же родительский каталог, что и соответствующий.

Свойство `scriptFile` в `function.json` может быть использовано для получения структуры папки, которая выглядит как следующий пример:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.ps1
```

В этом случае `function.json` `myFunction` для `scriptFile` включено свойство, ссылающееся на файл с экспортируемой функцией для запуска.

```json
{
  "scriptFile": "../lib/PSFunction.ps1",
  "bindings": [
    // ...
  ]
}
```

## <a name="use-powershell-modules-by-configuring-an-entrypoint"></a>Используйте модули PowerShell, настраивая entryPoint

В этой статье показаны функции PowerShell в файле скрипта по умолчанию, `run.ps1` генерируемом шаблонами.
Тем не менее, вы также можете включить свои функции в модули PowerShell. Вы можете ссылаться на свой конкретный `scriptFile` `entryPoint` функциональный код в модуле, используя поля и поля в файле конфигурации function.json.

В этом `entryPoint` случае, это имя функции или cmdlet в `scriptFile`модуле PowerShell, на который ссылается .

Рассмотрим следующую структуру папки:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.psm1
```

Где `PSFunction.psm1` содержится:

```powershell
function Invoke-PSTestFunc {
    param($InputBinding, $TriggerMetadata)

    Push-OutputBinding -Name OutputBinding -Value "output"
}

Export-ModuleMember -Function "Invoke-PSTestFunc"
```

В этом примере `myFunction` конфигурация `scriptFile` включает `PSFunction.psm1`свойство, которое ссылается, которое является модулем PowerShell в другой папке.  Свойство `entryPoint` ссылается `Invoke-PSTestFunc` на функцию, которая является точкой входа в модуле.

```json
{
  "scriptFile": "../lib/PSFunction.psm1",
  "entryPoint": "Invoke-PSTestFunc",
  "bindings": [
    // ...
  ]
}
```

С этой конфигурацией, `Invoke-PSTestFunc` получает выполняется точно так же, `run.ps1` как бы.

## <a name="considerations-for-powershell-functions"></a>Рассмотрение функций PowerShell

При работе с функциями PowerShell будьте в курсе следующих разделов.

### <a name="cold-start"></a>Холодный запуск

При разработке функций Azure в [модели без серверов хостинга](functions-scale.md#consumption-plan)холодные старты становятся реальностью. *Холодный старт* относится к периоду времени, необходимому приложению функции для начала работы для обработки запроса. Холодный старт происходит чаще в плане потребления, потому что приложение функции закрывается в периоды бездействия.

### <a name="bundle-modules-instead-of-using-install-module"></a>Комплектные модули вместо использования`Install-Module`

Ваш скрипт работает на каждом вызове. Избегайте `Install-Module` использования в скрипте. Вместо `Save-Module` этого используйте перед публикацией, чтобы ваша функция не тратить время на загрузку модуля. Если холодные старты влияют на ваши функции, рассмотрите возможность развертывания приложения функции в [плане службы приложений,](functions-scale.md#app-service-plan) установленного *для всегда на* или в плане [Premium.](functions-scale.md#premium-plan)

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения см. в следующих ресурсах:

* [Рекомендации по функциям Azure](functions-best-practices.md)
* [Справочник разработчика по функциям Azure](functions-reference.md)
* [Триггеры и привязки функций Azure](functions-triggers-bindings.md)

[Справочник по host.json]: functions-host-json.md
