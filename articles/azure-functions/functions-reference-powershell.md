---
title: Справочник разработчика PowerShell для функций Azure
description: Узнайте, как разрабатывать функции с помощью PowerShell.
author: eamonoreilly
ms.topic: conceptual
ms.date: 04/22/2019
ms.openlocfilehash: 2fa510e447d4d9b054a37f7665d010382a5db819
ms.sourcegitcommit: 5ab4f7a81d04a58f235071240718dfae3f1b370b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2019
ms.locfileid: "74974246"
---
# <a name="azure-functions-powershell-developer-guide"></a>Рекомендации для разработчиков по функциям Azure PowerShell

Эта статья содержит сведения о том, как вы пишете функции Azure с помощью PowerShell.

Функция Azure PowerShell (функция) представляется в виде скрипта PowerShell, который выполняется при срабатывании. Каждый сценарий функции имеет связанный файл `function.json`, который определяет, как работает функция, например, как она запускается, а также ее входные и выходные параметры. Дополнительные сведения см. в [статье о триггерах и привязке](functions-triggers-bindings.md). 

Как и другие виды функций, функции скриптов PowerShell принимают параметры, соответствующие именам всех входных привязок, определенных в файле `function.json`. Также передается параметр `TriggerMetadata`, содержащий дополнительные сведения о триггере, который запустил функцию.

В этой статье предполагается, что вы уже прочли [руководство для разработчиков по Функциям Azure](functions-reference.md). Кроме того, для создания первой функции PowerShell необходимо завершить работу с [кратким руководством по функциям PowerShell](functions-create-first-function-powershell.md) .

## <a name="folder-structure"></a>Структура папок

Необходимая структура папок для проекта PowerShell выглядит следующим образом. Это значение по умолчанию можно изменить. Дополнительные сведения см. в разделе о [scriptFile](#configure-function-scriptfile) ниже.

```
PSFunctionApp
 | - MyFirstFunction
 | | - run.ps1
 | | - function.json
 | - MySecondFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - myFirstHelperModule
 | | | - myFirstHelperModule.psd1
 | | | - myFirstHelperModule.psm1
 | | - mySecondHelperModule
 | | | - mySecondHelperModule.psd1
 | | | - mySecondHelperModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
 | - profile.ps1
 | - extensions.csproj
 | - bin
```

В корне проекта имеется общий файл [`host.json`](functions-host-json.md) , который можно использовать для настройки приложения-функции. У каждой функции есть папка с собственным файлом кода (PS1) и файл конфигурации привязки (`function.json`). Имя родительского каталога файла Function. JSON всегда является именем функции.

Для определенных привязок требуется наличие файла `extensions.csproj`. Расширения привязки, необходимые в [версии 2. x и более поздних версиях](functions-versions.md) среды выполнения функций, определяются в файле `extensions.csproj` с фактическими файлами библиотеки в папке `bin`. При локальной разработке необходимо [зарегистрировать расширения привязки](functions-bindings-register.md#extension-bundles). При разработке функций на портале Azure эта регистрация выполняется автоматически.

В приложениях-функциях PowerShell при необходимости можно использовать `profile.ps1`, который выполняется при запуске приложения-функции (в противном случае это может быть " *[холодный" Запуск](#cold-start)* ). Дополнительные сведения см. в разделе [профиль PowerShell](#powershell-profile).

## <a name="defining-a-powershell-script-as-a-function"></a>Определение скрипта PowerShell как функции

По умолчанию среда выполнения Функций ищет функцию в файле `run.ps1`, где `run.ps1` использует тот же родительский каталог, что и соответствующий файл `function.json`.

При выполнении скрипту передается ряд аргументов. Чтобы обрабатывал эти параметры, добавьте блок `param` в начало скрипта, как показано в следующем примере:

```powershell
# $TriggerMetadata is optional here. If you don't need it, you can safely remove it from the param block
param($MyFirstInputBinding, $MySecondInputBinding, $TriggerMetadata)
```

### <a name="triggermetadata-parameter"></a>Тригжерметадата, параметр

Параметр `TriggerMetadata` используется для предоставления дополнительных сведений о триггере. Дополнительные метаданные отличаются от привязки к привязке, но все они содержат свойство `sys`, которое содержит следующие данные:

```powershell
$TriggerMetadata.sys
```

| Свойство   | Описание                                     | Тип     |
|------------|-------------------------------------------------|----------|
| UtcNow     | Когда, в формате UTC, была активирована функция        | Дата и время |
| MethodName | Имя функции, которая была активирована     | string   |
| рандгуид   | уникальный идентификатор GUID для этого выполнения функции | string   |

Каждый тип триггера имеет другой набор метаданных. Например, `$TriggerMetadata` для `QueueTrigger` содержит `InsertionTime`, `Id`, `DequeueCount`, помимо прочего. Дополнительные сведения о метаданных триггера очереди см. в [официальной документации по триггерам очереди](functions-bindings-storage-queue.md#trigger---message-metadata). Ознакомьтесь с документацией по [триггерам](functions-triggers-bindings.md) , с которыми вы работаете, чтобы узнать, что входит в метаданные триггера.

## <a name="bindings"></a>Привязки

В PowerShell [привязки](functions-triggers-bindings.md) настраиваются и определяются в функции. JSON функции. Функции взаимодействуют с привязками несколькими способами.

### <a name="reading-trigger-and-input-data"></a>Чтение триггера и входных данных

Привязки триггера и ввода считываются как параметры, передаваемые в функцию. Для входных привязок `direction` задано значение `in` в Function. JSON. Свойство `name`, определенное в `function.json`, является именем параметра в блоке `param`. Так как PowerShell использует именованные параметры для привязки, порядок параметров не имеет значения. Однако рекомендуется следовать порядку привязок, определенных в `function.json`.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)
```

### <a name="writing-output-data"></a>запись выходных данных;

В функциях выходная привязка имеет `direction` задано `out` в Function. JSON. Запись в выходную привязку можно выполнить с помощью командлета `Push-OutputBinding`, который доступен для среды выполнения функций. Во всех случаях свойство `name` привязки, определенное в `function.json`, соответствует параметру `Name` командлета `Push-OutputBinding`.

Ниже показано, как вызвать `Push-OutputBinding` в скрипте функции:

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Push-OutputBinding -Name myQueue -Value $myValue
```

Можно также передать значение для конкретной привязки через конвейер.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Produce-MyOutputValue | Push-OutputBinding -Name myQueue
```

`Push-OutputBinding` ведет себя по-разному в зависимости от значения, указанного для `-Name`:

* Если указанное имя не может быть разрешено в допустимую выходную привязку, возникает ошибка.

* Когда выходная привязка принимает коллекцию значений, можно многократно вызывать `Push-OutputBinding` для отправки нескольких значений.

* Если выходная привязка принимает только одноэлементное значение, вызов `Push-OutputBinding` второй раз вызывает ошибку.

#### <a name="push-outputbinding-syntax"></a>Синтаксис `Push-OutputBinding`

Ниже приведены допустимые параметры для вызова `Push-OutputBinding`.

| Name | Тип | Позиция | Описание |
| ---- | ---- |  -------- | ----------- |
| **`-Name`** | Строка | 1 | Имя выходной привязки, которую необходимо задать. |
| **`-Value`** | Объекты | 2 | Значение выходной привязки, которое необходимо задать, которое принимается из Бивалуе конвейера. |
| **`-Clobber`** | SwitchParameter | именованная | Используемых При указании параметра устанавливает значение для заданной выходной привязки. | 

Также поддерживаются следующие общие параметры: 
* `Verbose`
* `Debug`
* `ErrorAction`
* `ErrorVariable`
* `WarningAction`
* `WarningVariable`
* `OutBuffer`
* `PipelineVariable`
* `OutVariable` 

Дополнительные сведения см. в разделе [About общиепараметры](https://go.microsoft.com/fwlink/?LinkID=113216).

#### <a name="push-outputbinding-example-http-responses"></a>Push-Аутпутбиндинг пример: HTTP-ответы

Триггер HTTP возвращает ответ, используя выходную привязку с именем `response`. В следующем примере выходная привязка `response` имеет значение "Output #1":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #1"
})
```

Поскольку выходным данным является HTTP, которая принимает только одноэлементное значение, возникает ошибка, когда `Push-OutputBinding` вызывается второй раз.

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #2"
})
```

Для выходов, которые принимают только одноэлементные значения, можно использовать параметр `-Clobber` для переопределения старого значения вместо попытки добавления в коллекцию. В следующем примере предполагается, что вы уже добавили значение. При использовании `-Clobber`ответ из следующего примера переопределяет существующее значение, чтобы вернуть значение "Output #3":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #3"
}) -Clobber
```

#### <a name="push-outputbinding-example-queue-output-binding"></a>Пример Push-Аутпутбиндинг: Выходная привязка очереди

`Push-OutputBinding` используется для отправки данных в выходные привязки, такие как [выходная привязка хранилища очередей Azure](functions-bindings-storage-queue.md#output). В следующем примере сообщение, записанное в очередь, имеет значение "Output #1":

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #1"
```

Выходная привязка для очереди хранилища принимает несколько выходных значений. В этом случае вызов следующего примера после первой записи в очередь списка с двумя элементами: "Output #1" и "Output #2".

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #2"
```

В следующем примере, когда вызывается после двух предыдущих, в выходную коллекцию добавляется еще два значения:

```powershell
PS >Push-OutputBinding -Name outQueue -Value @("output #3", "output #4")
```

При запись в очередь сообщение содержит следующие четыре значения: "Output #1", "Output #2", "Output #3" и "Output #4".

#### <a name="get-outputbinding-cmdlet"></a>Командлет `Get-OutputBinding`

Можно использовать командлет `Get-OutputBinding` для получения значений, заданных в данный момент для выходных привязок. Этот командлет извлекает хэш-таблицу, содержащую имена выходных привязок с соответствующими значениями. 

Ниже приведен пример использования `Get-OutputBinding` для возврата текущих значений привязки:

```powershell
Get-OutputBinding
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
MyOtherQueue                   myData
```

`Get-OutputBinding` также содержит параметр с именем `-Name`, который можно использовать для фильтрации возвращаемой привязки, как показано в следующем примере:

```powershell
Get-OutputBinding -Name MyQ*
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
```

В `Get-OutputBinding`поддерживаются подстановочные знаки (*).

## <a name="logging"></a>Ведение журнала

Ведение журнала в функциях PowerShell работает как обычное ведение журнала PowerShell. Командлеты ведения журнала можно использовать для записи в каждый выходной поток. Каждый командлет сопоставляется с уровнем ведения журнала, который используется функциями.

| Уровень ведения журнала функций | Командлет ведения журнала |
| ------------- | -------------- |
| Ошибка | **`Write-Error`** |
| Предупреждение | **`Write-Warning`**  | 
| Информация | **`Write-Information`** <br/> **`Write-Host`** <br /> **`Write-Output`**      | Информация | Выполняет запись в журнал на уровне _информации_ . |
| Отладка | **`Write-Debug`** |
| Трассировка | **`Write-Progress`** <br /> **`Write-Verbose`** |

Помимо этих командлетов, все данные, записанные в конвейер, перенаправляются на уровень журнала `Information` и отображаются с форматированием PowerShell по умолчанию.

> [!IMPORTANT]
> Использование командлетов `Write-Verbose` или `Write-Debug` недостаточно для просмотра подробных сведений и ведения журнала на уровне отладки. Кроме того, необходимо настроить пороговое значение уровня ведения журнала, которое объявляет, какой уровень журналов вы в действительности интересуют. Дополнительные сведения см. в статье [Настройка уровня ведения журнала приложения функции](#configure-the-function-app-log-level).

### <a name="configure-the-function-app-log-level"></a>Настройка уровня ведения журнала приложения функции

Функции Azure позволяют определить пороговый уровень, чтобы упростить управление способом записи функций в журналы. Чтобы задать пороговое значение для всех трассировок, записываемых на консоль `logging.logLevel.default` , используйте свойство [`host.json`в справочнике ][справочник по host. json]. Этот параметр применяется ко всем функциям в приложении-функции.

В следующем примере устанавливается пороговое значение для включения подробного ведения журнала для всех функций, но устанавливается пороговое значение включения ведения журнала отладки для функции с именем `MyFunction`:

```json
{
    "logging": {
        "logLevel": {
            "Function.MyFunction": "Debug",
            "default": "Trace"
        }
    }
}  
```

Дополнительные сведения см. в [Справочник по Host. JSON].

### <a name="viewing-the-logs"></a>Просмотр журналов

Если приложение-функция выполняется в Azure, можно использовать Application Insights для мониторинга. Дополнительные сведения о просмотре журналов функций и обращении к ним см. в статье [мониторинг Функций Azure](functions-monitoring.md).

Если вы используете приложение-функция локально для разработки, ведет журнал по умолчанию в файловой системе. Чтобы просмотреть журналы в консоли, задайте для переменной среды `AZURE_FUNCTIONS_ENVIRONMENT` значение `Development` перед запуском приложение-функция.

## <a name="triggers-and-bindings-types"></a>Типы триггеров и привязок

Существует ряд триггеров и привязок, которые можно использовать с приложением-функцией. Полный список триггеров и привязок [можно найти здесь](functions-triggers-bindings.md#supported-bindings).

Все триггеры и привязки представлены в коде как несколько реальных типов данных:

* Хэш-таблицы
* string
* byte[]
* int
* Double
* HttpRequestContext
* HttpResponseContext

Первые пять типов в этом списке являются стандартными типами .NET. Последние два используются только [триггером HttpTrigger](#http-triggers-and-bindings).

Каждый параметр привязки в функциях должен иметь один из этих типов.

### <a name="http-triggers-and-bindings"></a>Триггеры и привязки HTTP

Триггеры HTTP и webhook, а также привязки вывода HTTP используют объекты запроса и ответа для обмена сообщениями HTTP.

#### <a name="request-object"></a>Объект запроса

Объект запроса, переданный в скрипт, имеет тип `HttpRequestContext`, который имеет следующие свойства:

| Свойство  | Описание                                                    | Тип                      |
|-----------|----------------------------------------------------------------|---------------------------|
| **`Body`**    | Объект, содержащий текст запроса. `Body` сериализуется в лучший тип на основе данных. Например, если данные являются JSON, они передаются в виде хэш-таблицы. Если данные являются строкой, они передаются в виде строки. | object |
| **`Headers`** | Словарь, содержащий заголовки запроса.                | Строка < словаря, строка ><sup>*</sup> |
| **`Method`** | Метод HTTP, используемый для запроса.                                | string                    |
| **`Params`**  | Объект, содержащий параметры маршрутизации запроса. | Строка < словаря, строка ><sup>*</sup> |
| **`Query`** | Объект, содержащий параметры запроса.                  | Строка < словаря, строка ><sup>*</sup> |
| **`Url`** | URL-адрес запроса.                                        | string                    |

<sup>*</sup> Все ключи `Dictionary<string,string>` не чувствительны к регистру.

#### <a name="response-object"></a>Объект ответа

Объект ответа, который необходимо отправить обратно, имеет тип `HttpResponseContext`, который имеет следующие свойства:

| Свойство      | Описание                                                 | Тип                      |
|---------------|-------------------------------------------------------------|---------------------------|
| **`Body`**  | Объект, содержащий текст ответа.           | object                    |
| **`ContentType`** | Короткий рукой для установки типа содержимого для ответа. | string                    |
| **`Headers`** | Объект, содержащий заголовок ответа.               | Словарь или хэш-таблица   |
| **`StatusCode`**  | Код состояния HTTP ответа.                       | строка или целое число             |

#### <a name="accessing-the-request-and-response"></a>Доступ к запросу и ответу

При работе с триггерами HTTP доступ к HTTP-запросу можно получить так же, как и с любой другой входной привязкой. Он находится в блоке `param`.

Используйте объект `HttpResponseContext` для возврата ответа, как показано ниже:

`function.json`

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "anonymous"
    },
    {
      "type": "http",
      "direction": "out"
    }
  ]
}
```

`run.ps1`

```powershell
param($req, $TriggerMetadata)

$name = $req.Query.Name

Push-OutputBinding -Name res -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "Hello $name!"
})
```

Результат вызова этой функции будет следующим:

```
PS > irm http://localhost:5001?Name=Functions
Hello Functions!
```

### <a name="type-casting-for-triggers-and-bindings"></a>Приведение типов для триггеров и привязок

Для некоторых привязок, таких как привязка больших двоичных объектов, можно указать тип параметра.

Например, чтобы данные из хранилища BLOB-объектов передавались в виде строки, добавьте приведенный ниже тип в мой блок `param`:

```powershell
param([string] $myBlob)
```

## <a name="powershell-profile"></a>Профиль PowerShell

В PowerShell есть понятие профиля PowerShell. Если вы не знакомы с профилями PowerShell, см. раздел [About Profiles](/powershell/module/microsoft.powershell.core/about/about_profiles).

В функциях PowerShell скрипт профиля выполняется при запуске приложения функции. Приложения-функции запускаются при первом развертывании и после бездействия ([холодный запуск](#cold-start)).

При создании приложения-функции с помощью таких средств, как Visual Studio Code и Azure Functions Core Tools, создается `profile.ps1` по умолчанию. Профиль по умолчанию хранится [в репозитории основных средств](https://github.com/Azure/azure-functions-core-tools/blob/dev/src/Azure.Functions.Cli/StaticResources/profile.ps1) , который содержит:

* Автоматическая проверка подлинности MSI в Azure.
* Возможность включения Azure PowerShell `AzureRM` псевдонимов PowerShell при желании.

## <a name="powershell-version"></a>Версия PowerShell

В следующей таблице показана версия PowerShell, используемая каждой основной версией среды выполнения функций.

| Версия службы "Функции" | Версия PowerShell                             |
|-------------------|------------------------------------------------|
| 1.x               | Windows PowerShell 5,1 (заблокировано средой выполнения) |
| 2.x               | PowerShell Core 6                              |

Текущую версию можно просмотреть, выполнив печать `$PSVersionTable` из любой функции.

## <a name="dependency-management"></a>Управление зависимостями

Функции позволяют использовать [коллекцию PowerShell](https://www.powershellgallery.com) для управления зависимостями. С включенным управлением зависимостями файл требований. PSD1 используется для автоматического скачивания необходимых модулей. Это поведение можно включить, задав для свойства `managedDependency` значение `true` в корне [файла host. JSON](functions-host-json.md), как показано в следующем примере:

```json
{
  "managedDependency": {
          "enabled": true
       }
}
```

При создании нового проекта функций PowerShell управление зависимостями включается по умолчанию с включенным [модулем`Az`](/powershell/azure/new-azureps-module-az) Azure. Максимальное число модулей, поддерживаемое в настоящее время, равно 10. Поддерживаемый синтаксис — _`MajorNumber`_ `.*` или точную версию модуля, как показано в следующих требованиях. пример PSD1:

```powershell
@{
    Az = '1.*'
    SqlServer = '21.1.18147'
}
```

При обновлении файла требований. PSD1 обновленные модули устанавливаются после перезагрузки.

> [!NOTE]
> Управляемым зависимостям требуется доступ к www.powershellgallery.com для скачивания модулей. При локальном запуске убедитесь, что среда выполнения может получить доступ к этому URL-адресу, добавив необходимые правила брандмауэра. 

Следующие параметры приложения можно использовать для изменения способа загрузки и установки управляемых зависимостей. Обновление приложения начинается в пределах `MDMaxBackgroundUpgradePeriod`, и процесс обновления завершается примерно в `MDNewSnapshotCheckPeriod`.

| Параметр приложение-функция              | Значение по умолчанию             | Описание                                         |
|   -----------------------------   |   -------------------     |  -----------------------------------------------    |
| **`MDMaxBackgroundUpgradePeriod`**      | `7.00:00:00` (7 дней)     | Каждый рабочий процесс PowerShell инициирует проверку обновления модулей на коллекция PowerShell при запуске процесса и каждый `MDMaxBackgroundUpgradePeriod` после этого. Если в коллекция PowerShell доступна новая версия модуля, она устанавливается в файловую систему и становится доступной для рабочих ролей PowerShell. Уменьшение этого значения позволяет приложению-функции получать более новые версии модулей быстрее, но также увеличивает использование ресурсов приложения (сетевой ввод-вывод, ЦП, хранилище). Увеличение этого значения приводит к уменьшению использования ресурсов приложением, но может также задержать доставку новых версий модуля в приложение. | 
| **`MDNewSnapshotCheckPeriod`**         | `01:00:00` (1 час)       | После установки новых версий модулей в файловой системе необходимо перезапустить каждый рабочий процесс PowerShell. Перезапуск рабочих ролей PowerShell влияет на доступность приложения, так как он может прерывать текущее выполнение функции. До тех пор пока все рабочие процессы PowerShell не будут перезапущены, вызовы функций могут использовать либо старые, либо новые версии модулей. Перезапуск всех рабочих ролей PowerShell завершен в `MDNewSnapshotCheckPeriod`. Увеличение этого значения снижает частоту прерываний, но также может увеличить период времени, в течение которого вызовы функций используют старую или новую версию модуля недетерминированно. |
| **`MDMinBackgroundUpgradePeriod`**      | `1.00:00:00` (1 день)     | Чтобы избежать чрезмерного обновления модулей при частых перезапусках рабочих ролей, проверка обновления модулей не выполняется, когда любой рабочий процесс уже инициировал эту проверку в последней `MDMinBackgroundUpgradePeriod`. |

Использование собственных пользовательских модулей немного отличается от того, как это можно сделать обычным образом.

На локальном компьютере модуль устанавливается в одну из глобально доступных папок в `$env:PSModulePath`. При работе в Azure у вас нет доступа к модулям, установленным на вашем компьютере. Это означает, что `$env:PSModulePath` для приложения-функции PowerShell отличается от `$env:PSModulePath` в регулярном скрипте PowerShell.

В функциях `PSModulePath` содержит два пути:

* Папка `Modules`, которая находится в корне приложения-функции.
* Путь к папке `Modules`, управляемой рабочим модулем PowerShell.

### <a name="function-app-level-modules-folder"></a>Папка `Modules` уровня приложения-функции

Чтобы использовать пользовательские модули, можно разместить модули, от которых зависит ваша функция, в папке `Modules`. Из этой папки модули автоматически становятся доступными для среды выполнения функций. Все функции в приложении функции могут использовать эти модули. 

> [!NOTE]
> Модули, указанные в файле требований. PSD1, автоматически загружаются и включаются в путь, поэтому их не нужно включать в папку Modules. Они хранятся локально в папке `$env:LOCALAPPDATA/AzureFunctions` и в папке `/data/ManagedDependencies` при запуске в облаке.

Чтобы воспользоваться функцией пользовательского модуля, создайте папку `Modules` в корне приложения-функции. Скопируйте модули, которые вы хотите использовать в функциях, в это расположение.

```powershell
mkdir ./Modules
Copy-Item -Path /mymodules/mycustommodule -Destination ./Modules -Recurse
```

При наличии папки `Modules` приложение-функция должно иметь следующую структуру папок:

```
PSFunctionApp
 | - MyFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - MyCustomModule
 | | - MyOtherCustomModule
 | | - MySpecialModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
```

При запуске приложения-функции языковой рабочий процесс PowerShell добавляет эту `Modules`ную папку в `$env:PSModulePath`, чтобы вы могли полагаться на автозагрузку модуля точно так же, как в обычном сценарии PowerShell.

### <a name="language-worker-level-modules-folder"></a>Языковой `Modules` папка уровня рабочего процесса

Рабочие роли языка PowerShell обычно используют несколько модулей. Эти модули определяются в последнем положении `PSModulePath`. 

Текущий список модулей выглядит следующим образом:

* [Microsoft. PowerShell. Archive](https://www.powershellgallery.com/packages/Microsoft.PowerShell.Archive): модуль, используемый для работы с архивами, такими как `.zip`, `.nupkg`и другие.
* **Среаджоб**: реализация API-интерфейсов задания PowerShell на основе потока.

По умолчанию функции используют самые последние версии этих модулей. Чтобы использовать конкретную версию модуля, вставьте эту конкретную версию в папку `Modules` приложения-функции.

## <a name="environment-variables"></a>Переменные среды

В Функциях [параметры приложения](functions-app-settings.md), такие как строки подключения службы, доступны в виде переменных среды во время выполнения. Доступ к этим параметрам можно получить с помощью `$env:NAME_OF_ENV_VAR`, как показано в следующем примере:

```powershell
param($myTimer)

Write-Host "PowerShell timer trigger function ran! $(Get-Date)"
Write-Host $env:AzureWebJobsStorage
Write-Host $env:WEBSITE_SITE_NAME
```

[!INCLUDE [Function app settings](../../includes/functions-app-settings.md)]

При локальном запуске приложения параметры считываются из файла проекта [local.settings.json](functions-run-local.md#local-settings-file).

## <a name="concurrency"></a>Параллелизм

По умолчанию среда выполнения PowerShell для функций может обрабатывать только один вызов функции за раз. Однако этот уровень параллелизма может быть недостаточно в следующих ситуациях:

* При одновременной обработке большого количества вызовов одновременно.
* При наличии функций, которые вызывают другие функции в одном и том же приложении функции.

Это поведение можно изменить, задав для следующей переменной среды целочисленное значение:

```
PSWorkerInProcConcurrencyUpperBound
```

Эта переменная среды задается в [параметрах приложения](functions-app-settings.md) приложение-функция.

### <a name="considerations-for-using-concurrency"></a>Рекомендации по использованию параллелизма

По умолчанию PowerShell является _отдельным потоковым_ языком сценариев. Однако параллелизм можно добавить с помощью нескольких пространств выполнения PowerShell в одном процессе. Объем созданных пространств выполнения будет соответствовать параметру приложения Псворкеринпрокконкурренциуппербаунд. На пропускную способность влияет объем ресурсов ЦП и памяти, доступный в выбранном плане.

Azure PowerShell использует некоторые контексты и состояния _уровня процесса_ , чтобы помочь сэкономить от чрезмерного ввода. Однако при включении параллелизма в приложении функции и вызове действий, изменяющих состояние, могут возникнуть состояния гонки. Эти состояния гонки трудно отлаживать, поскольку один вызов зависит от определенного состояния, а другой вызов изменил состояние.

Во время параллелизма Azure PowerShell, так как некоторые операции могут занимать значительное количество времени. Однако следует соблюдать осторожность. Если вы считаете, что столкнулись с состоянием гонки, задайте для параметра приложения Псворкеринпрокконкурренциуппербаунд значение `1` и вместо этого используйте [изоляцию уровня языкового рабочего процесса](functions-app-settings.md#functions_worker_process_count) для параллелизма.

## <a name="configure-function-scriptfile"></a>Настройка `scriptFile` функций

По умолчанию функция PowerShell выполняется из `run.ps1`— файла, который использует тот же родительский каталог, что и соответствующий `function.json`.

Свойство `scriptFile` в `function.json` можно использовать для получения структуры папок, которая выглядит, как в следующем примере:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.ps1
```

В этом случае `function.json` для `myFunction` содержит свойство `scriptFile`, ссылающееся на файл с выполняемой экспортированной функцией.

```json
{
  "scriptFile": "../lib/PSFunction.ps1",
  "bindings": [
    // ...
  ]
}
```

## <a name="use-powershell-modules-by-configuring-an-entrypoint"></a>Использование модулей PowerShell с помощью настройки точки входа

В этой статье показаны функции PowerShell в файле сценария по умолчанию `run.ps1`, созданном шаблонами.
Однако можно также включить функции в модули PowerShell. Вы можете ссылаться на код конкретной функции в модуле, используя поля `scriptFile` и `entryPoint` в файле конфигурации Function. JSON.

В этом случае `entryPoint` — это имя функции или командлета в модуле PowerShell, на который ссылается `scriptFile`.

Рассмотрим следующую структуру папок:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.psm1
```

Где `PSFunction.psm1` содержит:

```powershell
function Invoke-PSTestFunc {
    param($InputBinding, $TriggerMetadata)

    Push-OutputBinding -Name OutputBinding -Value "output"
}

Export-ModuleMember -Function "Invoke-PSTestFunc"
```

В этом примере конфигурация для `myFunction` включает свойство `scriptFile`, которое ссылается на `PSFunction.psm1`, который является модулем PowerShell в другой папке.  Свойство `entryPoint` ссылается на функцию `Invoke-PSTestFunc`, которая является точкой входа в модуле.

```json
{
  "scriptFile": "../lib/PSFunction.psm1",
  "entryPoint": "Invoke-PSTestFunc",
  "bindings": [
    // ...
  ]
}
```

В этой конфигурации `Invoke-PSTestFunc` выполняется точно так же, как `run.ps1`.

## <a name="considerations-for-powershell-functions"></a>Рекомендации по функциям PowerShell

При работе с функциями PowerShell учитывайте рекомендации в следующих разделах.

### <a name="cold-start"></a>Холодный запуск

При разработке функций Azure в [модели размещения, не поддерживающей сервер](functions-scale.md#consumption-plan), холодный запуск — это реальность. *Холодный запуск* — это период времени, который требуется для запуска приложения-функции для обработки запроса. Холодный запуск чаще всего происходит в плане потребления, так как приложение-функция завершает работу в периоды бездействия.

### <a name="bundle-modules-instead-of-using-install-module"></a>Модули пакета вместо использования `Install-Module`

Сценарий выполняется при каждом вызове. Старайтесь не использовать `Install-Module` в скрипте. Вместо этого используйте `Save-Module` перед публикацией, чтобы функция не затратила время на загрузку модуля. Если холодный запуск влияет на ваши функции, рассмотрите возможность развертывания приложения-функции в [плане службы приложений](functions-scale.md#app-service-plan) со значением *Always on* или в [плане Premium](functions-scale.md#premium-plan).

## <a name="next-steps"></a>Дальнейшие действия

Для получения дополнительных сведений см. следующие ресурсы:

* [Рекомендации по функциям Azure](functions-best-practices.md)
* [Справочник разработчика по функциям Azure](functions-reference.md)
* [Триггеры и привязки в функциях Azure](functions-triggers-bindings.md)

[Справочник по Host. JSON]: functions-host-json.md
