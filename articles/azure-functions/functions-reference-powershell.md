---
title: Справочник разработчика PowerShell для функций Azure
description: Узнайте, как разрабатывать функции с помощью PowerShell.
services: functions
documentationcenter: na
author: tylerleonhardt
manager: jeconnoc
ms.service: azure-functions
ms.devlang: powershell
ms.topic: conceptual
ms.date: 04/22/2019
ms.author: tyleonha
ms.reviewer: glenga
ms.openlocfilehash: 6cf03d1269cac5dcfa67c2d4778be3fce9ee63aa
ms.sourcegitcommit: c2e7595a2966e84dc10afb9a22b74400c4b500ed
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/05/2019
ms.locfileid: "71973368"
---
# <a name="azure-functions-powershell-developer-guide"></a>Рекомендации для разработчиков по функциям Azure PowerShell

Эта статья содержит сведения о том, как вы пишете функции Azure с помощью PowerShell.

[!INCLUDE [functions-powershell-preview-note](../../includes/functions-powershell-preview-note.md)]

Функция Azure PowerShell (функция) представляется в виде скрипта PowerShell, который выполняется при срабатывании. Каждый сценарий функции имеет связанный файл `function.json`, который определяет, как работает функция, например, как она запускается, а также ее входные и выходные параметры. Дополнительные сведения см. в [статье о триггерах и привязке](functions-triggers-bindings.md). 

Как и другие виды функций, функции скриптов PowerShell принимают параметры, соответствующие именам всех входных привязок, определенных в файле `function.json`. Также передается параметр `TriggerMetadata`, содержащий дополнительные сведения о триггере, который запустил функцию.

В этой статье предполагается, что вы уже прочли [руководство для разработчиков по Функциям Azure](functions-reference.md). Кроме того, для создания первой функции PowerShell необходимо завершить работу с [кратким руководством по функциям PowerShell](functions-create-first-function-powershell.md) .

## <a name="folder-structure"></a>Структура папок

Необходимая структура папок для проекта PowerShell выглядит следующим образом. Это значение по умолчанию можно изменить. Дополнительные сведения см. в разделе о [scriptFile](#configure-function-scriptfile) ниже.

```
PSFunctionApp
 | - MyFirstFunction
 | | - run.ps1
 | | - function.json
 | - MySecondFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - myFirstHelperModule
 | | | - myFirstHelperModule.psd1
 | | | - myFirstHelperModule.psm1
 | | - mySecondHelperModule
 | | | - mySecondHelperModule.psd1
 | | | - mySecondHelperModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
 | - profile.ps1
 | - extensions.csproj
 | - bin
```

В корне проекта имеется общий файл [`host.json`](functions-host-json.md) , который можно использовать для настройки приложения-функции. У каждой функции есть папка с собственным файлом кода (PS1) и файл конфигурации привязки (`function.json`). Имя родительского каталога файла Function. JSON всегда является именем функции.

Для некоторых привязок требуется наличие файла `extensions.csproj`. Расширения привязки, необходимые в [версии 2. x](functions-versions.md) среды выполнения функций, определяются в файле `extensions.csproj` с фактическими файлами библиотеки в папке `bin`. При локальной разработке необходимо [зарегистрировать расширения привязки](functions-bindings-register.md#extension-bundles). При разработке функций на портале Azure эта регистрация выполняется автоматически.

В приложениях-функциях PowerShell при необходимости можно использовать `profile.ps1`, который выполняется при запуске приложения-функции (в противном случае — как *[холодный запуск](#cold-start)* ). Дополнительные сведения см. в разделе [профиль PowerShell](#powershell-profile).

## <a name="defining-a-powershell-script-as-a-function"></a>Определение скрипта PowerShell как функции

По умолчанию среда выполнения Функций ищет функцию в файле `run.ps1`, где `run.ps1` использует тот же родительский каталог, что и соответствующий файл `function.json`.

При выполнении скрипту передается ряд аргументов. Чтобы обрабатывал эти параметры, добавьте блок `param` в начало скрипта, как показано в следующем примере:

```powershell
# $TriggerMetadata is optional here. If you don't need it, you can safely remove it from the param block
param($MyFirstInputBinding, $MySecondInputBinding, $TriggerMetadata)
```

### <a name="triggermetadata-parameter"></a>Тригжерметадата, параметр

Параметр `TriggerMetadata` используется для предоставления дополнительных сведений о триггере. Дополнительные метаданные отличаются от привязки к привязке, но все они содержат свойство `sys`, которое содержит следующие данные:

```powershell
$TriggerMetadata.sys
```

| Свойство   | Description                                     | Type     |
|------------|-------------------------------------------------|----------|
| UtcNow     | Когда, в формате UTC, была активирована функция        | DateTime |
| MethodName | Имя функции, которая была активирована     | string   |
| рандгуид   | уникальный идентификатор GUID для этого выполнения функции | string   |

Каждый тип триггера имеет другой набор метаданных. Например, `$TriggerMetadata` для `QueueTrigger` содержит `InsertionTime`, `Id`, `DequeueCount`, помимо прочего. Дополнительные сведения о метаданных триггера очереди см. в [официальной документации по триггерам очереди](functions-bindings-storage-queue.md#trigger---message-metadata). Ознакомьтесь с документацией по [триггерам](functions-triggers-bindings.md) , с которыми вы работаете, чтобы узнать, что входит в метаданные триггера.

## <a name="bindings"></a>Привязки

В PowerShell [привязки](functions-triggers-bindings.md) настраиваются и определяются в функции. JSON функции. Функции взаимодействуют с привязками несколькими способами.

### <a name="reading-trigger-and-input-data"></a>Чтение триггера и входных данных

Привязки триггера и ввода считываются как параметры, передаваемые в функцию. Входные привязки имеют значение @no__t 0, равное `in` в Function. JSON. Свойство `name`, определенное в `function.json`, является именем параметра в блоке `param`. Так как PowerShell использует именованные параметры для привязки, порядок параметров не имеет значения. Однако рекомендуется следовать порядку привязок, определенных в `function.json`.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)
```

### <a name="writing-output-data"></a>Запись выходных данных

В функциях выходная привязка имеет `direction`, для которой задано значение `out` в файл function. JSON. Запись в выходную привязку можно выполнить с помощью командлета `Push-OutputBinding`, который доступен для среды выполнения функций. Во всех случаях свойство `name` привязки, определенное в `function.json`, соответствует параметру `Name` командлета `Push-OutputBinding`.

Ниже показано, как вызвать `Push-OutputBinding` в скрипте функции:

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Push-OutputBinding -Name myQueue -Value $myValue
```

Можно также передать значение для конкретной привязки через конвейер.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Produce-MyOutputValue | Push-OutputBinding -Name myQueue
```

`Push-OutputBinding` ведет себя иначе в зависимости от значения, указанного для `-Name`:

* Если указанное имя не может быть разрешено в допустимую выходную привязку, возникает ошибка.

* Если выходная привязка принимает коллекцию значений, можно многократно вызывать `Push-OutputBinding` для отправки нескольких значений.

* Если выходная привязка принимает только одноэлементное значение, вызов `Push-OutputBinding` во второй раз вызывает ошибку.

#### <a name="push-outputbinding-syntax"></a>синтаксис `Push-OutputBinding`

Ниже приведены допустимые параметры для вызова `Push-OutputBinding`.

| Название | Type | Положение | Описание |
| ---- | ---- |  -------- | ----------- |
| **`-Name`** | Строка, | 1 | Имя выходной привязки, которую необходимо задать. |
| **`-Value`** | Object | 2 | Значение выходной привязки, которое необходимо задать, которое принимается из Бивалуе конвейера. |
| **`-Clobber`** | SwitchParameter | именованная | Используемых При указании параметра устанавливает значение для заданной выходной привязки. | 

Также поддерживаются следующие общие параметры: 
* `Verbose`
* `Debug`
* `ErrorAction`
* `ErrorVariable`
* `WarningAction`
* `WarningVariable`
* `OutBuffer`
* `PipelineVariable`
* `OutVariable` 

Дополнительные сведения см. в разделе [About общиепараметры](https://go.microsoft.com/fwlink/?LinkID=113216).

#### <a name="push-outputbinding-example-http-responses"></a>Пример Push-Аутпутбиндинг: Ответы HTTP

Триггер HTTP возвращает ответ, используя выходную привязку с именем `response`. В следующем примере выходная привязка `response` имеет значение "Output #1":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #1"
})
```

Поскольку выходным данным является HTTP, которая принимает только одноэлементное значение, возникает ошибка, когда `Push-OutputBinding` вызывается второй раз.

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #2"
})
```

Для выходов, которые принимают только одноэлементные значения, можно использовать параметр `-Clobber` для переопределения старого значения вместо попытки добавления в коллекцию. В следующем примере предполагается, что вы уже добавили значение. При использовании `-Clobber` ответ из следующего примера переопределяет существующее значение, чтобы вернуть значение "Output #3":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #3"
}) -Clobber
```

#### <a name="push-outputbinding-example-queue-output-binding"></a>Пример Push-Аутпутбиндинг: Выходная привязка очереди

`Push-OutputBinding` используется для отправки данных в выходные привязки, такие как [выходная привязка хранилища очередей Azure](functions-bindings-storage-queue.md#output). В следующем примере сообщение, записанное в очередь, имеет значение "Output #1":

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #1"
```

Выходная привязка для очереди хранилища принимает несколько выходных значений. В этом случае вызов следующего примера после первой записи в очередь списка с двумя элементами: "Output #1" и "Output #2".

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #2"
```

В следующем примере, когда вызывается после двух предыдущих, в выходную коллекцию добавляется еще два значения:

```powershell
PS >Push-OutputBinding -Name outQueue -Value @("output #3", "output #4")
```

При запись в очередь сообщение содержит следующие четыре значения: "Output #1", "Output #2", "Output #3" и "Output #4".

#### <a name="get-outputbinding-cmdlet"></a>Командлет `Get-OutputBinding`

Вы можете использовать командлет `Get-OutputBinding` для получения значений, заданных в данный момент для выходных привязок. Этот командлет извлекает хэш-таблицу, содержащую имена выходных привязок с соответствующими значениями. 

Ниже приведен пример использования `Get-OutputBinding` для возврата текущих значений привязки:

```powershell
Get-OutputBinding
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
MyOtherQueue                   myData
```

`Get-OutputBinding` также содержит параметр с именем `-Name`, который можно использовать для фильтрации возвращаемой привязки, как показано в следующем примере:

```powershell
Get-OutputBinding -Name MyQ*
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
```

В `Get-OutputBinding` поддерживаются подстановочные знаки (*).

## <a name="logging"></a>Ведение журнала

Ведение журнала в функциях PowerShell работает как обычное ведение журнала PowerShell. Командлеты ведения журнала можно использовать для записи в каждый выходной поток. Каждый командлет сопоставляется с уровнем ведения журнала, который используется функциями.

| Уровень ведения журнала функций | Командлет ведения журнала |
| ------------- | -------------- |
| Ошибка | **`Write-Error`** |
| Предупреждение | **`Write-Warning`**  | 
| Сведения | **`Write-Information`** <br/> **`Write-Host`** <br /> **`Write-Output`**      | Сведения | Выполняет запись в журнал на уровне _информации_ . |
| Отладить | **`Write-Debug`** |
| Трассировка | **`Write-Progress`** <br /> **`Write-Verbose`** |

Помимо этих командлетов, все данные, записанные в конвейер, перенаправляются на уровень журнала `Information` и отображаются с форматированием по умолчанию PowerShell.

> [!IMPORTANT]
> Использование командлетов `Write-Verbose` или `Write-Debug` недостаточно для просмотра подробных сведений и ведения журнала на уровне отладки. Кроме того, необходимо настроить пороговое значение уровня ведения журнала, которое объявляет, какой уровень журналов вы в действительности интересуют. Дополнительные сведения см. в статье [Настройка уровня ведения журнала приложения функции](#configure-the-function-app-log-level).

### <a name="configure-the-function-app-log-level"></a>Настройка уровня ведения журнала приложения функции

Функции Azure позволяют определить пороговый уровень, чтобы упростить управление способом записи функций в журналы. Чтобы задать пороговое значение для всех трассировок, записываемых на консоль `logging.logLevel.default` , используйте свойство [`host.json`в справочнике ][справочник по host. json]. Этот параметр применяется ко всем функциям в приложении-функции.

В следующем примере устанавливается пороговое значение для включения подробного ведения журнала для всех функций, но устанавливается пороговое значение включения ведения журнала отладки для функции с именем `MyFunction`:

```json
{
    "logging": {
        "logLevel": {
            "Function.MyFunction": "Debug",
            "default": "Trace"
        }
    }
}  
```

Дополнительные сведения см. в [Справочник по Host. JSON].

### <a name="viewing-the-logs"></a>Просмотр журналов

Если приложение-функция выполняется в Azure, можно использовать Application Insights для мониторинга. Дополнительные сведения о просмотре журналов функций и обращении к ним см. в статье [мониторинг Функций Azure](functions-monitoring.md).

Если вы используете приложение-функция локально для разработки, ведет журнал по умолчанию в файловой системе. Чтобы просмотреть журналы в консоли, задайте для переменной среды `AZURE_FUNCTIONS_ENVIRONMENT` значение `Development` перед запуском приложение-функция.

## <a name="triggers-and-bindings-types"></a>Типы триггеров и привязок

Существует ряд триггеров и привязок, которые можно использовать с приложением-функцией. Полный список триггеров и привязок [можно найти здесь](functions-triggers-bindings.md#supported-bindings).

Все триггеры и привязки представлены в коде как несколько реальных типов данных:

* Hashtable
* string
* byte[]
* int
* double
* HttpRequestContext
* HttpResponseContext

Первые пять типов в этом списке являются стандартными типами .NET. Последние два используются только [триггером HttpTrigger](#http-triggers-and-bindings).

Каждый параметр привязки в функциях должен иметь один из этих типов.

### <a name="http-triggers-and-bindings"></a>Триггеры и привязки HTTP

Триггеры HTTP и webhook, а также привязки вывода HTTP используют объекты запроса и ответа для обмена сообщениями HTTP.

#### <a name="request-object"></a>Объект запроса

Объект запроса, переданный в скрипт, имеет тип `HttpRequestContext`, который имеет следующие свойства:

| Свойство  | Description                                                    | Type                      |
|-----------|----------------------------------------------------------------|---------------------------|
| **`Body`**    | Объект, содержащий текст запроса. `Body` сериализуется в лучший тип на основе данных. Например, если данные являются JSON, они передаются в виде хэш-таблицы. Если данные являются строкой, они передаются в виде строки. | object |
| **`Headers`** | Словарь, содержащий заголовки запроса.                | Словарь < строка, строка ><sup>*</sup> |
| **`Method`** | Метод HTTP, используемый для запроса.                                | string                    |
| **`Params`**  | Объект, содержащий параметры маршрутизации запроса. | Словарь < строка, строка ><sup>*</sup> |
| **`Query`** | Объект, содержащий параметры запроса.                  | Словарь < строка, строка ><sup>*</sup> |
| **`Url`** | URL-адрес запроса.                                        | string                    |

<sup>*</sup> Все ключи `Dictionary<string,string>` не учитывают регистр.

#### <a name="response-object"></a>Объект ответа

Объект ответа, который необходимо отправить обратно, имеет тип `HttpResponseContext`, который имеет следующие свойства:

| Свойство      | Description                                                 | Type                      |
|---------------|-------------------------------------------------------------|---------------------------|
| **`Body`**  | Объект, содержащий текст ответа.           | object                    |
| **`ContentType`** | Короткий рукой для установки типа содержимого для ответа. | string                    |
| **`Headers`** | Объект, содержащий заголовок ответа.               | Словарь или хэш-таблица   |
| **`StatusCode`**  | Код состояния HTTP ответа.                       | строка или целое число             |

#### <a name="accessing-the-request-and-response"></a>Доступ к запросу и ответу

При работе с триггерами HTTP доступ к HTTP-запросу можно получить так же, как и с любой другой входной привязкой. Он находится в блоке `param`.

Используйте объект `HttpResponseContext`, чтобы вернуть ответ, как показано ниже:

`function.json`

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "anonymous"
    },
    {
      "type": "http",
      "direction": "out"
    }
  ]
}
```

`run.ps1`

```powershell
param($req, $TriggerMetadata)

$name = $req.Query.Name

Push-OutputBinding -Name res -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "Hello $name!"
})
```

Результат вызова этой функции будет следующим:

```
PS > irm http://localhost:5001?Name=Functions
Hello Functions!
```

### <a name="type-casting-for-triggers-and-bindings"></a>Приведение типов для триггеров и привязок

Для некоторых привязок, таких как привязка больших двоичных объектов, можно указать тип параметра.

Например, чтобы данные из хранилища BLOB-объектов передавались в виде строки, добавьте приведенный ниже тип в мой блок `param`:

```powershell
param([string] $myBlob)
```

## <a name="powershell-profile"></a>Профиль PowerShell

В PowerShell есть понятие профиля PowerShell. Если вы не знакомы с профилями PowerShell, см. раздел [About Profiles](/powershell/module/microsoft.powershell.core/about/about_profiles).

В функциях PowerShell скрипт профиля выполняется при запуске приложения функции. Приложения-функции запускаются при первом развертывании и после бездействия ([холодный запуск](#cold-start)).

При создании приложения-функции с помощью таких средств, как Visual Studio Code и Azure Functions Core Tools, для вас создается значение по умолчанию `profile.ps1`. Профиль по умолчанию хранится [в репозитории основных средств](https://github.com/Azure/azure-functions-core-tools/blob/dev/src/Azure.Functions.Cli/StaticResources/profile.ps1) , который содержит:

* Автоматическая проверка подлинности MSI в Azure.
* Возможность включения Azure PowerShell псевдонимов PowerShell `AzureRM` при желании.

## <a name="powershell-version"></a>Версия PowerShell

В следующей таблице показана версия PowerShell, используемая каждой основной версией среды выполнения функций.

| Версия службы "Функции" | Версия PowerShell                             |
|-------------------|------------------------------------------------|
| 1.x               | Windows PowerShell 5,1 (заблокировано средой выполнения) |
| 2.x               | PowerShell Core 6                              |

Текущую версию можно просмотреть, выполнив печать `$PSVersionTable` из любой функции.

## <a name="dependency-management"></a>Управление зависимостями

Функции PowerShell поддерживают скачивание модулей [коллекции PowerShell](https://www.powershellgallery.com) и управление ими с помощью службы. Изменяя Host. JSON и устанавливая для свойства Манажеддепенденци Enabled значение true, файл требований. PSD1 будет обработан. Указанные модули будут автоматически скачаны и станут доступными для функции. 

Максимальное число модулей, поддерживаемое в настоящее время, равно 10. Поддерживаемый синтаксис — Мажорнумбер. * или точная версия модуля, как показано ниже. Модуль Azure AZ включается по умолчанию при создании нового приложения-функции PowerShell.

Языковой рабочий процесс будет получать обновленные модули при перезапуске.

Host. JSON
```json
{
  "managedDependency": {
          "enabled": true
       }
}
```

требования. PSD1

```powershell
@{
    Az = '1.*'
    SqlServer = '21.1.18147'
}
```

Для изменения способа загрузки и установки управляемых зависимостей доступны следующие параметры. Обновление приложения начнется в Мдмаксбаккграундупградепериод, а процесс обновления завершится примерно в Мдневснапшотчеккпериод.

| Параметр приложение-функция              | Значение по умолчанию             | Описание                                         |
|   -----------------------------   |   -------------------     |  -----------------------------------------------    |
| мдмаксбаккграундупградепериод      | "7.00:00:00" (7 дней)     | Каждый рабочий процесс PS инициирует проверку обновления модулей в коллекции PS при запуске рабочего процесса и каждый Мдмаксбаккграундупградепериод после этого. Если в коллекции PS доступны новые версии модулей, они будут установлены в файловую систему, доступную для рабочих ролей PS. Уменьшение этого значения позволит приложению-функции получить более новые версии модулей быстрее, но также увеличит использование ресурсов приложения (сетевые операции ввода-вывода, ЦП, хранения). Увеличение этого значения приведет к уменьшению использования ресурсов приложения, но может также отложить доставку новых версий модуля в приложение.      | 
| мдневснапшотчеккпериод          | "01:00:00" (1 час)       | После установки новых версий модулей в файловую систему необходимо перезапустить каждую рабочую роль POWERSHELL. Перезапуск рабочих процессов PS может повлиять на доступность приложения, так как он может прерывать текущие вызовы функций. До тех пор пока все рабочие роли PS не будут перезапущены, в вызовах функций могут использоваться либо старые, либо новые версии модулей. Перезапуск всех рабочих ролей PS будет выполнен в Мдневснапшотчеккпериод. Увеличение этого значения приведет к уменьшению частоты прерываний, но также может увеличить период времени, в течение которого вызовы функций будут использовать старую или новую версию модуля недетерминированным образом. |
| мдминбаккграундупградепериод      | "1,00:00:00" (1 день)     | Чтобы избежать чрезмерного обновления модулей при частых перезапусках рабочих ролей, проверка обновления модуля не будет выполнена, если любой рабочий процесс уже был инициирован в течение последнего Мдминбаккграундупградепериод. |

Использование собственных пользовательских модулей немного отличается от того, как это можно сделать обычным образом.

При установке модуля на локальном компьютере он помещается в одну из глобально доступных папок в `$env:PSModulePath`. Так как ваша функция выполняется в Azure, вы не сможете получить доступ к модулям, установленным на вашем компьютере. Для этого требуется, чтобы `$env:PSModulePath` для приложения-функции PowerShell отличались от `$env:PSModulePath` в регулярном скрипте PowerShell.

В функциях `PSModulePath` содержит два пути:

* Папка `Modules`, которая находится в корне приложение-функция.
* Путь к папке `Modules`, которая находится внутри рабочей роли языка PowerShell.

### <a name="function-app-level-modules-folder"></a>Папка `Modules` уровня приложения-функции

Чтобы использовать пользовательские модули, можно разместить модули, от которых зависит ваша функция, в папке `Modules`. Из этой папки модули автоматически становятся доступными для среды выполнения функций. Все функции в приложении функции могут использовать эти модули. 

> [!NOTE]
> Модули, указанные в файле требований. PSD1, автоматически загружаются и включаются в путь, поэтому их не нужно включать в папку Modules. Они хранятся локально в папке $env: LOCALAPPDATA/Азурефунктионс и в папке/Дата/манажеддепенденЦиес при запуске в облаке.

Чтобы воспользоваться функцией пользовательского модуля, создайте папку `Modules` в корне приложения-функции. Скопируйте модули, которые вы хотите использовать в функциях, в это расположение.

```powershell
mkdir ./Modules
Copy-Item -Path /mymodules/mycustommodule -Destination ./Modules -Recurse
```

В папке modules приложение-функция должно иметь следующую структуру папок:

```
PSFunctionApp
 | - MyFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - MyCustomModule
 | | - MyOtherCustomModule
 | | - MySpecialModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
```

Когда вы запускаете приложение-функцию, Рабочий процесс PowerShell добавляет эту папку `Modules` в `$env:PSModulePath`, чтобы вы могли полагаться на автозагрузку модуля точно так же, как в обычном сценарии PowerShell.

### <a name="language-worker-level-modules-folder"></a>Языковой рабочий уровень `Modules` папка

Рабочие роли языка PowerShell обычно используют несколько модулей. Эти модули определяются в последнем положении `PSModulePath`. 

Текущий список модулей выглядит следующим образом:

* [Microsoft. PowerShell. Archive](https://www.powershellgallery.com/packages/Microsoft.PowerShell.Archive): модуль, используемый для работы с архивами, например `.zip`, `.nupkg` и другие.
* **Среаджоб**: Реализация интерфейсов API задания PowerShell на основе потока.

Самые последние версии этих модулей используются функциями. Чтобы использовать определенную версию этих модулей, можно разместить определенную версию в папке `Modules` приложения-функции.

## <a name="environment-variables"></a>Переменные среды

В Функциях [параметры приложения](functions-app-settings.md), такие как строки подключения службы, доступны в виде переменных среды во время выполнения. Доступ к этим параметрам можно получить с помощью `$env:NAME_OF_ENV_VAR`, как показано в следующем примере:

```powershell
param($myTimer)

Write-Host "PowerShell timer trigger function ran! $(Get-Date)"
Write-Host $env:AzureWebJobsStorage
Write-Host $env:WEBSITE_SITE_NAME
```

[!INCLUDE [Function app settings](../../includes/functions-app-settings.md)]

При локальном запуске приложения параметры считываются из файла проекта [local.settings.json](functions-run-local.md#local-settings-file).

## <a name="concurrency"></a>Параллелизм

По умолчанию среда выполнения PowerShell для функций может обрабатывать только один вызов функции за раз. Однако этот уровень параллелизма может быть недостаточно в следующих ситуациях:

* При одновременной обработке большого количества вызовов одновременно.
* При наличии функций, которые вызывают другие функции в одном и том же приложении функции.

Это поведение можно изменить, задав для следующей переменной среды целочисленное значение:

```
PSWorkerInProcConcurrencyUpperBound
```

Эта переменная среды задается в [параметрах приложения](functions-app-settings.md) приложение-функция.

### <a name="considerations-for-using-concurrency"></a>Рекомендации по использованию параллелизма

По умолчанию PowerShell является _отдельным потоковым_ языком сценариев. Однако параллелизм можно добавить с помощью нескольких пространств выполнения PowerShell в одном процессе. Объем созданных пространств выполнения будет соответствовать параметру приложения Псворкеринпрокконкурренциуппербаунд. На пропускную способность влияет объем ресурсов ЦП и памяти, доступный в выбранном плане.

Azure PowerShell использует некоторые контексты и состояния _уровня процесса_ , чтобы помочь сэкономить от чрезмерного ввода. Однако при включении параллелизма в приложении функции и вызове действий, изменяющих состояние, могут возникнуть состояния гонки. Эти состояния гонки трудно отлаживать, поскольку один вызов зависит от определенного состояния, а другой вызов изменил состояние.

Во время параллелизма Azure PowerShell, так как некоторые операции могут занимать значительное количество времени. Однако следует соблюдать осторожность. Если вы считаете, что столкнулись с состоянием гонки, задайте для параметра приложения Псворкеринпрокконкурренциуппербаунд значение `1`, а вместо этого используйте [изоляцию уровня языкового рабочего процесса](functions-app-settings.md#functions_worker_process_count) для параллелизма.

## <a name="configure-function-scriptfile"></a>Настройка функции `scriptFile`

По умолчанию функция PowerShell выполняется из `run.ps1`, файла, который использует тот же родительский каталог, что и соответствующий `function.json`.

Свойство `scriptFile` в `function.json` можно использовать для получения структуры папок, которая выглядит, как в следующем примере:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.ps1
```

В этом случае `function.json` для `myFunction` включает свойство `scriptFile`, ссылающееся на файл с выполняемой экспортированной функцией.

```json
{
  "scriptFile": "../lib/PSFunction.ps1",
  "bindings": [
    // ...
  ]
}
```

## <a name="use-powershell-modules-by-configuring-an-entrypoint"></a>Использование модулей PowerShell с помощью настройки точки входа

В этой статье показаны функции PowerShell в файле сценария по умолчанию `run.ps1`, созданном шаблонами.
Однако можно также включить функции в модули PowerShell. Вы можете ссылаться на код конкретной функции в модуле, используя поля `scriptFile` и `entryPoint` в файле конфигурации Function. JSON.

В этом случае `entryPoint` — это имя функции или командлета в модуле PowerShell, на который ссылается `scriptFile`.

Рассмотрим следующую структуру папок:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.psm1
```

Где `PSFunction.psm1` содержит:

```powershell
function Invoke-PSTestFunc {
    param($InputBinding, $TriggerMetadata)

    Push-OutputBinding -Name OutputBinding -Value "output"
}

Export-ModuleMember -Function "Invoke-PSTestFunc"
```

В этом примере конфигурация для `myFunction` включает свойство `scriptFile`, которое ссылается на `PSFunction.psm1`, который является модулем PowerShell в другой папке.  Свойство `entryPoint` ссылается на функцию `Invoke-PSTestFunc`, которая является точкой входа в модуле.

```json
{
  "scriptFile": "../lib/PSFunction.psm1",
  "entryPoint": "Invoke-PSTestFunc",
  "bindings": [
    // ...
  ]
}
```

В этой конфигурации `Invoke-PSTestFunc` выполняется точно так же, как `run.ps1`.

## <a name="considerations-for-powershell-functions"></a>Рекомендации по функциям PowerShell

При работе с функциями PowerShell учитывайте рекомендации в следующих разделах.

### <a name="cold-start"></a>Холодный запуск

При разработке функций Azure в [модели размещения, не поддерживающей сервер](functions-scale.md#consumption-plan), холодный запуск — это реальность. *Холодный запуск* — это период времени, который требуется для запуска приложения-функции для обработки запроса. Холодный запуск чаще всего происходит в плане потребления, так как приложение-функция завершает работу в периоды бездействия.

### <a name="bundle-modules-instead-of-using-install-module"></a>Модули пакета вместо использования `Install-Module`

Сценарий выполняется при каждом вызове. Избегайте использования `Install-Module` в скрипте. Вместо этого используйте `Save-Module` перед публикацией, чтобы функция не затратила время на загрузку модуля. Если холодный запуск влияет на ваши функции, рассмотрите возможность развертывания приложения-функции в [плане службы приложений](functions-scale.md#app-service-plan) со значением *Always on* или в [плане Premium](functions-scale.md#premium-plan).

## <a name="next-steps"></a>Следующие шаги

Для получения дополнительных сведений см. следующие ресурсы:

* [Рекомендации по функциям Azure](functions-best-practices.md)
* [Справочник разработчика по функциям Azure](functions-reference.md)
* [Azure Functions triggers and bindings (Триггеры и привязки в Функциях Azure)](functions-triggers-bindings.md)

[Справочник по Host. JSON]: functions-host-json.md
