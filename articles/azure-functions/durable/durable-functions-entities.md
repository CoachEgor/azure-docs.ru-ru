---
title: Устойчивые сущности — Функции Azure
description: Узнайте, что такое устойчивые сущности и как их использовать в расширении "Устойчивые функции" для Функций Azure.
services: functions
author: cgillum
manager: jeconnoc
keywords: ''
ms.service: azure-functions
ms.topic: overview
ms.date: 08/31/2019
ms.author: azfuncdf
ms.openlocfilehash: 99e61cef55bd97704063e4d2da90909d0376c327
ms.sourcegitcommit: dd69b3cda2d722b7aecce5b9bd3eb9b7fbf9dc0a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2019
ms.locfileid: "70961465"
---
# <a name="entity-functions-preview"></a>Функции сущностей (предварительная версия)

Функции сущностей определяют операции чтения и обновления мелких частей состояния, известных как *устойчивые сущности*. Как и функции оркестратора, функции сущностей — это функции с особым типом триггера, *триггером сущности*. В отличие от функций оркестратора, для функций сущностей отсутствуют специальные ограничения кода. Функции сущностей также управляют состоянием явным образом, а не неявно представляют состояние с помощью потока управления.

> [!NOTE]
> Функции сущностей и связанные функции доступны только в Устойчивых функциях версии 2.0 и более поздних версиях. Сейчас Функции сущностей доступны в общедоступной предварительной версии.

## <a name="entity-identity"></a>Удостоверение сущности

Доступ к сущностям (иногда называемым *экземплярами* сущностей) осуществляется с помощью уникального идентификатора, *идентификатора сущности*. Идентификатор сущности — это просто пара строк, с помощью которых уникально идентифицируется экземпляр сущности. В ее состав входит:

* **Имя сущности** — это имя, идентифицирующее тип сущности (например, "счетчик").
* **Ключ сущности** — это строка, однозначно идентифицирующая сущность среди всех других сущностей с тем же именем (например, GUID).

Например, функция сущности *счетчика* может использоваться для отслеживания оценки в интернет-игре. Каждый экземпляр игры будет иметь уникальный идентификатор сущности, например `@Counter@Game1`, `@Counter@Game2` и т. д. Для всех операций, предназначенных для определенной сущности, необходимо указать идентификатор в качестве параметра.

## <a name="programming-models"></a>Модели программирования

Устойчивые сущности поддерживают две различные модели программирования. Первая модель является динамической "функциональной" моделью, в которой сущность определяется с помощью одной функции. Вторая модель — это объектно-ориентированная модель, в которой сущность определяется с помощью классов и методов. Эти модели и модели программирования для взаимодействия с сущностями описаны в следующих разделах.

### <a name="defining-entities"></a>Определение сущностей

Есть две необязательные модели программирования для создания устойчивых сущностей. Указанный ниже код является примером простой сущности *счетчика*, реализованной в виде стандартной функции. Эта функция определяет три *операции*, `add`, `reset` и `get`, каждая из которых работает с целочисленным значением состояния `currentValue`.

```csharp
[FunctionName("Counter")]
public static void Counter([EntityTrigger] IDurableEntityContext ctx)
{
    int currentValue = ctx.GetState<int>();

    switch (ctx.OperationName.ToLowerInvariant())
    {
        case "add":
            int amount = ctx.GetInput<int>();
            currentValue += operand;
            break;
        case "reset":
            currentValue = 0;
            break;
        case "get":
            ctx.Return(currentValue);
            break;
    }

    ctx.SetState(currentValue);
}
```

Эта модель лучше подходит для простых реализаций сущностей или реализаций с динамическим набором операций. Можно также использовать модель программирования на основе классов, которая полезна при работе со статическими сущностями реализованными более сложным образом. Следующий пример представляет собой эквивалентную реализацию сущности `Counter` с помощью классов и методов.

```csharp
public class Counter
{
    [JsonProperty("value")]
    public int CurrentValue { get; set; }

    public void Add(int amount) => this.CurrentValue += amount;
    
    public void Reset() => this.CurrentValue = 0;
    
    public int Get() => this.CurrentValue;

    [FunctionName(nameof(Counter))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<Counter>();
}
```

> [!NOTE]
> Метод точки входа функции `[FunctionName]` с атрибутом *должен* быть объявлен `static` при использовании классов сущностей. Нестатические методы точек входа могут привести к инициализации нескольких объектов и возможно других неопределенных поведений.

В модели программирования на основе классов объект `IDurableEntityContext` доступен в статическом свойстве `Entity.Current`.

Модель на основе классов аналогична модели программирования, популяризированной [Orleans](https://www.microsoft.com/research/project/orleans-virtual-actors/). В этой модели тип сущности определяется как класс .NET. Каждый метод класса представляет собой операцию, которую можно вызвать с помощью внешнего клиента. Однако в отличие от Orleans интерфейсы .NET необязательны. В предыдущем примере *счетчика* не использовался интерфейс, но его все равно можно вызвать с помощью других функций или вызовов API HTTP.

> [!NOTE]
> Функции триггера сущности доступны в Устойчивых функциях версии 2.0 и более поздних версиях. В настоящее время функции триггера сущности доступны только для приложений функций .NET.

### <a name="accessing-entities-from-clients"></a>Доступ к сущностям из клиентов

Устойчивые сущности могут вызываться или запрашиваться из обычных функций, также известных как *клиентские функции*, с помощью [выходной привязки клиента сущности](durable-functions-bindings.md#entity-client). В следующем примере показана функция, активируемая очередью, которая *сигнализирует* сущностям, использующим эту привязку.

```csharp
[FunctionName("AddFromQueue")]
public static Task Run(
    [QueueTrigger("durable-function-trigger")] string input,
    [DurableClient] IDurableEntityClient client)
{
    // Entity operation input comes from the queue message content.
    var entityId = new EntityId(nameof(Counter), "myCounter");
    int amount = int.Parse(input);
    return client.SignalEntityAsync(entityId, "Add", amount);
}
```

> [!NOTE]
> Функции .NET поддерживают слабо типизированные и типобезопасные методы для сигнализации сущностям. Дополнительные сведения см. в справочной документации по [привязке клиента сущности](durable-functions-bindings.md#entity-client-usage).

*Сигнализация* означает, что вызов API сущности является односторонним и асинхронным. *Клиентской функции* не может быть известно, когда сущность обработала операцию, а функция сущности не возвращает значение в клиентскую функцию. Односторонняя система обмена сообщениями на основе очередей используется при разработке Устойчивых сущностей, чтобы установить приоритет надежности над производительностью. Этот вариант разработки является одним из компромиссов Устойчивых сущностей по сравнению с аналогичными технологиями. В настоящее время только оркестрации могут обрабатывать возвращаемые сущностями значения, как описано в следующем разделе.

Клиентские функции могут также запрашивать состояние сущностей, как показано в примере ниже:

```csharp
[FunctionName("QueryCounter")]
public static async Task<HttpResponseMessage> Run(
    [HttpTrigger(AuthorizationLevel.Function)] HttpRequestMessage req,
    [DurableClient] IDurableEntityClient client)
{
    var entityId = new EntityId(nameof(Counter), "myCounter");
    JObject state = await client.ReadEntityStateAsync<JObject>(entityId);
    return req.CreateResponse(HttpStatusCode.OK, state);
}
```

Запросы о состоянии объектов отправляются в хранилище отслеживания Устойчивых сущностей и возвращают последнее *сохраненное* состояние сущности. Возвращаемое состояние может быть устаревшим по сравнению с состоянием сущности в памяти. Только оркестрации могут считывать состояние сущности в памяти, как описано в разделе ниже.

### <a name="accessing-entities-from-orchestrations"></a>Доступ к сущностям из оркестрации

Функции оркестрации могут обращаться к сущностям с помощью API-интерфейсов в [привязке триггера оркестрации](durable-functions-bindings.md#orchestration-trigger). Функции оркестрации могут выбирать между односторонней связью (по принципу "обнаружил и забыл", также называемой *сигнализацией*) и двусторонним обменом данными (запрос и ответ *, также называемый вызовом*). В следующем примере кода показан *вызов* функции оркестрации и *сигнализация* сущности *счетчика*.

```csharp
[FunctionName("CounterOrchestration")]
public static async Task Run(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    var entityId = new EntityId(nameof(Counter), "myCounter");

    // Synchronous call to the entity which returns a value
    int currentValue = await context.CallEntityAsync<int>(entityId, "Get");
    if (currentValue < 10)
    {
        // Asynchronous call which updates the value
        await context.SignalEntityAsync<int>(entityId, "Add", 1);
    }
}
```

Только оркестрации могут вызывать сущности и получать ответ, который может быть либо возвращаемым значением, либо исключением. Клиентские функции, [использующие клиентскую привязку](durable-functions-bindings.md#entity-client), могут сигнализировать только *сущностям*.

> [!NOTE]
> Вызов сущности из функции оркестрации аналогичен вызову [функции действия](durable-functions-types-features-overview.md#activity-functions) из функции оркестрации. Основное отличие заключается в том, что функции сущностей являются устойчивыми объектами с адресом (*идентификатор сущности*) и поддерживают указание имени операции. Функции действий, с другой стороны, не имеют состояния и концепции использования системы.

### <a name="dependency-injection-in-entity-classes-net"></a>Внедрение зависимостей в классы сущностей (.NET)

Классы сущностей [поддерживают внедрение зависимостей Функций Azure](../functions-dotnet-dependency-injection.md). В следующем примере показано, как зарегистрировать службу `IHttpClientFactory` в сущность на основе класса.

```csharp
[assembly: FunctionsStartup(typeof(MyNamespace.Startup))]

namespace MyNamespace
{
    public class Startup : FunctionsStartup
    {
        public override void Configure(IFunctionsHostBuilder builder)
        {
            builder.Services.AddHttpClient();
        }
    }
}
```

В следующем фрагменте кода показано, как встроить внедренную службу в класс сущностей.

```csharp
public class HttpEntity
{
    private readonly HttpClient client;

    public class HttpEntity(IHttpClientFactory factory)
    {
        this.client = factory.CreateClient();
    }

    public Task<int> GetAsync(string url)
    {
        using (var response = await this.client.GetAsync(url))
        {
            return (int)response.StatusCode;
        }
    }

    // The function entry point must be declared static
    [FunctionName(nameof(HttpEntity))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<HttpEntity>();
}
```

> [!NOTE]
> В отличие от внедрения конструктора в обычных Функциях Azure .NET, метод точки входа функций для сущностей на основе класса *необходимо* объявить `static`. Объявление нестатической точки входа функции может привести к конфликтам между обычным инициализатором объектов Функций Azure и инициализатором объектов Устойчивых сущностей.

### <a name="bindings-in-entity-classes-net"></a>Привязки в классах сущностей (.NET)

В отличие от обычных функций, методы классов сущностей не имеют прямого доступа к входным и выходным привязкам. Вместо этого данные привязки должны быть записаны в объявлении функции точки входа, а затем переданы в метод `DispatchAsync<T>`. Любые объекты, передаваемые в `DispatchAsync<T>`, будут автоматически переданы в конструктор класса сущностей в виде аргумента.

В следующем примере показано, как можно сделать ссылку `CloudBlobContainer` из [входной привязки BLOB-объекта](../functions-bindings-storage-blob.md#input) доступной для сущности на основе класса.

```csharp
public class BlobBackedEntity
{
    private readonly CloudBlobContainer container;

    public BlobBackedEntity(CloudBlobContainer container)
    {
        this.container = container;
    }

    // ... entity methods can use this.container in their implementations ...
    
    [FunctionName(nameof(BlobBackedEntity))]
    public static Task Run(
        [EntityTrigger] IDurableEntityContext context,
        [Blob("my-container", FileAccess.Read)] CloudBlobContainer container)
    {
        // passing the binding object as a parameter makes it available to the
        // entity class constructor
        return context.DispatchAsync<BlobBackedEntity>(container);
    }
}
```

Дополнительные сведения о привязках в Функциях Azure см. в статье[Azure Functions triggers and bindings concepts](../functions-triggers-bindings.md) (Основные понятия триггеров и привязок в Функциях Azure).

## <a name="entity-coordination"></a>Координация сущностей

Иногда приходится координировать операции между несколькими сущностями. Например, в приложении для банковских операций могут быть сущности, представляющие отдельные банковские счета. При передаче средств из одной учетной записи в другую необходимо убедиться, что на _исходном счете_ имеется достаточно средств, и что как _исходный счет_, так и _целевой_ обновляются в транзакционно согласованном виде.

### <a name="transfer-funds-example-in-c"></a>Пример перемещения средств на языке C#

Следующий пример кода перемещает средства между двумя сущностями _счетов_ с помощью функции оркестрации. Для координации обновлений сущностей необходимо использовать метод `LockAsync`, чтобы создать _критическую секцию_ в оркестрации:

> [!NOTE]
> Для простоты в этом примере повторно используется сущность `Counter`, определенная ранее. Однако в реальных приложениях лучше определить более подробную сущность `BankAccount`.

```csharp
// This is a method called by an orchestrator function
public static async Task<bool> TransferFundsAsync(
    string sourceId,
    string destinationId,
    int transferAmount,
    IDurableOrchestrationContext context)
{
    var sourceEntity = new EntityId(nameof(Counter), sourceId);
    var destinationEntity = new EntityId(nameof(Counter), destinationId);

    // Create a critical section to avoid race conditions.
    // No operations can be performed on either the source or
    // destination accounts until the locks are released.
    using (await context.LockAsync(sourceEntity, destinationEntity))
    {
        ICounter sourceProxy = 
            context.CreateEntityProxy<ICounter>(sourceEntity);
        ICounter destinationProxy =
            context.CreateEntityProxy<ICounter>(destinationEntity);

        int sourceBalance = await sourceProxy.Get();

        if (sourceBalance >= transferAmount)
        {
            await sourceProxy.Add(-transferAmount);
            await destinationProxy.Add(transferAmount);

            // the transfer succeeded
            return true;
        }
        else
        {
            // the transfer failed due to insufficient funds
            return false;
        }
    }
}
```

В .NET `LockAsync` возвращает `IDisposable`, который завершает критическую секцию при удалении. Этот результат `IDisposable` можно использовать вместе с блоком `using`, чтобы получить синтаксическое представление критической секции.

В предыдущем примере функция оркестрации передала средства из _исходной_ сущности в _целевую_. Метод `LockAsync` заблокировал сущности _исходного_ и _целевого_ счета. Такая блокировка гарантирует, что никакой другой клиент не сможет запросить или изменить состояние любого счета, пока логика оркестрации не выйдет из _критической секции_ в конце инструкции `using`. Это эффективно препятствует возможности перерасхода из _исходного_ счета.

### <a name="critical-section-behavior"></a>Поведение критической секции

Метод `LockAsync` создает _критическую секцию_ в оркестрации. Эти _критические секции_ предотвращают внесение перекрывающихся изменений в указанный набор сущностей. На внутреннем уровне API `LockAsync` отправляет операции блокировки в сущности и возвращает, когда получает ответное сообщение о получении блокировки от каждой из этих сущностей. *Блокировка* и *разблокировка* являются встроенными операциями, поддерживаемыми всеми сущностями.

Никакие операции от других клиентов не разрешены для сущности, находящейся в заблокированном состоянии. Такое поведение гарантирует, что только один экземпляр оркестрации может блокировать сущность за один раз. Если вызывающий объект пытается вызвать операцию для сущности, пока она заблокирована оркестрацией, такая операция будет помещена в *очередь ожидающих операций*. Ни одна из ожидающих операций не будет обработана до тех пор, пока оркестрация не снимет блокировку.

> [!NOTE] 
> Это несколько отличается от примитивов синхронизации, используемых в большинстве языков программирования, таких как инструкция `lock` в C#. Например, в C# инструкция `lock` должна использоваться всеми потоками, чтобы обеспечить надлежащую синхронизацию в нескольких потоках. Однако для сущностей не требуется, чтобы все вызывающие объекты _явно_ блокировали сущность. Если любой вызывающий объект блокирует сущность, все остальные операции с этой сущностью будут заблокированы и помещены в очередь после этой блокировки.

Блокировки сущностей являются устойчивыми, поэтому они сохраняются даже при повторном запуске процесса. Блокировки внутренне сохраняются как часть устойчивого состояния сущности.

### <a name="critical-section-restrictions"></a>Ограничения для критических секций

На способ использования критических секций накладываются несколько ограничений. Эти ограничения необходимы для предотвращения взаимоблокировок и повторного входа.

* Критические секции не могут быть вложенными.
* Критические секции не могут создавать подоркестрации.
* Критические разделы могут вызывать только те сущности, которые они заблокировали.
* Критические секции не могут вызывать одну и ту же сущность с помощью нескольких параллельных вызовов.
* Критические разделы могут сигнализировать только тем сущностям, которые не заблокированы.

## <a name="comparison-with-virtual-actors"></a>Сравнение с виртуальными субъектами

Многие из функций Устойчивых сущностей представляют собой [модель субъектов](https://en.wikipedia.org/wiki/Actor_model). Если вы уже знакомы с субъектами, вам могут быть знакомы многие из концепций, описанных в этой статье. В частности, устойчивые сущности во многом похожи на [виртуальные субъекты](https://research.microsoft.com/projects/orleans/):

* К устойчивым сущностям можно обращаться с помощью *идентификатора сущности*.
* Операции с устойчивыми сущностями выполняются последовательно, по очереди, чтобы предотвратить состояние гонки.
* Устойчивые сущности создаются автоматически при их вызове или получении сигнала.
* Если операции не выполняются, устойчивые сущности выгружаются из памяти без вывода сообщений.

Однако следует отметить несколько важных отличий.

* Для устойчивых сущностей *устойчивость* важнее, чем *задержка*. Таким образом они могут не подходить для приложений с требованиями к длительной задержке.
* Сообщения, передаваемые между сущностями, доставляются надежно и по порядку.
* Устойчивые сущности можно использовать совместно с устойчивой оркестрацией вместе с поддержкой механизмов распределенной блокировки.
* Шаблоны запросов и ответов в сущностях ограничены оркестрацией. Для *обмена данными между клиентами* и *между сущностями* допускается только односторонний обмен сообщениями (также называемый "сигнализацией"), как в исходной субъектной модели. Такое поведение предотвращает распределенные взаимоблокировки.

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Task hubs in Durable Functions (Azure Functions)](durable-functions-task-hubs.md) (Центры задач в устойчивых функциях (Функции Azure))