---
title: Контрольные точки и воспроизведение в устойчивых функциях — Azure
description: Сведения о работе контрольных точек и воспроизведении в расширении устойчивых функций для Функций Azure.
services: functions
author: ggailey777
manager: jeconnoc
keywords: ''
ms.service: azure-functions
ms.topic: conceptual
ms.date: 12/07/2018
ms.author: azfuncdf
ms.openlocfilehash: 79cb276f121c351a9954994038d9d826819edf5d
ms.sourcegitcommit: 44e85b95baf7dfb9e92fb38f03c2a1bc31765415
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2019
ms.locfileid: "70087452"
---
# <a name="checkpoints-and-replay-in-durable-functions-azure-functions"></a>Контрольные точки и воспроизведение в устойчивых функциях (Функции Azure)

Одним из ключевых атрибутов устойчивых функций является **надежное выполнение**. Функции оркестратора и функции действий могут выполняться на разных виртуальных машинах в центре обработки данных. Эти виртуальные машины или базовая сетевая инфраструктура не полностью надежные.

Несмотря на это устойчивые функции гарантируют надежное выполнение оркестрации. Они используют очереди хранилища, чтобы управлять вызовом функции, а также создают контрольные точки в журнале выполнения в таблицах хранилища (с помощью конструктивных шаблонов облачных решений, также известных как [шаблоны источников событий](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)). Этот журнал затем воспроизводится, чтобы автоматически перестроить состояние в памяти функции оркестратора.

## <a name="orchestration-history"></a>Журнал оркестраций

Предположим, что у вас есть следующая функция оркестратора:

### <a name="c"></a>C#

```csharp
[FunctionName("E1_HelloSequence")]
public static async Task<List<string>> Run(
    [OrchestrationTrigger] DurableOrchestrationContext context)
{
    var outputs = new List<string>();

    outputs.Add(await context.CallActivityAsync<string>("E1_SayHello", "Tokyo"));
    outputs.Add(await context.CallActivityAsync<string>("E1_SayHello", "Seattle"));
    outputs.Add(await context.CallActivityAsync<string>("E1_SayHello", "London"));

    // returns ["Hello Tokyo!", "Hello Seattle!", "Hello London!"]
    return outputs;
}
```

### <a name="javascript-functions-2x-only"></a>JavaScript (только для решения "Функции" версии 2.x)

```javascript
const df = require("durable-functions");

module.exports = df.orchestrator(function*(context) {
    const output = [];
    output.push(yield context.df.callActivity("E1_SayHello", "Tokyo"));
    output.push(yield context.df.callActivity("E1_SayHello", "Seattle"));
    output.push(yield context.df.callActivity("E1_SayHello", "London"));

    // returns ["Hello Tokyo!", "Hello Seattle!", "Hello London!"]
    return output;
});
```

В каждой инструкции `await` (C#) или `yield` (JavaScript) платформа устойчивых задач создает контрольные точки состояния выполнения функции в хранилище таблиц. Это состояние также называется *журналом оркестрации*.

## <a name="history-table"></a>Таблица журнала

Как правило, платформа устойчивых задач выполняет следующие действия в каждой контрольной точке:

1. Сохраняет журнал выполнения в таблицах службы хранилища Azure.
2. Помещает в очередь сообщения для функций, которые хочет вызвать оркестратор.
3. Помещает в очередь сообщения для самого оркестратора, например сообщения устойчивого таймера.

После создания контрольной точки функцию оркестратора можно удалить из памяти, пока для нее не появится работа.

> [!NOTE]
> Служба хранилища Azure не предоставляет никаких гарантий выполнения транзакций между сохранением данных в хранилище таблиц и очередях. Для обработки ошибок поставщик хранилища устойчивых функций использует шаблоны *итоговой согласованности*. Эти шаблоны позволяют избежать потери данных в случае аварийного завершения или потери возможности подключения в середине контрольной точки.

По завершении приведенный выше журнал функций будет выглядеть примерно следующим образом в хранилище таблиц Azure (следующий пример приведен в сокращенном виде):

| PartitionKey (InstanceId)                     | EventType             | Метка времени               | Ввод | Название             | Результат                                                    | Status |
|----------------------------------|-----------------------|----------|--------------------------|-------|------------------|-----------------------------------------------------------|
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:32.362Z |       |                  |                                                           |                     |
| eaee885b | ExecutionStarted      | 2017-05-05T18:45:28.852Z | null  | E1_HelloSequence |                                                           |                     |
| eaee885b | TaskScheduled         | 2017-05-05T18:45:32.670Z |       | E1_SayHello      |                                                           |                     |
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:32.670Z |       |                  |                                                           |                     |
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:34.232Z |       |                  |                                                           |                     |
| eaee885b | TaskCompleted         | 2017-05-05T18:45:34.201Z |       |                  | """Hello Tokyo!"""                                        |                     |
| eaee885b | TaskScheduled         | 2017-05-05T18:45:34.435Z |       | E1_SayHello      |                                                           |                     |
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:34.435Z |       |                  |                                                           |                     |
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:34.857Z |       |                  |                                                           |                     |
| eaee885b | TaskCompleted         | 2017-05-05T18:45:34.763Z |       |                  | """Hello Seattle!"""                                      |                     |
| eaee885b | TaskScheduled         | 2017-05-05T18:45:34.857Z |       | E1_SayHello      |                                                           |                     |
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:34.857Z |       |                  |                                                           |                     |
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:35.032Z |       |                  |                                                           |                     |
| eaee885b | TaskCompleted         | 2017-05-05T18:45:34.919Z |       |                  | """Hello London!"""                                       |                     |
| eaee885b | ExecutionCompleted    | 2017-05-05T18:45:35.044Z |       |                  | "[""Hello Tokyo!"",""Hello Seattle!"",""Hello London!""]" | Завершено           |
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:35.044Z |       |                  |                                                           |                     |

Некоторые сведения о значениях столбцов:

* **PartitionKey.** Содержит идентификатор экземпляра оркестрации.
* **EventType.** Предоставляет тип события. Принимается один из следующих типов:
  * **OrchestrationStarted.** Функция оркестратора, которая возобновлена после состояния ожидания или выполняется впервые. Столбец `Timestamp` используется, чтобы заполнить детерминированное значение для API [CurrentUtcDateTime](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CurrentUtcDateTime).
  * **ExecutionStarted.** Функция оркестратора, которая начала выполнение впервые. Это событие также содержит входные данные функции в столбце `Input`.
  * **TaskScheduled.** Функция действия была запланирована. Имя функции действия сохраняется в столбце `Name`.
  * **TaskCompleted.** Функция действия выполнена. Результаты функции находятся в столбце `Result`.
  * **TimerCreated.** Устойчивый таймер создан. Столбец `FireAt` содержит запланированное время в формате UTC, когда истекает срок действия таймера.
  * **TimerFired.** Устойчивый таймер активирован.
  * **EventRaised.** Внешнее событие отправлено в экземпляр оркестрации. Столбец `Name` содержит имя события, а столбец `Input` — полезные данные события.
  * **OrchestratorCompleted.** Функция оркестратора находится в состоянии ожидания.
  * **ContinueAsNew.** Функция оркестратора выполнена и автоматически перезапущена с новым состоянием. Столбец `Result` содержит значение, которое используется в качестве входных данных в перезапущенном экземпляре.
  * **ExecutionCompleted.** Функция оркестратора выполнена (или завершилась сбоем). Выходные данные функции или сведения об ошибке хранятся в столбце `Result`.
* **Timestamp.** Метка времени события журнала в формате UTC.
* **Name**. Имя вызванной функции.
* **Входные данные** Входные данные функции в формате JSON.
* **Result.** Выходные данные функции (то есть ее возвращаемое значение).

> [!WARNING]
> Хотя это удобно использовать в качестве средства отладки, не используйте в таблице никакие зависимости. Они могут измениться при развитии расширения устойчивых функций.

Каждый раз, когда функция возобновляется из состояния `await` (C#) или `yield` (JavaScript), платформа устойчивых задач повторно выполняет функцию оркестратора с нуля. При каждом повторном выполнении она учитывает журнал выполнения, чтобы определить, выполнялась ли асинхронная операция.  Если операция выполнялась, платформа немедленно воспроизводит выходные данные этой операции и переходит к следующему объекту с состоянием `await` (C#) или `yield` (JavaScript). Этот процесс продолжается, пока весь журнал не будет воспроизведен. После этого все локальные переменные в функции оркестратора восстанавливают свои прежние значения.

## <a name="orchestrator-code-constraints"></a>Ограничения кода оркестратора

Поведение воспроизведения ограничивает тип кода, который может быть записан в функцию оркестратора.

* Код оркестратора должен быть **детерминированным**. Он будет воспроизведен несколько раз и должен каждый раз выдавать одинаковый результат. Например, не должно быть прямых вызовов, чтобы получить текущие дату и время, получить случайные числа, создать случайные значения GUID, а также вызовов удаленных конечных точек.

  Если коду оркестратора нужно получить текущие значения даты и времени, он должен использовать API [CurrentUtcDateTime](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CurrentUtcDateTime) (.NET) или `currentUtcDateTime` (JavaScript), который безопасен для воспроизведения.

  Если коду оркестратора нужно создать случайный идентификатор GUID, он должен использовать API [NewGuid](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_NewGuid) (.NET), который безопасен для воспроизведения, или делегировать создание GUID функции действия (JavaScript), как показано в этом примере:

  ```javascript
  const uuid = require("uuid/v1");

  module.exports = async function(context) {
    return uuid();
  }
  ```

  В функциях действий должны выполняться недетерминированные операции. Сюда входят любые взаимодействия с другими входными или выходными привязками. Это гарантирует, что все недетерминированные значения будут создаваться один раз при первом выполнении и сохранятся в журнал выполнения. Последующие выполнения будут автоматически использовать сохраненные значения.

* Код оркестратора не должен иметь **блокировки**. Например, это означает отсутствие операций ввода-вывода и вызовов `Thread.Sleep` (.NET) или эквивалентных API.

  Если для оркестратора требуется задержка, он может использовать API [CreateTimer](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CreateTimer_) (.NET) или `createTimer` (JavaScript).

* Код оркестратора никогда не должен **запускать асинхронную операцию**, разве что с помощью API [DurableOrchestrationContext](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html) или API объекта `context.df`. Например, не выполнять `Task.Run` `Task.Delay` или `HttpClient.SendAsync` в .NET либо `setTimeout()` и `setInterval()` в JavaScript. Платформа устойчивых задач выполняет код оркестратора в одном потоке и не может взаимодействовать с другими потоками, которые могут планироваться другими асинхронными API. В `InvalidOperationException` этом случае возникает исключение.

* **Следует избегать бесконечных циклов** в коде оркестратора. Так как платформа устойчивых задач сохраняет журнал выполнения в ходе работы функции оркестрации, бесконечный цикл может привести к нехватке памяти для экземпляра оркестратора. Для сценариев с бесконечным циклом используйте API, например [ContinueAsNew](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_ContinueAsNew_) (.NET) или `continueAsNew` (JavaScript), чтобы перезапустить выполнение функции и отменить предыдущий журнал выполнения.

* Функции оркестратора JavaScript не могут быть асинхронными (`async`). Они должны быть объявленными как синхронные функции генератора.

Хотя эти ограничения могут показаться пугающими, на практике им легко следовать. Платформа устойчивых задач пытается обнаружить нарушения приведенных выше правил и выдает исключение `NonDeterministicOrchestrationException`. Тем не менее это поведение обнаружения является лучшим вариантом и вы не должны от него зависеть.

> [!NOTE]
> Все эти правила применяются только к функциям, активированным привязкой `orchestrationTrigger`. Функции действий, активированные привязкой `activityTrigger`, и функции, использующие привязку`orchestrationClient`, не имеют таких ограничений.

## <a name="durable-tasks-net"></a>Устойчивые задачи (.NET)

> [!NOTE]
> Этот раздел содержит сведения о внутренней реализации платформы устойчивых задач. Вы можете использовать устойчивые функции, не зная эту информацию. Она предназначена только для того, чтобы помочь вам понять поведение воспроизведения.

Задачи, которые могут безопасно ожидаться в функциях оркестратора, иногда называются *устойчивыми задачами*. Создание этих задач и управление ими осуществляется с помощью платформы устойчивых задач. Примерами являются задачи, возвращаемые `CallActivityAsync`, `WaitForExternalEvent`, и `CreateTimer`.

Управление этими *устойчивыми задачами* выполняется внутренне с помощью списка объектов `TaskCompletionSource`. Во время воспроизведения эти задачи создаются как часть выполнения кода оркестратора и завершаются, когда диспетчер перечисляет соответствующие события журнала. Это все выполняется синхронно с помощью одного потока до тех пор, пока весь журнал не будет воспроизведен. Для всех устойчивых задач, не завершенных до конца воспроизведения журнала, выполняются соответствующие действия. Например, сообщение может быть поставлено в очередь для вызова функции действия.

Описанное здесь поведение выполнения должно помочь вам понять, почему код функции оркестратора никогда не должен ожидать`await` неустойчивые задачи. Поток диспетчера не может ожидать их завершения, а любой обратный вызов этой задачи может повредить состояние отслеживания функции оркестратора. Чтобы этого избежать, выполняются некоторые проверки среды выполнения.

Чтобы получить дополнительные сведения о том, как платформа устойчивых задач выполняет функции оркестратора, ознакомьтесь с [исходным кодом устойчивых задач на сайте GitHub](https://github.com/Azure/durabletask). В частности, просмотрите сведения о [TaskOrchestrationExecutor.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationExecutor.cs) и [TaskOrchestrationContext.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationContext.cs)

## <a name="next-steps"></a>Следующие шаги

> [!div class="nextstepaction"]
> [Узнайте больше об управлении экземплярами](durable-functions-instance-management.md)
