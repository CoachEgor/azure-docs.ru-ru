---
title: Ограничения протертора кода оркестратора - Функции Azure
description: Воспроизведение функций оркестровки и ограничения кода для функций Azure Durable.
author: cgillum
ms.topic: conceptual
ms.date: 11/02/2019
ms.author: azfuncdf
ms.openlocfilehash: 4ed604302ca187ad4953e865d68dc73030a37c02
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "77562145"
---
# <a name="orchestrator-function-code-constraints"></a>Ограничения функции функции оркестра

Прочная функция — это расширение [функций Azure,](../functions-overview.md) которое позволяет создавать приложения с состоянием. Функция [оркестратора](durable-functions-orchestrations.md) может быть организована для организации выполнения других длительных функций в приложении функции. Функции оркестратора являются государственными, надежными и потенциально длительными.

## <a name="orchestrator-code-constraints"></a>Ограничения кода оркестратора

Функции Оркестратора используют [поиск событий](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) для обеспечения надежного выполнения и поддержания локального переменного состояния. [Поведение реплетов](durable-functions-orchestrations.md#reliability) оркестраторного кода создает ограничения на тип кода, который можно написать в функции оркестратора. Например, функции оркестратора должны быть *детерминированными:* функция оркестратора будет воспроизводиться несколько раз, и она должна производить один и тот же результат каждый раз.

### <a name="using-deterministic-apis"></a>Использование детерминированных AIS

В этом разделе приведены некоторые простые рекомендации, которые помогают гарантировать, что ваш код является детерминированным.

Функции оркестратора могут вызывать любой API на своих целевых языках. Однако важно, чтобы функции оркестратора называлитолько только детерминированными AIS. *Детерминированный API* — это API, который всегда возвращает одно и то же значение с учетом одного и того же ввода, независимо от того, когда и как часто он вызывается.

В следующей таблице приведены примеры AIS, которые следует избегать, поскольку они *не* являются детерминированными. Эти ограничения распространяются только на функции оркестратора. Другие типы функций не имеют таких ограничений.

| Категория API | Причина | Обходной путь |
| ------------ | ------ | ---------- |
| Даты и время  | AAP, возвращающие текущую дату или время, недетерминированы, поскольку возвратное значение отличается для каждого воспроизведения. | Используйте`CurrentUtcDateTime` API в .NET или `currentUtcDateTime` API в JavaScript, которые безопасны для воспроизведения. |
| GUIDs и UUIDs  | AAP, возвращающие случайные GUID или UUID, недетерминированы, поскольку генерируемое значение отличается для каждого воспроизведения. | Используйте `NewGuid` в `newGuid` .NET или javaScript для безопасного создания случайных GUID. |
| Случайные числа | AAP, возвращающие случайные числа, недетерминированы, поскольку генерируемое значение отличается для каждого воспроизведения. | Используйте функцию активности, чтобы вернуть случайные числа в оркестровку. Значения возврата функций активности всегда безопасны для воспроизведения. |
| Привязки | Входные и выходные привязки обычно ввода/вывода и являются недетерминированными. Функция оркестратора не должна напрямую использовать даже привязки [клиента-оркестра](durable-functions-bindings.md#orchestration-client) и [клиента сущности.](durable-functions-bindings.md#entity-client) | Используйте входные и выходные привязки внутри функций клиента или деятельности. |
| Сеть | Сетевые вызовы связаны с внешними системами и являются недетерминированными. | Используйте функции активности для звонков в сеть. Если вам нужно сделать http вызов от функции оркестратора, вы также можете использовать [прочные HTTP AIS.](durable-functions-http-features.md#consuming-http-apis) |
| Блокировка AIS | Блокировка AIS, как `Thread.Sleep` в .NET и аналогичных AIS, может вызвать проблемы с производительностью и масштабированием для функций оркестратора и следует избегать. В плане потребления функций Azure они могут даже привести к ненужным расходам на время выполнения. | Используйте альтернативы блокировке AИГИЛ, когда они доступны. Например, `CreateTimer` использовать для введения задержек в выполнении оркестровки. [Длительные](durable-functions-timers.md) задержки таймер не учитываются в момент выполнения функции оркестратора. |
| Async AIS | Код оркестратора никогда не должен начинать `IDurableOrchestrationContext` операцию async, кроме как с помощью API или API `context.df` объекта. Например, вы не `Task.Run`можете `Task.Delay`использовать, и `HttpClient.SendAsync` `setTimeout` в `setInterval` .NET или и в JavaScript. В рамках программы Durable Task Framework запускается оркестраторный код на одном потоке. Он не может взаимодействовать с другими потоками, которые могут быть вызваны другими AIS async. | Функция оркестратора должна делать только прочные вызовы async. Функции активности должны выполнять любые другие вызовы API API. |
| Функции Async JavaScript | Вы не можете объявить функции `async` оркестратора JavaScript, так как время выполнения node.js не гарантирует детерминационистские функции. | Объявить функции оркестратора JavaScript в качестве синхронных функций генератора. |
| Потоковые AIS | Платформа «Прочная задача» запускает оркестраторный код на одном потоке и не может взаимодействовать с другими потоками. Внедрение новых потоков в выполнение оркестровки может привести к недетерминированному исполнению или взаимоблокировкам. | Функции оркестратора почти никогда не должны использовать aIS потоков. Например, в .NET `ConfigureAwait(continueOnCapturedContext: false)`избегайте использования; это обеспечивает продолжение задачи на исходном. `SynchronizationContext` Если такие AA необходимы, ограничьте их использование только функциями активности. |
| Статические переменные | Избегайте использования непостоянных статических переменных в функциях оркестратора, поскольку их значения могут меняться с течением времени, что приводит к недетерминированному поведению в течение выполнения. | Используйте константы или ограничьте использование статических переменных функциями активности. |
| Переменные среды | Не используйте переменные среды в функциях оркестратора. Их значения могут меняться с течением времени, что приводит к недетерминированному поведению в течение выполнения. | Переменные среды должны быть отсылками только из функций клиента или функций деятельности. |
| Бесконечные петли | Избегайте бесконечных циклов в функциях оркестраторов. Поскольку система «Прочная задача» сохраняет историю выполнения по мере выполнения функции оркестровки, бесконечный цикл может привести к тому, что у экземпляра оркестранта заканчивается память. | Для сценариев бесконечного `ContinueAsNew` цикла используйте `continueAsNew` AI, как в .NET или javaScript, чтобы перезапустить выполнение функции и отказаться от предыдущей истории выполнения. |

Хотя применение этих ограничений может показаться трудным на первый, на практике они легко следовать.

В рамках «Долгосрочные задачи» предпринимаются попытки выявить нарушения предыдущих правил. Если он обнаруживает нарушение, фреймворк бросает исключение **NonDeterministicOrchestrationException.** Однако такое поведение обнаружения не устранит всех нарушений, и вы не должны зависеть от него.

## <a name="versioning"></a>Управление версиями

Прочная оркестровка может работать непрерывно в течение нескольких дней, месяцев, лет или даже [вечно.](durable-functions-eternal-orchestrations.md) Любые обновления кода, сделанные в приложениях Durable Functions, влияющие на незаконченные оркестровки, могут нарушить поведение воспроизведения оркестровок. Вот почему важно тщательно планировать при внесении обновлений в код. Более подробное описание версии кода можно узнать в [статье для версий.](durable-functions-versioning.md)

## <a name="durable-tasks"></a>Устойчивые задачи

> [!NOTE]
> Этот раздел содержит сведения о внутренней реализации платформы устойчивых задач. Вы можете использовать прочные функции, не зная этой информации. Она предназначена только для того, чтобы помочь вам понять поведение воспроизведения.

Задачи, которые можно безопасно ждать в функциях оркестратора, иногда *называются долговечными задачами.* Платформа «Прочная задача» создает и управляет этими задачами. Примерами являются задачи, возвращенные **CallActivityAsync**, **WaitForExternalEvent**и **CreateTimer** в функциях оркестратора .NET.

Эти долговременные задачи управляются `TaskCompletionSource` внутри страны списком объектов в .NET. Во время воспроизведения эти задачи создаются как часть выполнения кода-оркестра. Они закончены, когда диспетчер перечисляет соответствующие исторические события.

Задачи выполняются синхронно с помощью одного потока до тех пор, пока вся история не будет воспроизведена. Долгосрочные задачи, которые не будут завершены к концу воспроизведения истории, имеют соответствующие действия. Например, сообщение может быть enqueued для вызова функции активности.

Описание поведения в этом разделе о времени выполнения должно помочь вам понять, почему функция оркестратора не может использоваться `await` или `yield` в невыносимой задаче. Есть две причины: поток диспетчера не может ждать завершения задачи, и любой обратный вызов с помощью этой задачи может потенциально испортить состояние отслеживания функции оркестратора. Некоторые проверки времени выполнения на месте, чтобы помочь обнаружить эти нарушения.

Чтобы узнать больше о том, как система «Прочная задача» выполняет функции оркестратора, обратитесь к [исходному коду «Прочная задача» на GitHub.](https://github.com/Azure/durabletask) В частности, см. [TaskOrchestrationExecutor.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationExecutor.cs) и [TaskOrchestrationContext.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationContext.cs).

## <a name="next-steps"></a>Дальнейшие действия

> [!div class="nextstepaction"]
> [Узнайте, как вызвать подоркестрации](durable-functions-sub-orchestrations.md)

> [!div class="nextstepaction"]
> [Сведения об обработке управления версиями](durable-functions-versioning.md)
