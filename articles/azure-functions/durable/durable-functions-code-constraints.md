---
title: Устойчивые ограничения кода Orchestrator — функции Azure
description: Функции оркестрации и ограничения кода для Устойчивые функции Azure.
author: cgillum
manager: gwallace
keywords: ''
ms.service: azure-functions
ms.topic: conceptual
ms.date: 08/18/2019
ms.author: azfuncdf
ms.openlocfilehash: 87851a4879760c76950f765d05de4662ecb04bea
ms.sourcegitcommit: f3f4ec75b74124c2b4e827c29b49ae6b94adbbb7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2019
ms.locfileid: "70935772"
---
# <a name="orchestrator-function-code-constraints"></a>Ограничения кода функции Orchestrator

Устойчивые функции — это расширение [функций Azure](../functions-overview.md) , которое позволяет создавать приложения с отслеживанием состояния. [Функцию Orchestrator](durable-functions-orchestrations.md) можно использовать для координации выполнения других устойчивых функций в приложении-функции. Функции Orchestrator поддерживают отслеживание состояния, надежность и потенциально длительное выполнение.

## <a name="orchestrator-code-constraints"></a>Ограничения кода оркестратора

Функции Orchestrator используют [источники событий](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) для обеспечения надежного выполнения и поддержания состояния локальной переменной. [Поведение воспроизведения](durable-functions-orchestrations.md#reliability) кода Orchestrator создает ограничения на тип кода, который можно написать в функции Orchestrator. Например, код Orchestrator должен быть *детерминированным*.  Функции Orchestrator будут воспроизводиться несколько раз, и каждый раз будет выдавать один и тот же результат.

В следующих разделах приводятся некоторые простые рекомендации по обеспечению детерминированности кода.

### <a name="using-deterministic-apis"></a>Использование детерминированных интерфейсов API

Функции Orchestrator свободны для вызова любого API, который они хотят на целевом языке. Однако важно, чтобы функции Orchestrator вызывали только *детерминированные* API. *Детерминированный API* — это API, который всегда возвращает одно и то же значение при вводе одних и тех же входных данных независимо от того, когда или как часто он вызывается.

Ниже приведены некоторые примеры интерфейсов API, которые следует избегать, поскольку они *не* являются детерминированными. Эти ограничения относятся только к функциям Orchestrator. Другие типы функций не имеют таких ограничений.

| Категория API | Причина | Возможное решение |
| ------------ | ------ | ---------- |
| Даты и время  | API-интерфейсы, возвращающие _текущую_ дату или время, являются недетерминированными, так как возвращаемые значения будут отличаться для каждого воспроизведения. | Используйте API [CurrentUtcDateTime](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CurrentUtcDateTime) (.NET) или `currentUtcDateTime` (JavaScript), который является надежным для воспроизведения. |
| Идентификаторы GUID/UUID  | API-интерфейсы, возвращающие _случайный_ идентификатор GUID или UUID, являются недетерминированными, поскольку сформированное значение будет отличаться для каждого воспроизведения. | Используйте [NewGuid](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_NewGuid) (.NET) или `newGuid` (JavaScript) для безопасного создания случайных идентификаторов GUID. |
| Случайные числа | API-интерфейсы, возвращающие случайные числа, являются недетерминированными, поскольку сформированное значение будет отличаться для каждого воспроизведения. | Используйте функцию действия для возврата случайных чисел в согласование. Возвращаемые значения функций действий всегда являются надежными для воспроизведения. |
| Привязки | Входные и выходные привязки обычно выполняют операции ввода-вывода и не являются детерминированными. Даже [клиент оркестрации](durable-functions-bindings.md#orchestration-client) и привязки [клиента сущности](durable-functions-bindings.md#entity-client) не должны использоваться непосредственно функцией Orchestrator. | Используйте входные и выходные привязки внутри функций клиента или действия. |
| Network | Сетевые вызовы содержат внешние системы и не являются детерминированными. | Используйте функции действий для выполнения сетевых вызовов. Если необходимо выполнить HTTP-вызов из функции Orchestrator, вы также можете использовать [устойчивые API HTTP](durable-functions-http-features.md#consuming-http-apis). |
| Блокирующие API | Блокирующие интерфейсы API `Thread.Sleep` , такие как (.NET) или другие аналогичные API, могут вызвать проблемы производительности и масштабирования для функций Orchestrator, и их следует избегать. В плане потребления функций Azure они могут даже привести к ненужным затратам времени на выполнение. | Используйте альтернативы для блокирования API, если они `CreateTimer` доступны, например, чтобы привести к задержкам при выполнении оркестрации. [Устойчивые задержки таймера](durable-functions-timers.md) не учитываются во время выполнения функции Orchestrator. |
| Асинхронные API | Код оркестратора никогда не должен **запускать асинхронную операцию**, разве что с помощью API [DurableOrchestrationContext](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html) или API объекта `context.df`. Например, не выполнять `Task.Run` `Task.Delay` или `HttpClient.SendAsync` в .NET либо `setTimeout()` и `setInterval()` в JavaScript. Платформа устойчивых задач выполняет код оркестратора в одном потоке и не может взаимодействовать с другими потоками, которые могут планироваться другими асинхронными API. | Только *устойчивые* асинхронные вызовы должны выполняться функцией Orchestrator. Любые другие асинхронные вызовы API должны выполняться из функций действий. |
| Асинхронные функции JavaScript | Функции Orchestrator в JavaScript не `async` могут быть, поскольку среда выполнения Node. js не гарантирует, что асинхронные функции являются детерминированными. | Функции Orchestrator JavaScript должны быть объявлены как функции синхронного генератора. |
| API-интерфейсы потоков | Платформа устойчивых задач выполняет код Orchestrator в одном потоке и не может взаимодействовать с другими потоками. Введение новых потоков в выполнение оркестрации может привести к недетерминированному выполнению или взаимоблокировкам. | API-интерфейсы для работы с потоками практически никогда не должны использоваться в функциях Orchestrator. При необходимости они должны быть ограничены функциями действий. |
| Статические переменные | Неконстантные статические переменные следует избегать в функциях Orchestrator, так как их значения могут меняться со временем, что приводит к недетерминированному поведению при выполнении. | Используйте константы или ограничьте использование статических переменных функциями действий. |
| Переменные среды | Не используйте переменные среды в функциях Orchestrator. Их значения со временем могут меняться, что приводит к недетерминированному поведению при выполнении. | Ссылки на переменные среды должны осуществляться только из функций клиента или функций действий. |
| Бесконечные циклы | В функциях Orchestrator следует избегать бесконечных циклов. Платформа устойчивых задач сохраняет журнал выполнения в ходе выполнения функции оркестрации, поэтому бесконечный цикл может привести к нехватке памяти для экземпляра Orchestrator. | Для сценариев с бесконечным циклом используйте API, например [ContinueAsNew](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_ContinueAsNew_) (.NET) или `continueAsNew` (JavaScript), чтобы перезапустить выполнение функции и отменить предыдущий журнал выполнения. |

Хотя эти ограничения могут показаться пугающими, на практике им легко следовать. Платформа устойчивых задач пытается обнаружить нарушения приведенных выше правил и выдает исключение `NonDeterministicOrchestrationException`. Тем не менее это поведение обнаружения является лучшим вариантом и вы не должны от него зависеть.

## <a name="versioning"></a>Управление версиями

Устойчивое согласование может выполняться непрерывно в течение дней, месяцев, лет или даже [етерналли](durable-functions-eternal-orchestrations.md). Любые обновления кода, внесенные в Устойчивые функции приложения, которые влияют на незавершенные взаимодействия, могут нарушить поведение воспроизведения. Поэтому важно тщательно спланировать выполнение обновлений кода. Более подробное описание способов версии кода см. в статье [Управление версиями](durable-functions-versioning.md) .

## <a name="durable-tasks"></a>Устойчивые задачи

> [!NOTE]
> Этот раздел содержит сведения о внутренней реализации платформы устойчивых задач. Вы можете использовать устойчивые функции, не зная эту информацию. Она предназначена только для того, чтобы помочь вам понять поведение воспроизведения.

Задачи, которые могут безопасно ожидаться в функциях оркестратора, иногда называются *устойчивыми задачами*. Эти задачи создаются и управляются платформой устойчивых задач. Примерами являются задачи `CallActivityAsync`, возвращаемые `WaitForExternalEvent`, и `CreateTimer` в функциях .NET Orchestrator.

Эти *устойчивые задачи* управляются внутренне с помощью списка `TaskCompletionSource` объектов в .NET. Во время воспроизведения эти задачи создаются как часть выполнения кода оркестратора и завершаются, когда диспетчер перечисляет соответствующие события журнала. Выполнение выполняется синхронно с использованием одного потока, пока не будет воспроизведен весь журнал. Все устойчивые задачи, не завершенные окончанием воспроизведения журнала, имеют соответствующие действия. Например, сообщение может быть поставлено в очередь для вызова функции действия.

Описанное здесь поведение выполнения должно помочь вам понять, почему код функции Orchestrator никогда `await` не `yield` должен быть неустойчивой задачей: поток Dispatcher не может дождаться завершения, а любой обратный вызов этой задачи потенциально может повреждено отслеживание состояния функции Orchestrator. Для обнаружения этих нарушений необходимо выполнить некоторые проверки среды выполнения.

Чтобы получить дополнительные сведения о том, как платформа устойчивых задач выполняет функции оркестратора, ознакомьтесь с [исходным кодом устойчивых задач на сайте GitHub](https://github.com/Azure/durabletask). В частности, просмотрите сведения о [TaskOrchestrationExecutor.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationExecutor.cs) и [TaskOrchestrationContext.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationContext.cs)

## <a name="next-steps"></a>Следующие шаги

> [!div class="nextstepaction"]
> [Узнайте, как вызывать подсистемы взаимодействия](durable-functions-sub-orchestrations.md)

> [!div class="nextstepaction"]
> [Сведения об обработке управления версиями](durable-functions-versioning.md)
