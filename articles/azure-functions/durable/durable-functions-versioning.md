---
title: Управление версиями в устойчивых функциях — Azure
description: Сведения о том, как выполнять управление в расширении устойчивых функций для Функций Azure.
author: cgillum
ms.topic: conceptual
ms.date: 11/03/2019
ms.author: azfuncdf
ms.openlocfilehash: 87cbb94dbab241630dc7585bdf4314d858d5b4da
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74232754"
---
# <a name="versioning-in-durable-functions-azure-functions"></a>Управление версиями в устойчивых функциях (Функции Azure)

Функции добавляются, удаляются и изменяются на протяжении времени существования приложения. [Устойчивые функции](durable-functions-overview.md) позволяют связывать функции ранее недоступными способами, и это влияет на управление версиями.

## <a name="how-to-handle-breaking-changes"></a>Как управлять критическими изменениями

Есть несколько критических изменений, о которых следует знать. В этой статье рассматриваются самые распространенные из них. Общим для них является то, что на новую и имеющуюся функции оркестрации влияют изменения кода функции.

### <a name="changing-activity-or-entity-function-signatures"></a>Изменение подписей функций действия или сущности

Изменение сигнатуры относится к изменению имени, входных или выходных данных функции. Если такого рода изменения внося в функцию действия или сущности, это может нарушить любую функцию оркестратора, которая зависит от нее. Обновление функции оркестратора для применения этого изменения может привести к нарушению работы имеющихся активных экземпляров.

В качестве примера предположим, что у нас есть следующая функция оркестратора.

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] IDurableOrchestrationContext context)
{
    bool result = await context.CallActivityAsync<bool>("Foo");
    await context.CallActivityAsync("Bar", result);
}
```

Эта упрощенная функция принимает результаты **Foo** и передает их в **Bar**. Предположим, что нужно изменить возвращаемое значение **Foo** с `bool` на `int` для поддержки более широкого набора итоговых значений. Результат имеет следующий вид:

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] IDurableOrchestrationContext context)
{
    int result = await context.CallActivityAsync<int>("Foo");
    await context.CallActivityAsync("Bar", result);
}
```

> [!NOTE]
> Предыдущие примеры C' нацелены на функции durable 2.x. Для долгосрочных функций 1.x необходимо использовать `DurableOrchestrationContext` вместо `IDurableOrchestrationContext`. Для получения дополнительной информации о [Durable Functions versions](durable-functions-versions.md) различиях между версиями см.

Это изменение никак не сказывается на всех новых экземплярах функции оркестратора, но нарушает работу активных экземпляров. Например, рассмотрим случай, когда экземпляр оркестровки вызывает функцию с именем, `Foo`получает обратно значение boolean, а затем контрольно-пропускные пункты. Если на этой точке развернуто изменение сигнатуры, экземпляр с контрольной точкой завершится ошибкой сразу после возобновления работы и воспроизведения вызова `context.CallActivityAsync<int>("Foo")`. Этот сбой происходит потому, `bool` что результат в таблице истории, `int`но новый код пытается десериализировать его в .

Этот пример является лишь одним из множества способов, которымизменение подписи может нарушить существующие экземпляры. Как правило, изменение способа вызова функции для оркестратора может привести к проблемам.

### <a name="changing-orchestrator-logic"></a>Изменение логики оркестратора

Другой класс проблем с управлением версиями связан с изменением кода функции оркестратора способом, который может сбить с толку логику воспроизведения для активных экземпляров.

Рассмотрим следующую функцию оркестратора:

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] IDurableOrchestrationContext context)
{
    bool result = await context.CallActivityAsync<bool>("Foo");
    await context.CallActivityAsync("Bar", result);
}
```

Теперь предположим, что нужно внести небольшое изменение, чтобы добавить другой вызов функции.

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] IDurableOrchestrationContext context)
{
    bool result = await context.CallActivityAsync<bool>("Foo");
    if (result)
    {
        await context.CallActivityAsync("SendNotification");
    }

    await context.CallActivityAsync("Bar", result);
}
```

> [!NOTE]
> Предыдущие примеры C' нацелены на функции durable 2.x. Для долгосрочных функций 1.x необходимо использовать `DurableOrchestrationContext` вместо `IDurableOrchestrationContext`. Для получения дополнительной информации о [Durable Functions versions](durable-functions-versions.md) различиях между версиями см.

Это изменение добавит новый вызов функции в **SendNotification** между **Foo** и **Bar**. Изменения сигнатуры отсутствуют. Проблема возникает, когда имеющийся экземпляр возобновляет работу после вызова **Bar**. Во время воспроизведения, если исходный вызов **Foo** вернулся, `true`то реплетор-реплей вызовет в **SendNotification**, который не входит в историю его исполнения. В результате платформа устойчивых задач завершается сбоем с `NonDeterministicOrchestrationException` из-за выполнения вызова **SendNotification** вместо **Bar**. Такой же тип проблемы может возникнуть при добавлении `CreateTimer` `WaitForExternalEvent`любых вызовов к "долговечным" AIS, включая и т.д.

## <a name="mitigation-strategies"></a>Стратегии устранения рисков

Ниже приведены некоторые стратегии для устранения проблем с управлением версиями:

* Ничего не предпринимать
* Остановка всех активных экземпляров
* Выполнение параллельного развертывания

### <a name="do-nothing"></a>Ничего не предпринимать

Самая простая реакция на критическое изменение — позволить активным экземплярам оркестрации завершиться сбоем. Новые экземпляры успешно выполняют измененный код.

Является ли этот вид сбоя проблемой, зависит от важности ваших экземпляров в полете. Эта проблема не критична, если вы активно выполняете разработку и активные экземпляры не имеют значения. Тем не менее, вам придется иметь дело с исключениями и ошибками в конвейере диагностики. Если вы хотите этого избежать, необходимо рассмотреть другие варианты управления версиями.

### <a name="stop-all-in-flight-instances"></a>Остановка всех активных экземпляров

Другим вариантом является остановка всех активных экземпляров. Остановка всех экземпляров может быть осуществлена путем очистки содержимого очередей внутреннего **контроля** и **очередей рабочих и очередей.** Экземпляры будут навсегда застрял, где они находятся, но они не будут загромождать ваши журналы с отказом сообщений. Этот подход идеально подходит для быстрой разработки прототипов.

> [!WARNING]
> Со временем сведения об этих очередях могут изменяться, поэтому не рекомендуется использовать этот метод для рабочих нагрузок.

### <a name="side-by-side-deployments"></a>Выполнение параллельного развертывания

Параллельное развертывание с более старыми версиями — наиболее отказоустойчивый способ обеспечить безопасное развертывание критических изменений. Это можно сделать с помощью любого из следующих способов:

* Развертывайте все обновления в виде совершенно новых функций, оставляя существующие функции как есть. Это может быть сложно, потому что абоненты новых версий функций должны быть обновлены, а также следующие же руководящие принципы.
* Развертывание всех обновлений в качестве нового приложения-функции с помощью другой учетной записи хранения.
* Развертывание новой копии приложения функции с той же `taskHub` учетной записью хранения, но с обновленным именем. Перехидваемым методом является боковое развертывание.

### <a name="how-to-change-task-hub-name"></a>Как изменить имя центра задач

Имя центра задач можно настроить в файле *host.json* следующим образом:

#### <a name="functions-1x"></a>Функции 1.x

```json
{
    "durableTask": {
        "hubName": "MyTaskHubV2"
    }
}
```

#### <a name="functions-20"></a>Функции 2.0

```json
{
    "extensions": {
        "durableTask": {
            "hubName": "MyTaskHubV2"
        }
    }
}
```

Значение по умолчанию для долгосрочных `DurableFunctionsHub`функций v1.x . Начиная с функции «Прочная функциональность v2.0», имя концентратора `TestHubName` задачи по умолчанию совпадает с именем приложения функции в Azure или при запуске за пределами Azure.

Все сущности в службе хранилища Azure именуются на основе значения конфигурации `hubName`. Задавая новое имя для центра задач, вы гарантируете, что для новой версии приложения будут созданы отдельные очереди и таблица журнала. Функция приложение, однако, прекратит обработку событий для оркестровки или сущностей, созданных под предыдущим названием концентратора задач.

Мы советуем развертывать новую версию приложения-функции в новый [слот развертывания](../functions-deployment-slots.md). Слоты развертывания позволяют параллельно запускать несколько копий приложения-функции, при этом только один слот может быть активным *рабочим* слотом. Предоставить новую логику оркестрации для имеющейся инфраструктуры может быть так же просто, как заменить новую версию в рабочем слоте.

> [!NOTE]
> Эта стратегия оптимально подходит при использовании триггеров HTTP и веб-перехватчика для функций оркестратора. Для триггеров, не относясь к HTTP, таких как очереди или концентраторы событий, определение триггера должно [происходить из настройки приложения,](../functions-bindings-expressions-patterns.md#binding-expressions---app-settings) которая обновляется как часть операции своп.

## <a name="next-steps"></a>Дальнейшие действия

> [!div class="nextstepaction"]
> [Узнайте, как управлять проблемами с производительностью и масштабированием](durable-functions-perf-and-scale.md)
