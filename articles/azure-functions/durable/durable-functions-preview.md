---
title: Устойчивые функции предварительных версиях функций - функций Azure
description: Сведения о функциях предварительной версии для устойчивых функций.
services: functions
author: cgillum
manager: jeconnoc
keywords: ''
ms.service: azure-functions
ms.devlang: multiple
ms.topic: article
ms.date: 07/08/2019
ms.author: azfuncdf
ms.openlocfilehash: 7101519aa4a87995dac3a7f11046eed84a2c09b6
ms.sourcegitcommit: af31deded9b5836057e29b688b994b6c2890aa79
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2019
ms.locfileid: "67812761"
---
# <a name="durable-functions-20-preview-azure-functions"></a>Устойчивый Предварительный просмотр функций 2.0 (функции Azure)

*Устойчивые функции* являются расширением [Функций Azure](../functions-overview.md) и [веб-заданий Azure](../../app-service/web-sites-create-web-jobs.md), которое позволяет писать функции с отслеживанием состояния в безсерверной среде. Расширение автоматически управляет состоянием, создает контрольные точки и перезагружается. Если вы не знакомы с устойчивыми функциями, см. в разделе [обзорной документацией](durable-functions-overview.md).

Устойчивые функции 1.x — это функция (общедоступная) общедоступной версии функций Azure, но также содержит несколько вложенных компонентов, которые в настоящее время находятся в общедоступной предварительной версии. В этой статье описываются новые предварительные версии компонентов и попадают в сведения о том, как они работают и как можно начать использовать их.

> [!NOTE]
> Эти функции предварительной версии являются частью выпуска устойчивых функций 2.0, которая в данный момент **предварительный выпуск качества** с несколько критических изменений. Azure функции устойчивых создает пакет расширения можно найти на сайте nuget.org с версиями в виде **2.0.0-betaX**. Эти сборки не предназначены для рабочих нагрузок и последующих выпусках может содержать дополнительные критические изменения.

## <a name="breaking-changes"></a>Критические изменения

В устойчивых функций 2.0 представлены несколько критических изменений. Существующие приложения не должны быть совместимы с устойчивых функций 2.0 без изменения кода. В этом разделе перечислены некоторые изменения:

### <a name="hostjson-schema"></a>Схемы Host.JSON

В следующем фрагменте показано host.json новую схему. Основные изменения, которые следует учитывать приведены новые подразделы.

* `"storageProvider"` (и `"azureStorage"` подраздел) для конкретного хранилища конфигурации
* `"tracking"` для отслеживания и конфигурации ведения журнала
* `"notifications"` (и `"eventGrid"` подраздел) для конфигурации уведомлений сетки событий

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "azureStorage": {
          "connectionStringName": <string>,
          "controlQueueBatchSize": <int?>,
          "partitionCount": <int?>,
          "controlQueueVisibilityTimeout": <hh:mm:ss?>,
          "workItemQueueVisibilityTimeout": <hh:mm:ss?>,
          "trackingStoreConnectionStringName": <string?>,
          "trackingStoreNamePrefix": <string?>,
          "maxQueuePollingInterval": <hh:mm:ss?>
        }
      },
      "tracking": {
        "traceInputsAndOutputs": <bool?>,
        "traceReplayEvents": <bool?>,
      },
      "notifications": {
        "eventGrid": {
          "topicEndpoint": <string?>,
          "keySettingName": <string?>,
          "publishRetryCount": <string?>,
          "publishRetryInterval": <hh:mm:ss?>,
          "publishRetryHttpStatus": <int[]?>,
          "publishEventTypes": <string[]?>,
        }
      },
      "maxConcurrentActivityFunctions": <int?>,
      "maxConcurrentOrchestratorFunctions": <int?>,
      "extendedSessionsEnabled": <bool?>,
      "extendedSessionIdleTimeoutInSeconds": <int?>,
      "customLifeCycleNotificationHelperType": <string?>
  }
}
```

Так как устойчивых функций 2.0 продолжает стабилизация, будут представлены дополнительные изменения `durableTask` разделе host.json. Дополнительные сведения об этих изменениях см. в разделе [проблема GitHub](https://github.com/Azure/azure-functions-durable-extension/issues/641).

### <a name="public-interface-changes"></a>Открытый интерфейс изменения

Различные объекты «контекст», поддерживаемым устойчивыми функциями было абстрактных базовых классов, которые предназначены для использования в модульном тестировании. Как часть устойчивых функций 2.0 эти абстрактные базовые классы были заменены интерфейсами. Код функции, который использует устойчивые типы напрямую не затрагиваются.

В следующей таблице представлены основные изменения:

| Старый тип | Новый тип |
|----------|----------|
| DurableOrchestrationClientBase | IDurableOrchestrationClient |
| DurableOrchestrationContextBase | IDurableOrchestrationContext |
| DurableActivityContextBase | IDurableActivityContext |

В случае, в которых содержатся виртуальные методы в абстрактный базовый класс, эти виртуальные методы были заменены методы расширения, определенные в `DurableContextExtensions`.

## <a name="entity-functions"></a>Функции сущности

Функции сущности определяют операции для операций чтения и обновления небольшие части состояния, известный как *сущности долговременного*. Как функции оркестратора, функции сущности — это функции с типом специальные триггера *сущности триггер*. В отличие от функции оркестратора сущности функции не имеют все ограничения конкретный код. Функции сущности также управлять состоянием явным образом вместо того чтобы неявно представляющий состояние с помощью потока управления.

### <a name="net-programing-models"></a>Модели программирования .NET

Существует две дополнительные модели программирования для создания устойчивых сущностей. Ниже приведен пример простого *счетчика* сущность, реализованная как стандартная функция. Эта функция определяет три *операций*, `add`, `reset`, и `get`, каждый из который оперируют целочисленное значение состояния, `currentValue`.

```csharp
[FunctionName("Counter")]
public static void Counter([EntityTrigger] IDurableEntityContext ctx)
{
    int currentValue = ctx.GetState<int>();

    switch (ctx.OperationName.ToLowerInvariant())
    {
        case "add":
            int amount = ctx.GetInput<int>();
            currentValue += operand;
            break;
        case "reset":
            currentValue = 0;
            break;
        case "get":
            ctx.Return(currentValue);
            break;
    }

    ctx.SetState(currentValue);
}
```

Эта модель подходит для реализации простого объекта или реализаций, которые имеют ряд динамических операций. Тем не менее есть также основанные на классах модели программирования, который удобен для сущностей, которые являются статическими, но имеют более сложные реализации. Следующий пример представляет собой эквивалент реализацию `Counter` сущности с помощью .NET классы и методы.

```csharp
public class Counter
{
    [JsonProperty("value")]
    public int CurrentValue { get; set; }

    public void Add(int amount) => this.CurrentValue += amount;
    
    public void Reset() => this.CurrentValue = 0;
    
    public int Get() => this.CurrentValue;

    [FunctionName(nameof(Counter))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<Counter>();
}
```

Модель на основе класса подобна модели программирования, популяризированный Майклом [Orleans](https://www.microsoft.com/research/project/orleans-virtual-actors/). В этой модели в виде класса .NET определяется тип сущности. Каждый метод класса — это операция, могут быть вызваны внешнего клиента. В отличие от Орлеане интерфейсы .NET являются необязательными. Предыдущий *счетчика* примере не используется интерфейс, но его можно по-прежнему вызываться другими функциями или с помощью HTTP-вызовов API.

Сущность *экземпляров* осуществляется по уникальному идентификатору, *идентификатор сущности*. Идентификатор сущности — это просто пара строк, однозначно определяющее экземпляр сущности. В ее состав входит:

* **Имя сущности**: имя, которое определяет тип сущности (например, «Счетчик»).
* **Ключ сущности**: строка, уникальным образом идентифицирует объект среди всех других сущностей с тем же именем (например, GUID).

Например *счетчика* функция сущности могут использоваться для хранения оценка в онлайн-игру. Каждый экземпляр игры будет иметь идентификатор уникальная сущность, такие как `@Counter@Game1`, `@Counter@Game2`, и т. д.

### <a name="comparison-with-virtual-actors"></a>Сравнение с помощью виртуальных субъектов

Проектирование устойчивых сущностей сильно зависят от [модель субъектов](https://en.wikipedia.org/wiki/Actor_model). Если вы уже знакомы с субъектами, принципы устойчивых сущности должны быть знакомы вам. В частности, сущности долговременного аналогичны [виртуальных субъектов](https://research.microsoft.com/projects/orleans/) различными способами:

* Устойчивые сущности можно обращаться через *идентификатор сущности*.
* Устойчивых сущности операции последовательно, выполняются по одному за раз, чтобы избежать состояния гонок.
* Сущности долговременного создаются автоматически, когда они вызываются или сигнал.
* При выполнении операции не сущности долговременного автоматически выгружаются из памяти.

Существует ряд важных различий, тем не менее, стоит обратить внимание:

* Определять приоритеты сущности долговременного *устойчивости* над *задержки*и поэтому может не подойти для приложений с помощью строгих требований по задержкам.
* Надежно и в порядке доставки сообщений, отправляемых между сущностями.
* Устойчивые сущности можно использовать в сочетании с согласованиями устойчивых и может служить распределенных блокировок, которые описаны далее в этой статье.
* Шаблоны запросов и ответов в сущностях ограничены оркестрации. Для обмена данными сущности для сущности допускаются только односторонних сообщений (также называется «сигнализация»), как в исходной модели субъекта. Это предотвращает распределенные взаимные блокировки.

### <a name="durable-entity-net-apis"></a>Устойчивые сущности API-интерфейсы .NET

Поддержка Entity включает в себя несколько интерфейсов API. Для одного имеется новый интерфейс API для определения функций сущности, как показано выше, которые определяют, что должно происходить, когда операция вызывается для сущности. Кроме того новые функции для взаимодействия с сущностями были обновлены существующие API для клиентов и оркестрации.

#### <a name="implementing-entity-operations"></a>Реализация операций с сущностью

Эти элементы можно вызывать выполнение операции на сущности в объекте контекста (`IDurableEntityContext` в .NET):

* **Имя_операции**: Возвращает имя операции.
* **GetInput\<TInput >** : получает входные данные для операции.
* **GetState\<TState >** : возвращает текущее состояние сущности.
* **SetState**: обновляет состояние сущности.
* **SignalEntity**: отправляет одностороннее сообщение в сущность.
* **SELF**: Возвращает идентификатор сущности.
* **Вернуть**: возвращает значение клиенту или оркестрации, который вызывает операцию.
* **IsNewlyConstructed**: возвращает `true` если сущность не существует перед операцией.
* **DestructOnExit**: Удаляет сущность после завершения операции.

Ниже перечислены операции меньше ограничений, чем оркестрации.

* Операции можно вызвать внешних операций ввода-вывода, с помощью интерфейсов API синхронным или асинхронным (рекомендуется использовать асинхронные, только их).
* Операции могут быть недетерминированным. Например, можно вызвать `DateTime.UtcNow`, `Guid.NewGuid()` или `new Random()`.

#### <a name="accessing-entities-from-clients"></a>Доступ к сущности из клиентов

Устойчивые сущностей могут быть вызваны из обычных функций через `orchestrationClient` привязки (`IDurableOrchestrationClient` в .NET). Поддерживаются следующие методы:

* **ReadEntityStateAsync\<T >** : считывает состояние сущности.
* **SignalEntityAsync**: отправляет одностороннее сообщение в сущность и ожидает его для постановки в очередь.
* **SignalEntityAsync\<T >** : совпадение с кодом `SignalEntityAsync` , но использует созданный прокси-объект типа `T`.

Предыдущий `SignalEntityAsync` вызов требует указания имени сущности операцию, так как `string` и полезные данные операции в виде `object`. В следующем примере кода приведен пример этого шаблона:

```csharp
EntityId id = // ...
object amount = 5;
context.SignalEntityAsync(id, "Add", amount);
```

Можно также создать объект прокси-сервера для доступа к строго типизированным. Чтобы создать типизированный прокси, тип сущности должен реализовать интерфейс. Например, предположим, что `Counter` реализации сущности, упомянутые ранее `ICounter` интерфейс, определенный следующим образом:

```csharp
public interface ICounter
{
    void Add(int amount);
    void Reset();
    int Get();
}

public class Counter : ICounter
{
    // ...
}
```

Затем можно использовать клиентский код `SignalEntityAsync<T>` и укажите `ICounter` интерфейс в качестве параметра типа, чтобы создать типизированный прокси. В следующем образце кода демонстрируется такое использование строго типизированные прокси-серверы:

```csharp
[FunctionName("UserDeleteAvailable")]
public static async Task AddValueClient(
    [QueueTrigger("my-queue")] string message,
    [OrchestrationClient] IDurableOrchestrationClient client)
{
    int amount = int.Parse(message);
    var target = new EntityId(nameof(Counter), "MyCounter");
    await client.SignalEntityAsync<ICounter>(target, proxy => proxy.Add(amount));
}
```

В предыдущем примере `proxy` параметр — это динамически создаваемый экземпляр `ICounter`, который внутренне преобразует вызов `Add` в эквивалентную (нетипизированного) вызов `SignalEntityAsync`.

> [!NOTE]
> Важно отметить, что `ReadEntityStateAsync` и `SignalEntityAsync` методы `IDurableOrchestrationClient` определять их приоритеты производительности через согласованность. `ReadEntityStateAsync` может возвращать значение устаревших и `SignalEntityAsync` может вернуть значение до завершения операции.

#### <a name="accessing-entities-from-orchestrations"></a>Доступе к сущностям из оркестраций

Согласование можно получить доступ к сущности с помощью `IDurableOrchestrationContext` объекта. Они могут также выбрать одностороннюю связь (Отправить и забыть) и двусторонний обмен данными (запроса и ответа). Соответствующие методы являются:

* **SignalEntity**: отправляет одностороннее сообщение в сущность.
* **CallEntityAsync**: отправляет сообщение в сущность и ожидает ответа, указывающее, что операция завершена.
* **CallEntityAsync\<T >** : отправляет сообщение в сущность и ожидает ответ, содержащий результат типа T.

При использовании двустороннего обмена данными, все исключения, возникшие во время выполнения операции также передаются обратно вызывающей orchestration и создается повторно. Напротив при использовании выстрелил и забыл, исключения не наблюдаются.

Для доступа к строго типизированным функции оркестрации могут создавать прокси-серверы, на основе интерфейса. `CreateEntityProxy` Метод расширения может использоваться для этой цели:

```csharp
public interface IAsyncCounter
{
    Task AddAsync(int amount);
    Task ResetAsync();
    Task<int> GetAsync();
}

[FunctionName("CounterOrchestration)]
public static async Task Run(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    // ...
    IAsyncCounter proxy = context.CreateEntityProxy<IAsyncCounter>("MyCounter");
    await proxy.AddAsync(5);
    int newValue = await proxy.GetAsync();
    // ...
}
```

В предыдущем примере, объект «счетчик» предполагается, что существует, который реализует `IAsyncCounter` интерфейс. Оркестрация затем была возможность использовать `IAsyncCounter` определение для создания прокси-типа для синхронного взаимодействия с объектом типа.

### <a name="locking-entities-from-orchestrations"></a>Блокировки сущностей из оркестраций

Согласование можно заблокировать сущностей. Эта возможность предоставляет простой способ для предотвращения нежелательных состояния гонки с помощью *критических секций*.

Контекст объекта предоставляет следующие методы:

* **LockAsync**: получает блокировки на одной или нескольких сущностей.
* **Блокирована**: возвращает значение true, если в настоящее время в критической секции, значение false в противном случае.

Критический раздел прекращается и все блокировки освобождаются, при завершении согласования. В .NET `LockAsync` возвращает `IDisposable` заканчивается критической секции при удалении, который может использоваться вместе с `using` предложение для получения представления синтаксические критического раздела.

Например рассмотрим оркестрации, которые необходимо протестировать доступность два игрока и затем назначить их обоих в игре. Эта задача может быть реализована с помощью критическую секцию следующим образом:

```csharp
[FunctionName("Orchestrator")]
public static async Task RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext ctx)
{
    EntityId player1 = /* ... */;
    EntityId player2 = /* ... */;

    using (await ctx.LockAsync(player1, player2))
    {
        bool available1 = await ctx.CallEntityAsync<bool>(player1, "is-available");
        bool available2 = await ctx.CallEntityAsync<bool>(player2, "is-available");

        if (available1 && available2)
        {
            Guid gameId = ctx.NewGuid();

            await ctx.CallEntityAsync(player1, "assign-game", gameId);
            await ctx.CallEntityAsync(player2, "assign-game", gameId);
        }
    }
}
```

В критический раздел обе эти сущности проигрывателя будут заблокированы, это означает, что они не выполняются любые операции, отличные от тех, которые вызываются из критического раздела). Это предотвращает с выделением конфликтующих операций, таких как проигрыватели, назначаемый другой off игру или подписи.

Мы накладывают ряд ограничений на том, как критические секции могут использоваться. Эти ограничения служат для предотвращения взаимоблокировок и повторный вход.

* Критические секции не могут быть вложенными.
* Критические разделы не удается создать suborchestrations.
* Критические разделы можно вызвать только те сущности, которые они уже заблокировал.
* Критические секции нельзя вызывать ту же сущность, с помощью нескольких параллельных вызовов.
* Критические разделы могут послужить только те сущности, которые не заблокировали.

## <a name="alternate-storage-providers"></a>Поставщики альтернативные хранилища

Платформа устойчивых задач поддерживает несколько поставщиков хранилища, включая [хранилища Azure](https://github.com/Azure/durabletask/tree/master/src/DurableTask.AzureStorage), [служебной шины Azure](https://github.com/Azure/durabletask/tree/master/src/DurableTask.ServiceBus), [эмулятора в памяти](https://github.com/Azure/durabletask/tree/master/src/DurableTask.Emulator)и экспериментальных [Redis](https://github.com/Azure/durabletask/tree/redis/src/DurableTask.Redis) поставщика. Однако до сих пор расширения устойчивых задач для функций Azure поддерживается только поставщик хранилища Azure. Начиная с версии 2.0 устойчивых функций, поддержка поставщиков альтернативные хранилища был добавлен, начиная с поставщиком Redis.

> [!NOTE]
> Устойчивых функций 2.0 поддерживает только .NET Standard 2.0-совместимых поставщиков. Во время написания этой статьи поставщика служебной шины Azure не поддерживает .NET Standard 2.0 и поэтому не доступны в качестве альтернативного хранилища поставщика.

### <a name="emulator"></a>Эмулятор

[DurableTask.Emulator](https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Emulator/) поставщик является локальной памяти, поставщик непостоянного хранилища, подходящий для локального тестирования сценариев. Его можно настроить с помощью следующих минимальным **host.json** схемы:

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "emulator": { }
      }
    }
  }
}
```

### <a name="redis-experimental"></a>Redis (экспериментальная функция)

[DurableTask.Redis](https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Redis/) поставщик сохраняет все состояние оркестрации на настроенном кластере Redis.

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "redis": {
          "connectionStringName": <string>,
        }
      }
    }
  }
}
```

`connectionStringName` Должен ссылаться на имя приложения параметр или переменную среды. Этого приложения параметр или переменную среды должен содержать значение строки подключения Redis в виде *сервер: порт*. Например `localhost:6379` для подключения к локальному кластеру Redis.

> [!NOTE]
> Поставщик Redis сейчас экспериментальных и поддерживает только функции приложения, работающие на одном узле. Поставщик Redis будет когда-нибудь сделать общедоступным, что оно будет удалено в будущих версиях не гарантируется.
