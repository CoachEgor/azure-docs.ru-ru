---
title: Функции предварительной версии Устойчивые функции — функции Azure
description: Дополнительные сведения о функциях предварительной версии для Устойчивые функции.
services: functions
author: cgillum
manager: jeconnoc
keywords: ''
ms.service: azure-functions
ms.topic: article
ms.date: 07/08/2019
ms.author: azfuncdf
ms.openlocfilehash: a64276de3e535c8b7724927ce2e257542cc9e01a
ms.sourcegitcommit: 19a821fc95da830437873d9d8e6626ffc5e0e9d6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/29/2019
ms.locfileid: "70164409"
---
# <a name="durable-functions-20-preview-azure-functions"></a>Предварительная версия Устойчивые функции 2,0 (функции Azure)

*Устойчивые функции* являются расширением [Функций Azure](../functions-overview.md) и [веб-заданий Azure](../../app-service/web-sites-create-web-jobs.md), которое позволяет писать функции с отслеживанием состояния в безсерверной среде. Расширение автоматически управляет состоянием, создает контрольные точки и перезагружается. Если вы еще не знакомы с Устойчивые функции, см. [обзорную документацию](durable-functions-overview.md).

Устойчивые функции 1. x — это общедоступная (публичная) функция функций Azure, но также содержит несколько подкомпонентов, которые в настоящее время доступны в общедоступной предварительной версии. В этой статье описываются недавно выпущенные функции предварительной версии и приводятся подробные сведения о том, как они работают и как их можно приступить к использованию.

> [!NOTE]
> Эти функции предварительной версии являются частью выпуска Устойчивые функции 2,0, который в настоящее время является предварительным выпуском с несколькими критическими изменениями. Сборки пакета устойчивых расширений для функций Azure можно найти в nuget.org с версиями в формате **2.0.0-бетакс**. Эти сборки не предназначены для рабочих нагрузок, а последующие выпуски могут содержать дополнительные критические изменения.

## <a name="breaking-changes"></a>Критические изменения

В Устойчивые функции 2,0 введено несколько критических изменений. Существующие приложения не должны быть совместимы с Устойчивые функции 2,0 без изменений кода. В этом разделе перечислены некоторые из этих изменений.

### <a name="hostjson-schema"></a>Схема Host. JSON

В следующем фрагменте кода показана новая схема для Host. JSON. Основные изменения, о которых следует помнить, — это новые подразделы:

* `"storageProvider"`(и `"azureStorage"` подраздела) для конфигурации, относящейся к хранилищу
* `"tracking"`для конфигурации отслеживания и ведения журнала
* `"notifications"`(и `"eventGrid"` подраздела) для конфигурации уведомлений сетки событий

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "azureStorage": {
          "connectionStringName": <string>,
          "controlQueueBatchSize": <int?>,
          "partitionCount": <int?>,
          "controlQueueVisibilityTimeout": <hh:mm:ss?>,
          "workItemQueueVisibilityTimeout": <hh:mm:ss?>,
          "trackingStoreConnectionStringName": <string?>,
          "trackingStoreNamePrefix": <string?>,
          "maxQueuePollingInterval": <hh:mm:ss?>
        }
      },
      "tracking": {
        "traceInputsAndOutputs": <bool?>,
        "traceReplayEvents": <bool?>,
      },
      "notifications": {
        "eventGrid": {
          "topicEndpoint": <string?>,
          "keySettingName": <string?>,
          "publishRetryCount": <string?>,
          "publishRetryInterval": <hh:mm:ss?>,
          "publishRetryHttpStatus": <int[]?>,
          "publishEventTypes": <string[]?>,
        }
      },
      "maxConcurrentActivityFunctions": <int?>,
      "maxConcurrentOrchestratorFunctions": <int?>,
      "extendedSessionsEnabled": <bool?>,
      "extendedSessionIdleTimeoutInSeconds": <int?>,
      "customLifeCycleNotificationHelperType": <string?>
  }
}
```

Так как устойчивые функции 2,0 остается неустойчивой, в `durableTask` раздел Host. JSON будут внесены дополнительные изменения. Дополнительные сведения об этих изменениях см. в [этой ошибке GitHub](https://github.com/Azure/azure-functions-durable-extension/issues/641).

### <a name="public-interface-changes"></a>Изменения в открытом интерфейсе

Различные объекты "Context", поддерживаемые Устойчивые функции, имели абстрактные базовые классы, предназначенные для использования при модульном тестировании. В рамках Устойчивые функции 2,0 эти абстрактные базовые классы были заменены интерфейсами. Код функции, непосредственно использующий конкретные типы, не затрагивается.

В следующей таблице представлены основные изменения.

| Старый тип | Новый тип |
|----------|----------|
| DurableOrchestrationClientBase | идураблеорчестратионклиент |
| дураблеорчестратионконтекстбасе | идураблеорчестратионконтекст |
| дураблеактивитиконтекстбасе | идураблеактивитиконтекст |

В случае, когда абстрактный базовый класс содержал виртуальные методы, эти виртуальные методы были заменены методами расширения, определенными в `DurableContextExtensions`.

## <a name="entity-functions"></a>Функции сущностей

Функции сущностей определяют операции чтения и обновления мелких частей состояния, известных как *устойчивые сущности*. Как и функции Orchestrator, функции сущностей — это функции с особым типом триггера, *триггером сущности*. В отличие от функций Orchestrator, функции сущностей не имеют конкретных ограничений кода. Функции сущностей также управляют состоянием явным образом, а не неявно представляют состояние с помощью потока управления.

### <a name="net-programing-models"></a>Модели программирования .NET

Существует две необязательные модели программирования для создания устойчивых сущностей. Следующий код является примером простой сущности счетчика, реализованной в виде стандартной функции. Эта функция определяет три *операции*, `add` `reset`, и `get`, `currentValue`каждая из которых работает с целочисленным значением состояния.

```csharp
[FunctionName("Counter")]
public static void Counter([EntityTrigger] IDurableEntityContext ctx)
{
    int currentValue = ctx.GetState<int>();

    switch (ctx.OperationName.ToLowerInvariant())
    {
        case "add":
            int amount = ctx.GetInput<int>();
            currentValue += operand;
            break;
        case "reset":
            currentValue = 0;
            break;
        case "get":
            ctx.Return(currentValue);
            break;
    }

    ctx.SetState(currentValue);
}
```

Эта модель лучше подходит для простых реализаций сущностей или реализаций, имеющих динамический набор операций. Однако существует также модель программирования на основе классов, которая полезна для сущностей, которые являются статическими, но имеют более сложные реализации. Следующий пример представляет собой эквивалентную реализацию `Counter` сущности с помощью классов и методов .NET.

```csharp
public class Counter
{
    [JsonProperty("value")]
    public int CurrentValue { get; set; }

    public void Add(int amount) => this.CurrentValue += amount;
    
    public void Reset() => this.CurrentValue = 0;
    
    public int Get() => this.CurrentValue;

    [FunctionName(nameof(Counter))]
    public static Task Run([EntityTrigger] IDurableEntityContext ctx)
        => ctx.DispatchAsync<Counter>();
}
```

Модель на основе классов аналогична модели программирования, популярной [Orleans](https://www.microsoft.com/research/project/orleans-virtual-actors/). В этой модели тип сущности определяется как класс .NET. Каждый метод класса является операцией, которая может быть вызвана внешним клиентом. Однако в отличие от Orleans интерфейсы .NET являются необязательными. В предыдущем примере счетчика не использовался интерфейс, но его все равно можно вызвать через другие функции или через вызовы API HTTP.

Доступ к экземплярам сущностей осуществляется через уникальный идентификатор, *идентификатор сущности*. Идентификатор сущности — это просто пара строк, которая уникально идентифицирует экземпляр сущности. В ее состав входит:

* **Имя сущности**: имя, идентифицирующее тип сущности (например, "Counter").
* **Ключ сущности**— строка, однозначно идентифицирующая сущность между всеми другими сущностями с тем же именем (например, GUID).

Например, функция- сущность счетчика может использоваться для отслеживания оценки в интерактивной игре. Каждый экземпляр игры будет иметь уникальный идентификатор сущности, например `@Counter@Game1`, `@Counter@Game2`и т. д.

### <a name="comparison-with-virtual-actors"></a>Сравнение с виртуальными субъектами

[Модель субъектов](https://en.wikipedia.org/wiki/Actor_model)сильно влияет на проектирование устойчивых сущностей. Если вы уже знакомы с субъектами, вы должны быть знакомы с концепциями, лежащими в основе устойчивых сущностей. В частности, устойчивые сущности похожи на [Виртуальные субъекты](https://research.microsoft.com/projects/orleans/) различными способами:

* Устойчивые сущности могут быть устранены с помощью *идентификатора сущности*.
* Операции с устойчивыми сущностями выполняются последовательно, по одному за раз, чтобы предотвратить конкуренцию.
* Надежные сущности создаются автоматически при их вызове или получении сигнала.
* Если операции не выполняются, устойчивые сущности выгружаются из памяти без вывода сообщений.

Однако есть некоторые важные отличия, которые стоит отметить:

* Устойчивые сущности наделяют *устойчивость к устойчивости* с *задержкой*и, таким образом, могут не подходить для приложений с требованиями к длительной задержке.
* Сообщения, передаваемые между сущностями, надежно доставляются и по порядку.
* Устойчивые сущности можно использовать в сочетании с устойчивыми оркестрациими и могут служить распределенными блокировками, которые описаны далее в этой статье.
* Шаблоны запросов и ответов в сущностях ограничены согласованиями. Для обмена данными между сущностями разрешены только односторонние сообщения (также называемые "сигнализация"), как в исходной модели субъектов. Такое поведение предотвращает распределенные взаимоблокировки.

### <a name="durable-entity-net-apis"></a>Надежные сущности .NET API

Поддержка сущностей включает несколько интерфейсов API. Для одного существует новый API для определения функций сущности, как показано выше, который указывает, что должно происходить при вызове операции для сущности. Кроме того, существующие API для клиентов и оркестрации были обновлены с учетом новых функциональных возможностей взаимодействия с сущностями.

#### <a name="implementing-entity-operations"></a>Реализация операций с сущностями

Выполнение операции над сущностью может вызывать эти члены в объекте контекста (`IDurableEntityContext` в .NET):

* **Имя_операции**: Возвращает имя операции.
* **Тинпут ввода\<>** : получает входные данные для операции.
* **TState о\<состоянии >** : Возвращает текущее состояние сущности.
* **SetState**: обновляет состояние сущности.
* **Сигналентити**: отправляет одностороннее сообщение в сущность.
* **Self**: Возвращает идентификатор сущности.
* **Return**: Возвращает значение клиенту или оркестрации, которое вызвало операцию.
* **Исневликонструктед**: возвращает `true` , если сущность не существовала перед операцией.
* **Деструктонексит**: Удаляет сущность после завершения операции.

Операции менее ограничены по сравнению с согласованиями:

* Операции могут вызывать внешние операции ввода-вывода с использованием синхронных или асинхронных API-интерфейсов (рекомендуется использовать только асинхронные операторы).
* Операции могут быть недетерминированными. Например, можно спокойно вызвать метод `DateTime.UtcNow` `Guid.NewGuid()` или `new Random()`.

#### <a name="accessing-entities-from-clients"></a>Доступ к сущностям из клиентов

Устойчивые сущности можно вызывать из обычных функций через `orchestrationClient` привязку (`IDurableOrchestrationClient` в .NET). Поддерживаются следующие методы:

* **Реадентитистатеасинк\<T >** : считывает состояние сущности.
* **Сигналентитясинк**: отправляет одностороннее сообщение в сущность и ожидает его постановки в очередь.
* **Сигналентитясинк\<T >** : то же `SignalEntityAsync` , что и, но использует созданный прокси `T`-объект типа.

Для предыдущего `SignalEntityAsync` вызова необходимо указать имя операции сущности в `string` качестве и полезные данные операции как `object`. Ниже приведен пример кода для этого шаблона.

```csharp
EntityId id = // ...
object amount = 5;
context.SignalEntityAsync(id, "Add", amount);
```

Также можно создать прокси-объект для строго типизированного доступа. Для создания строго типизированного прокси-сервера тип сущности должен реализовать интерфейс. Например, предположим `Counter` , что упомянутая ранее сущность `ICounter` реализовала интерфейс, определенную следующим образом:

```csharp
public interface ICounter
{
    void Add(int amount);
    void Reset();
    int Get();
}

public class Counter : ICounter
{
    // ...
}
```

Затем клиентский код может `SignalEntityAsync<T>` использовать и `ICounter` указать интерфейс в качестве параметра типа для создания строго типизированного прокси. Использование типобезопасных прокси-серверов показано в следующем примере кода:

```csharp
[FunctionName("UserDeleteAvailable")]
public static async Task AddValueClient(
    [QueueTrigger("my-queue")] string message,
    [OrchestrationClient] IDurableOrchestrationClient client)
{
    int amount = int.Parse(message);
    var target = new EntityId(nameof(Counter), "MyCounter");
    await client.SignalEntityAsync<ICounter>(target, proxy => proxy.Add(amount));
}
```

В предыдущем примере `proxy` параметр является динамически создаваемым `ICounter`экземпляром, который внутренне `Add` преобразует вызов в `SignalEntityAsync`эквивалентный (нетипизированный) вызов.

Параметр Type для `SignalEntityAsync<T>` имеет следующие ограничения.

* Параметр типа должен быть интерфейсом.
* В интерфейсе могут быть определены только методы. Свойства не поддерживаются.
* В каждом методе должен быть определен один или несколько параметров.
* Каждый метод должен возвращать `void`значение `Task`, или `Task<T>` , `T` где является типом, сериализуемым в формат JSON.
* Интерфейс должен реализовываться только одним типом в сборке интерфейса.

В большинстве случаев интерфейсы, которые не соответствуют этим требованиям, приведут к исключению среды выполнения.

> [!NOTE]
> Важно отметить, что `ReadEntityStateAsync` методы и `SignalEntityAsync` для `IDurableOrchestrationClient` определения приоритетности производительности по сравнению с согласованностью. `ReadEntityStateAsync`может возвращать устаревшее значение и `SignalEntityAsync` может возвращать до завершения операции.

#### <a name="accessing-entities-from-orchestrations"></a>Доступ к сущностям из оркестрации

Оркестрации могут обращаться к сущностям `IDurableOrchestrationContext` с помощью объекта. Они могут выбирать между односторонней связью (пожара и забыть) и двусторонним обменом данными (запрос и ответ). Соответствующие методы:

* **Сигналентити**: отправляет одностороннее сообщение в сущность.
* **Каллентитясинк**: отправляет сообщение в сущность и ожидает ответа, указывающего на завершение операции.
* **Каллентитясинк\<T >** : отправляет сообщение в сущность и ожидает ответа, содержащего результат типа T.

При использовании двусторонней связи все исключения, возникающие во время выполнения операции, также передаются обратно в вызывающий механизм и вызываются повторно. В противоположность этому при использовании пожара и-забыть исключения не наблюдаются.

Для строго типизированного доступа функции оркестрации могут создавать прокси-серверы на основе интерфейса. Для этой цели можно использовать метод расширения:`CreateEntityProxy`

```csharp
public interface IAsyncCounter
{
    Task AddAsync(int amount);
    Task ResetAsync();
    Task<int> GetAsync();
}

[FunctionName("CounterOrchestration")]
public static async Task Run(
    [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    // ...
    IAsyncCounter proxy = context.CreateEntityProxy<IAsyncCounter>("MyCounter");
    await proxy.AddAsync(5);
    int newValue = await proxy.GetAsync();
    // ...
}
```

В предыдущем примере предполагается существование сущности "Counter", которая реализует `IAsyncCounter` интерфейс. В результате оркестрации удалось использовать `IAsyncCounter` определение типа для создания типа прокси для синхронного взаимодействия с сущностью.

### <a name="locking-entities-from-orchestrations"></a>Блокировка сущностей из оркестрации

Оркестрации могут блокировать сущности. Эта возможность обеспечивает простой способ предотвращения нежелательных состязаний с помощью *критических разделов*.

Объект context предоставляет следующие методы.

* **Локкасинк**: получает блокировки для одной или нескольких сущностей.
* **Блокировка**: Возвращает значение true, если в данный момент находится в критическом разделе, и false в противном случае.

Критическая секция заканчивается, и все блокировки освобождаются, когда завершается оркестрации. В .NET `LockAsync` `IDisposable` возвращает, который завершает критическую секцию при удалении, который можно использовать вместе с `using` предложением для получения синтаксического представления критического раздела.

Например, рассмотрим согласование, которое должно проверить, доступны ли два игрока, и назначить их для игры. Эту задачу можно реализовать с помощью критической секции следующим образом:

```csharp
[FunctionName("Orchestrator")]
public static async Task RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext ctx)
{
    EntityId player1 = /* ... */;
    EntityId player2 = /* ... */;

    using (await ctx.LockAsync(player1, player2))
    {
        bool available1 = await ctx.CallEntityAsync<bool>(player1, "is-available");
        bool available2 = await ctx.CallEntityAsync<bool>(player2, "is-available");

        if (available1 && available2)
        {
            Guid gameId = ctx.NewGuid();

            await ctx.CallEntityAsync(player1, "assign-game", gameId);
            await ctx.CallEntityAsync(player2, "assign-game", gameId);
        }
    }
}
```

В критической секции обе сущности проигрывателя блокируются, что означает, что они не выполняют никаких операций, кроме тех, которые вызываются из критической секции. Такое поведение предотвращает состязание за конфликтующие операции, например проигрыватели, назначенные другой игре, или выход из системы.

Мы накладывают несколько ограничений на то, как можно использовать критические разделы. Эти ограничения служат для предотвращения взаимоблокировок и повторного входа.

* Критические разделы не могут быть вложенными.
* Критические разделы не могут создавать подсогласования.
* Критические разделы могут вызывать только те сущности, которые они заблокировали.
* Критические секции не могут вызывать одну и ту же сущность с помощью нескольких параллельных вызовов.
* Критические разделы могут сообщать только тем сущностям, которые не заблокированы.

## <a name="alternate-storage-providers"></a>Альтернативные поставщики хранилища

В настоящее время платформа устойчивых задач поддерживает несколько поставщиков хранилища, включая службу [хранилища Azure](https://github.com/Azure/durabletask/tree/master/src/DurableTask.AzureStorage), [служебную шину Azure](https://github.com/Azure/durabletask/tree/master/src/DurableTask.ServiceBus), [эмулятор в памяти](https://github.com/Azure/durabletask/tree/master/src/DurableTask.Emulator)и экспериментальный поставщик [Redis](https://github.com/Azure/durabletask/tree/redis/src/DurableTask.Redis) . Однако до настоящего момента расширение устойчивых задач для функций Azure поддерживало только поставщик хранилища Azure. Начиная с Устойчивые функции 2,0, добавляется поддержка альтернативных поставщиков хранилища, начиная с поставщика Redis.

> [!NOTE]
> Устойчивые функции 2,0 поддерживает только .NET Standard 2,0-совместимые поставщики. На момент написания этой статьи поставщик служебной шины Azure не поддерживает .NET Standard 2,0 и поэтому недоступен в качестве альтернативного поставщика хранилища.

### <a name="emulator"></a>эмулятор

Поставщик [DurableTask. Emulator](https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Emulator/) — это локальная память, неустойчивый поставщик хранилища, подходящий для локальных сценариев тестирования. Ее можно настроить с помощью следующей минимальной схемы **Host. JSON** :

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "emulator": { "enabled": true }
      }
    }
  }
}
```

### <a name="redis-experimental"></a>Redis (экспериментальная версия)

Поставщик [DurableTask. Redis](https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Redis/) сохраняет все состояния оркестрации в настроенном кластере Redis.

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "redis": {
          "connectionStringName": <string>,
        }
      }
    }
  }
}
```

Объект `connectionStringName` должен ссылаться на имя параметра приложения или переменной среды. Этот параметр приложения или переменная среды должны содержать значение строки подключения Redis в формате *"сервер: порт*". Например, `localhost:6379` для подключения к локальному кластеру Redis.

> [!NOTE]
> Поставщик Redis в настоящее время экспериментальен и поддерживает только приложения-функции, выполняющиеся на одном узле. Не гарантируется, что поставщик Redis становится общедоступным и может быть удален в будущем выпуске.
