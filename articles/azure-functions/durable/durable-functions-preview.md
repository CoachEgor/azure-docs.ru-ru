---
title: Устойчивые функции предварительных версиях функций - функций Azure
description: Сведения о функциях предварительной версии для устойчивых функций.
services: functions
author: cgillum
manager: jeconnoc
keywords: ''
ms.service: functions
ms.devlang: multiple
ms.topic: article
ms.date: 04/23/2019
ms.author: azfuncdf
ms.openlocfilehash: 8ceb84ab9e9c41ff6a9cbde62571fb12ae67d790
ms.sourcegitcommit: 1fbc75b822d7fe8d766329f443506b830e101a5e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/14/2019
ms.locfileid: "65596081"
---
# <a name="durable-functions-20-preview-azure-functions"></a>Устойчивый Предварительный просмотр функций 2.0 (функции Azure)

*Устойчивые функции* являются расширением [Функций Azure](../functions-overview.md) и [веб-заданий Azure](../../app-service/web-sites-create-web-jobs.md), которое позволяет писать функции с отслеживанием состояния в безсерверной среде. Расширение автоматически управляет состоянием, создает контрольные точки и перезагружается. Если вы не знакомы с устойчивыми функциями, см. в разделе [обзорной документацией](durable-functions-overview.md).

Устойчивые функции — это функция (общедоступная) общедоступной версии функций Azure, но также содержит несколько вложенных компонентов, которые в настоящее время находятся в общедоступной предварительной версии. В этой статье описываются новые предварительные версии компонентов и попадают в сведения о том, как они работают и как можно начать использовать их.

> [!NOTE]
> Эти функции предварительной версии являются частью выпуска устойчивых функций 2.0, которая в данный момент **альфа-версии выпуска** с несколько критических изменений. Azure функции устойчивых создает пакет расширения можно найти на сайте nuget.org с версиями в виде **2.0.0-alpha**. Эти сборки не подходят для любого рабочих нагрузок и последующих выпусках может содержать дополнительные критические изменения.

## <a name="breaking-changes"></a>Критические изменения

В устойчивых функций 2.0 представлены несколько критических изменений. Существующие приложения не должны быть совместимы с устойчивых функций 2.0 без изменения кода. В этом разделе перечислены некоторые изменения:

### <a name="dropping-net-framework-support"></a>Удаление поддержки .NET Framework

Для устойчивых функций 2.0 была удалена поддержка .NET Framework (и, следовательно, функции 1.0). Основная причина заключается в том, чтобы участники отличных от Windows, позволяющие легко создавать и тестировать изменения, которые они вносят устойчивых функций из платформах Linux и macOS. Вторичный причина — помочь призываем разработчиков для перемещения до последней версии среды выполнения функций Azure.

### <a name="hostjson-schema"></a>Схемы Host.JSON

В следующем фрагменте показано host.json новую схему. Основное изменение, которые следует учитывать, является новый `"storageProvider"` разделе и `"azureStorage"` разделе под ним. Это изменение было сделано для поддержки [альтернативный поставщиков хранилища](durable-functions-preview.md#alternate-storage-providers).

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "azureStorage": {
          "connectionStringName": <string>,
          "controlQueueBatchSize": <int?>,
          "partitionCount": <int?>,
          "controlQueueVisibilityTimeout": <hh:mm:ss?>,
          "workItemQueueVisibilityTimeout": <hh:mm:ss?>,
          "trackingStoreConnectionStringName": <string?>,
          "trackingStoreNamePrefix": <string?>,
          "maxQueuePollingInterval": <hh:mm:ss?>
        }
      },
      "maxConcurrentActivityFunctions": <int?>,
      "maxConcurrentOrchestratorFunctions": <int?>,
      "traceInputAndOutputs": <bool?>,
      "eventGridTopicEndpoint": <string?>,
      "eventGridKeySettingName": <string?>,
      "eventGridPublishRetryCount": <string?>,
      "eventGridPublishRetryInterval": <hh:mm:ss?>,
      "eventGridPublishRetryHttpStatus": <int[]?>,
      "eventgridPublishEventTypes": <string[]?>,
      "customLifeCycleNotificationHelperType"
      "extendedSessionsEnabled": <bool?>,
      "extendedSessionIdleTimeoutInSeconds": <int?>,
      "logReplayEvents": <bool?>
  }
}
```

Так как устойчивых функций 2.0 продолжает стабилизация, будут представлены дополнительные изменения `durableTask` разделе host.json. Дополнительные сведения об этих изменениях см. в разделе [проблема GitHub](https://github.com/Azure/azure-functions-durable-extension/issues/641).

### <a name="public-interface-changes"></a>Открытый интерфейс изменения

Различные объекты «контекст», поддерживаемым устойчивыми функциями было абстрактных базовых классов, которые предназначены для использования в модульном тестировании. Как часть устойчивых функций 2.0 эти абстрактные базовые классы были заменены интерфейсами. Код функции, который использует устойчивые типы напрямую не затрагиваются.

В следующей таблице представлены основные изменения:

| Старый тип | Новый тип |
|----------|----------|
| DurableOrchestrationClientBase | IDurableOrchestrationClient |
| DurableOrchestrationContextBase | IDurableOrchestrationContext |
| DurableActivityContextBase | IDurableActivityContext |

В случае, в которых содержатся виртуальные методы в абстрактный базовый класс, эти виртуальные методы были заменены методы расширения, определенные в `DurableContextExtensions`.

## <a name="entity-functions"></a>Функции сущности

Функции сущности определяют операции для операций чтения и обновления небольшие части состояния, известный как *сущности долговременного*. Как функции оркестратора, функции сущности — это функции с типом специальные триггера *сущности триггер*. В отличие от функции оркестратора сущности функции не имеют все ограничения конкретный код. Функции сущности также управлять состоянием явным образом вместо того чтобы неявно представляющий состояние с помощью потока управления.

Ниже приведен пример простого объекта функции, которая определяет *счетчика* сущности. Функция задает три операции `add`, `subtract`, и `reset`, каждая из для обновления целочисленное значение, `currentValue`.

```csharp
[FunctionName("Counter")]
public static async Task Counter(
    [EntityTrigger] IDurableEntityContext ctx)
{
    int currentValue = ctx.GetState<int>();
    int operand = ctx.GetInput<int>();

    switch (ctx.OperationName)
    {
        case "add":
            currentValue += operand;
            break;
        case "subtract":
            currentValue -= operand;
            break;
        case "reset":
            await SendResetNotificationAsync();
            currentValue = 0;
            break;
    }

    ctx.SetState(currentValue);
}
```

Сущность *экземпляров* осуществляется по уникальному идентификатору, *идентификатор сущности*. Идентификатор сущности — это просто пара строк, однозначно определяющее экземпляр сущности. В ее состав входит:

1. **имя сущности**: имя, которое определяет тип сущности (например, «Счетчик»)
2. **ключ сущности**: строка, уникальным образом идентифицирует объект среди всех других сущностей с тем же именем (например, GUID)

Например *счетчика* функция сущности могут использоваться для хранения оценка в онлайн-игру. Каждый экземпляр игры будет иметь идентификатор уникальная сущность, такие как `@Counter@Game1`, `@Counter@Game2`, и т. д.

### <a name="comparison-with-virtual-actors"></a>Сравнение с помощью виртуальных субъектов

Проектирование устойчивых сущностей сильно зависят от [модель субъектов](https://en.wikipedia.org/wiki/Actor_model). Если вы уже знакомы с субъектами, принципы устойчивых сущности должны быть знакомы вам. В частности, сущности долговременного аналогичны [виртуальных субъектов](https://research.microsoft.com/en-us/projects/orleans/) различными способами:

* Устойчивые сущности можно обращаться через *идентификатор сущности*.
* Устойчивых сущности операции последовательно, выполняются по одному за раз, чтобы избежать состояния гонок.
* Сущности долговременного создаются автоматически, когда они вызываются или сигнал.
* При выполнении операции не сущности долговременного автоматически выгружаются из памяти.

Существует ряд важных различий, тем не менее, стоит обратить внимание:

* Устойчивые сущностями моделируются в виде чистых функций. Такой подход отличается от большинство инфраструктур объектно ориентированного, которые представляют субъекты с использованием языковой поддержки для классов, свойств и методов.
* Определять приоритеты сущности долговременного *устойчивости* над *задержки*и поэтому может не подойти для приложений с помощью строгих требований по задержкам.
* Надежно и в порядке доставки сообщений, отправляемых между сущностями.
* Устойчивые сущности можно использовать в сочетании с согласованиями устойчивых и может служить распределенных блокировок, которые описаны далее в этой статье.
* Шаблоны запросов и ответов в сущностях ограничены оркестрации. Для обмена данными сущности для сущности допускаются только односторонних сообщений (также называется «сигнализация»), как в исходной модели субъекта. Это предотвращает распределенные взаимные блокировки.

### <a name="durable-entity-apis"></a>API-интерфейсы устойчивых сущности

Поддержка Entity включает в себя несколько интерфейсов API. Для одного имеется новый интерфейс API для определения функций сущности, как показано выше, которые определяют, что должно происходить, когда операция вызывается для сущности. Кроме того новые функции для взаимодействия с сущностями были обновлены существующие API для клиентов и оркестрации.

### <a name="implementing-entity-operations"></a>Реализация операций с сущностью

Эти элементы можно вызывать выполнение операции на сущности в объекте контекста (`IDurableEntityContext` в .NET):

* **Имя_операции**: Возвращает имя операции.
* **GetInput\<T >**: получает входные данные для операции.
* **GetState\<T >**: возвращает текущее состояние сущности.
* **SetState**: обновляет состояние сущности.
* **SignalEntity**: отправляет одностороннее сообщение в сущность.
* **SELF**: Возвращает идентификатор сущности.
* **Вернуть**: возвращает значение клиенту или оркестрации, который вызывает операцию.
* **IsNewlyConstructed**: возвращает `true` если сущность не существует перед операцией.
* **DestructOnExit**: Удаляет сущность после завершения операции.

Ниже перечислены операции меньше ограничений, чем оркестрации.

* Операции можно вызвать внешних операций ввода-вывода, с помощью интерфейсов API синхронным или асинхронным (рекомендуется использовать асинхронные, только их).
* Операции могут быть недетерминированным. Например, можно вызвать `DateTime.UtcNow`, `Guid.NewGuid()` или `new Random()`.

### <a name="accessing-entities-from-clients"></a>Доступ к сущности из клиентов

Устойчивые сущностей могут быть вызваны из обычных функций через `orchestrationClient` привязки (`IDurableOrchestrationClient` в .NET). Поддерживаются следующие методы:

* **ReadEntityStateAsync\<T >**: считывает состояние сущности.
* **SignalEntityAsync**: отправляет одностороннее сообщение в сущность и ожидает его для постановки в очередь.

Эти методы определения приоритетов производительности через согласованность: `ReadEntityStateAsync` может возвращать значение устаревших и `SignalEntityAsync` может вернуть значение до завершения операции. Напротив вызов сущностей из согласований (как описано далее) является строго согласованной.

### <a name="accessing-entities-from-orchestrations"></a>Доступе к сущностям из оркестраций

Оркестрации можно получить доступ к сущности с помощью объекта контекста. Они могут также выбрать одностороннюю связь (Отправить и забыть) и двусторонний обмен данными (запроса и ответа). Методы, соответствующие

* **SignalEntity**: отправляет одностороннее сообщение в сущность.
* **CallEntityAsync**: отправляет сообщение в сущность и ожидает ответа, указывающее, что операция завершена.
* **CallEntityAsync\<T >**: отправляет сообщение в сущность и ожидает ответ, содержащий результат типа T.

При использовании двустороннего обмена данными, все исключения, возникшие во время выполнения операции также передаются обратно вызывающей orchestration и создается повторно. Напротив при использовании выстрелил и забыл, исключения не наблюдаются.

### <a name="locking-entities-from-orchestrations"></a>Блокировки сущностей из оркестраций

Согласование можно заблокировать сущностей. Эта возможность предоставляет простой способ для предотвращения нежелательных состояния гонки с помощью *критических секций*.

Контекст объекта предоставляет следующие методы:

* **LockAsync**: получает блокировки на одной или нескольких сущностей.
* **Блокирована**: возвращает значение true, если в настоящее время в критической секции, значение false в противном случае.

Критический раздел прекращается и все блокировки освобождаются, при завершении согласования. В .NET `LockAsync` возвращает `IDisposable` заканчивается критической секции при удалении, который может использоваться вместе с `using` предложение для получения представления синтаксические критического раздела.

Например рассмотрим оркестрации, которые необходимо протестировать доступность два игрока и затем назначить их обоих в игре. Эта задача может быть реализована с помощью критическую секцию следующим образом:

```csharp
[FunctionName("Orchestrator")]
public static async Task RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext ctx)
{
    EntityId player1 = /* ... */;
    EntityId player2 = /* ... */;

    using (await ctx.LockAsync(player1, player2))
    {
        bool available1 = await ctx.CallEntityAsync<bool>(player1, "is-available");
        bool available2 = await ctx.CallEntityAsync<bool>(player2, "is-available");

        if (available1 && available2)
        {
            Guid gameId = ctx.NewGuid();

            await ctx.CallEntityAsync(player1, "assign-game", gameId);
            await ctx.CallEntityAsync(player2, "assign-game", gameId);
        }
    }
}
```

В критический раздел обе эти сущности проигрывателя будут заблокированы, это означает, что они не выполняются любые операции, отличные от тех, которые вызываются из критического раздела). Это предотвращает с выделением конфликтующих операций, таких как проигрыватели, назначаемый другой off игру или подписи.

Мы накладывают ряд ограничений на том, как критические секции могут использоваться. Эти ограничения служат для предотвращения взаимоблокировок и повторный вход.

* Критические секции не могут быть вложенными.
* Критические разделы не удается создать suborchestrations.
* Критические разделы можно вызвать только те сущности, которые они уже заблокировал.
* Критические секции нельзя вызывать ту же сущность, с помощью нескольких параллельных вызовов.
* Критические разделы могут послужить только те сущности, которые не заблокировали.

## <a name="alternate-storage-providers"></a>Поставщики альтернативные хранилища

Платформа устойчивых задач поддерживает несколько поставщиков хранилища, включая [хранилища Azure](https://github.com/Azure/durabletask/tree/master/src/DurableTask.AzureStorage), [служебной шины Azure](https://github.com/Azure/durabletask/tree/master/src/DurableTask.ServiceBus), [эмулятора в памяти](https://github.com/Azure/durabletask/tree/master/src/DurableTask.Emulator)и экспериментальных [Redis](https://github.com/Azure/durabletask/tree/redis/src/DurableTask.Redis) поставщика. Однако до сих пор расширения устойчивых задач для функций Azure поддерживается только поставщик хранилища Azure. Начиная с версии 2.0 устойчивых функций, поддержка поставщиков альтернативные хранилища был добавлен, начиная с поставщиком Redis.

> [!NOTE]
> Устойчивых функций 2.0 поддерживает только .NET Standard 2.0-совместимых поставщиков. Во время написания этой статьи поставщика служебной шины Azure не поддерживает .NET Standard 2.0 и поэтому не доступны в качестве альтернативного хранилища поставщика.

### <a name="emulator"></a>Эмулятор

[DurableTask.Emulator](https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Emulator/) поставщик является локальной памяти, поставщик непостоянного хранилища, подходящий для локального тестирования сценариев. Его можно настроить с помощью следующих минимальным **host.json** схемы:

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "emulator": { }
      }
    }
  }
}
```

### <a name="redis-experimental"></a>Redis (экспериментальная функция)

[DurableTask.Redis](https://www.nuget.org/packages/Microsoft.Azure.DurableTask.Redis/) поставщик сохраняет все состояние оркестрации на настроенном кластере Redis.

```json
{
  "version": "2.0",
  "extensions": {
    "durableTask": {
      "hubName": <string>,
      "storageProvider": {
        "redis": {
          "connectionStringName": <string>,
        }
      }
    }
  }
}
```

`connectionStringName` Должен ссылаться на имя приложения параметр или переменную среды. Этого приложения параметр или переменную среды должен содержать значение строки подключения Redis в виде *сервер: порт*. Например `localhost:6379` для подключения к локальному кластеру Redis.

> [!NOTE]
> Поставщик Redis сейчас экспериментальных и поддерживает только функции приложения, работающие на одном узле.
