---
title: Синтаксис запросов Lucene
titleSuffix: Azure Cognitive Search
description: Справочник по полному синтаксису запросов Lucene, используемому в Azure Когнитивный поиск для подстановочных знаков, нечетких поисков, регулярных выражений и других расширенных конструкций запросов.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/10/2020
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: d35c96657f48905f37c9ebe246d81ebb9545cf27
ms.sourcegitcommit: 7b25c9981b52c385af77feb022825c1be6ff55bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79283138"
---
# <a name="lucene-query-syntax-in-azure-cognitive-search"></a>Синтаксис запроса Lucene в Azure Когнитивный поиск

Вы можете создавать запросы к Когнитивный поиск Azure на основе расширенного синтаксиса [синтаксического анализатора запросов Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) для специализированных форм запросов: шаблон, нечеткий поиск, поиск с учетом расположения, регулярные выражения — несколько примеров. Большая часть синтаксиса синтаксического анализатора запросов Lucene [реализована не в azure когнитивный Поиск](search-lucene-query-architecture.md), за исключением *операций поиска по диапазонам* , созданных в Azure Когнитивный поиск с помощью выражений `$filter`. 

> [!NOTE]
> Полный синтаксис Lucene используется для выражений запроса, передаваемых в параметре **поиска** API [документов поиска](https://docs.microsoft.com/rest/api/searchservice/search-documents) , не путать с [синтаксисом OData](query-odata-filter-orderby-syntax.md) , используемым для параметра [$Filter](search-filters.md) этого API. Эти разные синтаксисы имеют собственные правила для построения запросов, экранирования строк и т. д.

## <a name="how-to-invoke-full-parsing"></a>Способы вызова полного синтаксического анализа

Задайте для параметра поиска значение `queryType`, чтобы указать, какое средство синтаксического анализа использовать. Допустимые значения: `simple|full` (`simple` как значение по умолчанию, а `full` как значение Lucene). 

<a name="bkmk_example"></a> 

### <a name="example-showing-full-syntax"></a>Пример полного синтаксиса

В следующем примере выполняется поиск документов в индексе с использованием синтаксиса запросов Lucene, что очевидно из параметра `queryType=full`. Этот запрос возвращает гостиницы, у которых поле «Категория» содержит термин «бюджет», а все поля для поиска содержат фразу «недавно сделан ремонт». Документам, содержащим слова "недавно сделан ремонт", присваивается более высокая оценка в результате повышенного значения этого термина (3).  

Параметр `searchMode=all` подходит для данного примера. Когда операторы находятся в запросе, обычно следует установить параметр `searchMode=all`, чтобы убедиться, что *все* критерии будут удовлетворены.

```
GET /indexes/hotels/docs?search=category:budget AND \"recently renovated\"^3&searchMode=all&api-version=2019-05-06&querytype=full
```

 Или используйте POST:  

```
POST /indexes/hotels/docs/search?api-version=2019-05-06
{
  "search": "category:budget AND \"recently renovated\"^3",
  "queryType": "full",
  "searchMode": "all"
}
```

Дополнительные примеры см. [в статье примеры синтаксиса запросов Lucene для создания запросов в когнитивный Поиск Azure](search-query-lucene-examples.md). Дополнительные сведения об указании полного зависимости от параметров запроса см. в разделе [Поиск документов &#40;когнитивный поиск&#41;REST API Azure](https://docs.microsoft.com/rest/api/searchservice/Search-Documents).

> [!NOTE]  
>  Azure Когнитивный поиск также поддерживает [простой синтаксис запросов](query-simple-syntax.md), простой и надежный язык запросов, который можно использовать для простого поиска по ключевым словам.  

##  <a name="bkmk_syntax"></a> Основные сведения о синтаксисе  
 Следующие основные сведения о синтаксисе применяются ко всем запросам, которые используют синтаксис Lucene.  

### <a name="operator-evaluation-in-context"></a>Оценивание операторов в контексте

Размещение определяет, как будет интерпретироваться символ: как оператор или просто как другой знак в строке.

Например, в полном синтаксисе Lucene тильда (~) используется для поиска нечетких соответствий и для поиска с учетом расположения. Если ~ ставится после фразы в кавычках, вызывается поиск с учетом расположения. Если ~ ставится в конце термина, вызывается поиск нечетких соответствий.

Внутри термина, такого как "business~analyst", знак не оценивается как оператор. В этом случае, предположив, что это запрос термина или фразы, [полнотекстовый поиск](search-lucene-query-architecture.md) с [лексическим анализом](search-lucene-query-architecture.md#stage-2-lexical-analysis) удаляет ~ и разбивает термин "business~analyst" на две части: business OR analyst.

В приведенном выше примере используется тильда (~), но тот же принцип применяется к каждому оператору.

### <a name="escaping-special-characters"></a>Экранирование специальных знаков

 Специальные знаки должны быть экранированы для использования в качестве части текста поискового запроса. Вы можете экранировать их, поставив перед ними обратную косую черту (\\). К специальным знакам, которые необходимо экранировать, относятся следующие:  
`+ - && || ! ( ) { } [ ] ^ " ~ * ? : \ /`  

 Например, чтобы экранировать символ-шаблон, используйте \\\*.

### <a name="encoding-unsafe-and-reserved-characters-in-urls"></a>Кодирование небезопасных и зарезервированных знаков в URL-адресах

 Убедитесь, что в URL-адресе закодированы все небезопасные и зарезервированные знаки. Например, "#" — это небезопасный знак, так как он является идентификатором фрагмента или привязки в URL-адресе. Знак должен быть закодирован как `%23`, если он используется в URL-адресе. "&" и "=" являются примерами зарезервированных символов, так как они разделяют параметры и указывают значения в Когнитивный поиск Azure. Дополнительные сведения см. в разделе [RFC1738: универсальные указатели ресурсов (URL-адрес)](https://www.ietf.org/rfc/rfc1738.txt) .

 Небезопасными знаками являются: ``" ` < > # % { } | \ ^ ~ [ ]``. Зарезервированными знаками являются: `; / ? : @ = + &`.

### <a name="precedence-operators-grouping-and-field-grouping"></a>Операторы приоритета: группирование и группирование полей  
 Вы можете использовать круглые скобки, чтобы создать вложенные запросы, включая операторы в заключенной в скобки инструкции. Например, `motel+(wifi||luxury)` будет выполнять поиск документов, содержащих термин "motel" и "wifi" или "luxury" (или оба).

Группирование полей аналогично, но группирование ограничивается одним полем. Например, `hotelAmenities:(gym+(wifi||pool))` ищет в поле "hotelAmenities" термины "gym" и "wifi" или "gym" и "pool".  

### <a name="searchmode-parameter-considerations"></a>Рекомендации по настройке параметров SearchMode  
 Влияние `searchMode` на запросы, как описано в разделе [простой синтаксис запросов в когнитивный Поиск Azure](query-simple-syntax.md), применяется к синтаксису запроса Lucene. А именно, `searchMode` в сочетании с операторами NOT может привести к результатам запроса, которые могут показаться необычными, если вы не знаете, какие последствия влечет за собой установка этого параметра. Если вы оставите значение по умолчанию (`searchMode=any`) и используете оператор NOT, операция вычисляется как действие OR. Например, запрос "New York" NOT "Seattle" возвращает все города, которые не являются Сиэтлом.  

##  <a name="bkmk_boolean"></a>Логические операторы (AND, OR, NOT) 
 Всегда указывайте текстовые логические операторы (AND, OR, NOT) прописными буквами.  

### <a name="or-operator-or-or-"></a>Оператор OR (`OR` или `||`)

Оператор OR представляет собой вертикальную черту. Например, условие `wifi || luxury` будет искать документы, содержащие "wifi" или "luxury", или и то и другое. Так как OR является оператором соединения по умолчанию, вы также можете его оставить, то есть `wifi luxury` аналогично `wifi || luxuery`.

### <a name="and-operator-and--or-"></a>Оператор AND (`AND`, `&&` или `+`)

Оператор AND представляет собой знак амперсанда или знак плюс. Например, условие `wifi && luxury` будет искать документы, содержащие и "wifi", и "luxury". Знак плюс (+) используется для обязательных терминов. Например, `+wifi +luxury` указывает, что оба термина должны появляться где-то в поле одного документа.


### <a name="not-operator-not--or--"></a>Оператор NOT (`NOT`, `!` или `-`)

Оператор NOT представляет собой восклицательный знак или знак минус. Например, условие `wifi !luxury` будет искать документы, содержащие "wifi" и/или не содержащие "luxury". Параметр `searchMode` контролирует, является ли условие с оператором NOT логическим AND или логическим OR с другими условиями запроса в отсутствие операторов "+" или "||". Напомним, что для `searchMode` можно установить значение `any` (по умолчанию) или `all`.

Значение `searchMode=any` увеличит количество повторных вызовов запросов, что даст большее количество результатов, и "-" по умолчанию интерпретируется как "OR NOT". Например, `wifi -luxury` соответствует документам, которые содержат термин *wifi*, или документам, которые не содержат термин *luxury*.

Значение `searchMode=all` увеличит точность запроса, что даст меньшее количество результатов, и "-" по умолчанию интерпретируется как "AND NOT". Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi` и не содержат термин `luxury`. Вероятно, это более интуитивное поведение оператора "-". Поэтому вам следует рассмотреть возможность использования `searchMode=all` вместо `searchMode=any`, если вы хотите оптимизировать точность поиска (в ущерб повторным вызовам) *и* если ваши пользователи часто используют оператор `-` в своих поисковых запросах.

##  <a name="bkmk_querysizelimits"></a> Ограничения размера запроса  
 Существует ограничение на размер запросов, которые можно отправить в Azure Когнитивный поиск. В частности, вы можете иметь не более 1024 предложений (выражения, разделенные AND, OR и т. д.). Кроме того, размер любого отдельного термина в запросе не может превышать 32 КБ. Если приложение создает поисковые запросы программным способом, рекомендуется разрабатывать его таким образом, чтобы оно не создавало запросы неограниченного размера.  

##  <a name="bkmk_searchscoreforwildcardandregexqueries"></a> Оценка запросов с подстановочными знаками и с регулярными выражениями
 Azure Когнитивный поиск использует оценку на основе частоты ([TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)) для текстовых запросов. Однако для запросов с подстановочными знаками и регулярными выражениями, где область терминов может быть широкой, фактор частоты игнорируется, чтобы предотвратить смещение ранжирования в сторону совпадений с более редкими терминами. Все совпадения обрабатываются одинаково для поиска с подстановочными знаками и с регулярными выражениями.

##  <a name="bkmk_fields"></a>Поиск по полям  
Можно определить операцию поиска по полю с помощью синтаксиса `fieldName:searchExpression`, где выражение поиска может представлять собой одно слово или фразу или более сложное выражение в круглых скобках, при необходимости с логическими операторами. Вот несколько примеров.  

- genre:jazz NOT history  

- artists:("Miles Davis" "John Coltrane")

Добавьте несколько строк в кавычках, если необходимо, чтобы обе строки считались одной сущностью, в приведенном случае поиска двух разных исполнителей в поле `artists`.  

Поле, указанное в `fieldName:searchExpression`, должно быть полем `searchable`.  Дополнительные сведения об использовании атрибутов индекса в определениях полей см. в статье [Create Index (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/create-index) (Создание индексов (REST API службы "Поиск Azure")).  

> [!NOTE]
> При использовании выражений с полями для поиска необязательно использовать параметр `searchFields`, так как каждое поле поиска с полями имеет явно заданное имя поля. Тем не менее можно по-прежнему использовать параметр `searchFields`, если необходимо выполнить запрос, в котором часть частей ограничена определенным полем, а остальное может быть применено к нескольким полям. Например, запрос `search=genre:jazz NOT history&searchFields=description` сопоставляется `jazz` только с полем `genre`, в то время как оно будет сопоставлять `NOT history` с полем `description`. Имя поля, указанное в `fieldName:searchExpression`, всегда имеет приоритет над параметром `searchFields`, поэтому в этом примере не нужно включать `genre` в параметр `searchFields`.

##  <a name="bkmk_fuzzy"></a> Поиск нечетких соответствий  
 Операция поиска нечетких соответствий позволяет найти совпадения в словах с аналогичной конструкцией. В [документации Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) поиск нечетких соответствий основан на [расстоянии Дамерау — Левенштейна](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance). Поиск нечетких соответствий может расширить термин до максимум 50 терминов, соответствующих критерию расстояния. 

 Чтобы выполнить поиск нечетких соответствий, необходимо поставить символ тильды "~" в конце слова. Дополнительно можно поставить цифру от 0 до 2 (по умолчанию), указывающую расстояние редактирования. Например, "blue~" или "blue~1" вернет результаты с "blue", "blues" и "glue".

 Нечеткий поиск можно применить только к терминам, а не к фразам, но можно добавить символ тильды к каждому термину по отдельности в составе имени или фразы. Например, "Унвиерсти ~ of ~" Вшингтон ~ "соответствует" университету Вашингтон ".
 

##  <a name="bkmk_proximity"></a> Поиск с учетом расположения  
 Операция поиска с учетом расположения позволяет найти слова, расположенные рядом в документе. Вставьте символ тильды "~" в конце фразы, а затем — цифру, обозначающую количество слов, определяющее границу близости. Например, если ввести `"hotel airport"~5`, будут найдены слова "hotel" и "airport", расположенные в пределах 5 слов друг от друга в документе.  


##  <a name="bkmk_termboost"></a> Повышение приоритета терминов  
 При повышении приоритета слов документы сортируются по приоритету, т. е. документы, в которых содержится условие поиска, имеют высший приоритет по отношению к документам, в которых его нет. Этот тип запроса отличается от профилей повышения, так как они повышают приоритет определенных полей, а не определенных слов.  

В следующем примере показаны эти различия. Предположим, что есть профиль повышения, который повышает приоритет совпадений в определенном поле, например, *genre* в [примере musicstoreindex](index-add-scoring-profiles.md#bkmk_ex). Повышение значимости слов может использоваться для дальнейшего повышения приоритета определенных условий поиска относительно других. Например, при вводе запроса `rock^2 electronic` документы, содержащие это условие поиска в поле genre, становятся приоритетнее документов, содержащих это условие поиска в других полях, поддерживающих поиск, в индексе. Кроме того, документы, содержащие слово *rock*, будут иметь более высокий приоритет, чем документы, содержащие слово *electronic*, так как введен коэффициент повышения приоритета (2).  

 Чтобы повысить приоритет условия поиска, используйте символ крышки "^" и коэффициент повышения приоритета (число) в конце этого условия. Вы также можете повысить приоритет фразы. Чем выше коэффициент повышения приоритета, тем приоритетнее условие поиска относительно других. Коэффициент повышения приоритета по умолчанию — 1. Несмотря на то что коэффициент повышения приоритета должен быть положительным числом, он может быть меньше 1 (например, 0,20).  

##  <a name="bkmk_regex"></a> Поиск с использованием регулярных выражений  
 Операция поиска по регулярным выражениям позволяет найти совпадение в зависимости от содержимого между косыми чертами "/", как указано в документации [класса RegExp](https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/util/automaton/RegExp.html).  

 Например, чтобы найти документы, содержащие "motel" или "hotel", укажите `/[mh]otel/`.  Поиск с регулярными выражениями сопоставляется с отдельными словами.   

##  <a name="bkmk_wildcard"></a> Поиск с использованием подстановочных знаков  
 Вы можете использовать распознаваемый синтаксис для поиска с использованием одного (?) или нескольких (*) подстановочных знаков. Обратите внимание, что средство синтаксического анализа запросов Lucene поддерживает использование этих символов для поиска одного слова, а не фразы.  

 Например, чтобы найти документы, содержащие слова с префиксом "note", например "notebook" или "notepad", укажите "note*".  

> [!NOTE]  
>  Символ "*" или "?" не может находиться в начале поискового запроса.  
>  Анализ текста для поисковых запросов с использованием подстановочных знаков не выполняется. Во время выполнения запроса термины запроса с подстановочным знаком сравниваются с проанализированными терминами в индексе поиска и расширяются.

## <a name="see-also"></a>См. также раздел  

+ [Поиск документов](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
+ [Синтаксис выражений OData для предложений фильтрации и упорядочивания в службе "Поиск Azure"](query-odata-filter-orderby-syntax.md)   
+ [Простой синтаксис запросов в Azure Когнитивный поиск](query-simple-syntax.md)   
