---
title: Синтаксис запросов Lucene
titleSuffix: Azure Cognitive Search
description: Справочник по полному синтаксису запросов Lucene, используемому в Azure Когнитивный поиск для подстановочных знаков, нечетких поисков, регулярных выражений и других расширенных конструкций запросов.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/10/2020
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: f4c3330b23b8b724cdbf5d7e09eec8a8dd5b8cfa
ms.sourcegitcommit: 849bb1729b89d075eed579aa36395bf4d29f3bd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "81258989"
---
# <a name="lucene-query-syntax-in-azure-cognitive-search"></a>Синтаксис запроса Lucene в Azure Когнитивный поиск

Вы можете создавать запросы к Когнитивный поиск Azure на основе расширенного синтаксиса [синтаксического анализатора запросов Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) для специализированных форм запросов: шаблон, нечеткий поиск, поиск с учетом расположения, регулярные выражения — несколько примеров. Большая часть синтаксиса синтаксического анализатора запросов Lucene [реализована не в azure когнитивный Поиск](search-lucene-query-architecture.md), за исключением *поиска по диапазонам* , созданных в Azure когнитивный поиск `$filter` с помощью выражений. 

> [!NOTE]
> Полный синтаксис Lucene используется для выражений запроса, передаваемых в параметре **поиска** API [документов поиска](https://docs.microsoft.com/rest/api/searchservice/search-documents) , не путать с [синтаксисом OData](query-odata-filter-orderby-syntax.md) , используемым для параметра [$Filter](search-filters.md) этого API. Эти разные синтаксисы имеют собственные правила для построения запросов, экранирования строк и т. д.

## <a name="invoke-full-parsing"></a>Вызвать полный синтаксический анализ

Задайте для параметра поиска значение `queryType`, чтобы указать, какое средство синтаксического анализа использовать. Допустимые значения: `simple|full` (`simple` как значение по умолчанию, а `full` как значение Lucene). 

<a name="bkmk_example"></a> 

### <a name="example-showing-full-syntax"></a>Пример полного синтаксиса

В следующем примере выполняется поиск документов в индексе с использованием синтаксиса запросов Lucene, что очевидно из параметра `queryType=full`. Этот запрос возвращает гостиницы, у которых поле «Категория» содержит термин «бюджет», а все поля для поиска содержат фразу «недавно сделан ремонт». Документам, содержащим слова "недавно сделан ремонт", присваивается более высокая оценка в результате повышенного значения этого термина (3).  

Параметр `searchMode=all` подходит для данного примера. Когда операторы находятся в запросе, обычно следует установить параметр `searchMode=all`, чтобы убедиться, что *все* критерии будут удовлетворены.

```
GET /indexes/hotels/docs?search=category:budget AND \"recently renovated\"^3&searchMode=all&api-version=2019-05-06&querytype=full
```

 Или используйте POST:  

```
POST /indexes/hotels/docs/search?api-version=2019-05-06
{
  "search": "category:budget AND \"recently renovated\"^3",
  "queryType": "full",
  "searchMode": "all"
}
```

Дополнительные примеры см. [в статье примеры синтаксиса запросов Lucene для создания запросов в когнитивный Поиск Azure](search-query-lucene-examples.md). Дополнительные сведения об указании полного зависимости от параметров запроса см. в разделе [Поиск документов &#40;Azure Когнитивный поиск REST API&#41;](https://docs.microsoft.com/rest/api/searchservice/Search-Documents).

> [!NOTE]  
>  Azure Когнитивный поиск также поддерживает [простой синтаксис запросов](query-simple-syntax.md), простой и надежный язык запросов, который можно использовать для простого поиска по ключевым словам.  

##  <a name="syntax-fundamentals"></a><a name="bkmk_syntax"></a> Основные сведения о синтаксисе  

следующие основные принципы синтаксиса применяются ко всем запросам, использующим синтаксис Lucene.  

### <a name="operator-evaluation-in-context"></a>Оценивание операторов в контексте

Размещение определяет, как будет интерпретироваться символ: как оператор или просто как другой знак в строке.

Например, в полном синтаксисе Lucene тильда (~) используется для поиска нечетких соответствий и для поиска с учетом расположения. Если ~ ставится после фразы в кавычках, вызывается поиск с учетом расположения. Если ~ ставится в конце термина, вызывается поиск нечетких соответствий.

Внутри термина, такого как "business~analyst", знак не оценивается как оператор. В этом случае, предположив, что это запрос термина или фразы, [полнотекстовый поиск](search-lucene-query-architecture.md) с [лексическим анализом](search-lucene-query-architecture.md#stage-2-lexical-analysis) удаляет ~ и разбивает термин "business~analyst" на две части: business OR analyst.

В приведенном выше примере используется тильда (~), но тот же принцип применяется к каждому оператору.

### <a name="escaping-special-characters"></a>Экранирование специальных знаков

Чтобы использовать любой оператор поиска как часть искомого текста, необходимо зафиксировать символ, добавив в него одну обратную косую черту (`\`). Например, для поиска с подстановочными знаками `https://`в `://` , где является частью строки запроса, необходимо указать `search=https\:\/\/*`. Аналогично, шаблон номер телефона с экранированием может выглядеть `\+1 \(800\) 642\-7676`следующим образом.

Специальные символы, требующие экранирования, включают следующее:  
`+ - & | ! ( ) { } [ ] ^ " ~ * ? : \ /`  

> [!NOTE]  
> Хотя экранирование сохраняет маркеры совместно, [лексический анализ](search-lucene-query-architecture.md#stage-2-lexical-analysis) во время индексирования может привести к их порождению. Например, стандартный анализатор Lucene будет разбивать слова на дефисы, пробелы и другие символы. Если в строке запроса требуются специальные символы, может потребоваться анализатор, сохраняющий их в индексе. К некоторым вариантам относятся [анализаторы](index-add-language-analyzers.md)естественного языка (Майкрософт), которые сохраняют перенос слов или пользовательский анализатор для более сложных шаблонов. Дополнительные сведения см. в разделе [частичные термины, шаблоны и специальные символы](search-query-partial-matching.md).

### <a name="encoding-unsafe-and-reserved-characters-in-urls"></a>Кодирование небезопасных и зарезервированных знаков в URL-адресах

Убедитесь, что в URL-адресе закодированы все небезопасные и зарезервированные знаки. Например, "#" является ненадежным символом, так как он является идентификатором фрагмента или привязки в URL-адресе. Знак должен быть закодирован как `%23`, если он используется в URL-адресе. "&" и "=" являются примерами зарезервированных символов, так как они разделяют параметры и указывают значения в Когнитивный поиск Azure. Дополнительные сведения см. в разделе [RFC1738: универсальные указатели ресурсов (URL-адрес)](https://www.ietf.org/rfc/rfc1738.txt) .

Небезопасными знаками являются: ``" ` < > # % { } | \ ^ ~ [ ]``. Зарезервированными знаками являются: `; / ? : @ = + &`.

###  <a name="query-size-limits"></a><a name="bkmk_querysizelimits"></a>Ограничения размера запроса

 Существует ограничение на размер запросов, которые можно отправить в Azure Когнитивный поиск. В частности, вы можете иметь не более 1024 предложений (выражения, разделенные AND, OR и т. д.). Кроме того, размер любого отдельного термина в запросе не может превышать 32 КБ. Если приложение создает поисковые запросы программным способом, рекомендуется разрабатывать его таким образом, чтобы оно не создавало запросы неограниченного размера.  

### <a name="precedence-operators-grouping"></a>Операторы приоритета (группирование)

 Вы можете использовать круглые скобки, чтобы создать вложенные запросы, включая операторы в заключенной в скобки инструкции. Например, `motel+(wifi||luxury)` будет выполнять поиск документов, содержащих термин "motel" и "wifi" или "luxury" (или оба).

Группирование полей аналогично, но группирование ограничивается одним полем. Например, `hotelAmenities:(gym+(wifi||pool))` ищет в поле "hotelAmenities" термины "gym" и "wifi" или "gym" и "pool".  

##  <a name="boolean-search"></a><a name="bkmk_boolean"></a>Логический поиск

 Всегда указывайте текстовые логические операторы (AND, OR, NOT) прописными буквами.  

### <a name="or-operator-or-or-"></a>Оператор OR (`OR` или `||`)

Оператор OR представляет собой вертикальную черту. Например, условие `wifi || luxury` будет искать документы, содержащие "wifi" или "luxury", или и то и другое. Так как OR является оператором соединения по умолчанию, вы также можете его оставить, то есть `wifi luxury` аналогично `wifi || luxury`.

### <a name="and-operator-and--or-"></a>Оператор AND (`AND`, `&&` или `+`)

Оператор AND представляет собой знак амперсанда или знак плюс. Например, условие `wifi && luxury` будет искать документы, содержащие и "wifi", и "luxury". Знак плюс (+) используется для обязательных терминов. Например, `+wifi +luxury` указывает, что оба термина должны появляться где-то в поле одного документа.

### <a name="not-operator-not--or--"></a>Оператор NOT (`NOT`, `!` или `-`)

Оператор NOT представляет собой знак минус. Например, будет `wifi –luxury` искать документы, у которых нет `wifi` термина и (или) нет `luxury`.

Параметр **searchMode** запроса определяет, является ли термин с оператором NOT and или ORed с другими условиями в запросе (при условии, что оператор `+` or `|` отсутствует в других терминах). Допустимые значения: `any` и `all`.

`searchMode=any`повышает отзыв запросов, включая дополнительные результаты, и по умолчанию `-` интерпретируется как «или not». Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi`, или документам, которые не содержат термин `luxury`.

`searchMode=all`увеличивает точность запросов, включая меньше результатов, и по умолчанию интерпретируется как «AND NOT». Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi` и не содержат термин "luxury". Вероятно, это более интуитивное поведение оператора `-`. Поэтому `searchMode=all` рекомендуется использовать вместо `searchMode=any` , если требуется оптимизировать поиск точности вместо отзыва, *а* пользователи часто используют `-` оператор в поиске.

При принятии решения о параметре **searchMode** следует учитывать закономерности взаимодействия с пользователем для запросов в различных приложениях. Пользователи, которые ищут информацию, скорее всего, включают оператор в запрос, а не сайты электронной коммерции с более встроенными структурами навигации.

##  <a name="fielded-search"></a><a name="bkmk_fields"></a>Поиск по полям

Можно определить операцию поиска по полю с `fieldName:searchExpression` синтаксисом, где выражение поиска может представлять собой одно слово или фразу или более сложное выражение в круглых скобках, при необходимости с логическими операторами. Вот несколько примеров.  

- genre:jazz NOT history  

- artists:("Miles Davis" "John Coltrane")

Добавьте несколько строк в кавычках, если необходимо, чтобы обе строки считались одной сущностью, в приведенном случае поиска двух разных исполнителей в поле `artists`.  

Поле, указанное в `fieldName:searchExpression`, должно быть полем `searchable`.  Дополнительные сведения об использовании атрибутов индекса в определениях полей см. в статье [Create Index (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/create-index) (Создание индексов (REST API службы "Поиск Azure")).  

> [!NOTE]
> При использовании выражений с полями для поиска не нужно использовать этот `searchFields` параметр, так как каждое поле поискового выражения имеет явно заданное имя поля. Тем не менее можно по-прежнему `searchFields` использовать параметр, если требуется выполнить запрос, в котором часть частей ограничена определенным полем, а остальное может быть применено к нескольким полям. Например, запрос `search=genre:jazz NOT history&searchFields=description` `jazz` будет сопоставляться только с `genre` полем, тогда как он будет соответствовать `NOT history` `description` полю. Имя поля, указанное в `fieldName:searchExpression` , всегда имеет приоритет над `searchFields` параметром, поэтому в этом примере не нужно включать `genre` в `searchFields` параметр.

##  <a name="fuzzy-search"></a><a name="bkmk_fuzzy"></a>Нечеткий поиск

Нечеткий поиск находит совпадения в терминах, имеющих похожую конструкцию, расширяя термин до максимума 50 терминов, отвечающих критериям расстояния двух или менее. Дополнительные сведения см. в разделе [нечеткий поиск](search-query-fuzzy.md).

 Чтобы выполнить поиск нечетких соответствий, необходимо поставить символ тильды "~" в конце слова. Дополнительно можно поставить цифру от 0 до 2 (по умолчанию), указывающую расстояние редактирования. Например, "blue~" или "blue~1" вернет результаты с "blue", "blues" и "glue".

 Нечеткий поиск можно применить только к терминам, а не к фразам, но можно добавить символ тильды к каждому термину по отдельности в составе имени или фразы. Например, "Унвиерсти ~ of ~" Вшингтон ~ "соответствует" университету Вашингтон ".
 
##  <a name="proximity-search"></a><a name="bkmk_proximity"></a>Поиск с учетом расположения

Операция поиска с учетом расположения позволяет найти слова, расположенные рядом в документе. Вставьте символ тильды "~" в конце фразы, а затем — цифру, обозначающую количество слов, определяющее границу близости. Например, если ввести `"hotel airport"~5`, будут найдены слова "hotel" и "airport", расположенные в пределах 5 слов друг от друга в документе.  


##  <a name="term-boosting"></a><a name="bkmk_termboost"></a>Повышение термина

При повышении приоритета слов документы сортируются по приоритету, т. е. документы, в которых содержится условие поиска, имеют высший приоритет по отношению к документам, в которых его нет. Этот тип запроса отличается от профилей повышения, так как они повышают приоритет определенных полей, а не определенных слов.  

В следующем примере показаны эти различия. Предположим, что есть профиль повышения, который повышает приоритет совпадений в определенном поле, например, *genre* в [примере musicstoreindex](index-add-scoring-profiles.md#bkmk_ex). Повышение значимости слов может использоваться для дальнейшего повышения приоритета определенных условий поиска относительно других. Например, при вводе запроса `rock^2 electronic` документы, содержащие это условие поиска в поле genre, становятся приоритетнее документов, содержащих это условие поиска в других полях, поддерживающих поиск, в индексе. Кроме того, документы, содержащие слово *rock*, будут иметь более высокий приоритет, чем документы, содержащие слово *electronic*, так как введен коэффициент повышения приоритета (2).  

 Чтобы повысить приоритет условия поиска, используйте символ крышки "^" и коэффициент повышения приоритета (число) в конце этого условия. Вы также можете повысить приоритет фразы. Чем выше коэффициент повышения приоритета, тем приоритетнее условие поиска относительно других. Коэффициент повышения приоритета по умолчанию — 1. Несмотря на то что коэффициент повышения приоритета должен быть положительным числом, он может быть меньше 1 (например, 0,20).  

##  <a name="regular-expression-search"></a><a name="bkmk_regex"></a> Поиск с использованием регулярных выражений  
 Операция поиска по регулярным выражениям позволяет найти совпадение в зависимости от содержимого между косыми чертами "/", как указано в документации [класса RegExp](https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/util/automaton/RegExp.html).  

 Например, чтобы найти документы, содержащие "motel" или "hotel", укажите `/[mh]otel/`. Поиск с регулярными выражениями сопоставляется с отдельными словами.

Некоторые средства и языки залагают дополнительные требования к escape-символам. Для JSON строки, включающие косую черту, переводятся обратной косой чертой: `search=/.*microsoft.com\/azure\/.*/` " `search=/.* <string-placeholder>.*/` Microsoft.com/Azure/" становится местом, где настраивается регулярное выражение, а `microsoft.com\/azure\/` — строка с экранированной косой чертой.

##  <a name="wildcard-search"></a><a name="bkmk_wildcard"></a>Поиск с подстановочными знаками  

Вы можете использовать распознаваемый синтаксис для поиска с использованием одного (?) или нескольких (*) подстановочных знаков. Обратите внимание, что средство синтаксического анализа запросов Lucene поддерживает использование этих символов для поиска одного слова, а не фразы.

При поиске префиксов также используется символ`*`звездочки (). Например, выражение запроса `search=note*` возвращает "Записная книжка" или "Блокнот". Для поиска по префиксу не требуется полный синтаксис Lucene. Этот сценарий поддерживается простым синтаксисом.

Поиск суффикса, `*` где `?` или перед строкой, требует полного синтаксиса Lucene и регулярного выражения (вы не можете использовать * или? символ в качестве первого символа поиска). При условии "буквенно-цифровых" выражение запроса (`search=/.*numeric.*/`) обнаружит совпадение.

> [!NOTE]  
> Во время синтаксического анализа запроса запросы, которые обрабатываются как префикс, суффикс, подстановочный знак или регулярные выражения, передаются как есть в дерево запроса, минуя [лексed Analysis](search-lucene-query-architecture.md#stage-2-lexical-analysis). Совпадения будут найдены, только если индекс содержит строки в формате, указанном в запросе. В большинстве случаев потребуется альтернативный анализатор во время индексирования, который сохраняет целостность строк, чтобы частичное совпадение терминов и шаблонов было продолжено. Дополнительные сведения см. [в статье Поиск неполных терминов в Azure когнитивный Поиск запросы](search-query-partial-matching.md).

##  <a name="scoring-wildcard-and-regex-queries"></a><a name="bkmk_searchscoreforwildcardandregexqueries"></a> Оценка запросов с подстановочными знаками и с регулярными выражениями

Azure Когнитивный поиск использует оценку на основе частоты ([TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)) для текстовых запросов. Однако для запросов с подстановочными знаками и регулярными выражениями, где область терминов может быть широкой, фактор частоты игнорируется, чтобы предотвратить смещение ранжирования в сторону совпадений с более редкими терминами. Все совпадения обрабатываются одинаково для поиска с подстановочными знаками и с регулярными выражениями.

## <a name="see-also"></a>См. также

+ [Примеры запросов для простого поиска](search-query-simple-examples.md)
+ [Примеры запросов для полного поиска в Lucene](search-query-lucene-examples.md)
+ [Поиск документов](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
+ [Синтаксис выражений OData для предложений фильтрации и упорядочивания в службе "Поиск Azure"](query-odata-filter-orderby-syntax.md)   
+ [Простой синтаксис запросов в Azure Когнитивный поиск](query-simple-syntax.md)   
