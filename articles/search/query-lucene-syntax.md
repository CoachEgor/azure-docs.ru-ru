---
title: Синтаксис запросов Lucene
titleSuffix: Azure Cognitive Search
description: Ссылка на полный синтаксис запроса Lucene, используемый в Azure Cognitive Search для подстановочного знака, нечеткого поиска, RegEx и других расширенных конструкций запросов.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/10/2020
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: d35c96657f48905f37c9ebe246d81ebb9545cf27
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79283138"
---
# <a name="lucene-query-syntax-in-azure-cognitive-search"></a>Синтаксис Lucene запросв в Azure Cognitive Search

Вы можете писать запросы против Azure Cognitive Search на основе богатого синтаксиса [Lucene Query Parser](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) для специализированных форм запросов: подстановочный знак, нечеткий поиск, поиск поблизости, регулярные выражения – вот несколько примеров. Большая часть синтаксиса Lucene Query Parser [реализована в Azure Cognitive Search,](search-lucene-query-architecture.md)за исключением `$filter` *поиска диапазона,* который строится в Azure Cognitive Search с помощью выражений. 

> [!NOTE]
> Полный синтаксис Lucene используется для выражения запроса, передаваемого в параметре **поиска** API [Поисковых документов,](https://docs.microsoft.com/rest/api/searchservice/search-documents) не следует путать с [синтаксисом OData,](query-odata-filter-orderby-syntax.md) используемым для [$filter](search-filters.md) параметра этого API. Эти различные синтаксисы имеют свои собственные правила для построения запросов, избегая строк и так далее.

## <a name="how-to-invoke-full-parsing"></a>Способы вызова полного синтаксического анализа

Задайте для параметра поиска значение `queryType`, чтобы указать, какое средство синтаксического анализа использовать. Допустимые значения: `simple|full` (`simple` как значение по умолчанию, а `full` как значение Lucene). 

<a name="bkmk_example"></a> 

### <a name="example-showing-full-syntax"></a>Пример полного синтаксиса

В следующем примере выполняется поиск документов в индексе с использованием синтаксиса запросов Lucene, что очевидно из параметра `queryType=full`. Этот запрос возвращает гостиницы, у которых поле «Категория» содержит термин «бюджет», а все поля для поиска содержат фразу «недавно сделан ремонт». Документам, содержащим слова "недавно сделан ремонт", присваивается более высокая оценка в результате повышенного значения этого термина (3).  

Параметр `searchMode=all` подходит для данного примера. Когда операторы находятся в запросе, обычно следует установить параметр `searchMode=all`, чтобы убедиться, что *все* критерии будут удовлетворены.

```
GET /indexes/hotels/docs?search=category:budget AND \"recently renovated\"^3&searchMode=all&api-version=2019-05-06&querytype=full
```

 Или используйте POST:  

```
POST /indexes/hotels/docs/search?api-version=2019-05-06
{
  "search": "category:budget AND \"recently renovated\"^3",
  "queryType": "full",
  "searchMode": "all"
}
```

Дополнительные примеры приведены [в примерах синтаксиса Lucene для создания запросов в Azure Cognitive Search.](search-query-lucene-examples.md) Подробнее об определении полного контингента параметров запроса читайте в материале [«Поисковые документы &#40;Azure Cognitive Search REST API&#41;. ](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)

> [!NOTE]  
>  Azure Cognitive Search также поддерживает [простой syntax запросов](query-simple-syntax.md), простой и надежный язык запросов, который может быть использован для простого поиска ключевых слов.  

##  <a name="syntax-fundamentals"></a><a name="bkmk_syntax"></a> Основные сведения о синтаксисе  
 Следующие основные сведения о синтаксисе применяются ко всем запросам, которые используют синтаксис Lucene.  

### <a name="operator-evaluation-in-context"></a>Оценивание операторов в контексте

Размещение определяет, как будет интерпретироваться символ: как оператор или просто как другой знак в строке.

Например, в полном синтаксисе Lucene тильда (~) используется для поиска нечетких соответствий и для поиска с учетом расположения. Если ~ ставится после фразы в кавычках, вызывается поиск с учетом расположения. Если ~ ставится в конце термина, вызывается поиск нечетких соответствий.

Внутри термина, такого как "business~analyst", знак не оценивается как оператор. В этом случае, предположив, что это запрос термина или фразы, [полнотекстовый поиск](search-lucene-query-architecture.md) с [лексическим анализом](search-lucene-query-architecture.md#stage-2-lexical-analysis) удаляет ~ и разбивает термин "business~analyst" на две части: business OR analyst.

В приведенном выше примере используется тильда (~), но тот же принцип применяется к каждому оператору.

### <a name="escaping-special-characters"></a>Экранирование специальных знаков

 Специальные знаки должны быть экранированы для использования в качестве части текста поискового запроса. Вы можете экранировать их, поставив перед ними обратную косую черту (\\). К специальным знакам, которые необходимо экранировать, относятся следующие:  
`+ - && || ! ( ) { } [ ] ^ " ~ * ? : \ /`  

 Например, чтобы избежать подстановочного персонажа, используйте \\ \*.

### <a name="encoding-unsafe-and-reserved-characters-in-urls"></a>Кодирование небезопасных и зарезервированных знаков в URL-адресах

 Убедитесь, что в URL-адресе закодированы все небезопасные и зарезервированные знаки. Например, "#" — это небезопасный знак, так как он является идентификатором фрагмента или привязки в URL-адресе. Знак должен быть закодирован как `%23`, если он используется в URL-адресе. «&» и «я» — это примеры зарезервированных символов, поскольку они разграничели параметры и указывают значения в Azure Cognitive Search. Для получения более подробной информации осваивай тесьмы [rFC1738: Единые локаторы ресурсов (URL)](https://www.ietf.org/rfc/rfc1738.txt) для получения более подробной информации.

 Небезопасными знаками являются: ``" ` < > # % { } | \ ^ ~ [ ]``. Зарезервированными знаками являются: `; / ? : @ = + &`.

### <a name="precedence-operators-grouping-and-field-grouping"></a>Операторы приоритета: группирование и группирование полей  
 Вы можете использовать круглые скобки, чтобы создать вложенные запросы, включая операторы в заключенной в скобки инструкции. Например, `motel+(wifi||luxury)` будет выполнять поиск документов, содержащих термин "motel" и "wifi" или "luxury" (или оба).

Группирование полей аналогично, но группирование ограничивается одним полем. Например, `hotelAmenities:(gym+(wifi||pool))` ищет в поле "hotelAmenities" термины "gym" и "wifi" или "gym" и "pool".  

### <a name="searchmode-parameter-considerations"></a>Рекомендации по настройке параметров SearchMode  
 Влияние `searchMode` запросов, описанное в [синтаксисе Simple queriery в Azure Cognitive Search,](query-simple-syntax.md)в равной степени относится и к синтаксису запроса Lucene. А именно, `searchMode` в сочетании с операторами NOT может привести к результатам запроса, которые могут показаться необычными, если вы не знаете, какие последствия влечет за собой установка этого параметра. Если вы оставите значение по умолчанию (`searchMode=any`) и используете оператор NOT, операция вычисляется как действие OR. Например, запрос "New York" NOT "Seattle" возвращает все города, которые не являются Сиэтлом.  

##  <a name="boolean-operators-and-or-not"></a><a name="bkmk_boolean"></a>Boolean операторов (И, ИЛИ, НЕ) 
 Всегда указывайте текстовые логические операторы (AND, OR, NOT) прописными буквами.  

### <a name="or-operator-or-or-"></a>Оператор OR (`OR` или `||`)

Оператор OR представляет собой вертикальную черту. Например, условие `wifi || luxury` будет искать документы, содержащие "wifi" или "luxury", или и то и другое. Так как OR является оператором соединения по умолчанию, вы также можете его оставить, то есть `wifi luxury` аналогично `wifi || luxuery`.

### <a name="and-operator-and--or-"></a>Оператор AND (`AND`, `&&` или `+`)

Оператор AND представляет собой знак амперсанда или знак плюс. Например, условие `wifi && luxury` будет искать документы, содержащие и "wifi", и "luxury". Знак плюс (+) используется для обязательных терминов. Например, `+wifi +luxury` указывает, что оба термина должны появляться где-то в поле одного документа.


### <a name="not-operator-not--or--"></a>Оператор NOT (`NOT`, `!` или `-`)

Оператор NOT представляет собой восклицательный знак или знак минус. Например, условие `wifi !luxury` будет искать документы, содержащие "wifi" и/или не содержащие "luxury". Параметр `searchMode` контролирует, является ли условие с оператором NOT логическим AND или логическим OR с другими условиями запроса в отсутствие операторов "+" или "||". Напомним, что для `searchMode` можно установить значение `any` (по умолчанию) или `all`.

Значение `searchMode=any` увеличит количество повторных вызовов запросов, что даст большее количество результатов, и "-" по умолчанию интерпретируется как "OR NOT". Например, `wifi -luxury` соответствует документам, которые содержат термин *wifi*, или документам, которые не содержат термин *luxury*.

Значение `searchMode=all` увеличит точность запроса, что даст меньшее количество результатов, и "-" по умолчанию интерпретируется как "AND NOT". Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi` и не содержат термин `luxury`. Вероятно, это более интуитивное поведение оператора "-". Поэтому вам следует рассмотреть возможность использования `searchMode=all` вместо `searchMode=any`, если вы хотите оптимизировать точность поиска (в ущерб повторным вызовам) *и* если ваши пользователи часто используют оператор `-` в своих поисковых запросах.

##  <a name="query-size-limitations"></a><a name="bkmk_querysizelimits"></a> Ограничения размера запроса  
 Размер запросов, которые можно отправить в Azure Cognitive Search, ограничен. В частности, вы можете иметь не более 1024 предложений (выражения, разделенные AND, OR и т. д.). Кроме того, размер любого отдельного термина в запросе не может превышать 32 КБ. Если приложение создает поисковые запросы программным способом, рекомендуется разрабатывать его таким образом, чтобы оно не создавало запросы неограниченного размера.  

##  <a name="scoring-wildcard-and-regex-queries"></a><a name="bkmk_searchscoreforwildcardandregexqueries"></a> Оценка запросов с подстановочными знаками и с регулярными выражениями
 Azure Cognitive Search использует частотный скоринг[(TF-IDF)](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)для текстовых запросов. Однако для запросов с подстановочными знаками и регулярными выражениями, где область терминов может быть широкой, фактор частоты игнорируется, чтобы предотвратить смещение ранжирования в сторону совпадений с более редкими терминами. Все совпадения обрабатываются одинаково для поиска с подстановочными знаками и с регулярными выражениями.

##  <a name="fielded-search"></a><a name="bkmk_fields"></a>Полевый поиск  
Вы можете определить полевую `fieldName:searchExpression` операцию поиска с помощью синтаксиса, где выражение поиска может быть одним словом или фразой, или более сложным выражением в скобках, по желанию с операторами Boolean. Вот несколько примеров.  

- genre:jazz NOT history  

- artists:("Miles Davis" "John Coltrane")

Добавьте несколько строк в кавычках, если необходимо, чтобы обе строки считались одной сущностью, в приведенном случае поиска двух разных исполнителей в поле `artists`.  

Поле, указанное в `fieldName:searchExpression`, должно быть полем `searchable`.  Дополнительные сведения об использовании атрибутов индекса в определениях полей см. в статье [Create Index (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/create-index) (Создание индексов (REST API службы "Поиск Azure")).  

> [!NOTE]
> При использовании полевых выражений поиска не `searchFields` нужно использовать параметр, поскольку каждое полевое выражение поиска имеет явно указанное имя поля. Тем не менее, `searchFields` вы все равно можете использовать параметр, если вы хотите запустить запрос, в котором некоторые части относятся к определенному полю, а остальные могут применяться к нескольким полям. `search=genre:jazz NOT history&searchFields=description` Например, запрос будет `jazz` соответствовать `genre` только полю, `NOT history` в `description` то время как он будет соответствовать с полем. Имя поля, `fieldName:searchExpression` представленное в всегда `searchFields` имеет приоритет над параметром, поэтому в `genre` этом `searchFields` примере нам не нужно включать в параметр.

##  <a name="fuzzy-search"></a><a name="bkmk_fuzzy"></a>Нечеткий поиск  
 Операция поиска нечетких соответствий позволяет найти совпадения в словах с аналогичной конструкцией. В [документации Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) поиск нечетких соответствий основан на [расстоянии Дамерау — Левенштейна](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance). Поиск нечетких соответствий может расширить термин до максимум 50 терминов, соответствующих критерию расстояния. 

 Чтобы выполнить поиск нечетких соответствий, необходимо поставить символ тильды "~" в конце слова. Дополнительно можно поставить цифру от 0 до 2 (по умолчанию), указывающую расстояние редактирования. Например, "blue~" или "blue~1" вернет результаты с "blue", "blues" и "glue".

 Нечеткий поиск может быть применен только к терминам, а не фразы, но вы можете приложить tilde к каждому термину индивидуально в нескольких частей имя или фразу. Например, "Unviersty" из "Wshington" будет соответствовать "Университет Вашингтона".
 

##  <a name="proximity-search"></a><a name="bkmk_proximity"></a>Поиск близости  
 Операция поиска с учетом расположения позволяет найти слова, расположенные рядом в документе. Вставьте символ тильды "~" в конце фразы, а затем — цифру, обозначающую количество слов, определяющее границу близости. Например, если ввести `"hotel airport"~5`, будут найдены слова "hotel" и "airport", расположенные в пределах 5 слов друг от друга в документе.  


##  <a name="term-boosting"></a><a name="bkmk_termboost"></a>Срок повышения  
 При повышении приоритета слов документы сортируются по приоритету, т. е. документы, в которых содержится условие поиска, имеют высший приоритет по отношению к документам, в которых его нет. Этот тип запроса отличается от профилей повышения, так как они повышают приоритет определенных полей, а не определенных слов.  

В следующем примере показаны эти различия. Предположим, что есть профиль повышения, который повышает приоритет совпадений в определенном поле, например, *genre* в [примере musicstoreindex](index-add-scoring-profiles.md#bkmk_ex). Повышение значимости слов может использоваться для дальнейшего повышения приоритета определенных условий поиска относительно других. Например, при вводе запроса `rock^2 electronic` документы, содержащие это условие поиска в поле genre, становятся приоритетнее документов, содержащих это условие поиска в других полях, поддерживающих поиск, в индексе. Кроме того, документы, содержащие слово *rock*, будут иметь более высокий приоритет, чем документы, содержащие слово *electronic*, так как введен коэффициент повышения приоритета (2).  

 Чтобы повысить приоритет условия поиска, используйте символ крышки "^" и коэффициент повышения приоритета (число) в конце этого условия. Вы также можете повысить приоритет фразы. Чем выше коэффициент повышения приоритета, тем приоритетнее условие поиска относительно других. Коэффициент повышения приоритета по умолчанию — 1. Несмотря на то что коэффициент повышения приоритета должен быть положительным числом, он может быть меньше 1 (например, 0,20).  

##  <a name="regular-expression-search"></a><a name="bkmk_regex"></a> Поиск с использованием регулярных выражений  
 Операция поиска по регулярным выражениям позволяет найти совпадение в зависимости от содержимого между косыми чертами "/", как указано в документации [класса RegExp](https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/util/automaton/RegExp.html).  

 Например, чтобы найти документы, содержащие "motel" или "hotel", укажите `/[mh]otel/`.  Поиск с регулярными выражениями сопоставляется с отдельными словами.   

##  <a name="wildcard-search"></a><a name="bkmk_wildcard"></a>Поиск wildcard  
 Вы можете использовать распознаваемый синтаксис для поиска с использованием одного (?) или нескольких (*) подстановочных знаков. Обратите внимание, что средство синтаксического анализа запросов Lucene поддерживает использование этих символов для поиска одного слова, а не фразы.  

 Например, чтобы найти документы, содержащие слова с префиксом "note", например "notebook" или "notepad", укажите "note*".  

> [!NOTE]  
>  Символ "*" или "?" не может находиться в начале поискового запроса.  
>  Анализ текста для поисковых запросов с использованием подстановочных знаков не выполняется. Во время выполнения запроса термины запроса с подстановочным знаком сравниваются с проанализированными терминами в индексе поиска и расширяются.

## <a name="see-also"></a>См. также  

+ [Поиск документов](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
+ [Синтаксис выражений OData для предложений фильтрации и упорядочивания в службе "Поиск Azure"](query-odata-filter-orderby-syntax.md)   
+ [Простой синтаксис запроса в когнитивном поиске Azure](query-simple-syntax.md)   
