---
title: Синтаксис запросов Lucene
titleSuffix: Azure Cognitive Search
description: Ссылка на полный синтаксис запроса Lucene, используемый в Azure Cognitive Search для подстановочного знака, нечеткого поиска, RegEx и других расширенных конструкций запросов.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/10/2020
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: f4c3330b23b8b724cdbf5d7e09eec8a8dd5b8cfa
ms.sourcegitcommit: 8dc84e8b04390f39a3c11e9b0eaf3264861fcafc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/13/2020
ms.locfileid: "81258989"
---
# <a name="lucene-query-syntax-in-azure-cognitive-search"></a>Синтаксис Lucene запросв в Azure Cognitive Search

Вы можете писать запросы против Azure Cognitive Search на основе богатого синтаксиса [Lucene Query Parser](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html) для специализированных форм запросов: подстановочный знак, нечеткий поиск, поиск поблизости, регулярные выражения – вот несколько примеров. Большая часть синтаксиса Lucene Query Parser [реализована в Azure Cognitive Search,](search-lucene-query-architecture.md)за исключением `$filter` *поиска диапазона,* который строится в Azure Cognitive Search с помощью выражений. 

> [!NOTE]
> Полный синтаксис Lucene используется для выражения запроса, передаваемого в параметре **поиска** API [Поисковых документов,](https://docs.microsoft.com/rest/api/searchservice/search-documents) не следует путать с [синтаксисом OData,](query-odata-filter-orderby-syntax.md) используемым для [$filter](search-filters.md) параметра этого API. Эти различные синтаксисы имеют свои собственные правила для построения запросов, избегая строк и так далее.

## <a name="invoke-full-parsing"></a>Вызвать полный разбор

Задайте для параметра поиска значение `queryType`, чтобы указать, какое средство синтаксического анализа использовать. Допустимые значения: `simple|full` (`simple` как значение по умолчанию, а `full` как значение Lucene). 

<a name="bkmk_example"></a> 

### <a name="example-showing-full-syntax"></a>Пример полного синтаксиса

В следующем примере выполняется поиск документов в индексе с использованием синтаксиса запросов Lucene, что очевидно из параметра `queryType=full`. Этот запрос возвращает гостиницы, у которых поле «Категория» содержит термин «бюджет», а все поля для поиска содержат фразу «недавно сделан ремонт». Документам, содержащим слова "недавно сделан ремонт", присваивается более высокая оценка в результате повышенного значения этого термина (3).  

Параметр `searchMode=all` подходит для данного примера. Когда операторы находятся в запросе, обычно следует установить параметр `searchMode=all`, чтобы убедиться, что *все* критерии будут удовлетворены.

```
GET /indexes/hotels/docs?search=category:budget AND \"recently renovated\"^3&searchMode=all&api-version=2019-05-06&querytype=full
```

 Или используйте POST:  

```
POST /indexes/hotels/docs/search?api-version=2019-05-06
{
  "search": "category:budget AND \"recently renovated\"^3",
  "queryType": "full",
  "searchMode": "all"
}
```

Дополнительные примеры приведены [в примерах синтаксиса Lucene для создания запросов в Azure Cognitive Search.](search-query-lucene-examples.md) Подробнее об определении полного контингента параметров запроса читайте в материале [«Поисковые документы &#40;Azure Cognitive Search REST API&#41;. ](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)

> [!NOTE]  
>  Azure Cognitive Search также поддерживает [простой syntax запросов](query-simple-syntax.md), простой и надежный язык запросов, который может быть использован для простого поиска ключевых слов.  

##  <a name="syntax-fundamentals"></a><a name="bkmk_syntax"></a> Основные сведения о синтаксисе  

следующие основы синтаксиса применяются ко всем запросам, которые используют синтаксис Lucene.  

### <a name="operator-evaluation-in-context"></a>Оценивание операторов в контексте

Размещение определяет, как будет интерпретироваться символ: как оператор или просто как другой знак в строке.

Например, в полном синтаксисе Lucene тильда (~) используется для поиска нечетких соответствий и для поиска с учетом расположения. Если ~ ставится после фразы в кавычках, вызывается поиск с учетом расположения. Если ~ ставится в конце термина, вызывается поиск нечетких соответствий.

Внутри термина, такого как "business~analyst", знак не оценивается как оператор. В этом случае, предположив, что это запрос термина или фразы, [полнотекстовый поиск](search-lucene-query-architecture.md) с [лексическим анализом](search-lucene-query-architecture.md#stage-2-lexical-analysis) удаляет ~ и разбивает термин "business~analyst" на две части: business OR analyst.

В приведенном выше примере используется тильда (~), но тот же принцип применяется к каждому оператору.

### <a name="escaping-special-characters"></a>Экранирование специальных знаков

Для того, чтобы использовать любой из поисковых операторов в качестве части текста поиска, избежать символа, предварительно его с одной backslash (`\`). Например, для поиска подстановочных знаков на, `https://`где `://` находится `search=https\:\/\/*`часть строки запроса, вы укажете. Аналогичным образом, сбежавший шаблон `\+1 \(800\) 642\-7676`номера телефона может выглядеть следующим образом.

Специальные символы, требующие побега, включают в себя следующее:  
`+ - & | ! ( ) { } [ ] ^ " ~ * ? : \ /`  

> [!NOTE]  
> Хотя побег держит токены вместе, [лексический анализ](search-lucene-query-architecture.md#stage-2-lexical-analysis) во время индексации может лишить их. Например, стандартный анализатор Lucene будет ломать слова на дефисах, белом пространстве и других символах. Если требуется специальные символы в строке запроса, может потребоваться анализатор, который сохраняет их в индексе. Некоторые варианты включают [анализаторы](index-add-language-analyzers.md)естественного языка Майкрософт , который сохраняет дефисные слова, или пользовательский анализатор для более сложных шаблонов. Для получения дополнительной [информации см.](search-query-partial-matching.md)

### <a name="encoding-unsafe-and-reserved-characters-in-urls"></a>Кодирование небезопасных и зарезервированных знаков в URL-адресах

Убедитесь, что в URL-адресе закодированы все небезопасные и зарезервированные знаки. Например, «К» — это небезопасный символ, поскольку он является идентификатором фрагмента/якоря в URL-адресе. Знак должен быть закодирован как `%23`, если он используется в URL-адресе. «&» и «я» — это примеры зарезервированных символов, поскольку они разграничели параметры и указывают значения в Azure Cognitive Search. Для получения более подробной информации осваивай тесьмы [rFC1738: Единые локаторы ресурсов (URL)](https://www.ietf.org/rfc/rfc1738.txt) для получения более подробной информации.

Небезопасными знаками являются: ``" ` < > # % { } | \ ^ ~ [ ]``. Зарезервированными знаками являются: `; / ? : @ = + &`.

###  <a name="query-size-limits"></a><a name="bkmk_querysizelimits"></a>Ограничения по размеру запроса

 Размер запросов, которые можно отправить в Azure Cognitive Search, ограничен. В частности, вы можете иметь не более 1024 предложений (выражения, разделенные AND, OR и т. д.). Кроме того, размер любого отдельного термина в запросе не может превышать 32 КБ. Если приложение создает поисковые запросы программным способом, рекомендуется разрабатывать его таким образом, чтобы оно не создавало запросы неограниченного размера.  

### <a name="precedence-operators-grouping"></a>Операторы прецедента (группировка)

 Вы можете использовать круглые скобки, чтобы создать вложенные запросы, включая операторы в заключенной в скобки инструкции. Например, `motel+(wifi||luxury)` будет выполнять поиск документов, содержащих термин "motel" и "wifi" или "luxury" (или оба).

Группирование полей аналогично, но группирование ограничивается одним полем. Например, `hotelAmenities:(gym+(wifi||pool))` ищет в поле "hotelAmenities" термины "gym" и "wifi" или "gym" и "pool".  

##  <a name="boolean-search"></a><a name="bkmk_boolean"></a>Булеан поиска

 Всегда указывайте текстовые логические операторы (AND, OR, NOT) прописными буквами.  

### <a name="or-operator-or-or-"></a>Оператор OR (`OR` или `||`)

Оператор OR представляет собой вертикальную черту. Например, условие `wifi || luxury` будет искать документы, содержащие "wifi" или "luxury", или и то и другое. Так как OR является оператором соединения по умолчанию, вы также можете его оставить, то есть `wifi luxury` аналогично `wifi || luxury`.

### <a name="and-operator-and--or-"></a>Оператор AND (`AND`, `&&` или `+`)

Оператор AND представляет собой знак амперсанда или знак плюс. Например, условие `wifi && luxury` будет искать документы, содержащие и "wifi", и "luxury". Знак плюс (+) используется для обязательных терминов. Например, `+wifi +luxury` указывает, что оба термина должны появляться где-то в поле одного документа.

### <a name="not-operator-not--or--"></a>Оператор NOT (`NOT`, `!` или `-`)

Оператор NOT представляет собой знак минус. Например, `wifi –luxury` будет искать документы, которые имеют `wifi` термин `luxury`и / или не имеют .

Параметр **searchMode** в запросе запроса запроса контролирует, является ли термин с оператором NOT ANDed `+` `|` или ORed с другими терминами в запросе (при условии, что нет или оператора на других терминах). Допустимые значения: `any` и `all`.

`searchMode=any`увеличивает отзыв запросов, включив больше `-` результатов, и по умолчанию будет интерпретироваться как "ИЛИ НЕ". Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi`, или документам, которые не содержат термин `luxury`.

`searchMode=all`повышает точность запросов, включая меньше результатов, и по умолчанию - будет интерпретироваться как "И НЕ". Например, `wifi -luxury` соответствует документам, которые содержат термин `wifi` и не содержат термин "luxury". Вероятно, это более интуитивное поведение оператора `-`. Поэтому следует использовать `searchMode=all` вместо `searchMode=any` того, чтобы оптимизировать поиск точности, а `-` не напомнить, *а* также использовать оператора в поисковых запросах.

При принятии решения о настройках **searchMode** учитывайте шаблоны взаимодействия пользователей для запросов в различных приложениях. Пользователи, которые ищут информацию, с большей вероятностью включают оператора в запрос, в отличие от сайтов электронной коммерции, которые имеют более встроенные навигационные структуры.

##  <a name="fielded-search"></a><a name="bkmk_fields"></a>Полевый поиск

Вы можете определить полевую `fieldName:searchExpression` операцию поиска с помощью синтаксиса, где выражение поиска может быть одним словом или фразой, или более сложным выражением в скобках, по желанию с операторами Boolean. Вот несколько примеров.  

- genre:jazz NOT history  

- artists:("Miles Davis" "John Coltrane")

Добавьте несколько строк в кавычках, если необходимо, чтобы обе строки считались одной сущностью, в приведенном случае поиска двух разных исполнителей в поле `artists`.  

Поле, указанное в `fieldName:searchExpression`, должно быть полем `searchable`.  Дополнительные сведения об использовании атрибутов индекса в определениях полей см. в статье [Create Index (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/create-index) (Создание индексов (REST API службы "Поиск Azure")).  

> [!NOTE]
> При использовании полевых выражений поиска не `searchFields` нужно использовать параметр, поскольку каждое полевое выражение поиска имеет явно указанное имя поля. Тем не менее, `searchFields` вы все равно можете использовать параметр, если вы хотите запустить запрос, в котором некоторые части относятся к определенному полю, а остальные могут применяться к нескольким полям. `search=genre:jazz NOT history&searchFields=description` Например, запрос будет `jazz` соответствовать `genre` только полю, `NOT history` в `description` то время как он будет соответствовать с полем. Имя поля, `fieldName:searchExpression` представленное в всегда `searchFields` имеет приоритет над параметром, поэтому в `genre` этом `searchFields` примере нам не нужно включать в параметр.

##  <a name="fuzzy-search"></a><a name="bkmk_fuzzy"></a>Нечеткий поиск

Нечеткий поиск находит совпадения в терминах, которые имеют аналогичную конструкцию, расширяя термин до максимум5 терминов, которые отвечают критериям расстояния двух или менее. Для получения дополнительной [информации, см.](search-query-fuzzy.md)

 Чтобы выполнить поиск нечетких соответствий, необходимо поставить символ тильды "~" в конце слова. Дополнительно можно поставить цифру от 0 до 2 (по умолчанию), указывающую расстояние редактирования. Например, "blue~" или "blue~1" вернет результаты с "blue", "blues" и "glue".

 Нечеткий поиск может быть применен только к терминам, а не фразы, но вы можете приложить tilde к каждому термину индивидуально в нескольких частей имя или фразу. Например, "Unviersty" из "Wshington" будет соответствовать "Университет Вашингтона".
 
##  <a name="proximity-search"></a><a name="bkmk_proximity"></a>Поиск близости

Операция поиска с учетом расположения позволяет найти слова, расположенные рядом в документе. Вставьте символ тильды "~" в конце фразы, а затем — цифру, обозначающую количество слов, определяющее границу близости. Например, если ввести `"hotel airport"~5`, будут найдены слова "hotel" и "airport", расположенные в пределах 5 слов друг от друга в документе.  


##  <a name="term-boosting"></a><a name="bkmk_termboost"></a>Срок повышения

При повышении приоритета слов документы сортируются по приоритету, т. е. документы, в которых содержится условие поиска, имеют высший приоритет по отношению к документам, в которых его нет. Этот тип запроса отличается от профилей повышения, так как они повышают приоритет определенных полей, а не определенных слов.  

В следующем примере показаны эти различия. Предположим, что есть профиль повышения, который повышает приоритет совпадений в определенном поле, например, *genre* в [примере musicstoreindex](index-add-scoring-profiles.md#bkmk_ex). Повышение значимости слов может использоваться для дальнейшего повышения приоритета определенных условий поиска относительно других. Например, при вводе запроса `rock^2 electronic` документы, содержащие это условие поиска в поле genre, становятся приоритетнее документов, содержащих это условие поиска в других полях, поддерживающих поиск, в индексе. Кроме того, документы, содержащие слово *rock*, будут иметь более высокий приоритет, чем документы, содержащие слово *electronic*, так как введен коэффициент повышения приоритета (2).  

 Чтобы повысить приоритет условия поиска, используйте символ крышки "^" и коэффициент повышения приоритета (число) в конце этого условия. Вы также можете повысить приоритет фразы. Чем выше коэффициент повышения приоритета, тем приоритетнее условие поиска относительно других. Коэффициент повышения приоритета по умолчанию — 1. Несмотря на то что коэффициент повышения приоритета должен быть положительным числом, он может быть меньше 1 (например, 0,20).  

##  <a name="regular-expression-search"></a><a name="bkmk_regex"></a> Поиск с использованием регулярных выражений  
 Операция поиска по регулярным выражениям позволяет найти совпадение в зависимости от содержимого между косыми чертами "/", как указано в документации [класса RegExp](https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/util/automaton/RegExp.html).  

 Например, чтобы найти документы, содержащие "motel" или "hotel", укажите `/[mh]otel/`. Поиск с регулярными выражениями сопоставляется с отдельными словами.

Некоторые инструменты и языки налагают дополнительные требования к персонажу побега. Для JSON строки, которые включают передний слэш, `search=/.*microsoft.com\/azure\/.*/` избежаны с отсталой чертой: "microsoft.com/azure/" становится местом, где `search=/.* <string-placeholder>.*/` устанавливает регулярное выражение, и `microsoft.com\/azure\/` является строкой с сбежавшей вперед слэш.

##  <a name="wildcard-search"></a><a name="bkmk_wildcard"></a>Поиск wildcard  

Вы можете использовать распознаваемый синтаксис для поиска с использованием одного (?) или нескольких (*) подстановочных знаков. Обратите внимание, что средство синтаксического анализа запросов Lucene поддерживает использование этих символов для поиска одного слова, а не фразы.

Приставка поиска также использует звездочку ()`*`характер. Например, выражение запроса `search=note*` возврата "ноутбук" или "блокнот". Полный синтаксис Lucene не требуется для поиска префикса. Простой синтаксис поддерживает этот сценарий.

Поиск суффикса, где `*` или `?` предшествует строке, требует полного синтаксиса Lucene и регулярного выражения (вы не можете использовать q или ? символ как первый символ поиска). Учитывая термин "буквенное", выражение`search=/.*numeric.*/`запроса ( ) найдет совпадение.

> [!NOTE]  
> Во время анализа запросов запросы, сформулированные как префикс, суффикс, подстановочный знак или регулярные выражения передаются как это в дерево запроса, минуя [лексический анализ.](search-lucene-query-architecture.md#stage-2-lexical-analysis) Совпадения будут найдены только в том случае, если индекс содержит строки в формате, о котором указывается запрос. В большинстве случаев во время индексирования потребуется альтернативный анализатор, который сохраняет целостность строки, так что частичное соответствие термина и шаблона будет успешным. Для получения дополнительной информации смотрите [поиск частичного термина в запросах Azure Cognitive Search.](search-query-partial-matching.md)

##  <a name="scoring-wildcard-and-regex-queries"></a><a name="bkmk_searchscoreforwildcardandregexqueries"></a> Оценка запросов с подстановочными знаками и с регулярными выражениями

Azure Cognitive Search использует частотный скоринг[(TF-IDF)](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)для текстовых запросов. Однако для запросов с подстановочными знаками и регулярными выражениями, где область терминов может быть широкой, фактор частоты игнорируется, чтобы предотвратить смещение ранжирования в сторону совпадений с более редкими терминами. Все совпадения обрабатываются одинаково для поиска с подстановочными знаками и с регулярными выражениями.

## <a name="see-also"></a>См. также раздел

+ [Примеры запросов для простого поиска](search-query-simple-examples.md)
+ [Примеры запросов для полного поиска Lucene](search-query-lucene-examples.md)
+ [Поиск документов](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
+ [Синтаксис выражений OData для предложений фильтрации и упорядочивания в службе "Поиск Azure"](query-odata-filter-orderby-syntax.md)   
+ [Простой синтаксис запроса в когнитивном поиске Azure](query-simple-syntax.md)   
