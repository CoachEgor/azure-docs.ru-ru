---
title: Индексация больших двоичных объектов JSON из индексатора больших двоичных объектов Azure для полнотекстового поиска в службе "Поиск Azure"
description: Сканирование больших двоичных объектов Azure JSON для поиска текстового содержимого с помощью индексатора больших двоичных объектов службы поиска Azure. Индексаторы автоматизируют прием данных из выбранных источников, таких как хранилище BLOB-объектов Azure.
ms.date: 05/02/2019
author: HeidiSteen
manager: cgronlun
ms.author: heidist
services: search
ms.service: search
ms.devlang: rest-api
ms.topic: conceptual
ms.custom: seodec2018
ms.openlocfilehash: f60a41c48b3e78b860dca0e93d399420900dbd46
ms.sourcegitcommit: 9b80d1e560b02f74d2237489fa1c6eb7eca5ee10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/01/2019
ms.locfileid: "67485442"
---
# <a name="how-to-index-json-blobs-using-azure-search-blob-indexer"></a>Как индексировать большие двоичные объекты JSON, с помощью индексатора больших двоичных объектов поиска Azure
В этой статье показано, как настроить большой двоичный объект службы поиска Azure [индексатора](search-indexer-overview.md) извлечения структурированного содержимого из документов JSON в хранилище BLOB-объектов Azure и сделать его доступным для поиска в службе поиска Azure. Этот рабочий процесс создает индекс поиска Azure и загружает в него существующий текст, извлекаемый из больших двоичных объектов JSON. 

Вы можете использовать [портал](#json-indexer-portal), [REST API](#json-indexer-rest) или [пакет SDK для .NET](#json-indexer-dotnet) для индексирования содержимого JSON. Общие для всех подходов — что документов JSON, расположены в контейнер больших двоичных объектов в учетной записи хранилища Azure. Рекомендации по отправке документов JSON с других платформ, отличных от Azure, см. в разделе [Импорт данных в службе поиска Azure](search-what-is-data-import.md).

Обычно являются большие двоичные объекты JSON в хранилище BLOB-объектов Azure к одному документу JSON или коллекцию сущностей JSON. Для коллекции JSON, могут использоваться большой двоичный объект **массива** элементов правильный формат JSON. Большие двоичные объекты, также может состоять из нескольких отдельных сущностей JSON, разделенных символом новой строки. Индексатор больших двоичных объектов в службе поиска Azure может анализировать такие конструкции, в зависимости от того, как задать **parsingMode** параметр в запросе.

Все анализа режимов JSON (`json`, `jsonArray`, `jsonLines`) теперь общедоступны. 

> [!NOTE]
> Следуйте рекомендациям по конфигурации индексатора в [один ко многим индексирования](search-howto-index-one-to-many-blobs.md) для вывода нескольких поиск документов из одного BLOB-объектов Azure.

<a name="json-indexer-portal"></a>

## <a name="use-the-portal"></a>Использование портала

Самый простой способ индексирования документов JSON — использование мастера на [портале Azure](https://portal.azure.com/). Путем синтаксического анализа метаданных в контейнере больших двоичных объектов Azure мастер [**импорта данных**](search-import-data-portal.md) может создать индекс по умолчанию, сопоставить поля источника с целевыми полями индекса и загрузить индекс в рамках одной операции. В зависимости от размера и сложности исходных данных можно создать рабочий индекс полнотекстового поиска за считаные минуты.

Мы рекомендуем использовать той же подписке Azure для службы поиска Azure и служба хранилища Azure, желательно в том же регионе.

### <a name="1---prepare-source-data"></a>1\. Подготовка исходных данных

1. [Войдите на портал Azure](https://portal.azure.com/).

1. [Создайте контейнер больших двоичных объектов](https://docs.microsoft.com/azure/storage/blobs/storage-quickstart-blobs-portal) данных. Уровень общего доступа можно присвоить любой из его допустимых значений.

Вам потребуется имя учетной записи хранения, имя контейнера и ключ доступа для извлечения данных в **импорта данных** мастера.

### <a name="2---start-import-data-wizard"></a>2\. Запуск мастера импорта данных

На странице Общие сведения о службе поиска Azure, вы можете [запустить мастер](search-import-data-portal.md) на панели команд, или щелкнув **добавить поиск Azure** в **служба BLOB-объектов** часть вашей Учетная запись хранения левой панели навигации.

   ![Команда импорта данных на портале](./media/search-import-data-portal/import-data-cmd2.png "Запуск мастера импорта данных")

### <a name="3---set-the-data-source"></a>3\. Настройка источника данных

На странице **Источник данных** должен быть указан источник **Хранилище BLOB-объектов Azure** со следующими спецификациями.

+ Для параметра **Извлекаемые данные** выберите *Контент и метаданные*. При выборе этого варианта мастер может определить схему индекса и сопоставить поля для импорта.
   
+ **Режим анализа** должно быть присвоено *JSON*, *массив JSON* или *строки JSON*. 

  *JSON* определяет каждый большой двоичный объект как один поисковой документ, отображающийся как независимый элемент в результатах поиска. 

  *Массив JSON* большие двоичные объекты, которые содержат данные правильного JSON - JSON с правильным форматом, соответствующий массив объектов, или имеет свойство, которое представляет собой массив объектов, и нужно быть определена как отдельный документ независимых поиска каждого элемента. Если большие двоичные объекты являются составными и вы не выберете *Массив JSON*, весь большой двоичный объект будет обработан как один документ.

  *Строки JSON* — для BLOB-объекты состоят из нескольких сущностей JSON, разделенных строки, где будут каждой сущности, чтобы быть определена как документ автономного независимых поиска. Если большие двоичные объекты являются сложными, и вы не выберете *строки JSON* синтаксического анализа в режиме, а затем весь большой двоичный объект принимаются как один документ.
   
+ Для параметра **Контейнер хранилища** укажите свою учетную запись хранения и контейнер или строку подключения, которая разрешается к контейнеру. Строки подключения можно получить на странице портала службы BLOB-объектов.

   ![Определение источника данных BLOB-объектов](media/search-howto-index-json/import-wizard-json-data-source.png)

### <a name="4---skip-the-add-cognitive-search-page-in-the-wizard"></a>4\. Пропуск страницы "Добавление когнитивного поиска" в мастере

Добавление когнитивных навыков не требуется для импорта документов JSON. Если у вас нет необходимости [включать API-интерфейсы Cognitive Services и преобразования](cognitive-search-concept-intro.md) в конвейер индексирования, пропустите этот шаг.

Чтобы пропустить шаг, сначала перейдите к следующей странице.

   ![Кнопка следующей страницы для когнитивного поиска](media/search-get-started-portal/next-button-add-cog-search.png)

С этой страницы можно перейти к настройке индекса.

   ![Пропуск шага когнитивных навыков](media/search-get-started-portal/skip-cog-skill-step.png)

### <a name="5---set-index-attributes"></a>5\. Настройка атрибутов индекса

На странице **Индекс** вы увидите список полей с типом данных и ряд флажков для настройки атрибутов индекса. Мастер создаст список полей, на основе метаданных и при выборке данных источника. 

Вы может массового выберите атрибуты, установив флажок над столбцом атрибутов. Выберите **доступный для получения** и **доступный для поиска** для каждого поля, который должен быть возвращен для клиентского приложения и подлежит обработки полнотекстового поиска. Вы заметите, что целых чисел не полный текст или Нечеткий поиск для поиска (числа вычисляются открытым текстом и которые часто используются в фильтрах).

Просмотрите описание [атрибуты индекса](https://docs.microsoft.com/rest/api/searchservice/create-index#bkmk_indexAttrib) и [языковых анализаторов](https://docs.microsoft.com/rest/api/searchservice/language-support) Дополнительные сведения. 

Просмотрите выбранные параметры. После запуска мастера создаются структуры физических данных и вы не сможете изменить эти поля без удаления и повторного создания всех объектов.

   ![Определение индексов больших двоичных объектов](media/search-howto-index-json/import-wizard-json-index.png)

### <a name="6---create-indexer"></a>6\. Создание индексатора

Полностью настроенный мастер создает три разных объекта в службе поиска. Объект источника данных и объект индекса сохраняются как именованные ресурсы в службе поиска Azure. На последнем шаге создает объект индексатора. Если присвоить индексатору имя, он будет существовать как отдельный ресурс, который можно запланировать и контролировать независимо от индекса и объекта источника данных, созданных в том же процессе мастера.

Если вы не знакомы с индексаторами, *индексатор* — это ресурс в службе поиска Azure, сканирующий внешний источник данных для поиска содержимого. Выходные данные мастера **импорта данных** — это индексатор, который сканирует источник данных JSON, извлекает содержимое для поиска и импортирует его в индекс поиска Azure.

   ![Определение индексатора больших двоичных объектов](media/search-howto-index-json/import-wizard-json-indexer.png)

Нажмите кнопку **OK** для запуска мастера и создания всех объектов. Индексирование начинается немедленно.

Вы можете отслеживать импорт данных на страницах портала. Уведомления о ходе выполнения указывают состояние индексирования и количество передаваемых документов. 

По завершении индексирования можно использовать [Проводник поиска](search-explorer.md), чтобы отправить запрос индексу.

> [!NOTE]
> Если вы не видите нужные данные, может потребоваться установить дополнительные атрибуты для дополнительных полей. Удаление индекса и индексатора, вы только что создали и следуйте инструкциям в мастере, изменив выбранные параметры атрибуты индекса на шаге 5. 

<a name="json-indexer-rest"></a>

## <a name="use-rest-apis"></a>Использование REST API

REST API можно использовать для индексирования больших двоичных объектов JSON, следуя трехкомпонентного рабочему процессу общие для всех индексаторов в службе поиска Azure: Создание источника данных, создание индекса, создайте индексатор. Извлечение данных из хранилища BLOB-объектов возникает, когда при отправке запроса Создание индексатора. После завершения этого запроса будет иметь поддерживает запросы индекс. 

Вы можете просмотреть [пример кода REST](#rest-example) в конце этого раздела, показано, как создать все три объекта. Этот раздел также содержит сведения о [анализа режимов JSON](#parsing-modes), [единый большие двоичные объекты](#parsing-single-blobs), [массивы JSON](#parsing-arrays), и [вложенные массивы](#nested-json-arrays).

Для подобных индексирования JSON используйте [Postman](search-get-started-postman.md) и REST API для создания этих объектов:

+ [Индекс](https://docs.microsoft.com/rest/api/searchservice/create-index)
+ [Источник данных](https://docs.microsoft.com/rest/api/searchservice/create-data-source)
+ [Индексатор](https://docs.microsoft.com/rest/api/searchservice/create-indexer)

Порядок операций необходимо создать и вызвать объекты в указанном порядке. В отличие от портала рабочего процесса, подход код требует доступным индексом, чтобы принять через документы JSON **Создание индексатора** запроса.

Обычно являются большие двоичные объекты JSON в хранилище BLOB-объектов Azure к одному документу JSON или JSON «array». Индексатор больших двоичных объектов в службе поиска Azure может анализировать любую конструкцию в зависимости от значения параметра **parsingMode** в запросе.

| Документ JSON | parsingMode | Описание | Доступность |
|--------------|-------------|--------------|--------------|
| Один на большой двоичный объект | `json` | Анализирует большие двоичные объекты JSON как отдельный блок текста. Каждый большой двоичный объект JSON становится отдельным документом в службе поиска Azure. | Общедоступен в [REST](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) API и [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer) SDK. |
| Несколько на большой двоичный объект | `jsonArray` | Анализирует массив JSON в большом двоичном объекте, где каждый элемент массива становится отдельным документом в службе поиска Azure.  | Общедоступен в [REST](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) API и [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer) SDK. |
| Несколько на большой двоичный объект | `jsonLines` | Выполняет синтаксический анализ большого двоичного объекта, который содержит несколько сущностей JSON («массив»), разделенных символом новой строки, где каждая сущность становится отдельным документом. | Общедоступен в [REST](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) API и [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer) SDK. |

### <a name="1---assemble-inputs-for-the-request"></a>1 — Создание входных данных для запроса

Для каждого запроса необходимо указать имя службы и ключ администратора для службы поиска Azure (в заголовке POST) и имя учетной записи хранения и ключ для хранилища BLOB-объектов. Можно использовать [Postman](search-get-started-postman.md) для отправки HTTP-запросы в службу поиска Azure.

Скопируйте следующие четыре значения в Блокнот, чтобы их можно вставить в запрос:

+ Имя службы поиска Azure
+ Ключ администратора Azure поиска
+ Имя учетной записи хранения Azure
+ Ключ учетной записи хранения Azure

Эти значения можно найти на портале:

1. На страницах портала для службы поиска Azure скопируйте URL-адрес службы поиска на странице обзора.

2. В области навигации слева щелкните **ключи** и скопируйте либо первичный или вторичный ключ (они эквивалентны).

3. Переключитесь на страницы портала для вашей учетной записи хранения. В области навигации слева в разделе **параметры**, нажмите кнопку **ключи доступа**. Эта страница содержит ключ и имя учетной записи. Скопируйте имя учетной записи хранения и один из ключей в Блокнот.

### <a name="2---create-a-data-source"></a>2 - Создание источника данных

Здесь приводятся данные о соединении с источником используемых индексатором. Источник данных — именованный объект в поиске Azure, которая сохраняет сведения о соединении. Тип, источника данных `azureblob`, определяет, какие поведения извлечения данных вызываются индексатора. 

Замените допустимые значения для имени службы, ключ администратора, учетной записи хранения, и учетной записи ключа заполнители.

    POST https://[service name].search.windows.net/datasources?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }   

### <a name="3---create-a-target-search-index"></a>3 - Создание целевого индекса поиска 

Индексаторы связываются со схемой индекса. При использовании API-интерфейса (а не портала) необходимо предварительно подготовить индекс для указания в операции индексатора.

Индекс хранит пригодное для поиска содержимое в службе поиска Azure. Чтобы создать индекс, предоставьте схему, которая задает поля в документе, атрибуты и другие компоненты, которые определяют процедуру поиска. Если вы создаете индекс, который имеет те же имена полей и типы данных в качестве источника, индексатор будет сопоставлять поля источника и назначения и вам не придется явным образом сопоставлять эти поля.

В следующем примере показан запрос [Создать индекс](https://docs.microsoft.com/rest/api/searchservice/create-index). У индекса будет доступное для поиска поле `content` для хранения текста, извлеченного из больших двоичных объектов:   

    POST https://[service name].search.windows.net/indexes?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }


### <a name="4---configure-and-run-the-indexer"></a>4 - Настройка и выполнение индексатора

Как и в индекс и данных источника и индексатор также именованный объект, который вы создаете и повторно использовать в службе поиска Azure. Полностью указанный запрос создать индексатор может выглядеть следующим образом:

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } }
    }

Конфигурации индексатора находится в теле запроса. Требуется источник данных и пустой целевой индекс, который уже существует в службе поиска Azure. 

Расписание и параметры являются необязательными. Если опустить их, сразу же запускается индексатор, используя `json` как режим анализа.

Этот определенный индексатор не включает сопоставления полей. В определении индексатора, вы можете оставить **сопоставления полей** Если свойств исходного документа JSON соответствует полей целевого индекса поиска. 


### <a name="rest-example"></a>С помощью REST

Ниже представлен краткий обзор всех запросов, используемых для создания объектов. Описание компонентов см. в разделе в предыдущих разделах этой статьи.

### <a name="data-source-request"></a>Запрос источника данных

Все индексаторы требуется объект источника данных, который предоставляет сведения о подключении к существующим данным. 

    POST https://[service name].search.windows.net/datasources?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }  


### <a name="index-request"></a>Запрос индекса

Все индексаторы требуют целевой индекс, который получает данные. Текст запроса определяет схему индекса, состоящая из поля, с атрибутом для поддержки ожидаемого поведения в поисковый индекс. Этот индекс должен быть пустым, при выполнении индексатора. 

    POST https://[service name].search.windows.net/indexes?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }


### <a name="indexer-request"></a>Запрос индексатора

Этот запрос показывает индексатора, указано полностью. Он включает сопоставления полей, которые были пропущены в предыдущих примерах. Помните, что «schedule», «parameters», и «fieldMappings» являются необязательными, до тех пор, пока доступны по умолчанию. Пропуск «schedule» приводит к индексатор для немедленного запуска. Пропуск «parsingMode» вызывает индекс, используемый по умолчанию «json».

Создание индексатора поиска Azure активирует импорта данных. Он выполняется немедленно и затем по расписанию, если вы предоставили.

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } },
      "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
        ]
    }


<a name="json-indexer-dotnet"></a>

## <a name="use-net-sdk"></a>Использование пакета SDK для .NET

Пакет SDK для .NET имеет полного соответствия с REST API. Мы рекомендуем прочитать предыдущий раздел о REST API, чтобы ознакомиться с концепциями, рабочим процессом и требованиями. Используйте следующую справочную документацию по .NET API для реализации индексатора JSON в управляемом коде.

+ [microsoft.azure.search.models.datasource](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.datasource?view=azure-dotnet)
+ [microsoft.azure.search.models.datasourcetype](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.datasourcetype?view=azure-dotnet) 
+ [microsoft.azure.search.models.index](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.index?view=azure-dotnet) 
+ [microsoft.azure.search.models.indexer](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer?view=azure-dotnet)

<a name="parsing-modes"></a>

## <a name="parsing-modes"></a>Режимы анализа

Большие двоичные объекты JSON может принимать несколько форм. **ParsingMode** параметр в индексаторе JSON определяет, как содержимое больших двоичных объектов JSON анализируется и структуру в индекс службы поиска Azure:

| parsingMode | Описание |
|-------------|-------------|
| `json`  | Индекс каждого большого двоичного объекта в качестве одного документа. Это уровень по умолчанию. |
| `jsonArray` | Выберите этот режим, если большие двоичные объекты состоят из массивов JSON и требуется каждый элемент массива в виде отдельного документа в службе поиска Azure. |
|`jsonLines` | Выберите этот режим, если большие двоичные объекты состоят из нескольких сущностей JSON, которые разделяются строки, и требуется, чтобы каждая сущность в качестве отдельного документа в службе поиска Azure. |

Документ можно представить себе как отдельный элемент в результатах поиска. Если требуется, чтобы каждый элемент массива отображались в результатах поиска, как независимый элемент, используйте `jsonArray` или `jsonLines` , соответственно.

В определении индексатора можно использовать [сопоставление полей](search-indexer-field-mappings.md) для выбора свойств исходного документа JSON, применяемых для заполнения целевого индекса поиска. Для `jsonArray` режим, анализа в том случае, если массив существует как свойство нижнего уровня, можно задать корневой каталог документов, указывающее, где размещается массива в большой двоичный объект.

> [!IMPORTANT]
> При использовании `json`, `jsonArray` или `jsonLines` режим анализа, поиска Azure будет предполагает, что все большие двоичные объекты в источнике данных содержат JSON. Если необходима поддержка как объектов JSON, так и других объектов в одном источнике данных, сообщите нам об этом на [нашем сайте UserVoice](https://feedback.azure.com/forums/263029-azure-search).


<a name="parsing-single-blobs"></a>

## <a name="parse-single-json-blobs"></a>Синтаксический анализ отдельных BLOB-объектов JSON

По умолчанию [индексатор больших двоичных объектов Поиска Azure](search-howto-indexing-azure-blob-storage.md) анализирует большие двоичные объекты JSON как один блок текста. Часто требуется сохранить структуру документов JSON. Например, предположим, что в хранилище BLOB-объектов Azure имеется следующий документ JSON:

    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13",
            "tags" : [ "search", "storage", "howto" ]    
        }
    }

Индексатор больших двоичных объектов анализирует документ JSON как один документ поиска Azure. Индексатор загружает индекс, сопоставляя значения text, datePublished и tags из источника с идентичными по названию и типу целевыми полями индекса.

Как уже отмечалось, сопоставления полей необязательны. Если имеется индекс с полями "text", "datePublished и "tags", индексатор больших двоичных объектов может определить правильное сопоставление без наличия сопоставления полей в запросе.

<a name="parsing-arrays"></a>

## <a name="parse-json-arrays"></a>Анализировать массивы JSON

Кроме того можно использовать параметр массива JSON. Этот параметр полезен, если большие двоичные объекты содержат *массив объектов JSON правильного*, и необходимо представить в виде отдельного документа поиска Azure каждый элемент. Например, если имеется следующий большой двоичный объект JSON, можно заполнить индекс поиска Azure тремя отдельными документами, каждый из которых содержит поля "id" и "text".  

    [
        { "id" : "1", "text" : "example 1" },
        { "id" : "2", "text" : "example 2" },
        { "id" : "3", "text" : "example 3" }
    ]

Для массива JSON определение индексатора должно выглядеть, как в следующем примере. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonArray`. Указание правой средство синтаксического анализа и наличие нужных данных входные данные являются только два требования к массиву для индексирования больших двоичных объектов JSON.

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonArray" } }
    }

Снова отметим, что сопоставления полей необязательны. Если имеется индекс с полями с аналогичными именами id и text, индексатор больших двоичных объектов может определить правильное сопоставление без явного списка сопоставления полей.

<a name="nested-json-arrays"></a>

## <a name="parse-nested-arrays"></a>Синтаксический анализ вложенных массивов
Для массивов JSON, вложенные элементы, можно указать `documentRoot` для указания многоуровневую структуру. Например, если большой двоичный объект выглядит следующим образом:

    {
        "level1" : {
            "level2" : [
                { "id" : "1", "text" : "Use the documentRoot property" },
                { "id" : "2", "text" : "to pluck the array you want to index" },
                { "id" : "3", "text" : "even if it's nested inside the document" }  
            ]
        }
    }

Используйте эту конфигурацию для индексации массива, содержащегося в свойстве `level2`:

    {
        "name" : "my-json-array-indexer",
        ... other indexer properties
        "parameters" : { "configuration" : { "parsingMode" : "jsonArray", "documentRoot" : "/level1/level2" } }
    }

## <a name="parse-blobs-separated-by-newlines"></a>Синтаксический анализ больших двоичных объектов, разделенных новыми строками

Если большой двоичный объект содержит несколько сущностей JSON, разделенных символом новой строки, и необходимо представить в виде отдельного документа поиска Azure каждый элемент, вы можете для параметра строки JSON. Например, если имеется следующий большой двоичный объект (при наличии трех разных сущностей JSON), можно заполнить индекс службы поиска Azure тремя отдельными документами, каждый с полями «id» и «text».

    { "id" : "1", "text" : "example 1" }
    { "id" : "2", "text" : "example 2" }
    { "id" : "3", "text" : "example 3" }

Для строк JSON определение индексатора должен выглядеть аналогично приведенному ниже. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonLines`. 

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonLines" } }
    }

Опять же, обратите внимание, что сопоставления полей может быть опущен, аналогичную `jsonArray` режим анализа.

## <a name="add-field-mappings"></a>Добавление сопоставления полей

Если исходные и целевые поля не полностью согласованы, можно определить область сопоставления полей в тексте запроса для их явного сопоставления.

В настоящее время службы поиска Azure не может индексировать произвольные документы JSON напрямую, так как он поддерживает только типы-примитивы, массивов строк и точки GeoJSON. Однако с помощью **сопоставления полей** можно выбирать части документа JSON и "поднимать" до полей верхнего уровня документа поиска. Общие сведения о сопоставлении полей см. в статье [Сопоставление полей в индексаторах Поиска Azure](search-indexer-field-mappings.md).

Вернемся к нашему примеру документа JSON:

    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13"
            "tags" : [ "search", "storage", "howto" ]    
        }
    }

Допустим, что у вас есть индекс поиска со следующими полями: `text` типа `Edm.String`, `date` типа `Edm.DateTimeOffset` и `tags` типа `Collection(Edm.String)`. Обратите внимание на несоответствие между полем "datePublished" в источнике и полем `date` в индексе. Чтобы сопоставить JSON с необходимой формой, используйте следующие сопоставления полей:

    "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
      ]

Имена полей источника в сопоставлениях задаются с помощью нотации [указателя JSON](https://tools.ietf.org/html/rfc6901) . Укажите косую черту (корень документа JSON) и путь до нужного свойства (на произвольном уровне вложенности), разделяя элементы пути косой чертой.

Также можно ссылаться на отдельные элементы массива, используя отсчитываемый от нуля индекс. Например, чтобы выбрать первый элемент массива "tags" из приведенного выше примера, используйте следующее сопоставление полей:

    { "sourceFieldName" : "/article/tags/0", "targetFieldName" : "firstTag" }

> [!NOTE]
> Если имя поля источника в пути сопоставления полей ссылается на свойство, которое не существует в JSON, это сопоставление пропускается без ошибки. Это необходимо для поддержки документов с разными схемами (что часто встречается на практике). Поскольку проверка на ошибки не выполняется, будьте внимательны и не допускайте опечаток в спецификации сопоставления полей.
>
>

## <a name="see-also"></a>См. также

+ [Индексаторы в службе поиска Azure](search-indexer-overview.md)
+ [Индексирование BLOB-объектов JSON с помощью индексатора BLOB-объектов службы поиска Azure](search-howto-index-json-blobs.md)
+ [Индексирование BLOB-объектов в формате CSV с помощью индексатора BLOB-объектов службы поиска Azure](search-howto-index-csv-blobs.md)
+ [Учебник. Поиск частично структурированных данных в хранилище BLOB-объектов Azure](search-semi-structured-data.md)
