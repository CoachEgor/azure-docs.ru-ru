---
title: Индексация больших двоичных объектов JSON из индексатора больших двоичных объектов Azure для полнотекстового поиска в службе "Поиск Azure"
description: Сканирование больших двоичных объектов Azure JSON для поиска текстового содержимого с помощью индексатора больших двоичных объектов службы поиска Azure. Индексаторы автоматизируют прием данных из выбранных источников, таких как хранилище BLOB-объектов Azure.
ms.date: 05/02/2019
author: HeidiSteen
manager: nitinme
ms.author: heidist
services: search
ms.service: search
ms.devlang: rest-api
ms.topic: conceptual
ms.custom: seodec2018
ms.openlocfilehash: 147a2b690139aff546d82fc89a2fbcdefed03e01
ms.sourcegitcommit: 6eecb9a71f8d69851bc962e2751971fccf29557f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/17/2019
ms.locfileid: "72533750"
---
# <a name="how-to-index-json-blobs-using-azure-search-blob-indexer"></a>Индексация больших двоичных объектов JSON с помощью индексатора BLOB-объектов поиска Azure
В этой статье показано, как настроить [индексатор](search-indexer-overview.md) BLOB-объектов службы поиска Azure для извлечения структурированного содержимого из документов JSON в хранилище BLOB-объектов Azure и сделать его поиском в службе поиска Azure. Этот рабочий процесс создает индекс службы поиска Azure и загружает его с использованием существующего текста, извлеченного из больших двоичных объектов JSON. 

Вы можете использовать [портал](#json-indexer-portal), [REST API](#json-indexer-rest) или [пакет SDK для .NET](#json-indexer-dotnet) для индексирования содержимого JSON. Общие для всех подходов — документы JSON находятся в контейнере больших двоичных объектов в учетной записи хранения Azure. Рекомендации по отправке документов JSON с других платформ, отличных от Azure, см. в разделе [Импорт данных в службе поиска Azure](search-what-is-data-import.md).

BLOB-объекты JSON в хранилище BLOB-объектов Azure обычно представляют собой один документ JSON (режим анализа — `json`) или коллекцию сущностей JSON. Для коллекций большой двоичный объект может иметь **массив** элементов JSON правильного формата (режим анализа — `jsonArray`). Большие двоичные объекты также могут состоять из нескольких отдельных сущностей JSON, разделенных новой строкой (режим анализа `jsonLines`). Параметр **parsingMode** в запросе определяет выходные структуры.

> [!NOTE]
> Дополнительные сведения об индексировании нескольких поисковых документов из одного большого двоичного объекта см. в разделе [индексирование "один ко многим](search-howto-index-one-to-many-blobs.md)".

<a name="json-indexer-portal"></a>

## <a name="use-the-portal"></a>Использование портала

Самый простой способ индексирования документов JSON — использование мастера на [портале Azure](https://portal.azure.com/). Путем синтаксического анализа метаданных в контейнере больших двоичных объектов Azure мастер [**импорта данных**](search-import-data-portal.md) может создать индекс по умолчанию, сопоставить поля источника с целевыми полями индекса и загрузить индекс в рамках одной операции. В зависимости от размера и сложности исходных данных можно создать рабочий индекс полнотекстового поиска за считаные минуты.

Мы рекомендуем использовать одну и ту же подписку Azure как для службы поиска Azure, так и для хранилища Azure (желательно в том же регионе).

### <a name="1---prepare-source-data"></a>1\. Подготовка исходных данных

[Войдите в портал Azure](https://portal.azure.com/) и [создайте контейнер больших двоичных объектов](https://docs.microsoft.com/azure/storage/blobs/storage-quickstart-blobs-portal) , который будет содержать ваши данные. Для общего уровня доступа можно задать любое из его допустимых значений.

Для получения данных в мастере **импорта данных** потребуется имя учетной записи хранения, имя контейнера и ключ доступа.

### <a name="2---start-import-data-wizard"></a>2\. Запуск мастера импорта данных

На странице Обзор службы поиска Azure можно [запустить мастер](search-import-data-portal.md) с панели команд.

   ![Команда "Импорт данных" на портале](./media/search-import-data-portal/import-data-cmd2.png "Запуск мастера импорта данных")

### <a name="3---set-the-data-source"></a>3\. Настройка источника данных

На странице **Источник данных** должен быть указан источник **Хранилище BLOB-объектов Azure** со следующими спецификациями.

+ Для параметра **Извлекаемые данные** выберите *Контент и метаданные*. При выборе этого варианта мастер может определить схему индекса и сопоставить поля для импорта.
   
+ Для **режима синтаксического анализа** необходимо задать значение *JSON*, *массив JSON* или *строки JSON*. 

  *JSON* определяет каждый большой двоичный объект как один поисковой документ, отображающийся как независимый элемент в результатах поиска. 

  *Массив JSON* предназначен для больших двоичных объектов, содержащих правильно сформированные данные JSON — формат JSON правильного формата соответствует массиву объектов или имеет свойство, являющееся массивом объектов, и требуется, чтобы каждый элемент был определен как отдельный, независимый документ поиска. Если большие двоичные объекты являются составными и вы не выберете *Массив JSON*, весь большой двоичный объект будет обработан как один документ.

  *Строки JSON* используются для больших двоичных объектов, состоящих из нескольких сущностей JSON, разделенных новой строкой, где каждая сущность должна располагаться как автономный независимый документ поиска. Если большие двоичные объекты являются сложными и вы не выбираете режим синтаксического анализа *JSON-строк* , то весь большой двоичный объект принимается как один документ.
   
+ Для параметра **Контейнер хранилища** укажите свою учетную запись хранения и контейнер или строку подключения, которая разрешается к контейнеру. Строки подключения можно получить на странице портала службы BLOB-объектов.

   ![Определение источника данных BLOB-объектов](media/search-howto-index-json/import-wizard-json-data-source.png)

### <a name="4---skip-the-add-cognitive-search-page-in-the-wizard"></a>4\. Пропуск страницы "Добавление когнитивного поиска" в мастере

Добавление когнитивных навыков не требуется для импорта документов JSON. Если у вас нет необходимости [включать API-интерфейсы Cognitive Services и преобразования](cognitive-search-concept-intro.md) в конвейер индексирования, пропустите этот шаг.

Чтобы пропустить этот шаг, сначала перейдите на следующую страницу.

   ![Кнопка следующей страницы для когнитивного поиска](media/search-get-started-portal/next-button-add-cog-search.png)

На этой странице можно сразу перейти к настройке индекса.

   ![Пропуск шага когнитивных навыков](media/search-get-started-portal/skip-cog-skill-step.png)

### <a name="5---set-index-attributes"></a>5\. Настройка атрибутов индекса

На странице **Индекс** вы увидите список полей с типом данных и ряд флажков для настройки атрибутов индекса. Мастер может создать список полей на основе метаданных и выборки исходных данных. 

Можно выполнить групповое выделение атрибутов, установив флажок в верхней части столбца атрибута. Выберите возможность **извлечения** и **поиска** для каждого поля, которое должно быть возвращено клиентскому приложению и которое подлежит обработке полнотекстового поиска. Вы заметите, что целые числа не являются полным текстом или нечеткими для поиска (числа оцениваются буквально и часто используются в фильтрах).

Дополнительные сведения см. в описании [атрибутов индекса](https://docs.microsoft.com/rest/api/searchservice/create-index#bkmk_indexAttrib) и [языковых анализаторов](https://docs.microsoft.com/rest/api/searchservice/language-support) . 

Просмотрите выбранные параметры. После запуска мастера создаются структуры физических данных и вы не сможете изменить эти поля без удаления и повторного создания всех объектов.

   ![Определение индексов больших двоичных объектов](media/search-howto-index-json/import-wizard-json-index.png)

### <a name="6---create-indexer"></a>6\. Создание индексатора

Полностью настроенный мастер создает три разных объекта в службе поиска. Объект источника данных и объект индекса сохраняются как именованные ресурсы в службе поиска Azure. На последнем шаге создает объект индексатора. Если присвоить индексатору имя, он будет существовать как отдельный ресурс, который можно запланировать и контролировать независимо от индекса и объекта источника данных, созданных в том же процессе мастера.

Если вы не знакомы с индексаторами, *индексатор* — это ресурс в службе поиска Azure, сканирующий внешний источник данных для поиска содержимого. Выходные данные мастера **импорта данных** — это индексатор, который сканирует источник данных JSON, извлекает содержимое для поиска и импортирует его в индекс поиска Azure.

   ![Определение индексатора больших двоичных объектов](media/search-howto-index-json/import-wizard-json-indexer.png)

Нажмите кнопку **OK** для запуска мастера и создания всех объектов. Индексирование начинается немедленно.

Вы можете отслеживать импорт данных на страницах портала. Уведомления о ходе выполнения указывают состояние индексирования и количество передаваемых документов. 

По завершении индексирования можно использовать [Проводник поиска](search-explorer.md), чтобы отправить запрос индексу.

> [!NOTE]
> Если вы не видите нужные данные, может потребоваться задать дополнительные атрибуты для дополнительных полей. Удалите индекс и индексатор, которые вы только что создали, и снова пошаговые инструкции мастера, изменив параметры индексов на шаге 5. 

<a name="json-indexer-rest"></a>

## <a name="use-rest-apis"></a>Использование REST API

Вы можете использовать REST API для индексации больших двоичных объектов JSON, следуя рабочему процессу из трех частей, общим для всех индексаторов в службе поиска Azure: создание источника данных, создание индекса и создание индексатора. Извлечение данных из хранилища BLOB-объектов происходит при отправке запроса на создание индексатора. После завершения этого запроса у вас будет индекс с запросом. 

Вы можете ознакомиться с [кодом примера оставшейся](#rest-example) в конце этого раздела, в котором показано, как создать все три объекта. В этом разделе также содержатся сведения о [режимах синтаксического анализа JSON](#parsing-modes), [отдельных больших двоичных](#parsing-single-blobs)объектах, [массивах JSON](#parsing-arrays)и [вложенных массивах](#nested-json-arrays).

Для индексации JSON на основе кода используйте [POST](search-get-started-postman.md) и REST API для создания этих объектов:

+ [номер](https://docs.microsoft.com/rest/api/searchservice/create-index)
+ [Источник данных](https://docs.microsoft.com/rest/api/searchservice/create-data-source)
+ [индексатора](https://docs.microsoft.com/rest/api/searchservice/create-indexer)

Порядок операций требует создания и вызова объектов в этом порядке. В отличие от рабочего процесса портала, для реализации кода требуется доступный индекс для приема документов JSON, отправленных через запрос на **Создание индексатора** .

Большие двоичные объекты JSON в хранилище BLOB-объектов Azure обычно представляют собой один документ JSON или JSON-массив. Индексатор больших двоичных объектов в службе поиска Azure может анализировать любую конструкцию в зависимости от значения параметра **parsingMode** в запросе.

| Документ JSON | parsingMode | Описание | Доступность |
|--------------|-------------|--------------|--------------|
| Один на большой двоичный объект | `json` | Анализирует большие двоичные объекты JSON как отдельный блок текста. Каждый большой двоичный объект JSON становится отдельным документом в службе поиска Azure. | Общедоступно в [интерфейсе API и в](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) пакете SDK для [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer) . |
| Несколько на большой двоичный объект | `jsonArray` | Анализирует массив JSON в большом двоичном объекте, где каждый элемент массива становится отдельным документом в службе поиска Azure.  | Общедоступно в [интерфейсе API и в](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) пакете SDK для [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer) . |
| Несколько на большой двоичный объект | `jsonLines` | Анализирует большой двоичный объект, который содержит несколько сущностей JSON ("Array"), разделенных новой строкой, где каждая сущность превращается в отдельный документ службы поиска Azure. | Общедоступно в [интерфейсе API и в](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) пакете SDK для [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer) . |

### <a name="1---assemble-inputs-for-the-request"></a>1\. формирование входных данных для запроса

Для каждого запроса необходимо указать имя службы и ключ администратора для поиска Azure (в заголовке POST), а также имя и ключ учетной записи хранения для хранилища BLOB-объектов. Вы можете использовать [POST](search-get-started-postman.md) для отправки HTTP-запросов в службу поиска Azure.

Скопируйте следующие четыре значения в блокнот, чтобы их можно было вставить в запрос:

+ Имя службы поиска Azure
+ Ключ администратора поиска Azure
+ Имя учетной записи хранения Azure
+ Ключ учетной записи хранения Azure

Эти значения можно найти на портале:

1. На страницах портала для поиска Azure скопируйте URL-адрес службы поиска на странице Обзор.

2. В левой области навигации щелкните **ключи** , а затем скопируйте либо первичный, либо вторичный ключ (они эквивалентны).

3. Перейдите на страницу портала для своей учетной записи хранения. В области навигации слева в разделе **Параметры**щелкните **ключи доступа**. На этой странице указаны имя и ключ учетной записи. Скопируйте имя учетной записи хранения и один из ключей в Блокнот.

### <a name="2---create-a-data-source"></a>2\. Создание источника данных

Этот шаг предоставляет сведения о соединении с источником данных, используемые индексатором. Источник данных — это именованный объект в поиске Azure, который сохраняет сведения о подключении. Тип источника данных, `azureblob`, определяет, какие поведения извлечения данных вызываются индексатором. 

Замените допустимые значения для имени службы, ключа администратора, учетной записи хранения и заполнители ключа учетной записи.

    POST https://[service name].search.windows.net/datasources?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }   

### <a name="3---create-a-target-search-index"></a>3\. Создание целевого индекса поиска 

Индексаторы связываются со схемой индекса. При использовании API-интерфейса (а не портала) необходимо предварительно подготовить индекс для указания в операции индексатора.

Индекс хранит пригодное для поиска содержимое в службе поиска Azure. Чтобы создать индекс, предоставьте схему, которая задает поля в документе, атрибуты и другие компоненты, которые определяют процедуру поиска. Если вы создаете индекс, который имеет те же имена полей и типы данных в качестве источника, индексатор будет сопоставлять поля источника и назначения и вам не придется явным образом сопоставлять эти поля.

В следующем примере показан запрос [Создать индекс](https://docs.microsoft.com/rest/api/searchservice/create-index). У индекса будет доступное для поиска поле `content` для хранения текста, извлеченного из больших двоичных объектов:   

    POST https://[service name].search.windows.net/indexes?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }


### <a name="4---configure-and-run-the-indexer"></a>4\. Настройка и запуск индексатора

Как и в случае с индексом и источником данных, индексатор также является именованным объектом, который создается и повторно используется в службе поиска Azure. Полностью указанный запрос на создание индексатора может выглядеть следующим образом:

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } }
    }

Конфигурация индексатора находится в тексте запроса. Для этого требуется источник данных и пустой целевой индекс, который уже существует в службе поиска Azure. 

Расписание и параметры являются необязательными. Если опустить их, индексатор выполняется немедленно, используя `json` в качестве режима анализа.

Этот конкретный индексатор не включает сопоставления полей. В определении индексатора можно оставить **сопоставления полей** , если свойства ИСХОДНОГО документа JSON соответствуют полям целевого индекса поиска. 


### <a name="rest-example"></a>Пример для RESTFUL

В этом разделе приведен краткий обзор всех запросов, используемых для создания объектов. Описание частей компонентов см. в предыдущих разделах этой статьи.

### <a name="data-source-request"></a>Запрос к источнику данных

Для всех индексаторов требуется объект источника данных, который предоставляет сведения о соединении с существующими данными. 

    POST https://[service name].search.windows.net/datasources?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }  


### <a name="index-request"></a>Запрос индекса

Для всех индексаторов требуется целевой индекс, который получает данные. Текст запроса определяет схему индекса, состоящую из полей с атрибутами, поддерживающими требуемое поведение в индексе с возможностью поиска. При запуске индексатора этот индекс должен быть пустым. 

    POST https://[service name].search.windows.net/indexes?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }


### <a name="indexer-request"></a>Запрос индексатора

Этот запрос показывает полностью указанный индексатор. Он включает сопоставления полей, которые были пропущены в предыдущих примерах. Помните, что «Schedule», «Parameters» и «Фиелдмаппингс» являются необязательными, если доступно по умолчанию. Пропуск "Schedule" приводит к немедленному запуску индексатора. Пропуск "parsingMode" приводит к тому, что индекс использует значение по умолчанию "JSON".

Создание индексатора в службе поиска Azure инициирует импорт данных. Он выполняется немедленно, а затем по расписанию, если вы предоставили его.

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key for Azure Search]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } },
      "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
        ]
    }


<a name="json-indexer-dotnet"></a>

## <a name="use-net-sdk"></a>Использование пакета SDK для .NET

Пакет SDK для .NET полностью использует четность с REST API. Мы рекомендуем прочитать предыдущий раздел о REST API, чтобы ознакомиться с концепциями, рабочим процессом и требованиями. Используйте следующую справочную документацию по .NET API для реализации индексатора JSON в управляемом коде.

+ [microsoft.azure.search.models.datasource](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.datasource?view=azure-dotnet)
+ [microsoft.azure.search.models.datasourcetype](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.datasourcetype?view=azure-dotnet) 
+ [microsoft.azure.search.models.index](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.index?view=azure-dotnet) 
+ [microsoft.azure.search.models.indexer](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer?view=azure-dotnet)

<a name="parsing-modes"></a>

## <a name="parsing-modes"></a>Режимы анализа

Большие двоичные объекты JSON могут полагаться на несколько форм. Параметр **parsingMode** индексатора JSON определяет способ синтаксического анализа и структурирования содержимого больших двоичных объектов JSON в индексе поиска Azure:

| parsingMode | Описание |
|-------------|-------------|
| `json`  | Индексировать каждый BLOB-объект как отдельный документ. Это уровень по умолчанию. |
| `jsonArray` | Выберите этот режим, если большие двоичные объекты состоят из массивов JSON, и каждый элемент массива должен стать отдельным документом в службе поиска Azure. |
|`jsonLines` | Выберите этот режим, если большие двоичные объекты состоят из нескольких сущностей JSON, разделенных новой строкой, и требуется, чтобы каждая сущность стала отдельным документом в поиске Azure. |

Документ можно представить себе как отдельный элемент в результатах поиска. Если требуется, чтобы каждый элемент массива отображался в результатах поиска как независимый элемент, используйте параметр `jsonArray` или `jsonLines`.

В определении индексатора можно использовать [сопоставление полей](search-indexer-field-mappings.md) для выбора свойств исходного документа JSON, применяемых для заполнения целевого индекса поиска. Для режима синтаксического анализа `jsonArray`, если массив существует как свойство более низкого уровня, можно задать корневой каталог документа, указывающий место размещения массива в большом двоичном объекте.

> [!IMPORTANT]
> При использовании `json`, `jsonArray` или `jsonLines` режиме синтаксического анализа служба поиска Azure предполагает, что все большие двоичные объекты в источнике данных содержат JSON. Если необходима поддержка как объектов JSON, так и других объектов в одном источнике данных, сообщите нам об этом на [нашем сайте UserVoice](https://feedback.azure.com/forums/263029-azure-search).


<a name="parsing-single-blobs"></a>

## <a name="parse-single-json-blobs"></a>Анализ единичных больших двоичных объектов JSON

По умолчанию [индексатор больших двоичных объектов Поиска Azure](search-howto-indexing-azure-blob-storage.md) анализирует большие двоичные объекты JSON как один блок текста. Часто требуется сохранить структуру документов JSON. Например, предположим, что в хранилище BLOB-объектов Azure имеется следующий документ JSON:

    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13",
            "tags" : [ "search", "storage", "howto" ]    
        }
    }

Индексатор больших двоичных объектов анализирует документ JSON как один документ поиска Azure. Индексатор загружает индекс, сопоставляя значения text, datePublished и tags из источника с идентичными по названию и типу целевыми полями индекса.

Как уже отмечалось, сопоставления полей необязательны. Если имеется индекс с полями "text", "datePublished и "tags", индексатор больших двоичных объектов может определить правильное сопоставление без наличия сопоставления полей в запросе.

<a name="parsing-arrays"></a>

## <a name="parse-json-arrays"></a>Анализ массивов JSON

Кроме того, можно использовать параметр массива JSON. Этот параметр полезен, если большие двоичные *объекты содержат массив объектов JSON правильного формата*, и каждый элемент должен стать отдельным документом службы поиска Azure. Например, если имеется следующий большой двоичный объект JSON, можно заполнить индекс поиска Azure тремя отдельными документами, каждый из которых содержит поля "id" и "text".  

    [
        { "id" : "1", "text" : "example 1" },
        { "id" : "2", "text" : "example 2" },
        { "id" : "3", "text" : "example 3" }
    ]

Для массива JSON определение индексатора должно выглядеть, как в следующем примере. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonArray`. Указание правильного средства синтаксического анализа и ввод правильного ввода данных — единственные требования к массиву для индексирования больших двоичных объектов JSON.

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonArray" } }
    }

Снова отметим, что сопоставления полей необязательны. Если имеется индекс с полями с аналогичными именами id и text, индексатор больших двоичных объектов может определить правильное сопоставление без явного списка сопоставления полей.

<a name="nested-json-arrays"></a>

## <a name="parse-nested-arrays"></a>Анализ вложенных массивов
Для массивов JSON, имеющих вложенные элементы, можно указать `documentRoot` для указания многоуровневой структуры. Например, если большой двоичный объект выглядит следующим образом:

    {
        "level1" : {
            "level2" : [
                { "id" : "1", "text" : "Use the documentRoot property" },
                { "id" : "2", "text" : "to pluck the array you want to index" },
                { "id" : "3", "text" : "even if it's nested inside the document" }  
            ]
        }
    }

Используйте эту конфигурацию для индексации массива, содержащегося в свойстве `level2`:

    {
        "name" : "my-json-array-indexer",
        ... other indexer properties
        "parameters" : { "configuration" : { "parsingMode" : "jsonArray", "documentRoot" : "/level1/level2" } }
    }

## <a name="parse-blobs-separated-by-newlines"></a>Анализ больших двоичных объектов, разделенных символами новой строки

Если ваш большой двоичный объект содержит несколько сущностей JSON, разделенных новой строкой, и требуется, чтобы каждый элемент стал отдельным документом службы поиска Azure, можно выбрать параметр JSON Lines. Например, при наличии следующего большого двоичного объекта (в котором есть три различные сущности JSON) можно заполнить индекс службы поиска Azure тремя отдельными документами, каждый из которых имеет поля "ID" и "Text".

    { "id" : "1", "text" : "example 1" }
    { "id" : "2", "text" : "example 2" }
    { "id" : "3", "text" : "example 3" }

Для строк JSON определение индексатора должно выглядеть примерно так, как показано в следующем примере. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonLines`. 

    POST https://[service name].search.windows.net/indexers?api-version=2019-05-06
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonLines" } }
    }

Опять же, обратите внимание, что сопоставления полей можно опустить, как в режиме `jsonArray`ного анализа.

## <a name="add-field-mappings"></a>Добавление сопоставлений полей

Если исходные и целевые поля не полностью согласованы, можно определить область сопоставления полей в тексте запроса для их явного сопоставления.

В настоящее время Поиск Azure не может индексировать произвольные документы JSON напрямую, так как он поддерживает только типы данных-примитивы, массивы строк и геоточки формата JSON. Однако с помощью **сопоставления полей** можно выбирать части документа JSON и "поднимать" до полей верхнего уровня документа поиска. Общие сведения о сопоставлении полей см. в статье [Сопоставление полей в индексаторах Поиска Azure](search-indexer-field-mappings.md).

Вернемся к нашему примеру документа JSON:

    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13"
            "tags" : [ "search", "storage", "howto" ]    
        }
    }

Допустим, что у вас есть индекс поиска со следующими полями: `text` типа `Edm.String`, `date` типа `Edm.DateTimeOffset` и `tags` типа `Collection(Edm.String)`. Обратите внимание на несоответствие между полем "datePublished" в источнике и полем `date` в индексе. Чтобы сопоставить JSON с необходимой формой, используйте следующие сопоставления полей:

    "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
      ]

Имена полей источника в сопоставлениях задаются с помощью нотации [указателя JSON](https://tools.ietf.org/html/rfc6901) . Укажите косую черту (корень документа JSON) и путь до нужного свойства (на произвольном уровне вложенности), разделяя элементы пути косой чертой.

Также можно ссылаться на отдельные элементы массива, используя отсчитываемый от нуля индекс. Например, чтобы выбрать первый элемент массива "tags" из приведенного выше примера, используйте следующее сопоставление полей:

    { "sourceFieldName" : "/article/tags/0", "targetFieldName" : "firstTag" }

> [!NOTE]
> Если имя поля источника в пути сопоставления полей ссылается на свойство, которое не существует в JSON, это сопоставление пропускается без ошибки. Это необходимо для поддержки документов с разными схемами (что часто встречается на практике). Поскольку проверка на ошибки не выполняется, будьте внимательны и не допускайте опечаток в спецификации сопоставления полей.
>
>

## <a name="see-also"></a>Дополнительные материалы

+ [Индексаторы в службе поиска Azure](search-indexer-overview.md)
+ [Индексирование BLOB-объектов JSON с помощью индексатора BLOB-объектов службы поиска Azure](search-howto-index-json-blobs.md)
+ [Индексирование BLOB-объектов в формате CSV с помощью индексатора BLOB-объектов службы поиска Azure](search-howto-index-csv-blobs.md)
+ [Учебник. Поиск частично структурированных данных из хранилища BLOB-объектов Azure](search-semi-structured-data.md)
