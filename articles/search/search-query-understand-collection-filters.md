---
title: Общие сведения о фильтрах коллекции OData - в службе поиска Azure
description: Понимание того, как работают фильтры коллекции OData в запросах поиска Azure.
ms.date: 06/13/2019
services: search
ms.service: search
ms.topic: conceptual
author: brjohnstmsft
ms.author: brjohnst
ms.manager: cgronlun
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: 7af1b0ab95d04249d6d74e3324dbeb30eda6e1de
ms.sourcegitcommit: 41ca82b5f95d2e07b0c7f9025b912daf0ab21909
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "67079604"
---
# <a name="understanding-odata-collection-filters-in-azure-search"></a>Общие сведения о фильтрах коллекции OData в службе поиска Azure

Чтобы [фильтра](query-odata-filter-orderby-syntax.md) в коллекции полей в службе поиска Azure, вы можете использовать [ `any` и `all` операторы](search-query-odata-collection-operators.md) вместе с **лямбда-выражения**. Лямбда-выражения — это логические выражения, ссылающиеся на **переменная диапазона**. `any` И `all` операторы аналогичны `for` цикл, в большинстве языков программирования, переменная диапазона, принимая роль переменной цикла и лямбда-выражения в теле цикла. Переменная диапазона принимает значение «current» коллекции во время итерации цикла.

По крайней мере, как это работает по существу. На самом деле поиска Azure реализует фильтры очень другим способом на то, как `for` циклы работают. В идеале эта разница будет невидима для вас, но в некоторых случаях это не так. Конечным результатом является то, что существуют правила, которые необходимо учитывать при написании лямбда-выражения.

В этой статье объясняется, почему существуют правила для коллекции фильтров, изучив, как службы поиска Azure выполняет эти фильтры. Если вы создаете расширенные фильтры с помощью сложных лямбда-выражения, в этой статье могут оказаться полезными при построении понять возможности в фильтрах и почему.

Сведения о новые правила для коллекции фильтров, включая примеры, см. в разделе [фильтры коллекции OData, устранение неполадок в службе поиска Azure](search-query-troubleshoot-collection-filters.md).

## <a name="why-collection-filters-are-limited"></a>Почему ограничены коллекции фильтров

Существует три основные причины, почему бы не поддерживает все возможности фильтра для всех типов коллекций.

1. Для определенных типов данных поддерживаются только определенные операторы. Например, нет смысла для сравнения логические значения `true` и `false` с помощью `lt`, `gt`, и т. д.
1. Поиск Azure не поддерживает **коррелированные поиска** для полей типа `Collection(Edm.ComplexType)`.
1. Azure использует поиск обращена индексов для выполнения по всем типам данных, включая коллекции фильтров.

Первая причина — просто следствием того, как определяются язык OData и система типов модели EDM. Последние два описаны более подробно в оставшейся части этой статьи.

## <a name="correlated-versus-uncorrelated-search"></a>Коррелированных событий и некоррелированных поиска

При применении нескольких критериев фильтра по коллекции сложных объектов, они **коррелированные** так, как они применяются к *каждого объекта в коллекции*. Например следующий фильтр возвращает гостиницы, по крайней мере один deluxe места скорость меньше 100:

    Rooms/any(room: room/Type eq 'Deluxe Room' and room/BaseRate lt 100)

Если фильтрация *некоррелированных*, фильтр выше может возвращать гостиницы, где один комната открыта deluxe и другой комнате имеет базу оценить меньше 100. Это бессмысленно, поскольку обоим предложениям, лямбда-выражения применяются к той же переменной диапазона, а именно `room`. Именно поэтому такие фильтры связаны друг с другом.

Однако для полнотекстового поиска, нет способа для ссылки на переменную определенного диапазона. Если вы используете относящегося к полю поиска для выдачи [полный запрос Lucene](query-lucene-syntax.md) наподобие данного:

    Rooms/Type:deluxe AND Rooms/Description:"city view"

Вы можете получить гостиницы обратно deluxe одного места, куда другой комнате упоминания «Город view» в описании. Например, документ ниже `Id` из `1` сопоставил бы запрос:

```json
{
  "value": [
    {
      "Id": "1",
      "Rooms": [
        { "Type": "deluxe", "Description": "Large garden view suite" },
        { "Type": "standard", "Description": "Standard city view room" }
      ]
    },
    {
      "Id": "2",
      "Rooms": [
        { "Type": "deluxe", "Description": "Courtyard motel room" }
      ]
    }
  ]
}
```

Причина в том, что `Rooms/Type` ссылается на все проанализированные условия `Rooms/Type` поле во всем документе и аналогично для `Rooms/Description`, как показано в приведенных ниже таблицах.

Как `Rooms/Type` хранится для полнотекстового поиска:

| Термин в `Rooms/Type` | Идентификаторы документов |
| --- | --- |
| Deluxe | 1, 2 |
| standard | 1 |

Как `Rooms/Description` хранится для полнотекстового поиска:

| Термин в `Rooms/Description` | Идентификаторы документов |
| --- | --- |
| Внутренний двор отеля | 2 |
| city | 1 |
| сад | 1 |
| Большой | 1 |
| мотель | 2 |
| Комнаты | 1, 2 |
| standard | 1 |
| Suite | 1 |
| view | 1 |

Так что в отличие от фильтр выше, который по сути говорящую: «документы, где имеет комнаты `Type` равным «Deluxe комнату» и **этой же комнате** имеет `BaseRate` менее 100», запрос поиска следующим образом: «match Документирует where `Rooms/Type`включает термин «deluxe» и `Rooms/Description` содержит фразу «Город view». Отсутствует понятие отдельных комнат, поля которых могут быть связаны в последнем случае.

> [!NOTE]
> Если вы хотите см. в статье поддержка коррелированные поиска, которые добавлены в службу поиска Azure, проголосуйте за [этот элемент User Voice](https://feedback.azure.com/forums/263029-azure-search/suggestions/37735060-support-correlated-search-on-complex-collections).

## <a name="inverted-indexes-and-collections"></a>Инвертированные индексы и коллекции

Вы заметите, что существуют гораздо меньше ограничения на лямбда-выражения, по сравнению с коллекциями сложные, чем простых коллекций, такие как `Collection(Edm.Int32)`, `Collection(Edm.GeographyPoint)`, и т. д. Это обусловлено поиска Azure хранит сложные коллекции как фактический коллекции вложенных документов, хотя простых коллекций не хранятся в виде коллекций вообще.

Рассмотрим фильтруемых строковое поле коллекции как `seasons` в индексе для Интернет-магазине. Некоторые документы, загруженные для этого индекса может выглядеть следующим образом:

```json
{
  "value": [
    {
      "id": "1",
      "name": "Hiking boots",
      "seasons": ["spring", "summer", "fall"]
    },
    {
      "id": "2",
      "name": "Rain jacket",
      "seasons": ["spring", "fall", "winter"]
    },
    {
      "id": "3",
      "name": "Parka",
      "seasons": ["winter"]
    }
  ]
}
```

Значения `seasons` поле хранятся в структуру, называемую **инвертированный индекс**, который выглядит примерно следующим образом:

| Термин | Идентификаторы документов |
| --- | --- |
| Spring | 1, 2 |
| летние | 1 |
| Осень | 1, 2 |
| зимние | 2, 3 |

Эта структура данных призван ответить на один вопрос очень быстро: В котором отображается данный термин? Отвечая на этот вопрос работает более подобно проверку plain равенства, чем цикл по коллекции. На самом деле, это, почему для коллекций строк, поиск Azure разрешает только `eq` как оператор сравнения внутри лямбда-выражение для `any`.

Переходите к разработке на равенство, Далее мы рассмотрим как можно объединить несколько проверок на равенство с той же переменной диапазона, с `or`. Он работает благодаря алгебры и [свойству дистрибутивности квантификаторы](https://en.wikipedia.org/wiki/Existential_quantification#Negation). Это выражение:

    seasons/any(s: s eq 'winter' or s eq 'fall')

эквивалентно правилу

    seasons/any(s: s eq 'winter') or seasons/any(s: s eq 'fall')

При этом каждая из двух `any` вложенных выражений можно эффективно выполнить, используя Обращенный индекс. Кроме того, выражаем благодарность [закон отрицания квантификаторов](https://en.wikipedia.org/wiki/Existential_quantification#Negation), это выражение:

    seasons/all(s: s ne 'winter' and s ne 'fall')

эквивалентно правилу

    not seasons/any(s: s eq 'winter' or s eq 'fall')

Поэтому можно использовать `all` с `ne` и `and`.

> [!NOTE]
> Несмотря на то, что данные выходят за рамки данного документа, эти же принципы расширение в [расстояние и пересечение тестов для геопространственные точек](search-query-odata-geo-spatial-functions.md) также. Именно поэтому в `any`:
>
> - `geo.intersects` не может быть изменен
> - `geo.distance` необходимо сравнить с помощью `lt` или `le`
> - выражения должны быть объединены с `or`, а не `and`
>
> Применяются правила встречных `all`.

При фильтрации с коллекциями данных типы, поддерживающие запрещено использовать широкий ряд выражений `lt`, `gt`, `le`, и `ge` операторы, такие как `Collection(Edm.Int32)` для примера. В частности, можно использовать `and` производительны `or` в `any`, до тех пор, пока базовые выражения сравнения объединяются в **сравнения в диапазоне** с помощью `and`, которые затем являются Дополнительные в сочетании с помощью `or`. Эта структура логических выражений называется [формы дизъюнктивная Normal (DNF)](https://en.wikipedia.org/wiki/Disjunctive_normal_form), также известное как «OR and». И наоборот, лямбда-выражения для `all` для данных, эти типы должны находиться в [формы соединительным Normal (CNF)](https://en.wikipedia.org/wiki/Conjunctive_normal_form), также известное как «Запускалась OR». Поиск Azure позволяет такие сравнения диапазона, так как он может выполнять их с помощью обращена индексы эффективно, так же, как его можно быстро термин поиска для строк.

Таким образом ниже приведены правила для допустимых лямбда-выражение.

- Внутри `any`, *положительное проверки* всегда разрешены, такие как сравнение, сравнения диапазонов `geo.intersects`, или `geo.distance` по сравнению с `lt` или `le` (обработки «близость», как равенство когда дело доходит до проверки расстояния).
- Внутри `any`, `or` разрешен всегда. Можно использовать `and` только для типов данных, которые можно выразить проверки диапазона, а также при использовании OR запускалась (DNF).
- Внутри `all`, отменяются правила — только *отрицательные проверки* разрешены, можно использовать `and` всегда, и вы можете использовать `or` только для проверок диапазона, выраженное как запускалась из OR (CNF).

На практике это типы фильтров, которые вы чаще всего используется в любом случае. По-прежнему важно понимать, что не менее границы.

Конкретные примеры допускаются какие виды фильтров и который не, см. в разделе [как допустимую коллекцию фильтров записи](search-query-troubleshoot-collection-filters.md#bkmk_examples).

## <a name="next-steps"></a>Дальнейшие действия  

- [Устранение неполадок фильтры коллекции OData в службе поиска Azure](search-query-troubleshoot-collection-filters.md)
- [Фильтры в службе "Поиск Azure"](search-filters.md)
- [Общие сведения о языках выражений OData для службы поиска Azure](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для службы поиска Azure](search-query-odata-syntax-reference.md)
- [Search Documents (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/Search-Documents) (Поиск по документам (REST API службы "Поиск Azure"))
