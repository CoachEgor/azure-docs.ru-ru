---
title: Общие сведения о фильтрах коллекции OData — Поиск Azure
description: Основные сведения о работе фильтров коллекции OData в запросах поиска Azure.
ms.date: 06/13/2019
services: search
ms.service: search
ms.topic: conceptual
author: brjohnstmsft
ms.author: brjohnst
manager: nitinme
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: 5c3a0205f5a9ac5115e78f1bc11f70b2c50a9714
ms.sourcegitcommit: bb8e9f22db4b6f848c7db0ebdfc10e547779cccc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2019
ms.locfileid: "69647427"
---
# <a name="understanding-odata-collection-filters-in-azure-search"></a>Общие сведения о фильтрах коллекции OData в службе поиска Azure

Для [фильтрации](query-odata-filter-orderby-syntax.md) по полям коллекции в службе поиска Azure можно использовать [ `any` операторы и `all` ](search-query-odata-collection-operators.md) вместе с **лямбда-выражениями**. Лямбда-выражения — это логические выражения, которые ссылаются на **переменную диапазона**. Операторы и являются`all` аналогом циклавбольшинствеязыковпрограммирования,спеременнойдиапазона,принимающейрольпеременнойцикла,илямбда-выражениемвкачестветелацикла.`for` `any` Переменная диапазона принимает значение Current в коллекции во время итерации цикла.

По крайней мере, это работает по принципу концептуально. В реальности Поиск Azure реализует фильтры по-другому, как `for` работают циклы. В идеале это различие будет невидимым для вас, но в некоторых ситуациях это не так. Конечный результат заключается в том, что при написании лямбда-выражений необходимо следовать правилам.

В этой статье объясняется, почему правила для фильтров коллекции существуют, изучив, как служба поиска Azure выполняет эти фильтры. Если вы пишете расширенные фильтры с помощью сложных лямбда-выражений, эта статья поможет вам получить представление о возможностях фильтров и о том, почему.

Сведения о правилах фильтров коллекции, включая примеры, см. [в разделе Устранение неполадок фильтров коллекции OData в службе поиска Azure](search-query-troubleshoot-collection-filters.md).

## <a name="why-collection-filters-are-limited"></a>Почему фильтры коллекции ограничены

Существуют три основные причины, по которым не все функции фильтра поддерживаются для всех типов коллекций:

1. Для определенных типов данных поддерживаются только определенные операторы. Например, не имеет смысла сравнивать логические `true` значения и `false` использовать `lt`, `gt`и т. д.
1. Поиск Azure не поддерживает **коррелированный Поиск** по полям типа `Collection(Edm.ComplexType)`.
1. Служба поиска Azure использует Инвертированные индексы для выполнения фильтров по всем типам данных, включая коллекции.

Первая причина — это лишь следствие того, как определяются язык OData и система типов EDM. Последние два более подробно описаны в оставшейся части этой статьи.

## <a name="correlated-versus-uncorrelated-search"></a>Коррелированный и некоррелированный Поиск

При применении нескольких условий фильтра к коллекции сложных объектов эти критерии сопоставляются, так как они применяются к *каждому объекту в коллекции*. Например, следующий фильтр возвратит Гостиницы, у которых есть хотя бы одна комната Deluxe с частотой менее 100:

    Rooms/any(room: room/Type eq 'Deluxe Room' and room/BaseRate lt 100)

Если фильтрация быланекоррелированной, то приведенный выше фильтр может вернуть Гостиницы, где одна комната — Deluxe, а другая комната будет иметь базовый уровень менее 100. Это не имеет смысла, так как оба предложения лямбда-выражения применяются к одной и той же переменной диапазона, а `room`именно. Именно поэтому такие фильтры связаны.

Однако для полнотекстового поиска не существует способа ссылаться на определенную переменную диапазона. Если вы используете поиск с полями для выполнения [полного запроса Lucene](query-lucene-syntax.md) , подобного этому:

    Rooms/Type:deluxe AND Rooms/Description:"city view"

Вы можете получить Гостиницы, где одна комната — Deluxe, а другая комната упоминается в описании. Например, следующий `Id` `1` документ должен соответствовать запросу:

```json
{
  "value": [
    {
      "Id": "1",
      "Rooms": [
        { "Type": "deluxe", "Description": "Large garden view suite" },
        { "Type": "standard", "Description": "Standard city view room" }
      ]
    },
    {
      "Id": "2",
      "Rooms": [
        { "Type": "deluxe", "Description": "Courtyard motel room" }
      ]
    }
  ]
}
```

Причина заключается в том `Rooms/Type` , что относится ко всем проанализированным условиям `Rooms/Type` поля во всем документе, а также к `Rooms/Description`, как показано в таблицах ниже.

Как `Rooms/Type` хранится для полнотекстового поиска:

| Термин в`Rooms/Type` | Идентификаторы документов |
| --- | --- |
| Обучающий | 1, 2 |
| Стандартный | 1 |

Как `Rooms/Description` хранится для полнотекстового поиска:

| Термин в`Rooms/Description` | Идентификаторы документов |
| --- | --- |
| кауртярд | 2 |
| city | 1 |
| процессор | 1 |
| достаточ | 1 |
| мотель | 2 |
| залах | 1, 2 |
| Стандартный | 1 |
| Suite | 1 |
| просмотреть | 1 |

Таким образом, в отличие от приведенного выше фильтра, в котором по сути говорится « `Type` сопоставление документов, в которых комната имеет значение «Deluxe Room `BaseRate` », и **что размер комнаты** меньше 100», поисковый запрос `Rooms/Type` говорит «найти документы, где имеет термин «Deluxe». "и `Rooms/Description` содержит фразу" представление города ". Нет концепции отдельных комнат, поля которых можно связать в последнем случае.

> [!NOTE]
> Если вы хотите увидеть поддержку коррелированного поиска, добавленного в службу поиска Azure, проголосуйте за [этот пользовательский голосовый элемент](https://feedback.azure.com/forums/263029-azure-search/suggestions/37735060-support-correlated-search-on-complex-collections).

## <a name="inverted-indexes-and-collections"></a>Инвертированные индексы и коллекции

Вы могли заметить, что существует гораздо меньше ограничений на лямбда-выражения по сравнению со сложными коллекциями, чем `Collection(Edm.Int32)`для `Collection(Edm.GeographyPoint)`простых коллекций, таких как, и т. д. Это связано с тем, что служба поиска Azure хранит сложные коллекции как фактические коллекции поддокументов, а простые коллекции вообще не хранятся как коллекции.

Например, рассмотрим поле `seasons` коллекции строк, которое можно фильтровать, например в индексе для Интернет-магазина. Некоторые документы, отправленные по этому индексу, могут выглядеть следующим образом:

```json
{
  "value": [
    {
      "id": "1",
      "name": "Hiking boots",
      "seasons": ["spring", "summer", "fall"]
    },
    {
      "id": "2",
      "name": "Rain jacket",
      "seasons": ["spring", "fall", "winter"]
    },
    {
      "id": "3",
      "name": "Parka",
      "seasons": ["winter"]
    }
  ]
}
```

Значения `seasons` поля хранятся в структуре, которая называется инвертированным индексом, которая выглядит примерно так:

| Термин | Идентификаторы документов |
| --- | --- |
| Весна | 1, 2 |
| Лето | 1 |
| делят | 1, 2 |
| зимне | 2, 3 |

Эта структура данных предназначена для ответа на один вопрос с высокой скоростью: В каких документах отображается указанный термин? Ответ на этот вопрос работает более похоже на проверку обычного равенства, чем на цикл по коллекции. По сути, именно поэтому для коллекций строк Поиск Azure позволяет `eq` только в качестве оператора сравнения в лямбда-выражении для. `any`

Основываясь на равенстве, далее мы рассмотрим, как можно объединить несколько проверок равенства для одной и той же переменной диапазона с `or`. Он работает с благодарностью и [свойством дистрибутиве кванторов](https://en.wikipedia.org/wiki/Existential_quantification#Negation). Следующее выражение:

    seasons/any(s: s eq 'winter' or s eq 'fall')

эквивалентно выражению:

    seasons/any(s: s eq 'winter') or seasons/any(s: s eq 'fall')

и каждое из двух `any` подвыражений может эффективно выполняться с использованием инвертированного индекса. Кроме того, благодаря [закону отрицания](https://en.wikipedia.org/wiki/Existential_quantification#Negation), приведенному ниже, это выражение:

    seasons/all(s: s ne 'winter' and s ne 'fall')

эквивалентно выражению:

    not seasons/any(s: s eq 'winter' or s eq 'fall')

Именно поэтому можно использовать `all` с `ne` и `and`.

> [!NOTE]
> Хотя подробные сведения выходят за рамки этого документа, эти же принципы расширяются на [тесты расстояния и пересечения для коллекций геопространственных точек](search-query-odata-geo-spatial-functions.md) . Именно поэтому в `any`:
>
> - `geo.intersects`не может быть отрицанием
> - `geo.distance`необходимо сравнить с помощью `lt` или`le`
> - выражения должны быть объединены `or`с, а не`and`
>
> Правила обратной стороны применяются для `all`.

При фильтрации по коллекциям типов данных, `lt`которые поддерживают операторы `le`, `gt`, и `ge` , такие как `Collection(Edm.Int32)` , например, могут использоваться более широкий спектр выражений. `or` В частности, можно использовать `and` и в `any`, пока Базовые выражения сравнения объединяются в **диапазоны сравнения** с помощью `and`, которые затем объединяются с помощью. `or` Эта структура логических выражений называется [Дисжунктиве обычной формой (ДНФ)](https://en.wikipedia.org/wiki/Disjunctive_normal_form), которая в противном случае называется or and. И наоборот, лямбда-выражения для `all` этих типов данных должны быть в [был соединительным обычной форме (cnf)](https://en.wikipedia.org/wiki/Conjunctive_normal_form), в противном случае известной как "and of or". Поиск Azure позволяет выполнять такие сравнения диапазонов, так как позволяет эффективно исполнять их с помощью инвертированных индексов, точно так же, как это может сделать быстрый поиск строк.

В сводке ниже приведены правила, которые можно использовать в лямбда-выражении.

- Внутри `any`, *положительные проверки* всегда разрешены, такие как равенство, сравнения `geo.intersects`диапазонов, `geo.distance` или по `lt` сравнению с или `le` (Представьте «близкость» как равенство, когда дело доходит до проверки Расстояние).
- Внутри `any` ,`or` всегда разрешено. Можно использовать `and` только для типов данных, которые могут выражать проверки диапазона, и только при использовании or из and (ДНФ).
- Внутри `all`правила являются обратными, то есть разрешены только *отрицательные проверки* , можно использовать `and` Always и можно использовать `or` только для проверок диапазона, выраженного как and or (cnf).

На практике это типы фильтров, которые, скорее всего, будут использоваться в любом случае. По-прежнему полезно понимать границы того, что возможно.

Конкретные примеры того, какие виды фильтров разрешены, а какие нет, см. [в разделе как записать допустимые фильтры коллекции](search-query-troubleshoot-collection-filters.md#bkmk_examples).

## <a name="next-steps"></a>Следующие шаги  

- [Устранение неполадок фильтров коллекции OData в службе поиска Azure](search-query-troubleshoot-collection-filters.md)
- [Фильтры в службе "Поиск Azure"](search-filters.md)
- [Общие сведения о языке выражений OData для поиска Azure](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для поиска Azure](search-query-odata-syntax-reference.md)
- [Search Documents (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/Search-Documents) (Поиск по документам (REST API службы "Поиск Azure"))
