---
title: Понимание фильтров сбора OData
titleSuffix: Azure Cognitive Search
description: Узнайте механику работы фильтров коллекции OData в запросах Azure Cognitive Search, включая ограничения и поведение, пригодиваемые коллекциям.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: f6e8ed5baef9b8594bb1fe03942e831fd8264a56
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74113074"
---
# <a name="understanding-odata-collection-filters-in-azure-cognitive-search"></a>Понимание фильтров сбора OData в когнитивном поиске Azure

Для [фильтрации](query-odata-filter-orderby-syntax.md) полей сбора в Azure Cognitive Search можно использовать [ `any` `all` ](search-query-odata-collection-operators.md) и операторов вместе с **выражениями lambda.** Выражения Lambda являются выражениями Boolean, которые относятся к **переменной диапазона.** `any` Операторы `all` и операторы `for` аналогичны циклу в большинстве языков программирования, при этом переменная диапазона берет на себя роль переменной цикла, а выражение лямбды — как тело цикла. Переменная диапазона приобретает "текущее" значение коллекции во время итерации цикла.

По крайней мере, так это работает концептуально. На самом деле Azure Cognitive Search реализует фильтры `for` совершенно по-другому, чем циклы. В идеале, эта разница будет невидимой для вас, но в некоторых ситуациях это не так. Конечным результатом является то, что Есть правила, которые вы должны следовать при написании выражений lambda.

В этой статье объясняется, почему существуют правила для фильтров сбора, исследуя, как Azure Cognitive Search выполняет эти фильтры. Если вы пишете продвинутые фильтры со сложными выражениями lambda, вы можете найти эту статью полезной в построении вашего понимания того, что возможно в фильтрах и почему.

Для получения информации о правилах для фильтров сбора, включая примеры, [см.](search-query-troubleshoot-collection-filters.md)

## <a name="why-collection-filters-are-limited"></a>Почему фильтры сбора ограничены

Существует три основные причины, по которым не все функции фильтра поддерживаются для всех типов коллекций:

1. Только определенные операторы поддерживаются для определенных типов данных. Например, нет смысла сравнивать значения Boolean `true` и `false` `lt`использовать, `gt`и так далее.
1. Azure Cognitive Search не поддерживает **коррелированный поиск** на полях типа. `Collection(Edm.ComplexType)`
1. Azure Cognitive Search использует перевернутые индексы для выполнения фильтров для всех типов данных, включая коллекции.

Первая причина является лишь следствием того, как определяются язык OData и система типа EDM. Последние два описаны более подробно в остальной части этой статьи.

## <a name="correlated-versus-uncorrelated-search"></a>Коррелированный и некоррелированный поиск

При применении нескольких критериев фильтра по набору сложных объектов критерии **коррелируются,** поскольку они применяются к *каждому объекту в коллекции.* Например, следующий фильтр вернет отели, в которых есть по крайней мере один номер повышенной комфортности со ставкой менее 100:

    Rooms/any(room: room/Type eq 'Deluxe Room' and room/BaseRate lt 100)

Если фильтрация была *некоррелирована,* вышеуказанный фильтр может вернуть отели, где один номер люкс и другой номер имеет базовую ставку менее 100. Это не имеет смысла, так как оба положения выражения лямбда применяются `room`к одной и той же переменной диапазона, а именно . Вот почему такие фильтры коррелируются.

Однако для полнотекстовых поисков нет возможности сослаться на определенную переменную диапазона. Если вы используете поиск на местах, чтобы выдать [полный запрос Lucene,](query-lucene-syntax.md) как этот:

    Rooms/Type:deluxe AND Rooms/Description:"city view"

Вы можете получить отели обратно, где один номер люкс, и другой номер упоминает "вид на город" в описании. Например, документ, `Id` приведенный ниже, `1` соответствует запросу:

```json
{
  "value": [
    {
      "Id": "1",
      "Rooms": [
        { "Type": "deluxe", "Description": "Large garden view suite" },
        { "Type": "standard", "Description": "Standard city view room" }
      ]
    },
    {
      "Id": "2",
      "Rooms": [
        { "Type": "deluxe", "Description": "Courtyard motel room" }
      ]
    }
  ]
}
```

Причина в `Rooms/Type` том, что относится `Rooms/Type` ко всем проанализированным условиям `Rooms/Description`поля во всем документе, и аналогичным образом для , как показано в таблицах ниже.

Как `Rooms/Type` хранится для полнотекстовых поисков:

| Срок в`Rooms/Type` | Ит-документы |
| --- | --- |
| Делюкс | 1, 2 |
| standard | 1 |

Как `Rooms/Description` хранится для полнотекстовых поисков:

| Срок в`Rooms/Description` | Ит-документы |
| --- | --- |
| Внутренний двор | 2 |
| city | 1 |
| Сад | 1 |
| большой. | 1 |
| мотель | 2 |
| комната | 1, 2 |
| standard | 1 |
| Люкс | 1 |
| представление | 1 |

Таким образом, в отличие от фильтра выше, `Type` который в основном говорит "матч документов, где комната равна" Deluxe room "и **что же комната** имеет `BaseRate` менее 100", поисковый запрос говорит "матч документы, где `Rooms/Type` есть термин "люкс" и `Rooms/Description` имеет фразу "вид города". Нет понятия отдельных комнат, поля которых могут быть соотнесены в последнем случае.

> [!NOTE]
> Если вы хотите, чтобы поддержка коррелированных поиска добавлена в Azure Cognitive Search, пожалуйста, проголосуйте за [этот элемент Голос пользователя:](https://feedback.azure.com/forums/263029-azure-search/suggestions/37735060-support-correlated-search-on-complex-collections)

## <a name="inverted-indexes-and-collections"></a>Перевернутые индексы и коллекции

Возможно, вы заметили, что Есть гораздо меньше ограничений на выражения лямбда над сложными коллекциями, чем Есть для простых коллекций, как `Collection(Edm.Int32)`, `Collection(Edm.GeographyPoint)`и так далее. Это связано с тем, что Azure Cognitive Search хранит сложные коллекции как фактические коллекции субдокументов, в то время как простые коллекции вообще не хранятся в виде коллекций.

Например, рассмотрим фильтруемое `seasons` поле сбора строк, как в индексе для интернет-магазина. Некоторые документы, загруженные в этот индекс, могут выглядеть следующим образом:

```json
{
  "value": [
    {
      "id": "1",
      "name": "Hiking boots",
      "seasons": ["spring", "summer", "fall"]
    },
    {
      "id": "2",
      "name": "Rain jacket",
      "seasons": ["spring", "fall", "winter"]
    },
    {
      "id": "3",
      "name": "Parka",
      "seasons": ["winter"]
    }
  ]
}
```

Значения `seasons` поля хранятся в структуре, называемой **перевернутым индексом,** которая выглядит примерно так:

| Термин | Ит-документы |
| --- | --- |
| Весна | 1, 2 |
| Лето | 1 |
| Падения | 1, 2 |
| Зима | 2, 3 |

Эта структура данных предназначена для того, чтобы с большой скоростью ответить на один вопрос: в каких документах отображается данный термин? Ответ на этот вопрос больше похож на простую проверку равенства, чем на петлю над коллекцией. В самом деле, именно поэтому для строки `eq` коллекции, Azure Когнитивный `any`поиск только позволяет в качестве оператора сравнения внутри выражения lambda для .

Далее, исходя из равенства, мы рассмотрим, как можно объединить несколько проверок равенства на одной и той же переменной диапазона с `or`. Он работает благодаря алгебре и [распределительной собственности квантификаторов.](https://en.wikipedia.org/wiki/Existential_quantification#Negation) Это выражение:

    seasons/any(s: s eq 'winter' or s eq 'fall')

эквивалентно правилу

    seasons/any(s: s eq 'winter') or seasons/any(s: s eq 'fall')

и каждое `any` из двух подвыражений может быть эффективно выполнено с помощью перевернутого индекса. Кроме того, благодаря [отрицанию закона квантификаторов](https://en.wikipedia.org/wiki/Existential_quantification#Negation), это выражение:

    seasons/all(s: s ne 'winter' and s ne 'fall')

эквивалентно правилу

    not seasons/any(s: s eq 'winter' or s eq 'fall')

Именно поэтому можно использовать `all` с `ne` и `and`.

> [!NOTE]
> Хотя детали выходят за рамки этого документа, эти же принципы распространяются и на [дистанционные и перекрестные тесты для коллекций геопространственных точек.](search-query-odata-geo-spatial-functions.md) Вот почему, `any`в :
>
> - `geo.intersects`не может быть сведена на нет
> - `geo.distance`должны быть `lt` сопоставлены с использованием или`le`
> - выражения должны сочетаться `or`с, а не`and`
>
> Обратные правила `all`применяются для .

Более широкий спектр выражений допускается при фильтрации коллекций `gt` `le`типов `ge` данных, `Collection(Edm.Int32)` которые поддерживают, `lt`и операторов, таких как, например. В частности, `and` вы `or` можете `any`использовать, а также в , до тех пор, как основные `or`выражения сравнения объединены в диапазон **сравнения** с помощью, `and`которые затем далее сочетаются с помощью. Эта структура булеаных выражений называется [Disjunctive Normal Form (DNF),](https://en.wikipedia.org/wiki/Disjunctive_normal_form)иначе известной как "ORs ANDs". И наоборот, выражения lambda для `all` этих типов данных должны быть в [конъюнктурной нормальной форме (CNF),](https://en.wikipedia.org/wiki/Conjunctive_normal_form)иначе известной как "ANDs oRs". Azure Cognitive Search позволяет такие сравнения диапазона, потому что он может выполнять их с помощью перевернутых индексов эффективно, так же, как он может сделать быстрый срок поиска строк.

Таким образом, вот правила большого пальца за то, что разрешено в выражение лямбда:

- `any`Внутри, *положительные проверки* всегда разрешены, `geo.intersects`как `geo.distance` равенство, `lt` `le` сравнение диапазона, , или по сравнению с или (думаю, "близость", как равенство, когда дело доходит до проверки расстояния).
- `any`Внутри, `or` всегда допускается. Вы можете `and` использовать только для типов данных, которые могут выражать проверки диапазона, и только если вы используете ORs ANDs (DNF).
- Внутри `all`правила отменены - разрешены только *отрицательные проверки,* вы можете использовать `and` всегда, и вы можете использовать `or` только для проверки диапазона, выраженного как ANDs ORs (CNF).

На практике это типы фильтров, которые вы, скорее всего, будете использовать в любом случае. Это все еще полезно понять границы того, что возможно, хотя.

Для конкретных примеров, какие виды фильтров разрешены, а какие нет, [см. Как написать действительные фильтры сбора.](search-query-troubleshoot-collection-filters.md#bkmk_examples)

## <a name="next-steps"></a>Дальнейшие действия  

- [Устранение неполадок в сборах OData в Azure Cognitive Search](search-query-troubleshoot-collection-filters.md)
- [Фильтры в когнитивном поиске Azure](search-filters.md)
- [Обзор языка выражения OData для когнитивного поиска Azure](query-odata-filter-orderby-syntax.md)
- [Ссылка синтаксиса выражения OData для когнитивного поиска Azure](search-query-odata-syntax-reference.md)
- [Поиск документов &#40;Azure Когнитивный поиск REST API&#41;](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
