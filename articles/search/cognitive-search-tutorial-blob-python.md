---
title: Учебник по Python. Вызов Cognitive Services в конвейере индексирования в службе "Поиск Azure"
description: Ознакомьтесь с примером извлечения данных, обработки естественного языка и изображений с применением искусственного интеллекта в службе "Поиск Azure" с помощью записной книжки Jupyter для Python. Извлеченные данные индексируются и легко доступны по запросу.
manager: cgronlun
author: LisaLeib
services: search
ms.service: search
ms.devlang: python
ms.topic: tutorial
ms.date: 06/04/2019
ms.author: v-lilei
ms.openlocfilehash: b7f1baa473ca28db696835a7b0895f1603c74770
ms.sourcegitcommit: 4b647be06d677151eb9db7dccc2bd7a8379e5871
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/19/2019
ms.locfileid: "68359402"
---
# <a name="python-tutorial-call-cognitive-services-apis-in-an-azure-search-indexing-pipeline"></a>Учебник по Python. Вызов API-интерфейсов Cognitive Services в конвейере индексирования службы "Поиск Azure"

В этом руководстве вы узнаете о механизме программирования обогащения данных в службе "Поиск Azure" с использованием *когнитивных методик*. Навыки подкрепляются возможностями обработки естественного языка (NLP) и анализа изображений в Cognitive Services. Настроив сочетание и конфигурацию набора навыков, можно извлечь текст и текстовые представления изображения или файл отсканированного документа. Кроме того, вы можете определить язык, сущности, ключевые фразы и многое другое. Результатом является расширенное содержимое в индексе Поиска Azure, созданное конвейером индексирования с возможностями ИИ. 

В рамках этого учебника мы используем Python, чтобы выполнить следующие задачи:

> [!div class="checklist"]
> * Создадите конвейер индексирования, который дополняет пример данных в маршруте к индексу.
> * Примените встроенные функции: распознавание объектов, распознавание языка, обработка текста и извлечение ключевых слов.
> * Объединять методики, сопоставляя входные данные с результатами в наборе навыков.
> * Выполнить запросы и просмотреть результаты.
> * Сбросить индекс и индексаторы для дальнейшей разработки.

Выходные данные — это полнотекстовый индекс с поддержкой поиска в службе "Поиск Azure". Вы можете улучшить индекс с помощью других стандартных возможностей, таких как [синонимы](search-synonyms.md), [профили оценки](https://docs.microsoft.com/rest/api/searchservice/add-scoring-profiles-to-a-search-index), [анализаторы](search-analyzers.md) и [фильтры](search-filters.md). 

В рамках этого учебника используется бесплатная служба, но количество бесплатных транзакций ограничено 20 документами в день. Если вы хотите выполнять описанные здесь операции несколько раз в день, используйте меньший набор файлов.

> [!NOTE]
> По мере расширения области путем увеличения частоты обработки и добавления большего количества документов или дополнительных алгоритмов ИИ, вам нужно будет [присоединить оплачиваемый ресурс Cognitive Services](cognitive-search-attach-cognitive-services.md). Плата взимается при вызове API в Cognitive Services и извлечении изображений при открытии документов в службе "Поиск Azure". За извлечение текста из документов плата не взимается.
>
> Плата за выполнение встроенных навыков взимается в рамках существующей [модели оплаты Cognitive Services по мере использования](https://azure.microsoft.com/pricing/details/cognitive-services/). Плата за извлечение изображений указана на [странице с ценами на Поиск Azure](https://go.microsoft.com/fwlink/?linkid=2042400).

Если у вас еще нет подписки Azure, [создайте бесплатную учетную запись Azure](https://azure.microsoft.com/free/?WT.mc_id=A261C142F), прежде чем начинать работу.

## <a name="prerequisites"></a>Предварительные требования

В этом руководстве используются приведенные ниже службы, инструменты и данные. 

+ [Создайте учетную запись хранения Azure](https://docs.microsoft.com/azure/storage/common/storage-quickstart-create-account) для хранения примера данных. Создайте учетную запись хранения в том регионе, где находится служба "Поиск Azure".

+ [Anaconda 3.x](https://www.anaconda.com/distribution/#download-section) с Python 3.x и записными книжками Jupyter Notebook.

+ [Пример данных](https://1drv.ms/f/s!As7Oy81M_gVPa-LCb5lC_3hbS-4), который состоит из небольшого набора файлов различных типов. 

+ [Создайте службу "Поиск Azure"](search-create-service-portal.md) или [найдите имеющуюся службу](https://ms.portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices) в рамках текущей подписки. Вы можете использовать бесплатную службу для выполнения инструкций, описанных в этом учебнике.

## <a name="get-a-key-and-url"></a>Получение ключа и URL-адреса

Для взаимодействия со службой "Поиск Azure" вам потребуется URL-адрес службы и ключ доступа. Служба поиска создана с обоими элементами, поэтому если вы добавили службу "Поиск Azure" в подписку, выполните следующие действия для получения необходимых сведений:

1. [Войдите на портал Azure](https://portal.azure.com/) и на странице **обзора** службы поиска получите URL-адрес. Пример конечной точки может выглядеть так: `https://mydemo.search.windows.net`.

1. В разделе **Параметры** > **Ключи** получите ключ администратора, чтобы обрести полные права на службу. Существуют два взаимозаменяемых ключа администратора, предназначенных для обеспечения непрерывности бизнес-процессов на случай, если вам потребуется сменить один из них. Вы можете использовать первичный или вторичный ключ для выполнения запросов на добавление, изменение и удаление объектов.

![Получение конечной точки HTTP и ключа доступа](media/search-get-started-postman/get-url-key.png "Получение конечной точки HTTP и ключа доступа")

Для выполнения любого запроса к службе требуется использование ключа API. Действительный ключ устанавливает для каждого запроса отношения доверия между приложением, которое отправляет запрос, и службой, которая его обрабатывает.

## <a name="prepare-sample-data"></a>Подготовка примера данных

Конвейер обогащения извлекает данные из источников данных Azure. Исходные данные должны поступать из поддерживаемого типа источника данных [индексатора службы "Поиск Azure"](search-indexer-overview.md). Хранилище таблиц Azure не поддерживается для когнитивного поиска. В этом упражнении используется хранилище BLOB-объектов, чтобы продемонстрировать несколько типов содержимого.

1. [Войдите на портал Azure](https://portal.azure.com), перейдите к учетной записи хранения Azure, выберите **Большие двоичные объекты**, а затем щелкните **Контейнер**.

1. [Создайте контейнер больших двоичных объектов](https://docs.microsoft.com/azure/storage/blobs/storage-quickstart-blobs-portal) для хранения примера данных. Можно задать любое из допустимых значений уровня общего доступа.

1. После создания контейнера откройте его и выберите **Передать** на панели команд, чтобы передать примеры файлов, которые вы скачали на предыдущем шаге.

   ![Исходные файлы в хранилище BLOB-объектов Azure](./media/cognitive-search-quickstart-blob/sample-data.png)

1. После загрузки примеров файлов введите имя контейнера и строку подключения для хранилища BLOB-объектов. Это можно сделать, перейдя в учетную запись хранения на портале Azure. На вкладке **Ключи доступа** скопируйте поле **Строка подключения**.

Строка подключения имеет такой формат: `DefaultEndpointsProtocol=https;AccountName=<YOUR-STORAGE-ACCOUNT-NAME>;AccountKey=<YOUR-STORAGE-ACCOUNT-KEY>;EndpointSuffix=core.windows.net`

Держите эту строку подключения под рукой. Она понадобится в дальнейшем.

Существуют и другие способы указать строку подключения, например предоставить подписанный URL-адрес. Дополнительные сведения об учетных данных источника данных см. в статье [Индексирование документов в хранилище BLOB-объектов Azure с помощью службы поиска Azure](search-howto-indexing-azure-blob-storage.md#Credentials).

## <a name="create-a-jupyter-notebook"></a>Создание записной книжки Jupyter

> [!Note]
> В этой статье показано, как создать источник данных, индекс, индексатор и набор навыков, используя серию скриптов Python. Чтобы скачать полный пример записной книжки, перейдите в репозиторий [Azure-Search-python-samples](https://github.com/Azure-Samples/azure-search-python-samples/tree/master/Tutorial-AI-Enrichment-Jupyter-Notebook).

Используйте Anaconda Navigator, чтобы запустить Jupyter Notebook и создать новую записную книжку для Python 3.

## <a name="connect-to-azure-search"></a>Подключение к Поиску Azure

Запустите этот скрипт в своей записной книжке, чтобы загрузить библиотеки, используемые для работы с JSON и формулировки HTTP-запросов.

```python
import json
import requests
from pprint import pprint
```

Затем определите имена для источника данных, индекса, индексатора и набора навыков. Запустите этот скрипт, чтобы задать имена для работы с этим учебником.

```python
# Define the names for the data source, skillset, index and indexer
datasource_name = "cogsrch-py-datasource"
skillset_name = "cogsrch-py-skillset"
index_name = "cogsrch-py-index"
indexer_name = "cogsrch-py-indexer"
```

> [!Tip]
> В бесплатной службе вы ограничены тремя индексами, индексаторами и источниками данных. В этом руководстве создается по одному объекту из каждой категории. Прежде чем продолжать работу, убедитесь, что у вас есть место для создания новых объектов.

В следующем скрипте замените заполнители службы поиска (YOUR-SEARCH-SERVICE-NAME) и ключа API администратора (YOUR-ADMIN-API-KEY), а затем запустите его, чтобы настроить конечную точку службы поиска.

```python
# Setup the endpoint
endpoint = 'https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/'
headers = {'Content-Type': 'application/json',
           'api-key': '<YOUR-ADMIN-API-KEY>'}
params = {
    'api-version': '2019-05-06'
}
```

## <a name="create-a-data-source"></a>Создание источника данных

Теперь, когда службы и исходные файлы подготовлены, начните сборку компонентов конвейера индексирования. Начните с объекта источника данных, который указывает службе "Поиск Azure", как извлекать данные из внешнего источника.

В следующем скрипте замените заполнитель YOUR-BLOB-RESOURCE-CONNECTION-STRING на строку подключения к большому двоичному объекту, созданному на предыдущем шаге. Затем запустите скрипт, чтобы создать источник данных с именем `cogsrch-py-datasource`.

```python
# Create a data source
datasourceConnectionString = "<YOUR-BLOB-RESOURCE-CONNECTION-STRING>"
datasource_payload = {
    "name": datasource_name,
    "description": "Demo files to demonstrate cognitive search capabilities.",
    "type": "azureblob",
    "credentials": {
        "connectionString": datasourceConnectionString
    },
    "container": {
        "name": "basic-demo-data-pr"
    }
}
r = requests.put(endpoint + "/datasources/" + datasource_name,
                 data=json.dumps(datasource_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен вернуть код состояния 201, подтверждающий успешное выполнение.

На портале Azure на странице панели мониторинга службы поиска убедитесь, что источник cogsrch-py-datasource присутствует в списке **Источники данных**. Щелкните **Обновить**, чтобы обновить страницу.

![Плитка источников данных на портале](./media/cognitive-search-tutorial-blob-python/py-data-source-tile.png "Плитка источников данных на портале")

## <a name="create-a-skillset"></a>Создание набора навыков

На этом этапе вы определяете набор шагов обогащения, которые хотите применить к данным. Каждый шаг обогащения называется *навыком*, а набор шагов обогащения — *набором навыков*. В этом руководстве для набора навыков используются [встроенные когнитивные навыки](cognitive-search-predefined-skills.md):

+ [Распознавание языка](cognitive-search-skill-language-detection.md) для определения языка содержимого.

+ [Разделение текста](cognitive-search-skill-textsplit.md) для разбиения большого объема содержимого на более мелкие фрагменты данных перед вызовом метода извлечения ключевой фразы. Этот метод принимает входные данные объемом 50 000 символов или меньше. Некоторые примеры файлов следует разделить, чтобы удовлетворить это ограничение.

+ [Распознавание сущностей](cognitive-search-skill-entity-recognition.md) для извлечения названий организаций из содержимого в контейнере больших двоичных объектов.

+ [Извлечение ключевых фраз](cognitive-search-skill-keyphrases.md) для получения основных ключевых фраз. 

### <a name="python-script"></a>Сценарий Python
Выполните следующий скрипт, чтобы создать набор навыков `cogsrch-py-skillset`.

```python
# Create a skillset
skillset_payload = {
    "name": skillset_name,
    "description":
    "Extract entities, detect language and extract key-phrases",
    "skills":
    [
        {
            "@odata.type": "#Microsoft.Skills.Text.EntityRecognitionSkill",
            "categories": ["Organization"],
            "defaultLanguageCode": "en",
            "inputs": [
                {
                    "name": "text", "source": "/document/content"
                }
            ],
            "outputs": [
                {
                    "name": "organizations", "targetName": "organizations"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.LanguageDetectionSkill",
            "inputs": [
                {
                    "name": "text", "source": "/document/content"
                }
            ],
            "outputs": [
                {
                    "name": "languageCode",
                    "targetName": "languageCode"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.SplitSkill",
            "textSplitMode": "pages",
            "maximumPageLength": 4000,
            "inputs": [
                {
                    "name": "text",
                    "source": "/document/content"
                },
                {
                    "name": "languageCode",
                    "source": "/document/languageCode"
                }
            ],
            "outputs": [
                {
                    "name": "textItems",
                    "targetName": "pages"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.KeyPhraseExtractionSkill",
            "context": "/document/pages/*",
            "inputs": [
                {
                    "name": "text", "source": "/document/pages/*"
                },
                {
                    "name": "languageCode", "source": "/document/languageCode"
                }
            ],
            "outputs": [
                {
                    "name": "keyPhrases",
                    "targetName": "keyPhrases"
                }
            ]
        }
    ]
}

r = requests.put(endpoint + "/skillsets/" + skillset_name,
                 data=json.dumps(skillset_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен вернуть код состояния 201, подтверждающий успешное выполнение.

Для каждой страницы применяется навык извлечения ключевых фраз. Если установить контекст `"document/pages/*"`, средство обогащения будет выполнено для каждого элемента массива документов или страниц (для каждой страницы в документе).

Каждый навык выполняется в содержимом документа. Во время обработки служба "Поиск Azure" разбивает каждый документ для чтения содержимого из разных форматов файлов. Найденный в исходном файле текст помещается в поле `content`, по одному для каждого документа. Таким образом, установите входные данные как `"/document/content"`.

Графическое представление набора навыков показано ниже.

![Общие сведения о наборе навыков](media/cognitive-search-tutorial-blob/skillset.png "Общие сведения о наборе навыков")

Выходные данные могут быть сопоставлены с индексом, используемым в качестве входных данных для нисходящего навыка, или к обоим, как в случае с кодом языка. В индексе код языка полезен для фильтрации. В качестве входных данных код языка используется навыками анализа текста, чтобы указать лингвистические правила для разбивки слов.

Общие сведения о наборах навыков см. в статье [How to create a skillset in an enrichment pipeline](cognitive-search-defining-skillset.md) (Способ создания набора навыков в конвейере обогащения).

## <a name="create-an-index"></a>Создание индекса

В этом разделе вы определите схему индекса, указав поля для включения в индекс поиска, а также установите атрибуты поиска для каждого поля. Поля имеют тип и могут принимать атрибуты, определяющие их использование (поиск, сортировка и т. д.). Имена полей в индексе не обязательно должны точно соответствовать именам полей в источнике. На более позднем этапе вы добавите сопоставления полей в индексаторе для подключения полей "источник — назначение". Для этого шага определите индекс, используя соглашения об именовании полей, относящиеся к вашему поисковому приложению.

В этом упражнении используются следующие поля и типы полей:

| имена полей: | id         | Содержимое   | languageCode | keyPhrases         | organizations     |
|--------------|----------|-------|----------|--------------------|-------------------|
| типы полей: | Edm.String|Edm.String| Edm.String| List<Edm.String>  | List<Edm.String>  |

Запустите этот скрипт, чтобы создать индекс с именем `cogsrch-py-index`.

```python
# Create an index
index_payload = {
    "name": index_name,
    "fields": [
        {
            "name": "id",
            "type": "Edm.String",
            "key": "true",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false",
            "sortable": "true"
        },
        {
            "name": "content",
            "type": "Edm.String",
            "sortable": "false",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false"
        },
        {
            "name": "languageCode",
            "type": "Edm.String",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false"
        },
        {
            "name": "keyPhrases",
            "type": "Collection(Edm.String)",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false"
        },
        {
            "name": "organizations",
            "type": "Collection(Edm.String)",
            "searchable": "true",
            "sortable": "false",
            "filterable": "false",
            "facetable": "false"
        }
    ]
}

r = requests.put(endpoint + "/indexes/" + index_name,
                 data=json.dumps(index_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен вернуть код состояния 201, подтверждающий успешное выполнение.

Дополнительные сведения об определении индекса см. в статье [Create Index (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/create-index) (Создание индексов (REST API службы поиска Azure)).

## <a name="create-an-indexer-map-fields-and-execute-transformations"></a>Создание индексатора, сопоставление полей и выполнение преобразования

Пока вы создали источник данных, набор навыков и индекс. Эти три компонента становятся частью [индексатора](search-indexer-overview.md), который объединяет каждую часть в единую многофазную операцию. Чтобы связать эти объекты вместе в индексаторе, необходимо определить сопоставления полей.

+ Обработка FieldMappings выполняется перед набором навыков. Исходные поля из источника данных сопоставляются с целевыми полями в индексе. Если имена и типы полей одинаковы в исходном и целевом расположениях, сопоставление не требуется.

+ Обработка OutputFieldMappings выполняется после набора навыков. Добавляются ссылки на элементы sourceFieldNames, которые не существуют, пока они не будут созданы при анализе или обогащении документов. TargetFieldName — это поле в индексе.

Помимо привязки входных данных к выходным данным, можно также использовать сопоставления полей для преобразования структур данных в плоские структуры. Для получения дополнительных сведений см. раздел [Сопоставление обогащенных полей с индексом, поддерживающим поиск](cognitive-search-output-field-mapping.md).

Запустите этот скрипт, чтобы создать индексатор с именем `cogsrch-py-indexer`.

```python
# Create an indexer
indexer_payload = {
    "name": indexer_name,
    "dataSourceName": datasource_name,
    "targetIndexName": index_name,
    "skillsetName": skillset_name,
    "fieldMappings": [
        {
            "sourceFieldName": "metadata_storage_path",
            "targetFieldName": "id",
            "mappingFunction":
            {"name": "base64Encode"}
        },
        {
            "sourceFieldName": "content",
            "targetFieldName": "content"
        }
    ],
    "outputFieldMappings":
    [
        {
            "sourceFieldName": "/document/organizations",
            "targetFieldName": "organizations"
        },
        {
            "sourceFieldName": "/document/pages/*/keyPhrases/*",
            "targetFieldName": "keyPhrases"
        },
        {
            "sourceFieldName": "/document/languageCode",
            "targetFieldName": "languageCode"
        }
    ],
    "parameters":
    {
        "maxFailedItems": -1,
        "maxFailedItemsPerBatch": -1,
        "configuration":
        {
            "dataToExtract": "contentAndMetadata",
            "imageAction": "generateNormalizedImages"
        }
    }
}

r = requests.put(endpoint + "/indexers/" + indexer_name,
                 data=json.dumps(indexer_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен быстро вернуть код состояния 201, однако обработка может занять несколько минут. Хотя набор данных невелик, аналитические навыки, такие как анализ изображений, требуют значительных вычислительных ресурсов и занимают время.

Используйте скрипт [проверки состояния индексатора](#check-indexer-status) в следующем разделе, чтобы определить, когда процесс индексатора завершен.

> [!TIP]
> Создание индексатора вызывает конвейер. Если есть проблемы с получением данных, сопоставлением входных и выходных данных или порядком операций, они появятся на этом этапе. Чтобы повторно запустить конвейер с изменениями кода или скрипта, вам может потребоваться сначала удалить объекты. Дополнительные сведения см. в статье [Руководство по вызову API-интерфейсов когнитивного поиска (предварительная версия)](#reset).

#### <a name="explore-the-request-body"></a>Просмотр текста запроса

Скрипт устанавливает значение -1 для `"maxFailedItems"`, которое инструктирует механизм индексирования игнорировать ошибки во время импорта данных. Это полезно, потому что в демонстрационном источнике данных мало документов. Для большего источника данных необходимо установить значение больше 0.

Также обратите внимание на оператор `"dataToExtract":"contentAndMetadata"` в параметрах конфигурации. Этот оператор указывает индексатору извлекать содержимое из разных форматов файлов, а также метаданные, относящиеся к каждому файлу.

Когда содержимое будет извлечено, вы можете установить `imageAction` для извлечения текста из изображений, найденных в источнике данных. Конфигурация `"imageAction":"generateNormalizedImages"` вместе с навыком распознавания текста и навыком объединения текста инструктирует индексатор извлекать текст из изображений (например слово "стоп" из знака остановки движения) и вставлять его как часть поля содержимого. Это относится как к изображениям, встроенным в документы (например, изображение внутри PDF-файлов), так и к изображениям, найденным в источнике данных, например к файлу JPG.

<a name="check-indexer-status"></a>

## <a name="check-indexer-status"></a>Проверка состояния индексатора

После того как индексатор будет определен, он будет выполняться автоматически при отправке запроса. В зависимости от того, какие когнитивные навыки вы определили, индексирование может занять больше времени, чем вы ожидаете. Чтобы узнать, завершена ли обработка индексатора, запустите следующий скрипт.

```python
# Get indexer status
r = requests.get(endpoint + "/indexers/" + indexer_name +
                 "/status", headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

В ответе проверьте значения status и endTime для lastResult. Периодически запускайте скрипт для проверки состояния. Когда индексатор завершит работу, состояние будет иметь значение success, будет указано значение endTime, а в ответ будут включены все ошибки и предупреждения, которые произошли во время обогащения.

![Создание индексатора](./media/cognitive-search-tutorial-blob-python/py-indexer-is-created.png "Создание индексатора")

Предупреждения часто возникают с некоторыми исходными файлами и комбинациями навыков и не всегда указывают на проблему. В этом учебнике предупреждения являются неопасными. Например, для одного из файлов JPEG без текста будет отображено предупреждение, как на этом снимке экрана.

![Пример предупреждения индексатора](./media/cognitive-search-tutorial-blob-python/py-indexer-warning-example.png "Пример предупреждения индексатора")

## <a name="query-your-index"></a>Отправка запроса в индекс

После завершения индексации выполните запросы, возвращающие содержимое отдельных полей. По умолчанию служба "Поиск Azure" возвращает 50 лучших результатов. Примеры данных малы, поэтому параметр по умолчанию работает нормально. Однако при работе с большими наборами данных вам может потребоваться включить параметры в строку запроса, чтобы вернуть больше результатов. Инструкции см. в статье [Разбивка результатов поиска на страницы в службе поиска Azure](search-pagination-page-layout.md).

Для проверки запросите индекс для всех полей.

```python
# Query the index for all fields
r = requests.get(endpoint + "/indexes/" + index_name,
                 headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

Результат должен выглядеть следующим образом: На снимке экрана показана только часть ответа.

![Индекс запроса для всех полей](./media/cognitive-search-tutorial-blob-python/py-query-index-for-fields.png "Индекс запроса для всех полей")

В результате будет возвращена схема индекса с именем и типом, а также атрибуты каждого поля.

Отправьте второй запрос с `"*"`, чтобы вернуть все содержимое одного поля, например `organizations`.

```python
# Query the index to return the contents of organizations
r = requests.get(endpoint + "/indexes/" + index_name +
                 "/docs?&search=*&$select=organizations", headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

Результат должен выглядеть следующим образом: На снимке экрана показана только часть ответа.

![Индекс запроса для содержимого организаций](./media/cognitive-search-tutorial-blob-python/py-query-index-for-organizations.png "Индекс запроса для содержимого организаций")

Повторите запрос для дополнительных полей: content, languageCode, keyPhrases и organizations в этом упражнении. Вы можете возвратить несколько полей с помощью `$select`, используя разделенный запятыми список.

Можно использовать методы GET или POST, в зависимости от сложности и длины строки запроса. Дополнительные сведения см. в статье [Отправка запросов в индекс службы поиска Azure с помощью REST API](https://docs.microsoft.com/rest/api/searchservice/search-documents).
<a name="reset"></a>

## <a name="reset-and-rerun"></a>Сброс и повторный запуск

На ранних экспериментальных этапах разработки конвейера наиболее практичным подходом к итерации проектирования является удаление объектов из службы "Поиск Azure" и их восстановление. Имена ресурсов являются уникальными. Удаление объекта позволяет воссоздать его с использованием того же имени.

Чтобы повторно проиндексировать документы с использованием новых определений:

1. Удалите индекс, чтобы удалить сохраненные данные. Удалите индексатор для его восстановления в службе.
2. Измените определение набора навыков и индекса.
3. Заново создайте индекс и индексатор в службе для запуска конвейера.

Для удаления индексов, индексаторов и наборов навыков можно использовать портал. Когда вы удаляете индексатор, вы можете по желанию одновременно выборочно удалить индекс, набор навыков и источник данных.

![Удаление объектов поиска](./media/cognitive-search-tutorial-blob-python/py-delete-indexer-delete-all.png "Удаление объектов поиска")

Вы также можете удалить их, используя скрипт. Следующий скрипт удалит набор навыков, который мы создали. Вы можете легко изменить запрос так, чтобы он удалил индекс, индексатор и источник данных.

```python
# delete the skillset
r = requests.delete(endpoint + "/skillsets/" + skillset_name,
                    headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

По мере оптимизации кода вам может потребоваться уточнить стратегию восстановления. Дополнительные сведения см. в статье [How to rebuild an Azure Search index](search-howto-reindex.md) (Как восстановить индекс для службы "Поиск Azure").

## <a name="takeaways"></a>Общие выводы

В этом руководстве показаны основные шаги для построения обогащенного конвейера индексирования посредством создания компонентов: источника данных, набора навыков, индекса и индексатора.

Вы получили сведения о [предопределенных навыках](cognitive-search-predefined-skills.md), а также об определениях наборов навыков и механизме построения цепочек навыков путем сопоставления входных и выходных данных. Вы также узнали, что `outputFieldMappings` в определении индексатора требуется для маршрутизации обогащенных значений из конвейера в индекс для поиска в службе "Поиск Azure".

Наконец, вы узнали, как тестировать результаты и выполнять сброс системы для дальнейших итераций. Вы узнали, что отправка запросов к индексу возвращает результат, созданный обогащенным конвейером индексирования. В этом выпуске существует механизм просмотра внутренних конструкций (обогащенные документы, созданные системой). Вы также узнали, как проверить состояние индексатора и какие объекты нужно удалить перед повторным запуском конвейера.

## <a name="clean-up-resources"></a>Очистка ресурсов

Самый быстрый способ очистки после завершения работы с руководством — удалить группу ресурсов, содержащую службу "Поиск Azure" и службу BLOB-объектов Azure. Предположим, обе службы находятся в одной группе, в этом случае удалите группу ресурсов, чтобы окончательно удалить все ее содержимое, включая службы и любое хранимое содержимое, созданное для этого учебника. На портале имя группы ресурсов находится на странице "Обзор" каждой службы.

## <a name="next-steps"></a>Дополнительная информация

Настройте или расширьте конвейер, добавив пользовательские навыки. Создание пользовательского навыка и добавление его в набор навыков позволяет вам внедрять анализ текста или изображения, который вы пишете сами.

> [!div class="nextstepaction"]
> [Пример. Создание пользовательского навыка для Когнитивного поиска](cognitive-search-create-custom-skill-example.md)
