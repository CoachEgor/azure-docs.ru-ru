---
title: Индексные капли, содержащие несколько документов
titleSuffix: Azure Cognitive Search
description: Crawl Azure капли для текстового содержимого с помощью индекса Azure Congitive Search Blob, где каждый капли может дать один или несколько документов индекса поиска.
manager: nitinme
author: arv100kri
ms.author: arjagann
ms.devlang: rest-api
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
ms.openlocfilehash: 1840bda0ecc9462a5d8f796b616d728d0bb412f7
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74112260"
---
# <a name="indexing-blobs-to-produce-multiple-search-documents"></a>Индексирование капли для получения нескольких поисковых документов
По умолчанию индексер капли будет рассматривать содержимое капли как единый поисковый документ. Некоторые значения **разбораMode** поддерживают сценарии, в которых отдельный капли может привести к попачке поисковых документов. Различные **типы разбораMode,** которые позволяют указателю извлечь из капли более одного поискового документа:
+ `delimitedText`
+ `jsonArray`
+ `jsonLines`

## <a name="one-to-many-document-key"></a>Ключ от одного к многим документам
Каждый документ, отображаемый в индексе когнитивного поиска Azure, однозначно идентифицируется ключом документа. 

При отсутствии определенного режима разбора и при отсутствии явного отображения [maps](search-indexer-field-mappings.md) ключевого `metadata_storage_path` поля в индексе Azure Cognitive Search автоматически отображает свойство в качестве ключа. Это отображение гарантирует, что каждая капля отображается в виде отдельного поискового документа.

При использовании любого из режимов разбора, перечисленных выше, одна капля карты "многие" поисковые документы, что делает ключ документа исключительно на основе метаданных капли не подходит. Чтобы преодолеть это ограничение, Azure Cognitive Search способен создать ключ документа «один к много» для каждого отдельного объекта, извлеченного из капли. Это свойство `AzureSearch_DocumentKey` названо и добавляется к каждому отдельному объекту, извлеченному из капли. Значение этого свойства гарантированно будет уникальным для каждого отдельного субъекта _через капли_ и сущности будут отображаться в виде отдельных документов поиска.

По умолчанию, когда не указаны четкие картографы полей для ключевого поля индекса, `AzureSearch_DocumentKey` отображается к нему с помощью функции картирования `base64Encode` поля.

## <a name="example"></a>Пример
Предположим, что у вас есть определение индекса со следующими полями:
+ `id`
+ `temperature`
+ `pressure`
+ `timestamp`

И ваш контейнер капли имеет капли со следующей структурой:

_Blob1.json_

    { "temperature": 100, "pressure": 100, "timestamp": "2019-02-13T00:00:00Z" }
    { "temperature" : 33, "pressure" : 30, "timestamp": "2019-02-14T00:00:00Z" }

_Blob2.json_

    { "temperature": 1, "pressure": 1, "timestamp": "2018-01-12T00:00:00Z" }
    { "temperature" : 120, "pressure" : 3, "timestamp": "2013-05-11T00:00:00Z" }

При создании индекса и **установке разбора** `jsonLines` Mode без указания каких-либо явных карт для ключевого поля будет неявно применено следующее отображение
    
    {
        "sourceFieldName" : "AzureSearch_DocumentKey",
        "targetFieldName": "id",
        "mappingFunction": { "name" : "base64Encode" }
    }

В результате этого будет индекс когнитивного поиска Azure, содержащий следующую информацию (base64 закодирован идентификатор, сокращенный для краткости)

| идентификатор | Температура | pressure | TIMESTAMP |
|----|-------------|----------|-----------|
| hr0 ... YjEuanNvbjsx | 100 | 100 | 2019-02-13T00:00:00 |
| hr0 ... YjEuanNvbjsy | 33 | 30 | 2019-02-14T00:00:00 |
| hr0 ... YjIuanNvbjsx | 1 | 1 | 2018-01-12T00:00:00 |
| hr0 ... YjIuanNvbjsy | 120 | 3 | 2013-05-11T00:00:00 |

## <a name="custom-field-mapping-for-index-key-field"></a>Пользовательское картирование полей для поля ключевого индекса

Предполагая то же определение индекса, что и предыдущий пример, предположим, что ваш контейнер с каплями имеет капли со следующей структурой:

_Blob1.json_

    recordid, temperature, pressure, timestamp
    1, 100, 100,"2019-02-13T00:00:00Z" 
    2, 33, 30,"2019-02-14T00:00:00Z" 

_Blob2.json_

    recordid, temperature, pressure, timestamp
    1, 1, 1,"2018-01-12T00:00:00Z" 
    2, 120, 3,"2013-05-11T00:00:00Z" 

При создании индекса `delimitedText` с **помощью parsingMode**может показаться естественным настроить функцию картирования поля для ключевого поля следующим образом:

    {
        "sourceFieldName" : "recordid",
        "targetFieldName": "id"
    }

Однако, это отображение _не_ приведет к 4 `recordid` документов, показывая в индексе, потому что поле не является уникальным _через капли_. Поэтому мы рекомендуем использовать неявное картирование полей, применяемое от `AzureSearch_DocumentKey` свойства к ключевому поле индекса для режимов разогнания «один к многим».

Если вы хотите настроить явное картирование полей, убедитесь, что _sourceField_ отличается для каждого отдельного объекта **во всех капли.**

> [!NOTE]
> Подход, `AzureSearch_DocumentKey` используемый для обеспечения уникальности для извлекаемой сущности, может быть изменен, и поэтому не следует полагаться на его ценность для нужд приложения.

## <a name="next-steps"></a>Дальнейшие действия

Если вы еще не знакомы с основной структурой и рабочим процессом индексации каплей, сначала следует просмотреть [индексирование хранилища Azure Blob с Azure Cognitive Search.](search-howto-index-json-blobs.md) Для получения дополнительной информации о режимах разбора для различных типов контента blob, просмотрите следующие статьи.

> [!div class="nextstepaction"]
> [Индексирование CSV капли](search-howto-index-csv-blobs.md)
> [Индексирование JSON капли](search-howto-index-json-blobs.md)
