---
title: Создание средства подбора
titleSuffix: Azure Cognitive Search
description: Включите действия запроса типа вперед в Azure Cognitive Search, создавая предложители и формулируя запросы, которые ссылают сядебные или автопредлагаемые термины запроса.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 04/10/2020
ms.openlocfilehash: d40d4cfe1b86448f1e8df307013905d69f203dcd
ms.sourcegitcommit: 8dc84e8b04390f39a3c11e9b0eaf3264861fcafc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/13/2020
ms.locfileid: "81261063"
---
# <a name="create-a-suggester-to-enable-autocomplete-and-suggested-results-in-a-query"></a>Создание подсказчика для автоматического заполнения и предлагаемых результатов в запросе

В Azure Cognitive Search функция «поиск по типу» включена через конструкцию **отобрасвателя,** добавленную в [индекс поиска.](search-what-is-an-index.md) Suggester поддерживает два опыта: *автозаполнение*, который завершает термин или фразу, и *предложения,* которые возвращают короткий список соответствующих документов.  

Следующий скриншот из [Создайте свое первое приложение в СЗ](tutorial-csharp-type-ahead-and-suggestions.md) иллюстрирует и то, и другое. Автозаполнение предвосхищает потенциальный термин, заканчивая "tw" с "в". Предложения — это мини-результаты поиска, где такое поле, как название отеля, представляет собой соответствующий документ поиска отеля из индекса. Для предложений можно выложить любую область, предоставляющую описательную информацию.

![Визуальное сравнение автозаполнения и предлагаемых запросов](./media/index-add-suggesters/hotel-app-suggestions-autocomplete.png "Визуальное сравнение автозаполнения и предлагаемых запросов")

Вы можете использовать эти функции отдельно или вместе. Для реализации этих функций в Azure Cognitive Search существует компонент индекса и запроса. 

+ В индексе добавьте подсыплятеля к индексу. Вы можете использовать портал, [REST API](https://docs.microsoft.com/rest/api/searchservice/create-index)или [.NET SDK](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.suggester?view=azure-dotnet). Остальная часть этой статьи сосредоточена на создании подсобного предложения.

+ В запросе запроса позвоните в один из [AIS, перечисленных ниже.](#how-to-use-a-suggester)

Поддержка поиска по типу поиска включена на основе поля для полей строк. Вы можете реализовать оба поведения typeahead в одном и том же решении поиска, если вы хотите опыт, аналогичный тому, который указан на скриншоте. Оба запроса нацелены на сбор *документов* конкретного индекса, и ответы возвращаются после того, как пользователь предоставил по крайней мере три строки ввода символов.

## <a name="what-is-a-suggester"></a>Что такое подсобие?

Подсобитель — это структура данных, которая поддерживает поведение типа поиска по мере использования путем хранения префиксов для сопоставления по частичным запросам. Подобно токенизированным терминам, префиксы хранятся в перевернутых индексах, по одному для каждого поля, указанного в коллекции полей отосводного.

При создании префиксов, предложить имеет свою собственную цепочку анализа, похожую на тот, который используется для полного поиска текста. Однако, в отличие от анализа при полном текстовом поиске, предложить может работать только над полями, которые используют стандартный анализатор Lucene (по умолчанию) или [анализатор языка.](index-add-language-analyzers.md) Поля, в которых используются [пользовательские анализаторы](index-add-custom-analyzers.md) или [предопределенные анализаторы](index-add-custom-analyzers.md#predefined-analyzers-reference) (за исключением стандартного Lucene), явно запрещены для предотвращения плохих результатов.

> [!NOTE]
> Если вам нужно обойти ограничение анализатора, используйте два отдельных поля для одного и того же содержимого. Это позволит одному из полей иметь предложить, в то время как другое может быть настроено с пользовательской конфигурацией анализатора.

## <a name="define-a-suggester"></a>Определить наводящего

Хотя наводящий имеет несколько свойств, это в первую очередь коллекция полей, для которых вы позволяете поиск по мере ввода опыта. Например, приложение для путешествий может захотеть включить автоматическое заполнение пунктов назначения, городов и достопримечательностей. Таким образом, все три поля будут идти в сбор полей.

Чтобы создать подсобие, добавьте его в схему индекса. Вы можете иметь один наводящий в индексе (в частности, один наводящий в коллекции предложить). Наводящий берет список полей. 

+ Для предложений выберите поля, которые наилучшим образом представляют один результат. Имена, названия или другие уникальные поля, которые отличаются от документов, работают лучше всего. Если поля состоят из одинаковых или идентичных значений, предложения будут состоять из одинаковых результатов, и пользователь не будет знать, какой из них нажимать.

+ Убедитесь, что каждое `sourceFields` поле в списке отсылателей использует либо стандартный анализатор Lucene по умолчанию ()`"analyzer": null`или [анализатор языка](index-add-language-analyzers.md) (например, `"analyzer": "en.Microsoft"`). 

  Ваш выбор анализатора определяет, как поля токенизируются и впоследствии прекреплятся. Например, для дефисной строки, такой как "контекст-чувствительный", использование анализатора языка приведет к таким комбинациям маркеров: "контекст", "чувствительный", "контекст-чувствительный". Если бы вы использовали стандартный анализатор Lucene, дефисстроки не существовало бы.

> [!TIP]
> Рассмотрите возможность использования [API анализа текста](https://docs.microsoft.com/rest/api/searchservice/test-analyzer) для понимания того, как термины токенизируются и впоследствии прекрепляются. После создания индекса можно попробовать различные анализаторы на строке для просмотра испускаемых ими токенов.

### <a name="when-to-create-a-suggester"></a>Когда создать наводящего

Лучшее время для создания подсобного предложения — это когда вы также создаете само определение поля.

Если вы попытаетесь создать предложить с помощью уже существующих полей, API запретит его. Префиксы создаются во время индексации, когда частичные термины в двух или более комбинациях символов токенизируются вместе с целыми терминами. Учитывая, что существующие поля уже токенизированы, вам придется перестроить индекс, если вы хотите добавить их в предложить. Для получения дополнительной информации [см.](search-howto-reindex.md)

### <a name="create-using-the-rest-api"></a>Создание с помощью REST API

В REST API добавьте предложить через [Создать индекс](https://docs.microsoft.com/rest/api/searchservice/create-index) или [индекс обновления](https://docs.microsoft.com/rest/api/searchservice/update-index). 

  ```json
  {
    "name": "hotels-sample-index",
    "fields": [
      . . .
          {
              "name": "HotelName",
              "type": "Edm.String",
              "facetable": false,
              "filterable": false,
              "key": false,
              "retrievable": true,
              "searchable": true,
              "sortable": false,
              "analyzer": "en.microsoft",
              "indexAnalyzer": null,
              "searchAnalyzer": null,
              "synonymMaps": [],
              "fields": []
          },
    ],
    "suggesters": [
      {
        "name": "sg",
        "searchMode": "analyzingInfixMatching",
        "sourceFields": ["HotelName"]
      }
    ],
    "scoringProfiles": [
      . . .
    ]
  }
  ```

### <a name="create-using-the-net-sdk"></a>Создание с помощью .NET SDK

В C q определите [объект Suggester.](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.suggester?view=azure-dotnet) `Suggesters`представляет собой коллекцию, но она может принимать только один элемент. 

```csharp
private static void CreateHotelsIndex(SearchServiceClient serviceClient)
{
    var definition = new Index()
    {
        Name = "hotels-sample-index",
        Fields = FieldBuilder.BuildForType<Hotel>(),
        Suggesters = new List<Suggester>() {new Suggester()
            {
                Name = "sg",
                SourceFields = new string[] { "HotelName", "Category" }
            }}
    };

    serviceClient.Indexes.Create(definition);

}
```

### <a name="property-reference"></a>Справочные данные по свойствам

|Свойство      |Описание      |
|--------------|-----------------|
|`name`        |Имя средства подбора.|
|`searchMode`  |Стратегия, используемая для поиска фраз кандидата. В настоящее время поддерживается только режим `analyzingInfixMatching`, в рамках которого выполняется гибкий поиск совпадений в начале и середине фраз.|
|`sourceFields`|Список из одного или нескольких полей, которые служат источником содержимого для предложений. Поля должны быть `Edm.String` `Collection(Edm.String)`типа и . Если анализатор указан на поле, он должен быть названным анализатором из [этого списка](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.analyzername?view=azure-dotnet) (не пользовательский анализатор).<p/> В качестве наилучшей практики укажите только те области, которые поддаются ожидаемому и соответствующему ответу, будь то завершенная строка в строке поиска или список выпадающих.<p/>Название отеля является хорошим кандидатом, потому что он имеет точность. Области verbose, такие как описания и комментарии, слишком плотны. Аналогичным образом, повторяющиеся поля, такие как категории и теги, менее эффективны. В примерах мы включаем "категорию" в любом случае, чтобы продемонстрировать, что вы можете включить несколько полей. |

<a name="how-to-use-a-suggester"></a>

## <a name="use-a-suggester"></a>Используйте наводящий

В запросе используется подсобие. После создания наводящего запроса позвоните в соответствующий API в логике запроса, чтобы вызвать функцию. 

+ [Предложения REST API](https://docs.microsoft.com/rest/api/searchservice/suggestions) 
+ [Автополный REST API](https://docs.microsoft.com/rest/api/searchservice/autocomplete) 
+ [Предложитьметодhttpсообщенияасасинки](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.idocumentsoperations.suggestwithhttpmessagesasync?view=azure-dotnet)
+ [Метод AutocompleteWithMessagesasync](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.idocumentsoperations.autocompletewithhttpmessagesasync?view=azure-dotnet&viewFallbackFrom=azure-dotnet)

Использование API иллюстрируется в следующем вызове на Autocomplete REST API. Есть два вынос из этого примера. Во-первых, как и во всех запросах, операция противоречит сбору документов индекса. Во-вторых, можно добавить параметры запроса. Хотя многие параметры запроса являются общими для обоих AA, список отличается для каждого из них.

```http
GET https://[service name].search.windows.net/indexes/[index name]/docs/autocomplete?[query parameters]  
api-key: [admin or query key]
```

Если в индексе не определен указатель, вызов к автозаполнению или предложениям не будет выполнен.

## <a name="sample-code"></a>Образец кода

+ [Создание первого приложения в](tutorial-csharp-type-ahead-and-suggestions.md) образце СЗ демонстрирует наводящую конструкцию, предлагаемые запросы, автозаполнение и граненые навигации. Этот образец кода работает на службе когнитивного поиска Azure и использует предварительно загруженный индекс Отелей, так что все, что вам нужно сделать, это нажать F5 для запуска приложения. Подписка или ввоза не требуется.

+ [DotNetHowToAutocomplete](https://github.com/Azure-Samples/search-dotnet-getting-started/tree/master/DotNetHowToAutocomplete) — это старый образец, содержащий код как на C-е, так и на Java. Он также демонстрирует предполагаемое строительство, предлагаемые запросы, автозаполнение и граненую навигацию. В этом примере кода используются размещенные данные образца [NYCJobs.](https://github.com/Azure-Samples/search-dotnet-asp-net-mvc-jobs) 

## <a name="next-steps"></a>Дальнейшие действия

Мы рекомендуем следующий пример, чтобы увидеть, как формулируются запросы.

> [!div class="nextstepaction"]
> [Предложения и примеры автозаполнения](search-autocomplete-tutorial.md) 
