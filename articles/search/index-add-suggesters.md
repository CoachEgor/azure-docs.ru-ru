---
title: Создание средства подбора
titleSuffix: Azure Cognitive Search
description: Включите действия запроса типа вперед в Azure Cognitive Search, создавая предложители и формулируя запросы, которые ссылают сядебные или автопредлагаемые термины запроса.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 04/21/2020
ms.openlocfilehash: 7eb2988628d60fa72c7d83b81a58a1e0fae5de33
ms.sourcegitcommit: d57d2be09e67d7afed4b7565f9e3effdcc4a55bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81770101"
---
# <a name="create-a-suggester-to-enable-autocomplete-and-suggested-results-in-a-query"></a>Создание подсказчика для автоматического заполнения и предлагаемых результатов в запросе

В Azure Cognitive Search функция «поиск по типу» включена через конструкцию **отобрасвателя,** добавленную в [индекс поиска.](search-what-is-an-index.md) Suggester поддерживает два опыта: *автозаполнение*, который завершает частичный ввод для всего запроса термина, и *предложения,* которые предлагает нажать до определенного матча. Автозаполнение создает запрос. Предложения создают соответствующий документ.

Следующий скриншот из [Создайте свое первое приложение в СЗ](tutorial-csharp-type-ahead-and-suggestions.md) иллюстрирует и то, и другое. Автозаполнение предвосхищает потенциальный термин, заканчивая "tw" с "в". Предложения — это мини-результаты поиска, где такое поле, как название отеля, представляет собой соответствующий документ поиска отеля из индекса. Для предложений можно выложить любую область, предоставляющую описательную информацию.

![Визуальное сравнение автозаполнения и предлагаемых запросов](./media/index-add-suggesters/hotel-app-suggestions-autocomplete.png "Визуальное сравнение автозаполнения и предлагаемых запросов")

Вы можете использовать эти функции отдельно или вместе. Для реализации этих функций в Azure Cognitive Search существует компонент индекса и запроса. 

+ В индексе добавьте подсыплятеля к индексу. Вы можете использовать портал, [REST API](https://docs.microsoft.com/rest/api/searchservice/create-index)или [.NET SDK](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.suggester?view=azure-dotnet). Остальная часть этой статьи сосредоточена на создании подсобного предложения.

+ В запросе запроса позвоните в один из [AIS, перечисленных ниже.](#how-to-use-a-suggester)

Поддержка поиска по типу поиска включена на основе поля для полей строк. Вы можете реализовать оба поведения typeahead в одном и том же решении поиска, если вы хотите опыт, аналогичный тому, который указан на скриншоте. Оба запроса нацелены на сбор *документов* конкретного индекса, и ответы возвращаются после того, как пользователь предоставил по крайней мере три строки ввода символов.

## <a name="what-is-a-suggester"></a>Что такое подсобие?

Подсобитель — это внутренняя структура данных, которая поддерживает поведение типа поиска по мере использования путем хранения префиксов для сопоставления по частичным запросам. Как и в токенизированных терминах, префиксы хранятся в перевернутых индексах, по одному для каждого поля, указанного в коллекции полей отосваса.

## <a name="define-a-suggester"></a>Определить наводящего

Чтобы создать подсобича, добавьте его в [схему индекса](https://docs.microsoft.com/rest/api/searchservice/create-index) и [установите каждое свойство.](#property-reference) Лучшее время для создания подсобного предложения , когда вы также определения поля, которые будут использовать его.

+ Используйте только струнные поля

+ Используйте стандартный анализатор`"analyzer": null`Lucene по умолчанию () `"analyzer": "en.Microsoft"`или [анализатор языка](index-add-language-analyzers.md) (например, ) на поле

### <a name="choose-fields"></a>Выбор полей

Хотя наводящий имеет несколько свойств, это в первую очередь коллекция строевых полей, для которых вы позволяете поиск по мере ввода опыта. Существует один предложить для каждого индекса, так что список предложить должен включать все поля, которые вносят содержание как для предложений и автозаполнения.

Автозаполнение выгоды от большего пула полей, чтобы извлечь из, потому что дополнительное содержание имеет больше термина завершения потенциала.

Предложения, с другой стороны, дают лучшие результаты, когда ваш выбор поля является избирательным. Помните, что предложение является прокси для поискового документа, так что вы хотите поля, которые наилучшим образом представляют один результат. Имена, названия или другие уникальные поля, которые отличаются от нескольких совпадений, работают лучше всего. Если поля состоят из повторяющихся значений, предложения состоят из одинаковых результатов, и пользователь не будет знать, какой из них нажимать.

Чтобы удовлетворить оба поиска по мере использования опытом, добавьте все поля, которые вам нужны для автозаполнения, но затем используйте **$select,** **$top,** **$filter**и **searchFields** для управления результатами для предложений.

### <a name="choose-analyzers"></a>Выберите анализаторы

Ваш выбор анализатора определяет, как поля токенизируются и впоследствии прекреплятся. Например, для дефисной строки, такой как "контекст-чувствительный", использование анализатора языка приведет к таким комбинациям маркеров: "контекст", "чувствительный", "контекст-чувствительный". Если бы вы использовали стандартный анализатор Lucene, дефисстроки не существовало бы. 

При оценке анализаторов рассмотрите возможность использования [API анализа текста](https://docs.microsoft.com/rest/api/searchservice/test-analyzer) для понимания того, как термины токенизируются и впоследствии прекрепляются. После создания индекса можно попробовать различные анализаторы на строке для просмотра вывода маркеров.

Поля, в которых используются [пользовательские анализаторы](index-add-custom-analyzers.md) или [предопределенные анализаторы](index-add-custom-analyzers.md#predefined-analyzers-reference) (за исключением стандартного Lucene), явно запрещены для предотвращения плохих результатов.

> [!NOTE]
> Если вам нужно обойти ограничение анализатора, например, если вам нужен анализатор по ключевому слову или ngram для определенных сценариев запроса, следует использовать два отдельных поля для одного и того же содержимого. Это позволит одному из полей иметь предложить, в то время как другое может быть настроено с пользовательской конфигурацией анализатора.

### <a name="when-to-create-a-suggester"></a>Когда создать наводящего

Лучшее время для создания подсобного предложения — это когда вы также создаете само определение поля.

Если вы попытаетесь создать предложить с помощью уже существующих полей, API запретит его. Префиксы создаются во время индексации, когда частичные термины в двух или более комбинациях символов токенизируются вместе с целыми терминами. Учитывая, что существующие поля уже токенизированы, вам придется перестроить индекс, если вы хотите добавить их в предложить. Для получения дополнительной информации [см.](search-howto-reindex.md)

## <a name="create-using-rest"></a>Создание с помощью REST

В REST API добавьте предложить через [Создать индекс](https://docs.microsoft.com/rest/api/searchservice/create-index) или [индекс обновления](https://docs.microsoft.com/rest/api/searchservice/update-index). 

  ```json
  {
    "name": "hotels-sample-index",
    "fields": [
      . . .
          {
              "name": "HotelName",
              "type": "Edm.String",
              "facetable": false,
              "filterable": false,
              "key": false,
              "retrievable": true,
              "searchable": true,
              "sortable": false,
              "analyzer": "en.microsoft",
              "indexAnalyzer": null,
              "searchAnalyzer": null,
              "synonymMaps": [],
              "fields": []
          },
    ],
    "suggesters": [
      {
        "name": "sg",
        "searchMode": "analyzingInfixMatching",
        "sourceFields": ["HotelName"]
      }
    ],
    "scoringProfiles": [
      . . .
    ]
  }
  ```

## <a name="create-using-net"></a>Создание с помощью .NET

В C q определите [объект Suggester.](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.suggester?view=azure-dotnet) `Suggesters`представляет собой коллекцию, но она может принимать только один элемент. 

```csharp
private static void CreateHotelsIndex(SearchServiceClient serviceClient)
{
    var definition = new Index()
    {
        Name = "hotels-sample-index",
        Fields = FieldBuilder.BuildForType<Hotel>(),
        Suggesters = new List<Suggester>() {new Suggester()
            {
                Name = "sg",
                SourceFields = new string[] { "HotelName", "Category" }
            }}
    };

    serviceClient.Indexes.Create(definition);

}
```

## <a name="property-reference"></a>Справочные данные по свойствам

|Свойство.      |Описание      |
|--------------|-----------------|
|`name`        |Имя средства подбора.|
|`searchMode`  |Стратегия, используемая для поиска фраз кандидата. Единственный режим в `analyzingInfixMatching`настоящее время поддерживается, который в настоящее время совпадает в начале срока.|
|`sourceFields`|Список из одного или нескольких полей, которые служат источником содержимого для предложений. Поля должны быть `Edm.String` `Collection(Edm.String)`типа и . Если анализатор указан на поле, он должен быть названным анализатором из [этого списка](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.analyzername?view=azure-dotnet) (не пользовательский анализатор).<p/> В качестве наилучшей практики укажите только те области, которые поддаются ожидаемому и соответствующему ответу, будь то завершенная строка в строке поиска или список выпадающих.<p/>Название отеля является хорошим кандидатом, потому что он имеет точность. Области verbose, такие как описания и комментарии, слишком плотны. Аналогичным образом, повторяющиеся поля, такие как категории и теги, менее эффективны. В примерах мы включаем "категорию" в любом случае, чтобы продемонстрировать, что вы можете включить несколько полей. |

<a name="how-to-use-a-suggester"></a>

## <a name="use-a-suggester"></a>Используйте наводящий

В запросе используется подсобие. После создания наводящего на этот предложение позвоните в один из следующих AI для поиска по мере того, как вы набирайте:

+ [Предложения REST API](https://docs.microsoft.com/rest/api/searchservice/suggestions) 
+ [Автополный REST API](https://docs.microsoft.com/rest/api/searchservice/autocomplete) 
+ [Предложитьметодhttpсообщенияасасинки](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.idocumentsoperations.suggestwithhttpmessagesasync?view=azure-dotnet)
+ [Метод AutocompleteWithMessagesasync](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.idocumentsoperations.autocompletewithhttpmessagesasync?view=azure-dotnet&viewFallbackFrom=azure-dotnet)

В приложении поиска клиентский код должен использовать библиотеку, как [j'ury UI Autocomplete](https://jqueryui.com/autocomplete/) для сбора частичного запроса и предоставления совпадения. Для получения дополнительной информации об этой задаче [см.](search-autocomplete-tutorial.md)

Использование API иллюстрируется в следующем вызове на Autocomplete REST API. Есть два вынос из этого примера. Во-первых, как и во всех запросах, операция противоречит сбору документов индекса, а запрос включает параметр **поиска,** который в данном случае предоставляет частичный запрос. Во-вторых, необходимо добавить **suggesterName** к запросу. Если в индексе не определен указатель, вызов к автозаполнению или предложениям не будет выполнен.

```http
POST /indexes/myxboxgames/docs/autocomplete?search&api-version=2019-05-06
{
  "search": "minecraf",
  "suggesterName": "sg"
}
```

## <a name="sample-code"></a>Образец кода

+ [Создайте свое первое приложение в СЗ (урок 3 - Добавить поиск по мере вашего типа)](tutorial-csharp-type-ahead-and-suggestions.md) образец демонстрирует предполагаемой конструкции, предлагаемые запросы, автозаполнение и граненую навигацию. Этот образец кода работает на службе когнитивного поиска Azure и использует предварительно загруженный индекс Отелей, так что все, что вам нужно сделать, это нажать F5 для запуска приложения. Подписка или ввоза не требуется.

+ [DotNetHowToAutocomplete](https://github.com/Azure-Samples/search-dotnet-getting-started/tree/master/DotNetHowToAutocomplete) — это старый образец, содержащий код как на C-е, так и на Java. Он также демонстрирует предполагаемое строительство, предлагаемые запросы, автозаполнение и граненую навигацию. В этом примере кода используются размещенные данные образца [NYCJobs.](https://github.com/Azure-Samples/search-dotnet-asp-net-mvc-jobs) 

## <a name="next-steps"></a>Следующие шаги

Мы рекомендуем следующую статью, чтобы узнать больше о том, как формулировка запросов.

> [!div class="nextstepaction"]
> [Добавление автозаполнения и предложений в код клиента](search-autocomplete-tutorial.md) 
