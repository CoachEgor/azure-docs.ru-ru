---
title: Создание определения индекса и концепций
titleSuffix: Azure Cognitive Search
description: Введение в индексные термины и концепции в Azure Cognitive Search, включая компоненты и физическую структуру.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 12/17/2019
ms.openlocfilehash: d2b8b2fecbf85e6590294f1fbd7ff2a4453b9e87
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79282787"
---
# <a name="create-a-basic-index-in-azure-cognitive-search"></a>Создание базового индекса в когнитивном поиске Azure

В Azure Cognitive Search *индекс* представляет собой постоянное хранилище *документов* и других конструкций, используемых для отфильтрованного и полного поиска текста в службе когнитивного поиска Azure. Документ представляет собой единый блок доступных для поиска данных в индексе. Например, в интернет-магазине для каждой позиции продажи есть определенный документ, в агентстве новостей есть такой документ для каждой статьи и т. д. Можно сравнить эти понятия с более знакомыми понятиями баз данных. В таком случае *индекс* похож на *таблицу*, а *документы* — на *строки* в ней.

При добавлении или загрузке индекса Azure Cognitive Search создает физические структуры на основе предоставляемой вами схемы. Например, если поле в индексе помечено как доступное для поиска, для него создается инвертированный индекс. Позже, когда вы добавляете или загружаете документы или отправляете поисковые запросы в Azure Cognitive Search, вы отправляете запросы в определенный индекс в службе поиска. Загрузка полей со значениям документов называется *индексированием* или приемом данных.

Индекс можно создать с помощью портала, [REST API](search-create-index-rest-api.md) или [пакета SDK для .NET](search-create-index-dotnet.md).

## <a name="recommended-workflow"></a>Рекомендуемый рабочий процесс

Чтобы спроектировать правильный индекс, как правило, требуется выполнить несколько итераций. Сочетание различных инструментов и интерфейсов API поможет вам быстро создать проект.

1. Определите, можно ли использовать [индексатор](search-indexer-overview.md#supported-data-sources). Если одним из поддерживаемых источников данных являются внешние данные, вы можете создать прототип индекса и загрузить его с помощью мастера [**импорта данных**](search-import-data-portal.md).

2. Если использовать **импорт данных** невозможно, вы можете [создать начальный индекс на портале](search-create-index-portal.md), добавить поля, типы данных и назначить атрибуты с помощью элементов управления на странице **Добавление индекса**. На портале отображаются атрибуты, доступные для различных типов данных. Это удобно, если вы впервые проектируете индекс.

   ![Добавление страницы индекса, отображающие атрибуты по типу данных](media/search-create-index-portal/field-attributes.png "Добавление страницы индекса, отображающие атрибуты по типу данных")
  
   При нажатии кнопки **Создать** в службе поиска создаются все физические структуры, обеспечивающие работу индекса.

3. Скачайте схему индекса с помощью [REST API получения индекса](https://docs.microsoft.com/rest/api/searchservice/get-index) и веб-инструмента тестирования, например [Postman](search-get-started-postman.md). Теперь у вас есть индекс, созданный на портале, в формате JSON. 

   На этом этапе следует перейти к программированию. Портал не подходит для итерации, потому что вы не можете отсеить уже созданный индекс. Но для выполнения оставшихся задач можно использовать Postman и REST.

4. [Загрузите данные в индекс](search-what-is-data-import.md). Azure Cognitive Search принимает документы JSON. Для программной загрузки данных можно использовать Postman с добавлением документов JSON в полезные данные запроса. Если данные сложно представить в формате JSON, то этот шаг будет наиболее трудоемким.

5. Отправляйте запросы к индексу, проверяйте результаты и выполняйте дальнейшие итерации со схемой индекса, пока не добьетесь ожидаемых результатов. Для отправки запросов к индексу можно использовать [**проводник поиска**](search-explorer.md) или Postman.

6. Продолжайте использовать код для выполнения итераций проекта.  

Поскольку физические структуры создаются в службе, [удаление и воссоздание индексов](search-howto-reindex.md) необходимо всякий раз, когда вы вносят существенные изменения в существующее определение поля. Это означает, что на время разработки необходимо запланировать частые операции перестроения. Можно рассмотреть возможность использования подмножества данных, чтобы ускорить перестроение. 

Для итеративного проектирования рекомендуется использовать программный подход, а не портал. Если вы используете портал для определения индекса, потребуется заполнять определение индекса при каждом перестроении. Кроме того, для подтверждения концепции и тестирования на ранних этапах проектов по разработке удобно использовать такие инструменты, как [Postman и REST API](search-get-started-postman.md). Можно внести добавочные изменения в определение индекса в тексте запроса, и затем отправить запрос к службе для повторного создания индекса с помощью обновленной схемы.

## <a name="components-of-an-index"></a>Компоненты индекса

Схематически индекс когнитивного поиска Azure состоит из следующих элементов. 

[*Коллекция полей*](#fields-collection) обычно будет самой крупной частью индекса. Здесь каждому полю присвоены имя, тип и атрибуты, обозначающие допустимые поведения и порядок использования полей. Другие элементы включают в себя [предлагатели,](#suggesters) [скоринг профилей](#scoring-profiles), [анализаторы](#analyzers) с компонентами для поддержки настройки, [CORS](#cors) и [параметры ключей шифрования.](#encryption-key)

```json
{
  "name": (optional on PUT; required on POST) "name_of_index",
  "fields": [
    {
      "name": "name_of_field",
      "type": "Edm.String | Collection(Edm.String) | Edm.Int32 | Edm.Int64 | Edm.Double | Edm.Boolean | Edm.DateTimeOffset | Edm.GeographyPoint",
      "searchable": true (default where applicable) | false (only Edm.String and Collection(Edm.String) fields can be searchable),
      "filterable": true (default) | false,
      "sortable": true (default where applicable) | false (Collection(Edm.String) fields cannot be sortable),
      "facetable": true (default where applicable) | false (Edm.GeographyPoint fields cannot be facetable),
      "key": true | false (default, only Edm.String fields can be keys),
      "retrievable": true (default) | false,
      "analyzer": "name_of_analyzer_for_search_and_indexing", (only if 'searchAnalyzer' and 'indexAnalyzer' are not set)
      "searchAnalyzer": "name_of_search_analyzer", (only if 'indexAnalyzer' is set and 'analyzer' is not set)
      "indexAnalyzer": "name_of_indexing_analyzer", (only if 'searchAnalyzer' is set and 'analyzer' is not set)
      "synonymMaps": [ "name_of_synonym_map" ] (optional, only one synonym map per field is currently supported)
    }
  ],
  "suggesters": [
    {
      "name": "name of suggester",
      "searchMode": "analyzingInfixMatching",
      "sourceFields": ["field1", "field2", ...]
    }
  ],
  "scoringProfiles": [
    {
      "name": "name of scoring profile",
      "text": (optional, only applies to searchable fields) {
        "weights": {
          "searchable_field_name": relative_weight_value (positive #'s),
          ...
        }
      },
      "functions": (optional) [
        {
          "type": "magnitude | freshness | distance | tag",
          "boost": # (positive number used as multiplier for raw score != 1),
          "fieldName": "...",
          "interpolation": "constant | linear (default) | quadratic | logarithmic",
          "magnitude": {
            "boostingRangeStart": #,
            "boostingRangeEnd": #,
            "constantBoostBeyondRange": true | false (default)
          },
          "freshness": {
            "boostingDuration": "..." (value representing timespan leading to now over which boosting occurs)
          },
          "distance": {
            "referencePointParameter": "...", (parameter to be passed in queries to use as reference location)
            "boostingDistance": # (the distance in kilometers from the reference location where the boosting range ends)
          },
          "tag": {
            "tagsParameter": "..." (parameter to be passed in queries to specify a list of tags to compare against target fields)
          }
        }
      ],
      "functionAggregation": (optional, applies only when functions are specified) 
        "sum (default) | average | minimum | maximum | firstMatching"
    }
  ],
  "analyzers":(optional)[ ... ],
  "charFilters":(optional)[ ... ],
  "tokenizers":(optional)[ ... ],
  "tokenFilters":(optional)[ ... ],
  "defaultScoringProfile": (optional) "...",
  "corsOptions": (optional) {
    "allowedOrigins": ["*"] | ["origin_1", "origin_2", ...],
    "maxAgeInSeconds": (optional) max_age_in_seconds (non-negative integer)
  },
  "encryptionKey":(optional){
    "keyVaultUri": "azure_key_vault_uri",
    "keyVaultKeyName": "name_of_azure_key_vault_key",
    "keyVaultKeyVersion": "version_of_azure_key_vault_key",
    "accessCredentials":(optional){
      "applicationId": "azure_active_directory_application_id",
      "applicationSecret": "azure_active_directory_application_authentication_key"
    }
  }
}
```

<a name="fields-collection"></a>

## <a name="fields-collection-and-field-attributes"></a>Коллекции полей и атрибуты поля

При определении схемы необходимо указать имя, тип и атрибуты для каждого поля в индексе. Тип поля используется для классификации данных, хранящихся в этом поле. Атрибуты устанавливаются для отдельных полей для определения того, как эти поля будут использоваться. Доступные типы и атрибуты перечислены в таблицах ниже.

### <a name="data-types"></a>Типы данных
| Тип | Описание |
| --- | --- |
| *Edm.String* |Текст, который при необходимости может быть разбит на лексемы для полнотекстового поиска (разбиение на слова, выделение корней и т. д.). |
| *Коллекция (Edm.String)* |Список строк, которые при необходимости могут быть снабжены маркером для полнотекстового поиска. Для количества элементов в коллекции не предусмотрен теоретический верхний предел, но к коллекциям применяется верхний предел для объема полезных данных — 16 МБ. |
| *Edm.Boolean* |Содержит значения True или False. |
| *Edm.Int32* |32-разрядные целочисленные значения. |
| *Edm.Int64* |64-разрядные целочисленные значения. |
| *Edm.Double* |Числовые данные с двойной точностью. |
| *Edm.DateTimeOffset* |Значения даты и времени в формате OData V4 (например, `yyyy-MM-ddTHH:mm:ss.fffZ` или `yyyy-MM-ddTHH:mm:ss.fff[+/-]HH:mm`). |
| *Edm.GeographyPoint* |Точка, представляющая географическое расположение. |

Более подробную информацию о [поддерживаемых типах данных](https://docs.microsoft.com/rest/api/searchservice/Supported-data-types)Azure Cognitive Search можно найти здесь.

### <a name="index-attributes"></a>Атрибуты индекса

Ровно одно поле в индексе должно быть обозначено как **ключевое** поле, которое однозначно идентифицирует каждый документ.

Другие атрибуты определяют, как поле используется в приложении. Например, атрибут **поиска** присваивается каждому полю, которое должно быть включено в полный текстовый поиск. 

AA, которые используются для создания индекса, имеют различное поведение по умолчанию. Для [API REST](https://docs.microsoft.com/rest/api/searchservice/Create-Index)большинство атрибутов включены по умолчанию (например, **поиск** и **извлекаемые** данные верны для полей строки), и часто требуется установить их только в том случае, если вы хотите их отключить. Для .NET SDK все наоборот. На любом свойстве, который вы явно не установили, по умолчанию следует отключить соответствующее поведение поиска, если только вы специально не включить его.

| Атрибут | Описание |
| --- | --- |
| `key` |Уникальный строковый идентификатор (ключ) каждого документа, по которому выполняется обращение к документам. У каждого индекса должен быть один ключ. Ключом может быть только одно поле; в качестве его типа должно быть задано значение Edm.String. |
| `retrievable` |Указывает, возвращать ли поле в результатах поиска. |
| `filterable` |Позволяет использовать поле в запросах фильтра. |
| `Sortable` |Позволяет с помощью этого поля сортировать результаты поиска при запросе. |
| `facetable` |Позволяет использовать поле в структуре [фасетной навигации](search-faceted-navigation.md) для автоматической фильтрации пользователем. Обычно для фасетной навигации подходят поля, содержащие повторяющиеся значения, которые можно использовать для группирования различных документов (например, если несколько документов относятся к одной и той же категории или к одному производителю). |
| `searchable` |Помечает поле как доступное для полнотекстового поиска. |

## <a name="index-size"></a>Размер индекса

Размер индекса определяется размером загружаемых документов, а также конфигурацией индекса, например, включаете ли вы предложить и как вы устанавливаете атрибуты на отдельных полях. На следующем снимке экрана показаны шаблоны хранения индекса, полученные в результате различных сочетаний атрибутов.

Индекс основан на [встроенном источнике данных выборки недвижимости,](search-get-started-portal.md) который можно индексировать и задать на портале. Хотя схемы индексов не показаны, атрибуты можно определить на основе имени индекса. Например, для индекса *realestate-searchable* выбран только атрибут **searchable**, для индекса *realestate-retrievable* выбран только атрибут **retrievable** и т. д.

![Размер индекса, основанный на выборе атрибутов](./media/search-what-is-an-index/realestate-index-size.png "Размер индекса, основанный на выборе атрибутов")

Хотя эти варианты индекса являются искусственными, они подходят для общего сравнения влияния различных атрибутов на размер хранилища. Атрибут **retrievable** увеличивает размер индекса? Нет. Добавление полей в **средство подбора** увеличивает размер индекса? Да.

Индексы, поддерживающие фильтр и сортированные, пропорционально больше, чем индексы, поддерживающие просто полный поиск текста. Фильтр и сортировка операций сканирования для точных совпадений, требующих наличия нетронутых документов. Напротив, доступные для поиска поля, поддерживающие полнотекстовый поиск и поиск нечетких соответствий, используют инвертированные индексы, которые заполнены разбитыми на лексемы термины и занимают меньше места, чем целые документы. 

> [!Note]
> Архитектура хранения данных считается деталью реализации Azure Cognitive Search и может изменяться без предварительного уведомления. Нет никакой гарантии, что ее текущее поведение будет сохранено в будущем.

## <a name="suggesters"></a>Средства подбора
Средством подбора называется часть схемы, которая определяет, какие поля в индексе используются для поддержки автозавершения и упреждающего ввода запросов при поиске. Как правило, частичные строки поиска отправляются [в Предложения (REST API),](https://docs.microsoft.com/rest/api/searchservice/suggestions) в то время как пользователь печатает поисковый запрос, и API возвращает набор предлагаемых документов или фраз. 

Поля, добавленные в средство подбора, используются для создания терминов для упреждающего поиска. Все термины для поиска создаются во время индексирования и хранятся отдельно. Дополнительные сведения о создании структуры средства подбора см. в разделе [Добавление средств подбора в индекс службы "Поиск Azure"](index-add-suggesters.md).

## <a name="scoring-profiles"></a>Профили оценки

[Профиль скоринга](index-add-scoring-profiles.md) — это раздел схемы, определяющий пользовательские поведения скоринга, которые позволяют влиять на элементы, которые отображаются выше в результатах поиска. Профили оценки состоят из взвешенных полей и функций. Чтобы использовать их, необходимо задать профиль по имени в строке запроса.

Профиль оценки по умолчанию вычисляет оценку поиска для каждого элемента в результирующем наборе в фоновом режиме. Можно использовать внутренний профиль оценки без имени. Кроме того, установите **defaultScoringProfile** для использования пользовательского профиля в качестве по умолчанию, вызываемого всякий раз, когда пользовательский профиль не указан в строке запроса.

## <a name="analyzers"></a>Анализаторы

Элемент анализатора задает имя анализатора языка, который нужно использовать для поля. Для получения дополнительной информации о диапазоне доступных для вас анализаторов [см.](search-analyzers.md) Анализаторы могут использоваться только для доступных для поиска полей. После назначения полю анализатора его невозможно изменить без перестроения индекса.

## <a name="cors"></a>CORS

По умолчанию клиентский код JavaScript не может обращаться к API, так как браузер блокирует все запросы между разными источниками. Чтобы разрешить запросы между источниками к нужному индексу, включите CORS (Cross-Origin Resource Sharing — общий доступ к ресурсам независимо от источника), установив атрибут **corsOptions**. По соображениям безопасности технологию CORS поддерживают только интерфейсы API запросов. 

Для технологии CORS можно настроить перечисленные ниже параметры.

+ **allowedOrigins** (требуется): Это список происхождения, который будет предоставлен доступ к вашему индексу. Это означает, что любой код JavaScript из такого источника сможет отправлять запросы к этому индексу (при условии, что указан правильный ключ API). Источники здесь обычно задаются в формате `protocol://<fully-qualified-domain-name>:<port>`, хотя `<port>` часто опускается. Дополнительные сведения см. в статье Википедии [о предоставлении ресурсов для нескольких источников](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing).

  Если вы хотите разрешить доступ всем источникам, добавьте в массив **allowedOrigins** единственный элемент `*`. *Этот вариант не рекомендуется для служб поиска в рабочей среде*, но часто он удобен для разработки и отладки.

+ **maxAgeInSeconds** (необязательно): Браузеры используют это значение для определения продолжительности (в секундах) для кэша предполетных ответов CORS. Это значение должно быть целой неотрицательной величиной. Чем оно больше, чем выше производительность, однако при этом применение изменений в политике CORS занимает больше времени. Если это значение не задано, длительность по умолчанию составляет 5 минут.

## <a name="encryption-key"></a>Ключ шифрования

В то время как все индексы Azure Cognitive Search зашифрованы по умолчанию с помощью ключей, управляемых Корпорацией Майкрософт, индексы могут быть настроены для шифрования с **помощью ключей, управляемых клиентом** в Key Vault. Чтобы узнать больше, смотрите [Управление ключами шифрования в Azure Cognitive Search](search-security-manage-encryption-keys.md).

## <a name="next-steps"></a>Дальнейшие действия

Разобравшись со структурой индекса, вы можете перейти на портал и создать свой первый индекс.

> [!div class="nextstepaction"]
> [Создание индекса на портале](search-create-index-portal.md)
