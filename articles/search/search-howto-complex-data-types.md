---
title: Моделирование сложных типов данных в службе "Поиск Azure"
description: Вложенные или иерархические данные структуры можно моделировать в индексе поиска Azure с помощью ComplexType и коллекции типов данных.
author: brjohnstmsft
manager: jlembicz
ms.author: brjohnst
tags: complex data types; compound data types; aggregate data types
services: search
ms.service: search
ms.topic: conceptual
ms.date: 06/13/2019
ms.custom: seodec2018
ms.openlocfilehash: e7e6ddefd13d669c949389bc4fad85fb6cff4d3a
ms.sourcegitcommit: 6a42dd4b746f3e6de69f7ad0107cc7ad654e39ae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/07/2019
ms.locfileid: "67621366"
---
# <a name="how-to-model-complex-data-types-in-azure-search"></a>Моделирование сложных типов данных в службе поиска Azure

Внешние наборы данных, используемые для заполнения индекса службы поиска Azure может быть много фигур. Иногда они включают иерархические или вложенные подструктуры. Примеры могут включать в себя несколько адресов для одного клиента, несколько цветов и размеров для одного SKU, несколько авторов на одну книгу и так далее. Моделирование условия, может появиться эти структуры называются *сложных*, *комплексной*, *составного*, или *агрегатные* типов данных. В перспективе, поиск Azure использует для эта концепция является **сложного типа**. В службе поиска Azure, сложные типы моделируются с помощью **сложных полей**. Сложные поле является полем, которое содержит дочерние элементы (вложенные поля), которые могут быть любого типа данных, включая других сложных типов. Это работает точно так же как типы структурированных данных в языке программирования.

Сложные поля представляют один объект в документе, или массив объектов, в зависимости от типа данных. Поля типа `Edm.ComplexType` представляют отдельных объектов, а поля типа `Collection(Edm.ComplexType)` представляют массивы объектов.

Поиск Azure изначально поддерживает сложные типы и коллекции. Эти типы позволяют моделировать практически к любой структуре JSON в индекс службы поиска Azure. В предыдущих версиях API-интерфейсов поиска Azure только сведение строки, которые могут быть импортированы наборов. В последней версии индекс может теперь более точно соответствовать исходных данных. Другими словами Если исходные данные содержат сложные типы, индекс может иметь сложные типы также.

Чтобы приступить к работе, мы рекомендуем [набора данных гостиницы](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/README.md), который можно загрузить в **импорта данных** мастера на портале Azure. Мастер обнаруживает сложных типов в источнике и предлагает схему индекса, в зависимости от обнаруженных структур.

> [!Note]
> Поддержка сложных типов находится в общем доступе в `api-version=2019-05-06`. 
>
> Если решение поиска создан в более ранних обходные пути плоских наборов данных в коллекции, следует изменить индекс, чтобы включить одни сложные типы, так как поддерживается в последней версии API. Дополнительные сведения об обновлении версии API, см. в разделе [обновление до последней версии REST API](search-api-migration.md) или [обновление до последней версии пакета SDK для .NET](search-dotnet-sdk-migration-version-9.md).

## <a name="example-of-a-complex-structure"></a>Пример сложной структуры

Ниже приведен документ JSON состоит из простых и сложных поля. Комплексное полях, например `Address` и `Rooms`, имеют вложенные поля. `Address` имеет один набор значений для этих вложенных полей, так как он представляет собой один объект в документе. Напротив `Rooms` имеет несколько наборов значений для его вложенных полей, по одному для каждого объекта в коллекции.

```json
{
  "HotelId": "1",
  "HotelName": "Secret Point Motel",
  "Description": "Ideally located on the main commercial artery of the city in the heart of New York.",
  "Address": {
    "StreetAddress": "677 5th Ave",
    "City": "New York",
    "StateProvince": "NY"
  },
  "Rooms": [
    {
      "Description": "Budget Room, 1 Queen Bed (Cityside)",
      "Type": "Budget Room",
      "BaseRate": 96.99
    },
    {
      "Description": "Deluxe Room, 2 Double Beds (City View)",
      "Type": "Deluxe Room",
      "BaseRate": 150.99
    },
  ]
}
```

## <a name="creating-complex-fields"></a>Создание сложных полей

Как с помощью любого определения индекса, можно использовать портал, [REST API](https://docs.microsoft.com/rest/api/searchservice/create-index), или [пакета SDK для .NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.index?view=azure-dotnet) создать схему, которая включает в себя сложных типов. 

Следующий пример показывает схему индекса JSON с помощью простых полей, коллекций и сложные типы. Обратите внимание на то, что внутри сложного типа, имеет тип каждого поля и может иметь атрибуты, как просто верхнего уровня поля. Схема соответствует данные для примера выше. `Address` — Это сложный поле, не является коллекцией (Гостиница имеет один адрес). `Rooms` — Это поле סכמזםי (Гостиница имеет много комнаты).

<!---
For indexes used in a [push-model data import](search-what-is-data-import.md) strategy, where you are pushing a JSON data set to an Azure Search index, you can only have the basic syntax shown here: single complex types like `Address`, or a `Collection(Edm.ComplexType)` like `Rooms`. You cannot have complex types nested inside other complex types in an index used for push-model data ingestion.

Indexers are a different story. When defining an indexer, in particular one used to build a knowledge store, your index can have nested complex types. An indexer is able to hold a chain of complex data structures in-memory, and when it includes a skillset, it can support highly complex data forms. For more information and an example, see [How to get started with knowledge store](knowledge-store-howto.md).
-->

```json
{
  "name": "hotels",
  "fields": [
    { "name": "HotelId", "type": "Edm.String", "key": true, "filterable": true },
    { "name": "HotelName", "type": "Edm.String", "searchable": true, "filterable": false },
    { "name": "Description", "type": "Edm.String", "searchable": true, "analyzer": "en.lucene" },
    { "name": "Address", "type": "Edm.ComplexType",
      "fields": [
        { "name": "StreetAddress", "type": "Edm.String", "filterable": false, "sortable": false, "facetable": false, "searchable": true },
        { "name": "City", "type": "Edm.String", "searchable": true, "filterable": true, "sortable": true, "facetable": true },
        { "name": "StateProvince", "type": "Edm.String", "searchable": true, "filterable": true, "sortable": true, "facetable": true }
      ]
    },
    { "name": "Rooms", "type": "Collection(Edm.ComplexType)",
      "fields": [
        { "name": "Description", "type": "Edm.String", "searchable": true, "analyzer": "en.lucene" },
        { "name": "Type", "type": "Edm.String", "searchable": true },
        { "name": "BaseRate", "type": "Edm.Double", "filterable": true, "facetable": true }
      ]
    }
  ]
}
```

## <a name="updating-complex-fields"></a>Обновление сложных полей

Все [повторного индексирования правила](search-howto-reindex.md) , применяемые к поля вообще по-прежнему применяются к полям сложных. Изменение формулировки несколько основных правил, Добавление поля не требует перестроения индекса, но большинство изменений сделать.

### <a name="structural-updates-to-the-definition"></a>Структурные обновления к определению

Можно добавить новые поля вложенных сложных полю в любое время без необходимости перестроения индекса. Например, добавление «Почтовый индекс» `Address` или «Зайдем», чтобы `Rooms` разрешен, так же, как добавление верхнего уровня поля в индекс. Существующие документы имеют значение null для новых полей, пока не будет явно заполнить эти поля, обновив данные.

Обратите внимание, что внутри сложного типа, имеет тип каждого поля и может иметь атрибуты, как просто верхнего уровня поля

### <a name="data-updates"></a>Обновление данных

Обновление существующих документов в индексе с `upload` действие работает одинаково для сложных и простых полей--все поля заменяются. Тем не менее `merge` (или `mergeOrUpload` при применении к существующему документу) не работают одинаково для всех полей. В частности `merge` не поддерживает слияние элементов в коллекции. Это ограничение существует для типов-примитивов и сложных коллекций. Для обновления коллекции, вы будете требуется для получения значения полной сборки мусора, внести изменения и включите новой коллекции в запроса API индекса.

## <a name="searching-complex-fields"></a>Поиск сложных полей

Выражения поиска в свободной форме ожидаемым со сложными типами. Если все поля, поддерживающего поиск или поля в любом месте в документе соответствует, сам документ является соответствие.

Запросы get дополнительные этот, когда у вас есть несколько условий и операторов, а некоторые термины, имеют имена полей указано, как и в случае возможна с помощью [синтаксис Lucene](query-lucene-syntax.md). Например, этот запрос пытается сопоставить два термина, «Portland» и «OR», относительно двух вложенных полей поля адреса:

    search=Address/City:Portland AND Address/State:OR

Запрос в том числе составляют *некоррелированных* для полнотекстового поиска, в отличие от фильтров. В фильтрах, запросы к вложенные поля коллекции сложных коррелируются с использованием переменных диапазона в [ `any` или `all` ](search-query-odata-collection-operators.md). Приведенный выше запрос Lucene возвращает документы, содержащие «Портленд, Майн» и «Портленд, Орегон», а также другие города в «Орегон». Это происходит, так как каждое предложение применяется ко всем значениям поля во всем документе, поэтому отсутствует понятие «текущего вложенного документа». Дополнительные сведения об этом см. в разделе [OData основные сведения о коллекции фильтров в поиске Azure](search-query-understand-collection-filters.md).

## <a name="selecting-complex-fields"></a>Выбор сложных полей

`$select` Параметр используется, чтобы выбрать, какие поля возвращаются в результатах поиска. Чтобы использовать этот параметр для выбора конкретных полей вложенных сложных поля, включают родительского поля и вложенные поля, разделенные косой чертой (`/`).

    $select=HotelName, Address/City, Rooms/BaseRate

Должен быть помечен поля как доступный для получения в индексе, если их в результатах поиска. В можно использовать только поля, помеченные как доступный для получения `$select` инструкции.

## <a name="filter-facet-and-sort-complex-fields"></a>Фильтр, аспект и сложных поля сортировки

Же [синтаксис пути OData](query-odata-filter-orderby-syntax.md) использовать для фильтрации и были поиска также может использоваться для фасетная навигация, сортировка и выбрав поля в запросе поиска. Для сложных типов применяются правила, определяющие, какие вложенные поля может быть помечен как сортируемое или аспектируемый. Дополнительные сведения об этих правилах см. в разделе [Справочник по API создания индекса](https://docs.microsoft.com/rest/api/searchservice/create-index#request).

### <a name="faceting-sub-fields"></a>Фасетная Навигация дополнительные поля

Любые вложенные поля могут быть помечены как аспектируемый, если он не имеет типа `Edm.GeographyPoint` или `Collection(Edm.GeographyPoint)`.

Количество документов, возвращенных в результатах аспекта вычисляются для родительского документа (гостинице), не вложенные документы в коллекцию сложных (комнаты). Например предположим, что Гостиница имеет 20 комнаты типа «набор». Учитывая этот параметр аспекта `facet=Rooms/Type`, count аспекта будет иметь одно для гостиницы, а не 20 для помещения.

### <a name="sorting-complex-fields"></a>Сложные полей сортировки

Операции сортировки, применяются к документам (гостиницы) и не вложенных документов (комнаты). При наличии сложного типа коллекции, например залы, следует помнить, что нельзя сортировать по комнаты вообще. На самом деле нельзя выполнить сортировку по какой-либо коллекции.

Операции сортировки работать, если поля имеют одно значение в документе, является ли поле является простым полем или вложенные поля в сложном типе. Например `Address/City` может быть поддерживает сортировку, так как имеется только один адрес для каждого отеля, поэтому `$orderby=Address/City` сортировки гостиницы по городу.

### <a name="filtering-on-complex-fields"></a>Фильтрация по полям сложных

Можно ссылаться на вложенные поля сложных поля в выражении фильтра. Просто используйте тот же [синтаксис пути OData](query-odata-filter-orderby-syntax.md) , используемый для фасетная навигация, сортировка и выбрав поля. Например следующий фильтр будет возвращать все гостиницы в Канаде:

    $filter=Address/Country eq 'Canada'

Для фильтрации по полю сложные коллекции, можно использовать **лямбда-выражение** с [ `any` и `all` операторы](search-query-odata-collection-operators.md). В этом случае **переменная диапазона** лямбда-выражения, выражения является объектом с вложенные поля. Можно ссылаться на эти вложенные поля с помощью стандартного синтаксиса пути OData. Например следующий фильтр будет возвращать все гостиницы с по крайней мере один deluxe комнаты и всех не комнаты курящих:

    $filter=Rooms/any(room: room/Type eq 'Deluxe Room') and Rooms/all(room: not room/SmokingAllowed)

Как с помощью простого поля верхнего уровня, простые вложенные поля сложных полей включается только в фильтрах при наличии **фильтруемых** атрибут `true` в определении индекса. Дополнительные сведения см. в разделе [Справочник по API создания индекса](https://docs.microsoft.com/rest/api/searchservice/create-index#request).

## <a name="next-steps"></a>Следующие шаги

Попробуйте [набора данных гостиницы](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/README.md) в **импорта данных** мастера. Вам потребуется сведения о подключении Cosmos DB, содержащимся в файле readme для доступа к данным.

Располагая этой информацией первым шагом в мастере является создание нового источника данных Azure Cosmos DB. Дополнительно на в мастере, когда вы дойдете до целевой страницы индекса, вы увидите индекса со сложными типами. Создать и загрузить этот индекс затем выполнять запросы, чтобы понять новой структуры.

> [!div class="nextstepaction"]
> [Краткое руководство: портала мастера для импорта, индексирования и запросов](search-get-started-portal.md)