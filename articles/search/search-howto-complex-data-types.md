---
title: Как моделировать сложные типы данных
titleSuffix: Azure Cognitive Search
description: Вложенные или иерархические структуры данных можно смоделировать в индексе когнитивного поиска Azure с использованием типов данных ComplexType и Collections.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
tags: complex data types; compound data types; aggregate data types
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
ms.openlocfilehash: 2edd62825de08becf22f2f953a63a7f89f55e0a6
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79283060"
---
# <a name="how-to-model-complex-data-types-in-azure-cognitive-search"></a>Как смоделировать сложные типы данных в Azure Cognitive Search

Внешние наборы данных, используемые для заполнения индекса когнитивного поиска Azure, могут быть различены. Иногда они включают иерархические или вложенные подструктуры. Примеры могут включать несколько адресов для одного клиента, несколько цветов и размеров для одного SKU, несколько авторов одной книги и так далее. С точки зрения моделирования эти структуры называются *сложными,* *составными,* *композитными*или *агрегированными* типами данных. Термин Azure Cognitive Search для этой концепции является **сложным типом.** В Azure Cognitive Search сложные типы моделируются с использованием **сложных полей.** Сложное поле — это поле, содержащее детях (подполях), которое может быть любого типа данных, включая другие сложные типы. Это работает так же, как структурированные типы данных на языке программирования.

Сложные поля представляют собой либо один объект в документе, либо массив объектов, в зависимости от типа данных. Поля типа `Edm.ComplexType` представляют отдельные объекты, в то время как поля типа `Collection(Edm.ComplexType)` представляют массивы объектов.

Azure Cognitive Search намеренно поддерживает сложные типы и коллекции. Эти типы позволяют моделировать практически любую структуру JSON в индексе когнитивного поиска Azure. В предыдущих версиях AAP Azure Cognitive Search можно импортировать только сплющенные наборы строк. В новейшей версии индекс теперь может более точно соответствовать исходным данным. Другими словами, если исходные данные имеют сложные типы, индекс может иметь и сложные типы.

Для начала мы рекомендуем [набор данных Hotels,](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/README.md)который можно загрузить в мастере **данных Импорта** на портале Azure. Мастер обнаруживает сложные типы в источнике и предлагает схему индекса на основе обнаруженных структур.

> [!Note]
> Поддержка сложных типов, `api-version=2019-05-06`как правило, доступна в . 
>
> Если решение поиска построено на более ранних обходных обходах сплющенных наборов данных в коллекции, следует изменить индекс, включив сложные типы, поддерживаемые в новейшей версии API. Для получения дополнительной информации об обновлении версий API [Upgrade to the newest .NET SDK version](search-dotnet-sdk-migration-version-9.md) [см.](search-api-migration.md)

## <a name="example-of-a-complex-structure"></a>Пример сложной структуры

Следующий документ JSON состоит из простых полей и сложных полей. Сложные поля, `Address` такие `Rooms`как и, имеют подполя. `Address`имеет единый набор значений для этих подполей, так как это один объект в документе. В отличие `Rooms` от этого, имеет несколько наборов значений для своих подполей, по одному для каждого объекта в коллекции.

```json
{
  "HotelId": "1",
  "HotelName": "Secret Point Motel",
  "Description": "Ideally located on the main commercial artery of the city in the heart of New York.",
  "Address": {
    "StreetAddress": "677 5th Ave",
    "City": "New York",
    "StateProvince": "NY"
  },
  "Rooms": [
    {
      "Description": "Budget Room, 1 Queen Bed (Cityside)",
      "Type": "Budget Room",
      "BaseRate": 96.99
    },
    {
      "Description": "Deluxe Room, 2 Double Beds (City View)",
      "Type": "Deluxe Room",
      "BaseRate": 150.99
    },
  ]
}
```

## <a name="creating-complex-fields"></a>Создание сложных полей

Как и в любом определении индекса, для создания схемы, включающий сложные типы, можно использовать портал, [REST API](https://docs.microsoft.com/rest/api/searchservice/create-index)или [.NET SDK.](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.index?view=azure-dotnet) 

В следующем примере показана схема индекса JSON с простыми полями, коллекциями и сложными типами. Обратите внимание, что в сложном типе каждое подполе имеет тип и может иметь атрибуты, как и поля верхнего уровня. Схема соответствует приведенным выше данным примера. `Address`это сложное поле, которое не является коллекцией (у отеля есть один адрес). `Rooms`является сложным полем сбора (отель имеет много номеров).

```json
{
  "name": "hotels",
  "fields": [
    { "name": "HotelId", "type": "Edm.String", "key": true, "filterable": true },
    { "name": "HotelName", "type": "Edm.String", "searchable": true, "filterable": false },
    { "name": "Description", "type": "Edm.String", "searchable": true, "analyzer": "en.lucene" },
    { "name": "Address", "type": "Edm.ComplexType",
      "fields": [
        { "name": "StreetAddress", "type": "Edm.String", "filterable": false, "sortable": false, "facetable": false, "searchable": true },
        { "name": "City", "type": "Edm.String", "searchable": true, "filterable": true, "sortable": true, "facetable": true },
        { "name": "StateProvince", "type": "Edm.String", "searchable": true, "filterable": true, "sortable": true, "facetable": true }
      ]
    },
    { "name": "Rooms", "type": "Collection(Edm.ComplexType)",
      "fields": [
        { "name": "Description", "type": "Edm.String", "searchable": true, "analyzer": "en.lucene" },
        { "name": "Type", "type": "Edm.String", "searchable": true },
        { "name": "BaseRate", "type": "Edm.Double", "filterable": true, "facetable": true }
      ]
    }
  ]
}
```

## <a name="updating-complex-fields"></a>Обновление сложных полей

Все [правила переиндексации,](search-howto-reindex.md) применимые к полям в целом, по-прежнему применяются к сложным полям. Повторение нескольких основных правил здесь, добавление поля не требует перестроения индекса, но большинство изменений делают.

### <a name="structural-updates-to-the-definition"></a>Структурные обновления определения

Вы можете добавить новые подполя в сложное поле в любое время без необходимости восстановления индекса. Например, допускается `Address` добавление в индекс «Зипкод» или «Удобства», `Rooms` как и добавление поля верхнего уровня в индекс. Существующие документы имеют нулевое значение для новых полей до тех пор, пока вы явно не заселите эти поля, обновляя данные.

Обратите внимание, что в сложном типе каждое подполе имеет тип и может иметь атрибуты, как это делают поля верхнего уровня

### <a name="data-updates"></a>Обновления данных

Обновление существующих документов в `upload` индексе с действием работает одинаково для сложных и простых полей - все поля заменяются. Однако `merge` (или `mergeOrUpload` при применении к существующему документу) не работает одинаково во всех полях. В `merge` частности, не поддерживает слияние элементов в коллекции. Это ограничение существует для коллекций примитивных типов и сложных коллекций. Для обновления коллекции необходимо получить полную стоимость сбора, внести изменения, а затем включить новую коллекцию в запрос Index API.

## <a name="searching-complex-fields"></a>Поиск сложных полей

Выражения поиска свободной формы работают, как и ожидалось, со сложными типами. Если какое-либо поисковое поле или подполе где-либо в документе совпадает, то сам документ совпадает.

Запросы становятся более нюансированными, когда у вас есть несколько терминов и операторов, и некоторые термины имеют названия полей, указанные, как это возможно с [синтаксисом Lucene.](query-lucene-syntax.md) Например, этот запрос пытается сопоставить два термина, "Портленд" и "OR", с двумя подполями поля Адреса:

    search=Address/City:Portland AND Address/State:OR

Запросы, подобные этому, *не коррелируют* для полнотекстовых поисков, в отличие от фильтров. В фильтрах запросы по подполям сложной коллекции коррелируют с использованием переменных диапазона в [ `any` или. `all` ](search-query-odata-collection-operators.md) Запрос Lucene выше возвращает документы, содержащие как "Портленд, штат Мэн" и "Портленд, штат Орегон", наряду с другими городами в штате Орегон. Это происходит потому, что каждое положение применяется ко всем значениям своей области во всем документе, поэтому нет понятия "текущий поддокумент". Для получения дополнительной информации об этом смотрите [В Azure Cognitive Search для сбора данных «Понимание данных».](search-query-understand-collection-filters.md)

## <a name="selecting-complex-fields"></a>Выбор сложных полей

Параметр `$select` используется для выбора, какие поля возвращаются в результатах поиска. Чтобы использовать этот параметр для выбора конкретных подполей сложного поля, включите родительское поле и подполе, разделенное слэшем ().`/`

    $select=HotelName, Address/City, Rooms/BaseRate

Поля должны быть помечены как извлекаемые в индексе, если вы хотите, чтобы они были в результатах поиска. В `$select` отчете можно использовать только поля, помеченные как Retrievable.

## <a name="filter-facet-and-sort-complex-fields"></a>Фильтр, грань и сортировка сложных полей

Тот же [синтаксис пути OData,](query-odata-filter-orderby-syntax.md) используемый для фильтрации и поиска на местах, также может быть использован для граненых, сортировки и выбора полей в поисковом запросе. Для сложных типов применяются правила, регулирующие, какие подполя могут быть помечены как сортируемые или facetable. Для получения дополнительной информации [Create Index API reference](/rest/api/searchservice/create-index)об этих правилах см.

### <a name="faceting-sub-fields"></a>Лицоподполя

Любое подполе может быть помечено как `Edm.GeographyPoint` facetable, если оно не имеет типа или `Collection(Edm.GeographyPoint)`.

Документ рассчитывает сярлица, полученные в аспекте, исчисляются для родительского документа (гостиницы), а не для поддокументов в сложной коллекции (комнатах). Например, предположим, что в отеле 20 номеров типа «люкс». Учитывая этот `facet=Rooms/Type`параметр аспекта, количество граней будет одним для отеля, а не 20 для номеров.

### <a name="sorting-complex-fields"></a>Сортировка сложных полей

Сортировка операций применяется к документам (гостиницам), а не к поддокументам (комнаты). Если у вас есть сложная коллекция типов, таких как номера, важно понимать, что вы не можете сортировать по комнатам вообще. В самом деле, вы не можете сортировать на любой коллекции.

Сортировка операций работает, когда поля имеют единое значение на документ, является ли поле простым полем или подполем в сложном типе. Например, `Address/City` разрешается быть сортируемым, потому что `$orderby=Address/City` есть только один адрес в отеле, так что будет сортировать отели по городу.

### <a name="filtering-on-complex-fields"></a>Фильтрация на сложных полях

Можно ссылаться на подполя сложного поля в выражении фильтра. Просто используйте тот же [синтаксис пути OData,](query-odata-filter-orderby-syntax.md) который используется для огранки, сортировки и выбора полей. Например, следующий фильтр вернет все отели в Канаде:

    $filter=Address/Country eq 'Canada'

Для фильтрации на сложном поле сбора можно использовать **выражение лямбда** с [ `any` операторами. `all` ](search-query-odata-collection-operators.md) В этом случае **переменная диапазона** выражения лямбда является объектом с подполями. Вы можете обратиться к этим подполям со стандартным синтаксисом пути OData. Например, следующий фильтр вернет все отели с по крайней мере одним номером повышенной комфортности и все номера для некурящих:

    $filter=Rooms/any(room: room/Type eq 'Deluxe Room') and Rooms/all(room: not room/SmokingAllowed)

Как и `true` в случае с простыми полями верхнего уровня, простые подполя сложных полей могут быть включены в фильтры только в том случае, если они имеют **фильтруемый** атрибут, установленный в определении индекса. Для получения дополнительной [информации](/rest/api/searchservice/create-index)см.

## <a name="next-steps"></a>Дальнейшие действия

Попробуйте [набор данных Отелей](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/README.md) в мастере **данных Импорта.** Для доступа к данным вам понадобится информация о подключении Cosmos DB, представленная в readme.

С этой информацией в руках, ваш первый шаг в мастере заключается в создании нового источника данных Azure Cosmos DB. Далее в мастере, когда вы доберетесь до целевой страницы индекса, вы увидите индекс со сложными типами. Создайте и загрузите этот индекс, а затем выполните запросы, чтобы понять новую структуру.

> [!div class="nextstepaction"]
> [Быстрый запуск: мастер портала для импорта, индексирования и запросов](search-get-started-portal.md)
