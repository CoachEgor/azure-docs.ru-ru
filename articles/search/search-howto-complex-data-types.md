---
title: Моделирование сложных типов данных в службе "Поиск Azure"
description: Вложенные или иерархические данные структуры можно моделировать в индексе поиска Azure с помощью ComplexType и коллекции типов данных.
author: brjohnstmsft
manager: jlembicz
ms.author: brjohnst
tags: complex data types; compound data types; aggregate data types
services: search
ms.service: search
ms.topic: conceptual
ms.date: 05/02/2019
ms.custom: seodec2018
ms.openlocfilehash: 00606ed5cbcd8681748241e9404c6e6e5aa95021
ms.sourcegitcommit: f6ba5c5a4b1ec4e35c41a4e799fb669ad5099522
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65147312"
---
# <a name="how-to-model-complex-data-types-in-azure-search"></a>Моделирование сложных типов данных в службе поиска Azure

Внешние наборы данных, используемые для заполнения индекса службы поиска Azure иногда включают иерархические или вложенные подструктуры. Примеры могут включать несколько расположений и номеров телефонов для одного клиента, несколько цветов и размеров для одного SKU, несколько авторов на одну книгу и так далее. Моделирование условия, может появиться эти структуры называются *сложные типы данных*, *составные типы данных*, *составные типы данных*, или *статистические типы данных*. В терминологии службы поиска Azure сложный тип представляет собой поле, содержит дочерние элементы (вложенные поля) которые сами по себе может быть простой или сложный. Это похоже на структурный тип данных на языке программирования. Сложных полей может быть одного поля, которые представляют один объект в документ или коллекцию, которая представляет собой массив объектов

Поиск Azure изначально поддерживает сложные типы и коллекции. Вместе эти типы позволяют моделировать практически любой вложенной структуры JSON в индекс службы поиска Azure. В предыдущих версиях API-интерфейсов поиска Azure только сведение строки, которые могут быть импортированы наборов. В последней версии индекс может теперь более точно соответствовать исходных данных. Другими словами Если исходные данные содержат сложные типы, индекс может иметь сложные типы также.

Чтобы приступить к работе, мы рекомендуем [набора данных гостиницы](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/README.md), который можно загрузить в **импорта данных** мастера на портале Azure. Мастер обнаруживает сложных типов в источнике и предлагает схему индекса, в зависимости от обнаруженных структур.

> [!Note]
> Поддержка сложных типов находится в общем доступе в `api-version=2019-05-06`. 
>
> Если решение поиска создан в более ранних обходные пути плоских наборов данных в коллекции, следует изменить индекс, чтобы включить одни сложные типы, так как поддерживается в последней версии API. Дополнительные сведения об обновлении версии API, см. в разделе [обновление до последней версии REST API](search-api-migration.md) или [обновление до последней версии пакета SDK для .NET](search-dotnet-sdk-migration-version-9.md).

## <a name="example-of-a-complex-structure"></a>Пример сложной структуры

Ниже приведен документ JSON состоит из простых и сложных поля. Комплексное полях, например `Address` и `Rooms`, имеют вложенные поля. `Address` имеет один набор значений для этих вложенных полей, так как он представляет собой один объект в документе. Напротив `Rooms` имеет несколько наборов значений для его вложенных полей, по одному для каждого объекта в коллекции.

```json
{
    "HotelId": "1",
    "HotelName": "Secret Point Motel",
    "Description": "Ideally located on the main commercial artery of the city in the heart of New York.",
    "Address": {
        "StreetAddress": "677 5th Ave",
        "City": "New York",
        "StateProvince": "NY"
    },
    "Rooms": [
        {
            "Description": "Budget Room, 1 Queen Bed (Cityside)",
            "Type": "Budget Room",
            "BaseRate": 96.99,
        },
        {
            "Description": "Deluxe Room, 2 Double Beds (City View)",
            "Type": "Deluxe Room",
            "BaseRate": 150.99,
        },
    ]
}
```

## <a name="creating-complex-fields"></a>Создание сложных полей

Как с помощью любого определения индекса, можно использовать портал, [REST API](https://docs.microsoft.com/rest/api/searchservice/create-index), или [пакета SDK для .NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.index?view=azure-dotnet) создать схему, которая включает в себя сложных типов. 

Следующий пример показывает схему индекса JSON с помощью простых полей, коллекций и сложные типы. Обратите внимание на то, что внутри сложного типа, имеет тип каждого поля и может иметь атрибуты, как просто верхнего уровня поля. Схема соответствует данные для примера выше. `Address` — Это сложный поле, не является коллекцией (Гостиница имеет один адрес). `Rooms` — Это поле סכמזםי (Гостиница имеет много комнаты).

<!---
For indexes used in a [push-model data import](search-what-is-data-import.md) strategy, where you are pushing a JSON data set to an Azure Search index, you can only have the basic syntax shown here: single complex types like `Address`, or a `Collection(Edm.ComplexType)` like `Rooms`. You cannot have complex types nested inside other complex types in an index used for push-model data ingestion.

Indexers are a different story. When defining an indexer, in particular one used to build a knowledge store, your index can have nested complex types. An indexer is able to hold a chain of complex data structures in-memory, and when it includes a skillset, it can support highly complex data forms. For more information and an example, see [How to get started with Knowledge Store](knowledge-store-howto.md).
-->

```json
{
    "name": "hotels",
    "fields": [
        {   "name": "HotelId", "type": "Edm.String", "key": true, "filterable": true    },
        {   "name": "HotelName", "type": "Edm.String", "searchable": true, "filterable": false },
        { "name": "Description", "type": "Edm.String", "searchable": true, "analyzer": "en.lucene" },
        {   "name": "Address", "type": "Edm.ComplexType",
            "fields": [{
                    "name": "StreetAddress",
                    "type": "Edm.String",
                    "filterable": false,
                    "sortable": false,
                    "facetable": false,
                    "searchable": true  },
                {
                    "name": "City",
                    "type": "Edm.String",
                    "searchable": true,
                    "filterable": true,
                    "sortable": true,
                    "facetable": true
                },
                {
                    "name": "StateProvince",
                    "type": "Edm.String",
                    "searchable": true,
                    "filterable": true,
                    "sortable": true,
                    "facetable": true
                }
            ]
        },
        {
            "name": "Rooms",
            "type": "Collection(Edm.ComplexType)",
            "fields": [{
                    "name": "Description",
                    "type": "Edm.String",
                    "searchable": true,
                    "analyzer": "en.lucene"
                },
                {
                    "name": "Type",
                    "type": "Edm.String",
                    "searchable": true
                },
                {
                    "name": "BaseRate",
                    "type": "Edm.Double",
                    "filterable": true,
                    "facetable": true
                },
            ]
        }
    ]
}
```
## <a name="updating-complex-fields"></a>Обновление сложных полей

Все [повторного индексирования правила](search-howto-reindex.md) , применяемые к поля вообще по-прежнему применяются к полям сложных. Изменение формулировки несколько основных правил, Добавление поля не требует перестроения индекса, но большинство изменений сделать.

### <a name="structural-updates-to-the-definition"></a>Структурные обновления к определению

Можно добавить новые поля вложенных сложных полю в любое время без необходимости перестроения индекса. Например, добавление «Почтовый индекс» `Address` или «Зайдем», чтобы `Rooms` разрешен, так же, как добавление верхнего уровня поля в индекс. Существующие документы имеют значение null для новых полей, пока не будет явно заполнить эти поля, обновив данные.

Обратите внимание, что внутри сложного типа, имеет тип каждого поля и может иметь атрибуты, как просто верхнего уровня поля

### <a name="data-updates"></a>Обновление данных

Обновление существующих документов в индексе с действием отправки работает одинаково для сложных и простых полей--все поля заменяются. Тем не менее объединение (или mergeOrUpload при применении к существующему документу) не работают одинаково для всех полей. В частности слияния имеет возможность слияния элементов в коллекции. Это справедливо для коллекции типов-примитивов, а также сложные коллекции. Для обновления коллекции вы будет требуется для получения значения полной сборки мусора, внести изменения и включите новую коллекцию в запросе API индекса.


## <a name="searching-complex-fields"></a>Поиск сложных полей

Выражения поиска в свободной форме ожидаемым со сложными типами. Если все поля, поддерживающего поиск или поля в любом месте в документе соответствует, сам документ является соответствие. 

Запросы get дополнительные этот, когда у вас есть несколько условий и операторов, а некоторые термины, имеют имена полей указано, как и в случае возможна с помощью [синтаксис Lucene](query-lucene-syntax.md). Например, этот запрос пытается сопоставить два термина, «Portland» и «OR», относительно двух вложенных полей поля адреса:

```json
search=Address/City:Portland AND Address/State:OR
```

Подобные запросы не скоррелированы для полнотекстового поиска (в отличие от фильтров, где запросы через вложенные поля сложные коллекции могут быть взаимосвязаны с помощью любого или всех, как связанный вложенный запрос в SQL). Это означает, что выше Lucene запрос будет возвращать документы, содержащие «Портленд, Майн», «Портленд, Орегон», а также другие города в «Орегон». Это обусловлено каждое предложение вычисляется для всех значений указанного поля во всем документе, поэтому нет понятия «текущего вложенного документа». 

 

## <a name="selecting-complex-fields"></a>Выбор сложных полей

`$select` Параметр используется, чтобы выбрать, какие поля возвращаются в результатах поиска. Чтобы использовать этот параметр для выбора конкретных полей вложенных сложных поля, включают родительского поля и вложенные поля, разделенные косой чертой (`/`).

```json
$select=HotelName, Address/City, Rooms/BaseRate
```

Должен быть помечен поля как доступный для получения в индексе, если их в результатах поиска. В можно использовать только поля, помеченные как доступный для получения `$select` инструкции. 


## <a name="filter-facet-and-sort-complex-fields"></a>Фильтр, аспект и сложных поля сортировки

Же [синтаксис пути OData](query-odata-filter-orderby-syntax.md) использовать для фильтрации и были поиска также может использоваться для фасетная навигация, сортировка и выбрав поля в запросе поиска. Для сложных типов применяются правила, определяющие, какие вложенные поля может быть помечен как сортируемое или аспектируемый. 

### <a name="faceting-sub-fields"></a>Фасетная Навигация дополнительные поля 

Любые вложенные поля могут быть помечены как аспектируемый, если он не имеет типа `Edm.GeographyPoint` или `Collection(Edm.GeographyPoint)`. 

Если возвращается количество документов для структуры фасетной навигации, счетчики не относительно родительского документа (гостинице), для вложенных документов в коллекции сложных (комнаты). Например предположим, что Гостиница имеет 20 комнаты типа «набор». Учитывая этот параметр аспекта `facet=Rooms/Type`, count аспекта будет один для родительского документа (гостиницы) и не средний уровень вложенных документов (комнаты). 

### <a name="sorting-complex-fields"></a>Сложные полей сортировки

Операции сортировки, применяются к документам (гостиницы) и не вложенных документов (комнаты). При наличии сложного типа коллекции, например залы, следует помнить, что нельзя сортировать по комнаты вообще. На самом деле нельзя выполнить сортировку по какой-либо коллекции. 

Операции сортировки работе поля, одно значение, следует ли как простое поле или вложенные поля в сложном типе. Например `$orderby=Address/ZipCode` сложного типа подлежит сортировке, так как имеется только один почтовый индекс в гостинице. 

Изменение формулировки правила сортировки, в поле индекса должны быть отмечены как фильтруемые и сортируемый для использования в `$orderby` инструкции. 

## <a name="next-steps"></a>Дальнейшие действия

 Попробуйте [набора данных гостиницы](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/README.md) в **импорта данных** мастера. Вам потребуется сведения о подключении Cosmos DB, содержащимся в файле readme для доступа к данным. 
 
 Располагая этой информацией первым шагом в мастере является создание нового источника данных Azure Cosmos DB. Дополнительно на в мастере, когда вы дойдете до целевой страницы индекса, вы увидите индекса со сложными типами. Создать и загрузить этот индекс затем выполнять запросы, чтобы понять новой структуры.

> [!div class="nextstepaction"]
> [Краткое руководство: портала мастера для импорта, индексирования и запросов](search-get-started-portal.md)