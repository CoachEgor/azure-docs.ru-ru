---
title: Устранение неполадок фильтров коллекции OData
titleSuffix: Azure Cognitive Search
description: Устранение ошибок фильтра коллекции OData в запросах Когнитивный поиск Azure.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: 0af2525a15618c6bfd9022b4388c547209ee957b
ms.sourcegitcommit: b050c7e5133badd131e46cab144dd5860ae8a98e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/23/2019
ms.locfileid: "72793191"
---
# <a name="troubleshooting-odata-collection-filters-in-azure-cognitive-search"></a>Устранение неполадок фильтров коллекции OData в Azure Когнитивный поиск

Для [фильтрации](query-odata-filter-orderby-syntax.md) по полям коллекции в когнитивный Поиск Azure можно использовать [операторы`any` и `all`](search-query-odata-collection-operators.md) вместе с **лямбда-выражениями**. Лямбда-выражение — это вложенный фильтр, применяемый к каждому элементу коллекции.

Не все функции выражений фильтров доступны внутри лямбда-выражения. Доступные функции различаются в зависимости от типа данных поля коллекции, которое необходимо отфильтровать. Это может привести к ошибке при попытке использовать функцию в лямбда-выражении, которое не поддерживается в этом контексте. Если при попытке записи сложного фильтра по полям коллекции возникают такие ошибки, эта статья поможет вам устранить проблему.

## <a name="common-collection-filter-errors"></a>Распространенные ошибки фильтра коллекции

В следующей таблице перечислены ошибки, которые могут возникнуть при попытке выполнить фильтр коллекции. Эти ошибки возникают при использовании функции выражений фильтров, которые не поддерживаются внутри лямбда-выражения. Каждая ошибка дает некоторые рекомендации о том, как можно переписать фильтр, чтобы избежать ошибки. В таблице также содержится ссылка на соответствующий раздел этой статьи, где содержатся дополнительные сведения о том, как избежать этой ошибки.

| Сообщение об ошибке | Такая | Дополнительную информацию см. в разделе |
| --- | --- | --- |
| Функция "несоответствие" не имеет параметров, привязанных к переменной диапазона ". Внутри лямбда-выражений ("Any" или "ALL") поддерживаются только ссылки на связанные поля. Измените фильтр так, чтобы функция "не совпала" находилась за пределами лямбда-выражения, и повторите попытку. | Использование `search.ismatch` или `search.ismatchscoring` внутри лямбда-выражения | [Правила фильтрации сложных коллекций](#bkmk_complex) |
| Недопустимое лямбда-выражение. Обнаружена проверка на равенство или неравенство в лямбда-выражении, которое выполняет итерацию по полю коллекции типа (EDM. String). Для Any используйте выражения вида "x EQ y" или "search.in (...)". Для "ALL" используйте выражения в форме "x Ne y", "not (x EQ y)" или "not search.in (...)". | Фильтрация по полю типа `Collection(Edm.String)` | [Правила фильтрации коллекций строк](#bkmk_strings) |
| Недопустимое лямбда-выражение. Обнаружена неподдерживаемая форма сложного логического выражения. Для Any используйте выражения, которые имеют вид "or of and", также известный как Дисжунктиве обычная форма. Например: "(a и b) или (c и d)", где a, b, c и d являются подвыражениями сравнения или равенства. Для "ALL" используйте выражения, которые имеют вид "and of or", также известный как был соединительным обычная форма. Например: "(a или b) и (c или d)", где a, b, c и d являются подвыражениями сравнения или неравенства. Примеры выражений сравнения: "x gt 5", "x Le 2". Пример выражения равенства: "x EQ 5". Пример выражения неравенства: "x Ne 5". | Фильтрация по полям типа `Collection(Edm.DateTimeOffset)`, `Collection(Edm.Double)`, `Collection(Edm.Int32)`или `Collection(Edm.Int64)` | [Правила фильтрации сравниваемых коллекций](#bkmk_comparables) |
| Недопустимое лямбда-выражение. Обнаружено неподдерживаемое использование Geo. Distance () или Geo. intersects в лямбда-выражении, которое выполняет итерацию по полю коллекции типа (EDM. GeographyPoint). Для Any убедитесь, что вы сравниваете Geo. Distance () с помощью операторов "lt" или "Le" и убедитесь, что любое использование Geo. intersects () не имеет отрицания. Для "ALL" убедитесь, что вы сравниваете Geo. Distance () с помощью операторов "gt" или "GE" и убедитесь, что любое использование Geo. intersects () имеет отрицание. | Фильтрация по полю типа `Collection(Edm.GeographyPoint)` | [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints) |
| Недопустимое лямбда-выражение. Сложные логические выражения не поддерживаются в лямбда-выражениях, которые выполняют итерации по полям типа Collection (EDM. GeographyPoint). Для Any необходимо объединить подвыражения с "или"; "and" не поддерживается. Для "ALL" необходимо объединить подвыражения с "и"; "или" не поддерживается. | Фильтрация по полям типа `Collection(Edm.String)` или `Collection(Edm.GeographyPoint)` | [Правила фильтрации коллекций строк](#bkmk_strings) <br/><br/> [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints) |
| Недопустимое лямбда-выражение. Обнаружен оператор сравнения (один из "lt", "Le", "gt" или "GE"). В лямбда-выражениях, которые просматривают поля коллекции типа (EDM. String), допускаются только операторы равенства. Для Any используйте выражения вида "x EQ y". Для "ALL" используйте выражения в форме "x Ne y" или "not (x EQ y)". | Фильтрация по полю типа `Collection(Edm.String)` | [Правила фильтрации коллекций строк](#bkmk_strings) |

<a name="bkmk_examples"></a>

## <a name="how-to-write-valid-collection-filters"></a>Написание допустимых фильтров коллекции

Правила записи допустимых фильтров коллекции различаются для каждого типа данных. В следующих разделах описываются правила, в которых показаны примеры поддерживаемых функций фильтров, а какие нет:

- [Правила фильтрации коллекций строк](#bkmk_strings)
- [Правила фильтрации логических коллекций](#bkmk_bools)
- [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints)
- [Правила фильтрации сравниваемых коллекций](#bkmk_comparables)
- [Правила фильтрации сложных коллекций](#bkmk_complex)

<a name="bkmk_strings"></a>

## <a name="rules-for-filtering-string-collections"></a>Правила фильтрации коллекций строк

В лямбда-выражениях для коллекций строк можно использовать только `eq` и `ne`ые операторы сравнения.

> [!NOTE]
> Когнитивный поиск Azure не поддерживает `lt`/`le`/`gt`,/операторы для строк, вне зависимости от лямбда-выражения или за его пределами.

Текст `any` может проверять на равенство только в том случае, если текст `all` может проверяться на неравенство.

Можно также объединить несколько выражений с помощью `or` в тексте `any`и через `and` в теле `all`. Поскольку функция `search.in` эквивалентна объединению проверок равенства с `or`, она также разрешается в теле `any`. И наоборот, `not search.in` разрешен в теле `all`.

Например, следующие выражения разрешены:

- `tags/any(t: t eq 'books')`
- `tags/any(t: search.in(t, 'books, games, toys'))`
- `tags/all(t: t ne 'books')`
- `tags/all(t: not (t eq 'books'))`
- `tags/all(t: not search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' or t eq 'games')`
- `tags/all(t: t ne 'books' and not (t eq 'games'))`

Хотя эти выражения не допускаются:

- `tags/any(t: t ne 'books')`
- `tags/any(t: not search.in(t, 'books, games, toys'))`
- `tags/all(t: t eq 'books')`
- `tags/all(t: search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' and t ne 'games')`
- `tags/all(t: t ne 'books' or not (t eq 'games'))`

<a name="bkmk_bools"></a>

## <a name="rules-for-filtering-boolean-collections"></a>Правила фильтрации логических коллекций

Тип `Edm.Boolean` поддерживает только операторы `eq` и `ne`. Таким образом, не имеет смысла разрешать сочетание таких предложений, которые проверяют ту же переменную диапазона с `and`/`or`, так как это всегда приведет к таутологиес или противоречию.

Ниже приведены некоторые примеры фильтров для логических коллекций, которые разрешены:

- `flags/any(f: f)`
- `flags/all(f: f)`
- `flags/any(f: f eq true)`
- `flags/any(f: f ne true)`
- `flags/all(f: not f)`
- `flags/all(f: not (f eq true))`

В отличие от коллекций строк, логические коллекции не имеют ограничений на то, какой оператор можно использовать в лямбда-выражении. В теле `any` или `all`можно использовать как `eq`, так `ne`.

Следующие выражения не допускаются для логических коллекций:

- `flags/any(f: f or not f)`
- `flags/any(f: f or f)`
- `flags/all(f: f and not f)`
- `flags/all(f: f and f eq true)`

<a name="bkmk_geopoints"></a>

## <a name="rules-for-filtering-geographypoint-collections"></a>Правила фильтрации GeographyPointных коллекций

Значения типа `Edm.GeographyPoint` в коллекции не могут сравниваться напрямую друг с другом. Вместо этого они должны использоваться в качестве параметров функций `geo.distance` и `geo.intersects`. Функция `geo.distance`, в свою очередь, должна сравниваться со значением расстояния с помощью одного из операторов сравнения `lt`, `le`, `gt`или `ge`. Эти правила также применяются к полям EDM. GeographyPoint, не относящимся к коллекции.

Как и коллекции строк, `Edm.GeographyPoint` коллекции имеют некоторые правила для использования геопространственных функций и объединения в различные типы лямбда-выражений.

- Операторы сравнения, которые можно использовать с функцией `geo.distance`, зависят от типа лямбда-выражения. Для `any`можно использовать только `lt` или `le`. Для `all`можно использовать только `gt` или `ge`. Можно инвертировать выражения, включающие `geo.distance`, но необходимо изменить оператор сравнения (`geo.distance(...) lt x` преобразуется в `not (geo.distance(...) ge x)` и `geo.distance(...) le x` превращается в `not (geo.distance(...) gt x)`).
- В теле `all`функция `geo.intersects` должна быть инвертирована. И наоборот, в теле `any`функция `geo.intersects` не должна быть отрицанием.
- В тексте `any`геопространственные выражения можно комбинировать с помощью `or`. В тексте `all`такие выражения можно комбинировать с помощью `and`.

Указанные выше ограничения существуют по тем же причинам, что и ограничения на равенство и неравенство в коллекциях строк. Более подробные сведения по этим причинам см. в статье [Знакомство с фильтрами коллекции OData в когнитивный Поиск Azure](search-query-understand-collection-filters.md) .

Ниже приведены некоторые примеры фильтров для `Edm.GeographyPoint` коллекций, которые разрешены:

- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: not (geo.distance(l, geography'POINT(-122 49)') ge 10) or geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') ge 10 and not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

Следующие выражения не допускаются для коллекций `Edm.GeographyPoint`:

- `locations/any(l: l eq geography'POINT(-122 49)')`
- `locations/any(l: not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') gt 10)`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10 and geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') le 10 or not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

<a name="bkmk_comparables"></a>

## <a name="rules-for-filtering-comparable-collections"></a>Правила фильтрации сравниваемых коллекций

Этот раздел относится ко всем следующим типам данных:

- `Collection(Edm.DateTimeOffset)`
- `Collection(Edm.Double)`
- `Collection(Edm.Int32)`
- `Collection(Edm.Int64)`

Типы, такие как `Edm.Int32` и `Edm.DateTimeOffset`, поддерживают все шесть операторов сравнения: `eq`, `ne`, `lt`, `le`, `gt`и `ge`. Лямбда-выражения над коллекциями этих типов могут содержать простые выражения, использующие любой из этих операторов. Это относится как к `any`, так и к `all`. Например, эти фильтры разрешены:

- `ratings/any(r: r ne 5)`
- `dates/any(d: d gt 2017-08-24T00:00:00Z)`
- `not margins/all(m: m eq 3.5)`

Однако существуют ограничения на то, как такие выражения сравнения могут быть объединены в более сложные выражения в лямбда-выражении:

- Правила для `any`:
  - Простые выражения неравенства не могут быть полезны вместе с другими выражениями. Например, это выражение разрешено:
    - `ratings/any(r: r ne 5)`

    но это выражение не так:
    - `ratings/any(r: r ne 5 and r gt 2)`

    и хотя это выражение разрешено, оно не полезно, поскольку условия перекрываются:
    - `ratings/any(r: r ne 5 or r gt 7)`
  - Простые выражения сравнения, включающие `eq`, `lt`, `le`, `gt`или `ge`, можно сочетать с `and`/`or`. Пример.
    - `ratings/any(r: r gt 2 and r le 5)`
    - `ratings/any(r: r le 5 or r gt 7)`
  - Выражения сравнения, Объединенные с `and` (объединения), можно объединять с помощью `or`. Эта форма известна в логической логике как "[Дисжунктиве обычная форма](https://en.wikipedia.org/wiki/Disjunctive_normal_form)" (ДНФ). Пример.
    - `ratings/any(r: (r gt 2 and r le 5) or (r gt 7 and r lt 10))`
- Правила для `all`:
  - Простые выражения равенства не могут быть полезны вместе с другими выражениями. Например, это выражение разрешено:
    - `ratings/all(r: r eq 5)`

    но это выражение не так:
    - `ratings/all(r: r eq 5 or r le 2)`

    и хотя это выражение разрешено, оно не полезно, поскольку условия перекрываются:
    - `ratings/all(r: r eq 5 and r le 7)`
  - Простые выражения сравнения, включающие `ne`, `lt`, `le`, `gt`или `ge`, можно сочетать с `and`/`or`. Пример.
    - `ratings/all(r: r gt 2 and r le 5)`
    - `ratings/all(r: r le 5 or r gt 7)`
  - Выражения сравнения, Объединенные с `or` (дизъюнкции), можно объединять с помощью `and`. Эта форма известна в логической логике как "[был соединительным обычная форма](https://en.wikipedia.org/wiki/Conjunctive_normal_form)" (cnf). Пример.
    - `ratings/all(r: (r le 2 or gt 5) and (r lt 7 or r ge 10))`

<a name="bkmk_complex"></a>

## <a name="rules-for-filtering-complex-collections"></a>Правила фильтрации сложных коллекций

Лямбда-выражения над сложными коллекциями поддерживают гораздо более гибкий синтаксис, чем лямбда-выражения над коллекциями примитивных типов. В таком лямбда-выражении можно использовать любую конструкцию фильтра, которую можно использовать за пределами, за исключением двух исключений.

Во-первых, функции, `search.ismatch` и `search.ismatchscoring`, не поддерживаются внутри выражений лямбда. Дополнительные сведения см. [в разделе Основные сведения о фильтрах коллекции OData в когнитивный Поиск Azure](search-query-understand-collection-filters.md).

Во-вторых, не допускаются ссылки на поля, которые не *привязаны* к переменной диапазона (так называемые *свободные переменные*). Например, рассмотрим следующие два эквивалентных выражения фильтра OData:

1. `stores/any(s: s/amenities/any(a: a eq 'parking')) and details/margin gt 0.5`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and details/margin gt 0.5))`

Первое выражение будет разрешено, а вторая форма будет отклонена, так как `details/margin` не привязана к переменной диапазона `s`.

Это правило также распространяется на выражения, которые имеют переменные, привязанные во внешней области. Такие переменные свободны по отношению к области, в которой они отображаются. Например, первое выражение разрешено, а второе эквивалентное выражение не допускается, так как `s/name` является свободным по отношению к области переменной диапазона `a`:

1. `stores/any(s: s/amenities/any(a: a eq 'parking') and s/name ne 'Flagship')`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and s/name ne 'Flagship'))`

Это ограничение не должно быть проблемой на практике, поскольку всегда можно создавать фильтры таким, чтобы лямбда-выражения содержали только привязанные переменные.

## <a name="cheat-sheet-for-collection-filter-rules"></a>Лист Памятка по для правил фильтра коллекции

В следующей таблице перечислены правила построения допустимых фильтров для каждого типа данных коллекции.

[!INCLUDE [Limitations on OData lambda expressions in Azure Cognitive Search](../../includes/search-query-odata-lambda-limitations.md)]

Примеры создания допустимых фильтров для каждого варианта см. [в разделе как записать допустимые фильтры коллекции](#bkmk_examples).

Если вы часто пишете фильтры и понимаете, что правила из первых принципов могли бы помочь вам больше, чем просто запомнить их, см. раздел [Общие сведения о фильтрах коллекции OData в когнитивный Поиск Azure](search-query-understand-collection-filters.md).

## <a name="next-steps"></a>Дальнейшие действия  

- [Основные сведения о фильтрах коллекции OData в Azure Когнитивный поиск](search-query-understand-collection-filters.md)
- [Фильтры в Когнитивный поиск Azure](search-filters.md)
- [Общие сведения о языке выражений OData для Azure Когнитивный поиск](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для Azure Когнитивный поиск](search-query-odata-syntax-reference.md)
- [Поиск документов &#40;Когнитивный поиск Azure REST API&#41;](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
