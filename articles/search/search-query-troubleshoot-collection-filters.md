---
title: Устранение неполадок фильтры коллекции OData - поиска Azure
description: Устранение неполадок фильтр коллекции OData в запросах поиска Azure.
ms.date: 06/13/2019
services: search
ms.service: search
ms.topic: conceptual
author: brjohnstmsft
ms.author: brjohnst
ms.manager: cgronlun
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: c7fa00c82eea03a50bae22fcb1ad16e230aa5bcb
ms.sourcegitcommit: 41ca82b5f95d2e07b0c7f9025b912daf0ab21909
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "67079630"
---
# <a name="troubleshooting-odata-collection-filters-in-azure-search"></a>Устранение неполадок фильтры коллекции OData в службе поиска Azure

Чтобы [фильтра](query-odata-filter-orderby-syntax.md) в коллекции полей в службе поиска Azure, вы можете использовать [ `any` и `all` операторы](search-query-odata-collection-operators.md) вместе с **лямбда-выражения**. Лямбда-выражение — это вложенный фильтр, который применяется к каждому элементу коллекции.

Не все функции, выражения фильтров доступна внутри лямбда-выражения. Какие функции доступны зависит от типа данных поля коллекции, которое нужно выполнить фильтрацию. Это может привести к ошибке при попытке использовать функцию в лямбда-выражения, которая не поддерживается в этом контексте. Если такие ошибки возникать при попытке записи сложный фильтр коллекции полей, эта статья поможет вам устранить проблему.

## <a name="common-collection-filter-errors"></a>Распространенные ошибки фильтр коллекции

Ниже перечислены ошибки, которые могут возникнуть при попытке выполнения фильтр коллекции. Эти ошибки возникают при использовании функции выражений фильтра, который не поддерживается внутри лямбда-выражения. Каждая ошибка предоставляет некоторые рекомендации о том, как можно переписать фильтра, чтобы избежать этой ошибки. Таблица также содержит ссылку на соответствующий раздел этой статьи, предоставляющий дополнительные сведения о том, как избежать этой ошибки.

| Сообщение об ошибке | Ситуации | Дополнительную информацию см. в разделе |
| --- | --- | --- |
| Функция «ismatch» не имеет параметров привязан к переменной диапазона ". Только граница внутри лямбда-выражения («any» или «все») поддерживаются ссылки на поле. Измените фильтр, чтобы функция «ismatch» находится за пределами лямбда-выражения и повторите попытку. | С помощью `search.ismatch` или `search.ismatchscoring` внутри лямбда-выражения | [Правила для фильтрации сложные коллекции](#bkmk_complex) |
| Недопустимый лямбда-выражение. Найден тест на Признак равенства или неравенства, где ожидался противоположным в лямбда-выражение, которое выполняет итерацию по поле типа Collection(Edm.String). Для «any» используйте выражения формы «x eq y» или «search.in(...)». Для «all», используйте выражения формы «x ne y», «не (x y eq)» или «не search.in(...)». | Фильтрация по полю типа `Collection(Edm.String)` | [Правила для фильтрации коллекции строк](#bkmk_strings) |
| Недопустимый лямбда-выражение. Найти это неподдерживаемый вид сложных логическое выражение. Для «any» используйте выражения, являющиеся «OR из запускалась», также известный как дизъюнктивная нормальных форм. Например: '(a and b) или (c и d) ", где, b, c и d вложенных выражений сравнения или проверки на равенство. Для «all», используйте выражения, являющиеся «Запускалась из OR», также известный как соединительным нормальных форм. Например: '(a or b) и (c или d) ", где, b, c и d вложенных выражений сравнения или проверки на неравенство. Примеры выражений сравнения: "x gt 5 °" x le 2". Пример выражения равенства: "x eq 5 °. Пример выражения неравенства: "x ne 5 °. | Фильтрация по полям типа `Collection(Edm.DateTimeOffset)`, `Collection(Edm.Double)`, `Collection(Edm.Int32)`, или `Collection(Edm.Int64)` | [Правила для фильтрации сопоставимых коллекций](#bkmk_comparables) |
| Недопустимый лямбда-выражение. Найти неподдерживаемое использование geo.distance() или geo.intersects() в лямбда-выражение, которое выполняет итерацию по поле типа Collection(Edm.GeographyPoint). Для «any» убедитесь, что сравнение geo.distance(), с помощью операторов «lt» или «le» и убедитесь, что за использование geo.intersects() не отрицательное. Для «all», убедитесь, что сравнение geo.distance(), с помощью операторов «gt» или «ge» и убедитесь в том, что за использование geo.intersects() отрицательное. | Фильтрация по полю типа `Collection(Edm.GeographyPoint)` | [Правила для фильтрации коллекции GeographyPoint](#bkmk_geopoints) |
| Недопустимый лямбда-выражение. Сложные логические выражения не поддерживаются в лямбда-выражениях, которые проходят через поля типа Collection(Edm.GeographyPoint). Для «any», примите участие вложенных выражений с помощью «или»; «и» не поддерживается. Для «all», примите участие вложенных выражений с «и»; «или» не поддерживается. | Фильтрация по полям типа `Collection(Edm.String)` или `Collection(Edm.GeographyPoint)` | [Правила для фильтрации коллекции строк](#bkmk_strings) <br/><br/> [Правила для фильтрации коллекции GeographyPoint](#bkmk_geopoints) |
| Недопустимый лямбда-выражение. Найти оператора сравнения (один из «lt», «le», «gt» или «ge»). В лямбда-выражения, которые проходят через поля типа Collection(Edm.String) допускаются только операторы равенства. Для «any» используйте выражения в форме «x eq y». Для «all», используйте выражения формы «x ne y» или «не (x y eq»). | Фильтрация по полю типа `Collection(Edm.String)` | [Правила для фильтрации коллекции строк](#bkmk_strings) |

<a name="bkmk_examples"></a>

## <a name="how-to-write-valid-collection-filters"></a>Как написать допустимую коллекцию фильтров

Правила для написания допустимую коллекцию фильтры отличаются для каждого типа данных. В следующих разделах описаны правила, отображая примеры, какой фильтр функции поддерживаются, и который не:

- [Правила для фильтрации коллекции строк](#bkmk_strings)
- [Правила для фильтрации логическое коллекций](#bkmk_bools)
- [Правила для фильтрации коллекции GeographyPoint](#bkmk_geopoints)
- [Правила для фильтрации сопоставимых коллекций](#bkmk_comparables)
- [Правила для фильтрации сложные коллекции](#bkmk_complex)

<a name="bkmk_strings"></a>

## <a name="rules-for-filtering-string-collections"></a>Правила для фильтрации коллекции строк

Внутри лямбда-выражения для коллекций строк, являются только операторы, которые могут использоваться `eq` и `ne`.

> [!NOTE]
> Поиск Azure не поддерживает `lt` / `le` / `gt` / `ge` операторы для строк, следует ли внутри или за пределами лямбда-выражение.

Тело `any` можно только для проверки на равенство при тело `all` можно только для проверки неравенства.

Это также можно объединить несколько выражений с помощью `or` в теле `any`и через `and` в теле `all`. Так как `search.in` функция эквивалентна объединения проверки равенства с `or`, также допустимы в теле `any`. И наоборот `not search.in` в теле допускается `all`.

Например допускаются следующие выражения:

- `tags/any(t: t eq 'books')`
- `tags/any(t: search.in(t, 'books, games, toys'))`
- `tags/all(t: t ne 'books')`
- `tags/all(t: not (t eq 'books'))`
- `tags/all(t: not search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' or t eq 'games')`
- `tags/all(t: t ne 'books' and not (t eq 'games'))`

Хотя эти выражения не допускается:

- `tags/any(t: t ne 'books')`
- `tags/any(t: not search.in(t, 'books, games, toys'))`
- `tags/all(t: t eq 'books')`
- `tags/all(t: search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' and t ne 'games')`
- `tags/all(t: t ne 'books' or not (t eq 'games'))`

<a name="bkmk_bools"></a>

## <a name="rules-for-filtering-boolean-collections"></a>Правила для фильтрации логическое коллекций

Тип `Edm.Boolean` поддерживает только `eq` и `ne` операторы. Таким образом, нет смысла много разрешающее объединения таких предложений, которые проверяют одну и ту же переменную диапазона с `and` / `or` так, как всегда, приведет к tautologies или противоречия.

Ниже приведены некоторые примеры фильтров на логическое коллекций, которые разрешено.

- `flags/any(f: f)`
- `flags/all(f: f)`
- `flags/any(f: f eq true)`
- `flags/any(f: f ne true)`
- `flags/all(f: not f)`
- `flags/all(f: not (f eq true))`

В отличие от коллекций строк логическое коллекции имеют без ограничений, в которых оператор может использоваться в какой тип лямбда-выражение. Оба `eq` и `ne` может использоваться в теле `any` или `all`.

Для коллекций логическое запрещено использовать выражения, подобные следующему:

- `flags/any(f: f or not f)`
- `flags/any(f: f or f)`
- `flags/all(f: f and not f)`
- `flags/all(f: f and f eq true)`

<a name="bkmk_geopoints"></a>

## <a name="rules-for-filtering-geographypoint-collections"></a>Правила для фильтрации коллекции GeographyPoint

Значения типа `Edm.GeographyPoint` в коллекции можно сравнивать друг к другу. Вместо этого они должны использовать в качестве параметров для `geo.distance` и `geo.intersects` функции. `geo.distance` Функция в свою очередь должна быть по сравнению с значение расстояния, с помощью одного из операторов сравнения `lt`, `le`, `gt`, или `ge`. Эти правила также применяются к полям Edm.GeographyPoint не коллекции.

Такие как коллекции строк, `Edm.GeographyPoint` коллекции имеют некоторые правила как геопространственные функции можно использовать и объединять в различные типы лямбда-выражения:

- Какие операторы сравнения, можно использовать с `geo.distance` функция зависит от типа лямбда-выражения. Для `any`, можно использовать только `lt` или `le`. Для `all`, можно использовать только `gt` или `ge`. Можно отменить с использованием выражений `geo.distance`, но вам придется изменить оператор сравнения (`geo.distance(...) lt x` становится `not (geo.distance(...) ge x)` и `geo.distance(...) le x` становится `not (geo.distance(...) gt x)`).
- В теле `all`, `geo.intersects` функция должна быть инвертирована. И наоборот, в теле `any`, `geo.intersects` функция не должна быть инвертирована.
- В теле `any`, геопространственные выражения можно объединить с помощью `or`. В теле `all`, такие выражения могут объединяться с помощью `and`.

Вышеупомянутые ограничения существуют по тем же причинам ограничение равенства и неравенства коллекций строк. См. в разделе [OData основные сведения о коллекции фильтров в поиске Azure](search-query-understand-collection-filters.md) подробные сведения по этим причинам.

Ниже приведены некоторые примеры фильтров на `Edm.GeographyPoint` коллекций, которые разрешены:

- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: not (geo.distance(l, geography'POINT(-122 49)') ge 10) or geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') ge 10 and not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

Выражения, подобные следующему запрещены для `Edm.GeographyPoint` коллекций:

- `locations/any(l: l eq geography'POINT(-122 49)')`
- `locations/any(l: not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') gt 10)`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10 and geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') le 10 or not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

<a name="bkmk_comparables"></a>

## <a name="rules-for-filtering-comparable-collections"></a>Правила для фильтрации сопоставимых коллекций

Этот раздел относится к все следующие типы данных:

- `Collection(Edm.DateTimeOffset)`
- `Collection(Edm.Double)`
- `Collection(Edm.Int32)`
- `Collection(Edm.Int64)`

Типы, такие как `Edm.Int32` и `Edm.DateTimeOffset` поддерживают все шесть из операторов сравнения: `eq`, `ne`, `lt`, `le`, `gt`, и `ge`. Лямбда-выражения, по сравнению с коллекциями из этих типов может содержать простые выражения, с помощью любого из этих операторов. Это относится как `any` и `all`. Например допускаются следующие фильтры:

- `ratings/any(r: r ne 5)`
- `dates/any(d: d gt 2017-08-24T00:00:00Z)`
- `not margins/all(m: m eq 3.5)`

Тем не менее существуют ограничения на том, как такие сравнения выражения могут объединяться в более сложных выражений внутри лямбда-выражение:

- Правила для `any`:
  - Простыми выражениями неравенства не может быть полезно вместе с любые другие выражения. Например это выражение является допустимым:
    - `ratings/any(r: r ne 5)`

    но не это выражение:
    - `ratings/any(r: r ne 5 and r gt 2)`

    и хотя это выражение может, оно не слишком полезно, так как перекрываются условия:
    - `ratings/any(r: r ne 5 or r gt 7)`
  - Простое сравнение выражения с использованием `eq`, `lt`, `le`, `gt`, или `ge` могут сочетаться с `and` / `or`. Пример:
    - `ratings/any(r: r gt 2 and r le 5)`
    - `ratings/any(r: r le 5 or r gt 7)`
  - Выражения сравнения в сочетании с `and` (объединения) можно объединять с помощью `or`. Этот вид известен в булевой логики как "[дизъюнктивная нормальных форм](https://en.wikipedia.org/wiki/Disjunctive_normal_form)" (DNF). Пример:
    - `ratings/any(r: (r gt 2 and r le 5) or (r gt 7 and r lt 10))`
- Правила для `all`:
  - Простыми выражениями равенства, не может быть полезно вместе с любые другие выражения. Например это выражение является допустимым:
    - `ratings/all(r: r eq 5)`

    но не это выражение:
    - `ratings/all(r: r eq 5 or r le 2)`

    и хотя это выражение может, оно не слишком полезно, так как перекрываются условия:
    - `ratings/all(r: r eq 5 and r le 7)`
  - Простое сравнение выражения с использованием `ne`, `lt`, `le`, `gt`, или `ge` могут сочетаться с `and` / `or`. Пример:
    - `ratings/all(r: r gt 2 and r le 5)`
    - `ratings/all(r: r le 5 or r gt 7)`
  - Выражения сравнения в сочетании с `or` (разделения) можно объединять с помощью `and`. Этот вид известен в булевой логики как "[соединительным нормальных форм](https://en.wikipedia.org/wiki/Conjunctive_normal_form)" (CNF). Пример:
    - `ratings/all(r: (r le 2 or gt 5) and (r lt 7 or r ge 10))`

<a name="bkmk_complex"></a>

## <a name="rules-for-filtering-complex-collections"></a>Правила для фильтрации сложные коллекции

Лямбда-выражения сложных коллекций поддерживают более гибкий синтаксис чем лямбда-выражения по сравнению с коллекциями типов-примитивов. Можно использовать любой фильтр конструкции внутри таких лямбда-выражения можно использовать за пределы одной только двух исключений.

Во-первых, функции `search.ismatch` и `search.ismatchscoring` не поддерживаются внутри лямбда-выражения. Дополнительные сведения см. в разделе [OData основные сведения о коллекции фильтров в поиске Azure](search-query-understand-collection-filters.md).

Во-вторых, которые ссылаются на поля, которые не являются *привязан* к переменной диапазона (так называемые *освободить переменные*) не является допустимым. Например рассмотрим следующие два эквивалентных выражения фильтров OData:

1. `stores/any(s: s/amenities/any(a: a eq 'parking')) and details/margin gt 0.5`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and details/margin gt 0.5))`

Первое выражение будет разрешен, а второй формы будут отклонены, так как `details/margin` не привязан к переменной диапазона `s`.

Это правило также распространяется на выражений, содержащих переменные, привязанные во внешней области. Такие переменные предоставляются бесплатно по отношению к области, в котором они появляются. Например, первое выражение разрешено, а во-вторых, эквивалентное выражение недопустимо, поскольку `s/name` предоставляется бесплатно по отношению к области переменной диапазона `a`:

1. `stores/any(s: s/amenities/any(a: a eq 'parking') and s/name ne 'Flagship')`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and s/name ne 'Flagship'))`

Это ограничение не должно представлять проблему на практике, поскольку всегда существует возможность создавать фильтры таким образом, что лямбда-выражения содержат только связанные переменные.

## <a name="cheat-sheet-for-collection-filter-rules"></a>Памятка для коллекции правил фильтрации

В следующей таблице перечислены правила для создания допустимых фильтров для каждого типа данных коллекции.

[!INCLUDE [Limitations on OData lambda expressions in Azure Search](../../includes/search-query-odata-lambda-limitations.md)]

Примеры для построения допустимых фильтров для каждого варианта, см. в разделе [как допустимую коллекцию фильтров записи](#bkmk_examples).

Если фильтры записи часто и основные сведения о правилах из первого принципы помогают вам больше, чем просто выучить их, см. в разделе [OData основные сведения о коллекции фильтров в поиске Azure](search-query-understand-collection-filters.md).

## <a name="next-steps"></a>Дальнейшие действия  

- [Общие сведения о фильтрах коллекции OData в службе поиска Azure](search-query-understand-collection-filters.md)
- [Фильтры в службе "Поиск Azure"](search-filters.md)
- [Общие сведения о языках выражений OData для службы поиска Azure](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для службы поиска Azure](search-query-odata-syntax-reference.md)
- [Search Documents (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/Search-Documents) (Поиск по документам (REST API службы "Поиск Azure"))
