---
title: Устранение неполадок фильтров сбора OData
titleSuffix: Azure Cognitive Search
description: Изучите подходы к устранению ошибок фильтра сбора OData в запросах Azure Cognitive Search.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: e82fa00226c964d5ba774cdf06f5b0f3898bdc55
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74113082"
---
# <a name="troubleshooting-odata-collection-filters-in-azure-cognitive-search"></a>Устранение неполадок в сборах OData в Azure Cognitive Search

Для [фильтрации](query-odata-filter-orderby-syntax.md) полей сбора в Azure Cognitive Search можно использовать [ `any` `all` ](search-query-odata-collection-operators.md) и операторов вместе с **выражениями lambda.** Выражение лямбда — это подфильтр, который применяется к каждому элементу коллекции.

Не каждая особенность выражения фильтра доступна внутри выражения лямбда. Какие функции доступны, зависит от типа поля сбора данных, которое требуется отфильтровать. Это может привести к ошибке, если вы попытаетесь использовать функцию в выражении lambda, которое не поддерживается в этом контексте. Если вы столкнулись с такими ошибками при попытке написать сложный фильтр на полях сбора, эта статья поможет вам устранить неполадки.

## <a name="common-collection-filter-errors"></a>Общие ошибки фильтра сбора

В следующей таблице перечислены ошибки, с которыми можно столкнуться при попытке выполнения фильтра сбора. Эти ошибки возникают при использовании функции выражений фильтра, которая не поддерживается внутри выражения lambda. Каждая ошибка дает некоторые рекомендации о том, как вы можете переписать фильтр, чтобы избежать ошибки. В таблице также содержится ссылка на соответствующий раздел этой статьи, в который содержится дополнительная информация о том, как избежать этой ошибки.

| Сообщение об ошибке | Ситуация | Дополнительные сведения см. в разделе |
| --- | --- | --- |
| Функция 'ismatch' не имеет параметров, связанных с переменным диапазоном 's'. Только связанные ссылки на поле поддерживаются внутри выражений лямбды ("любой" или "все"). Пожалуйста, измените фильтр так, чтобы функция 'ismatch' была вне выражения лямбда и попробуйте еще раз. | Использование `search.ismatch` `search.ismatchscoring` или внутри выражения лямбда | [Правила фильтрации сложных коллекций](#bkmk_complex) |
| Недействительное выражение лямбды. Найдено испытание на равенство или неравенство, где ожидалось обратное в выражении лямбда, которое итерирует поле коллекции типа (Edm.String). Для "любого" используйте выражения формы 'x eq y' или "search.in (...)". Для "всех", пожалуйста, используйте выражения формы 'x ne y', 'не (x eq y)', или 'не search.in (...)»... | Фильтрация на поле типа`Collection(Edm.String)` | [Правила фильтрации сборов строк](#bkmk_strings) |
| Недействительное выражение лямбды. Найдено неподдерживаемая форма сложного булеаного выражения. Для "любого", пожалуйста, используйте выражения, которые являются "ORs ANDs", также известный как Disjunctive Normal Form. Например: 'a и b) или (c и d)', где a, b, c, и d являются подвыражениями сравнения или равенства. Для "всех", пожалуйста, используйте выражения, которые являются "ANDs ORs", также известный как конъюнктурная нормальная форма. Например: 'a или b) и (c или d)', где a, b, c, и d являются подвыражениями сравнения или неравенства. Примеры выражений сравнения: 'x gt 5', 'x le 2'. Пример выражения равенства: 'x eq 5'. Пример выражения неравенства: 'x ne 5'. | Фильтрация на полях `Collection(Edm.Double)` `Collection(Edm.Int32)`типа, `Collection(Edm.DateTimeOffset)`или`Collection(Edm.Int64)` | [Правила фильтрации сопоставимых коллекций](#bkmk_comparables) |
| Недействительное выражение лямбды. Найдено неподдерживаемое использование geo.distance() или geo.intersects() в выражении лямбды, которое итерирует поле коллекции типа (Edm.GeographyPoint). Для "любого", убедитесь, что вы сравните geo.distance() с помощью "lt" или "ле" операторов и убедитесь, что любое использование geo.intersects() не сводится на нет. Для "все", убедитесь, что вы сравните geo.distance() с помощью "gt" или "ge" операторов и убедитесь, что любое использование geo.intersects() сводится на нет. | Фильтрация на поле типа`Collection(Edm.GeographyPoint)` | [Правила фильтрации коллекций GeographyPoint](#bkmk_geopoints) |
| Недействительное выражение лямбды. Сложные выражения Boolean не поддерживаются в выражениях лямбды, которые итерируются над полями коллекции типов (Edm.GeographyPoint). Для "любого", пожалуйста, присоединяйтесь к субвыражениям с "или"; "и" не поддерживается. Для "всех", пожалуйста, присоединяйтесь к суб-выражениям с "и"; 'или' не поддерживается. | Фильтрация на полях типа `Collection(Edm.String)` или`Collection(Edm.GeographyPoint)` | [Правила фильтрации сборов строк](#bkmk_strings) <br/><br/> [Правила фильтрации коллекций GeographyPoint](#bkmk_geopoints) |
| Недействительное выражение лямбды. Найдено оператор сравнения (один из 'lt', 'le', 'gt', или 'ge'). Только операторы равенства допускаются в выражениях lambda которые итерируют над полями собрания типа (Edm.String). Для "любого" используйте выражения формы 'x eq y'. Для "всех", пожалуйста, используйте выражения формы 'x ne y' или 'not (x eq y)'. | Фильтрация на поле типа`Collection(Edm.String)` | [Правила фильтрации сборов строк](#bkmk_strings) |

<a name="bkmk_examples"></a>

## <a name="how-to-write-valid-collection-filters"></a>Как написать действительные фильтры сбора

Правила написания действительных фильтров сбора различны для каждого типа данных. В следующих разделах описываются правила, показывая примеры того, какие функции фильтра поддерживаются, а какие нет:

- [Правила фильтрации сборов строк](#bkmk_strings)
- [Правила фильтрации коллекций Boolean](#bkmk_bools)
- [Правила фильтрации коллекций GeographyPoint](#bkmk_geopoints)
- [Правила фильтрации сопоставимых коллекций](#bkmk_comparables)
- [Правила фильтрации сложных коллекций](#bkmk_complex)

<a name="bkmk_strings"></a>

## <a name="rules-for-filtering-string-collections"></a>Правила фильтрации сборов строк

Внутри lambda выражения для строки коллекции, только `eq` операторы сравнения, которые могут быть использованы и `ne`.

> [!NOTE]
> Azure Cognitive Search не `lt` / `le` / `gt` / `ge` поддерживает операторов для строк, будь то внутри или за пределами выражения лямбда.

Тело `any` может только проверить на равенство в `all` то время как тело может только проверить на неравенство.

Это также можно объединить несколько `or` выражений через `any`в теле, и `and` через `all`в теле . Так `search.in` как функция эквивалентна сочетанию проверок равенства с, `or`это `any`также разрешено в теле . И наоборот, `not search.in` допускается в `all`теле .

Например, эти выражения разрешены:

- `tags/any(t: t eq 'books')`
- `tags/any(t: search.in(t, 'books, games, toys'))`
- `tags/all(t: t ne 'books')`
- `tags/all(t: not (t eq 'books'))`
- `tags/all(t: not search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' or t eq 'games')`
- `tags/all(t: t ne 'books' and not (t eq 'games'))`

в то время как эти выражения не допускаются:

- `tags/any(t: t ne 'books')`
- `tags/any(t: not search.in(t, 'books, games, toys'))`
- `tags/all(t: t eq 'books')`
- `tags/all(t: search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' and t ne 'games')`
- `tags/all(t: t ne 'books' or not (t eq 'games'))`

<a name="bkmk_bools"></a>

## <a name="rules-for-filtering-boolean-collections"></a>Правила фильтрации коллекций Boolean

Тип `Edm.Boolean` поддерживает только `eq` `ne` операторов и операторов. Таким образом, это не имеет смысла, чтобы сочетание таких положений, `and` / `or` которые проверяют тот же диапазон переменной с тех пор, что всегда приведет к тавтологии или противоречий.

Вот несколько примеров фильтров на коллекциях Boolean, которые разрешены:

- `flags/any(f: f)`
- `flags/all(f: f)`
- `flags/any(f: f eq true)`
- `flags/any(f: f ne true)`
- `flags/all(f: not f)`
- `flags/all(f: not (f eq true))`

В отличие от струнных коллекций, коллекции Boolean не имеют ограничений, на каком операторе может быть использован о том, какой тип выражения лямбды. Оба `eq` `ne` и могут быть использованы в организме `any` или `all`.

Выражения, такие как следующие, не допускаются для коллекций Boolean:

- `flags/any(f: f or not f)`
- `flags/any(f: f or f)`
- `flags/all(f: f and not f)`
- `flags/all(f: f and f eq true)`

<a name="bkmk_geopoints"></a>

## <a name="rules-for-filtering-geographypoint-collections"></a>Правила фильтрации коллекций GeographyPoint

Значения типа `Edm.GeographyPoint` в коллекции не могут быть сопоставлены непосредственно друг с другом. Вместо этого они должны использоваться `geo.distance` в `geo.intersects` качестве параметров и функций. `geo.distance` Функция, в свою очередь, должна быть сопоставлена `lt` `le`с `gt`расстоянием значение с помощью одного из операторов сравнения , , или `ge`. Эти правила также распространяются на поля Edm.GeographyPoint, не связанные с коллекцией.

Как и `Edm.GeographyPoint` коллекции строк, коллекции имеют некоторые правила использования и объединения геопространственных функций в различных типах выражений лямбды:

- Какие операторы сравнения вы `geo.distance` можете использовать с функцией зависит от типа выражения lambda. Для, `any`вы можете `lt` `le`использовать только или . Для, `all`вы можете `gt` `ge`использовать только или . Вы можете свести на `geo.distance`нет выражения с участием, но`geo.distance(...) lt x` `not (geo.distance(...) ge x)` вам `geo.distance(...) le x` `not (geo.distance(...) gt x)`придется изменить оператора сравнения (становится и становится).
- В `all`теле, `geo.intersects` функция должна быть сведена на нет. И наоборот, в `any`теле, `geo.intersects` функция не должна быть сведена на нет.
- В `any`теле, геопространственные выражения могут быть объединены `or`с помощью. В `all`теле, такие выражения могут быть `and`объединены с помощью .

Вышеуказанные ограничения существуют по тем же причинам, что и ограничение равенства/неравенства в сборе строк. Более подробное представление об этих причинах можно найти [в фильтрах сбора OData в Azure Cognitive Search.](search-query-understand-collection-filters.md)

Вот несколько примеров `Edm.GeographyPoint` фильтров в коллекциях, которые разрешены:

- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: not (geo.distance(l, geography'POINT(-122 49)') ge 10) or geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') ge 10 and not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

Выражения, такие как следующие, `Edm.GeographyPoint` не допускаются для коллекций:

- `locations/any(l: l eq geography'POINT(-122 49)')`
- `locations/any(l: not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') gt 10)`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10 and geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') le 10 or not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

<a name="bkmk_comparables"></a>

## <a name="rules-for-filtering-comparable-collections"></a>Правила фильтрации сопоставимых коллекций

Данный раздел распространяется на все следующие типы данных:

- `Collection(Edm.DateTimeOffset)`
- `Collection(Edm.Double)`
- `Collection(Edm.Int32)`
- `Collection(Edm.Int64)`

Типы, `Edm.Int32` `Edm.DateTimeOffset` такие как и поддержка `eq`всех `ne` `lt`шести `le` `gt`операторов `ge`сравнения: , , , и . Выражения Lambda над коллекциями этих типов могут содержать простые выражения с помощью любого из этих операторов. Это относится `any` как `all`к . Например, эти фильтры разрешены:

- `ratings/any(r: r ne 5)`
- `dates/any(d: d gt 2017-08-24T00:00:00Z)`
- `not margins/all(m: m eq 3.5)`

Однако существуют ограничения в отношении того, как такие сравнительные выражения могут быть объединены в более сложные выражения внутри выражения лямбды:

- Правила `any`для:
  - Простые выражения неравенства не могут быть совмещены с другими выражениями. Например, это выражение допускается:
    - `ratings/any(r: r ne 5)`

    но это выражение не является:
    - `ratings/any(r: r ne 5 and r gt 2)`

    и хотя это выражение разрешено, оно не полезно, потому что условия перекрываются:
    - `ratings/any(r: r ne 5 or r gt 7)`
  - Простые выражения сравнения `eq` `lt`с `le` `gt`участием `ge` , , `and` / `or`, или могут быть объединены с . Пример:
    - `ratings/any(r: r gt 2 and r le 5)`
    - `ratings/any(r: r le 5 or r gt 7)`
  - Сравнение выражений `and` в сочетании с (соединения) может быть дополнительно объединены с помощью. `or` Эта форма известна в логике Boolean как «[Disjunctive Normal Form](https://en.wikipedia.org/wiki/Disjunctive_normal_form)» (DNF). Пример:
    - `ratings/any(r: (r gt 2 and r le 5) or (r gt 7 and r lt 10))`
- Правила `all`для:
  - Простые выражения равенства не могут быть спользованы с другими выражениями. Например, это выражение допускается:
    - `ratings/all(r: r eq 5)`

    но это выражение не является:
    - `ratings/all(r: r eq 5 or r le 2)`

    и хотя это выражение разрешено, оно не полезно, потому что условия перекрываются:
    - `ratings/all(r: r eq 5 and r le 7)`
  - Простые выражения сравнения `ne` `lt`с `le` `gt`участием `ge` , , `and` / `or`, или могут быть объединены с . Пример:
    - `ratings/all(r: r gt 2 and r le 5)`
    - `ratings/all(r: r le 5 or r gt 7)`
  - Сравнение выражений `or` в сочетании с (разъединений) может быть дополнительно объединены с помощью. `and` Эта форма известна в логике Boolean как «[Конъюнктивная нормальная форма](https://en.wikipedia.org/wiki/Conjunctive_normal_form)» (CNF). Пример:
    - `ratings/all(r: (r le 2 or gt 5) and (r lt 7 or r ge 10))`

<a name="bkmk_complex"></a>

## <a name="rules-for-filtering-complex-collections"></a>Правила фильтрации сложных коллекций

Выражения Lambda над сложными собраниями поддерживают гораздо более гибкий синтаксис, чем выражения лямбды над коллекциями примитивных типов. Вы можете использовать любую конструкцию фильтра внутри такого выражения лямбды, которое можно использовать за пределами одного, за двумя исключениями.

Во-первых, `search.ismatch` `search.ismatchscoring` функции и не поддерживаются внутри выражения лямбда. Для получения дополнительной информации смотрите [фильтры сбора OData в Azure Cognitive Search](search-query-understand-collection-filters.md).

Во-вторых, не допускается ссылка на поля, которые не *привязаны* к переменной диапазона (так называемые *свободные переменные).* Например, рассмотрим следующие два эквивалентных выражения фильтра OData:

1. `stores/any(s: s/amenities/any(a: a eq 'parking')) and details/margin gt 0.5`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and details/margin gt 0.5))`

Первое выражение будет разрешено, в то `details/margin` время как вторая форма `s`будет отклонена, поскольку не привязана к переменной диапазона.

Это правило также распространяется на выражения, которые имеют переменные, связанные во внешней области. Такие переменные свободны в отношении сферы, в которой они появляются. Например, допускается первое выражение, а второе эквивалентное выражение не допускается, `s/name` `a`поскольку является свободным по отношению к области переменной диапазона:

1. `stores/any(s: s/amenities/any(a: a eq 'parking') and s/name ne 'Flagship')`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and s/name ne 'Flagship'))`

Это ограничение не должно быть проблемой на практике, так как всегда можно создавать фильтры таким образом, что выражения lambda содержат только связанные переменные.

## <a name="cheat-sheet-for-collection-filter-rules"></a>Чит лист для правил фильтрации сбора

В следующей таблице кратко излагаются правила построения действительных фильтров для каждого типа данных сбора.

[!INCLUDE [Limitations on OData lambda expressions in Azure Cognitive Search](../../includes/search-query-odata-lambda-limitations.md)]

Примеры построения действительных фильтров для каждого случая можно найти по смотреть, [как писать допустимые фильтры сбора.](#bkmk_examples)

Если вы часто пишете фильтры, а понимание правил с первых принципов поможет вам не только запоминать их, см. [Понимание фильтров сбора OData в Azure Cognitive Search.](search-query-understand-collection-filters.md)

## <a name="next-steps"></a>Дальнейшие действия  

- [Понимание фильтров сбора OData в когнитивном поиске Azure](search-query-understand-collection-filters.md)
- [Фильтры в когнитивном поиске Azure](search-filters.md)
- [Обзор языка выражения OData для когнитивного поиска Azure](query-odata-filter-orderby-syntax.md)
- [Ссылка синтаксиса выражения OData для когнитивного поиска Azure](search-query-odata-syntax-reference.md)
- [Поиск документов &#40;Azure Когнитивный поиск REST API&#41;](https://docs.microsoft.com/rest/api/searchservice/Search-Documents)
