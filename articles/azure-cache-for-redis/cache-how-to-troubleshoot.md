---
title: Как устранить неполадки кэша Redis для Azure | Документация Майкрософт
description: Узнайте, как устранить типичные проблемы в кэше Redis для Azure.
services: cache
documentationcenter: ''
author: yegu-ms
manager: jhubbard
editor: ''
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache
ms.devlang: na
ms.topic: article
ms.date: 03/15/2019
ms.author: yegu
ms.openlocfilehash: 66361871d365068a90a2eeab70d92adb6b246a83
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "60830013"
---
# <a name="how-to-troubleshoot-azure-cache-for-redis"></a>Как устранить неполадки кэша Redis для Azure

Эта статья поможет устранить различные категории проблем, возникающих при подключении с кэшем Azure Redis экземпляров.

- [Устранение проблем на стороне клиента](#client-side-troubleshooting) помогает выявлять и устранять проблемы приложения, подключающиеся к вашему кэшу.
- [Устранение проблем на стороне сервера](#server-side-troubleshooting) помогает выявлять и устранять проблемы, возникающие на кэш Azure Redis стороны.
- [Устранение неполадок потери данных](#data-loss-troubleshooting) помогает выявлять и устранять инциденты, где ключи являются не обнаружен ожидаемый в кэше.
- [Исключения времени ожидания StackExchange.Redis](#stackexchangeredis-timeout-exceptions) приводятся конкретные рекомендации по устранению неполадок с библиотекой StackExchange.Redis.

> [!NOTE]
> Шаги по устранению проблем в этой статье также включают в себя указания по выполнению команд Redis и мониторингу различных метрик производительности. Дополнительные сведения и указания см. в разделе [Дополнительные сведения](#additional-information).
>
>

## <a name="client-side-troubleshooting"></a>Устранение неполадок на стороне клиента

В этом разделе рассматриваются способы устранения проблем, вызванных определенным условием в клиентском приложении.

- [Нехватка памяти на клиенте](#memory-pressure-on-the-client)
- [Увеличение трафика](#burst-of-traffic)
- [Высокий коэффициент загрузки ЦП клиента](#high-client-cpu-usage)
- [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded)
- [Большой размер запроса или ответа](#large-requestresponse-size)

### <a name="memory-pressure-on-the-client"></a>Нехватка памяти на клиенте

Нехватка памяти на клиентском компьютере служит причиной всевозможных проблем с производительностью, которые вызывают задержку обработки ответов из кэша. При посещении нехватки памяти, система может страниц данных на диск. Именно _ошибки страниц_ существенно замедляют работу системы.

Для обнаружения нехватки памяти на клиенте:

- Мониторинг использования памяти на компьютере, чтобы убедиться в том, что он не превышает объем доступной памяти.
- Мониторинг клиента `Page Faults/Sec` счетчика производительности. Во время обычной работы в большинстве систем имеют ошибки страниц возникают. Пики в ошибок страниц, соответствующий со значениями времени ожидания запроса можно указывать нехватки памяти.

Нехватка памяти на клиенте можно обойти несколькими способами:

- Во всех подробностях шаблоны использования памяти, снизив потребление памяти на клиенте.
- Обновите ваш клиент виртуальной Машины большего размера с большим объемом памяти.

### <a name="burst-of-traffic"></a>Увеличение трафика

Увеличение трафика в сочетании с недостаточными параметрами `ThreadPool` может привести к возникновению задержек обработки данных, отправленных сервером Redis, но еще не использованных на стороне клиента.

Монитор как вашей `ThreadPool` изменяется Статистика по сравнению с использованием времени [пример `ThreadPoolLogger` ](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs). Можно использовать `TimeoutException` сообщения от StackExchange.Redis, такие как ниже для дальнейшего изучения:

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0,
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

В предыдущем исключения существует несколько проблем, которые представляют интерес.

- Обратите внимание, что в разделах `IOCP` и `WORKER` значение `Busy` больше, чем значение `Min`. Это значит, ваши `ThreadPool` необходимо настроить параметры.
- Кроме того, обратите внимание на `in: 64221`. Это значение указывает, что 64211 байтов были получены на уровень сокета ядра клиента, но не считанных приложением. Это правило, это значит, приложение (например, StackExchange.Redis) не сразу же после отправки с сервера вам читает данные из сети.

Вы можете [Настройка вашей `ThreadPool` параметры](https://gist.github.com/JonCole/e65411214030f0d823cb) чтобы убедиться, что ваш масштаба пула потоков быстро в разделе увеличении.

### <a name="high-client-cpu-usage"></a>Высокий коэффициент загрузки ЦП клиента

Высокий уровень загрузки ЦП клиента указывает, что система не справляется с, что предлагается сделать. Несмотря на то, что кэш ответ отправлен быстро, клиент не сможет обработать ответ в отведенное время.

Мониторинг использования ЦП на уровне системы клиента, с помощью метрик, доступных на портале Azure или с помощью счетчиков производительности на компьютере. Не следует отслеживать *процесс* ЦП, так как один процесс может быть низкой загрузки ЦП, но системных ЦП может оказаться весьма высокой. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания. Высокой загрузки ЦП может также приводить к высокому `in: XXX` значения в `TimeoutException` сообщения об ошибках, как описано в разделе [увеличение трафика](#burst-of-traffic) раздел.

> [!NOTE]
> В StackExchange.Redis 1.1.603 и более поздней версии в сообщениях об ошибках `TimeoutException` содержится метрика `local-cpu`. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
>
>

Для устранения высокой загрузки ЦП клиента:

- Определите причину пиков использования ЦП.
- Обновите ваш клиент до большего размера виртуальной Машины емкость ЦП.

### <a name="client-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне клиента

В зависимости от архитектуры клиентских компьютеров на них применяются разные ограничения доступности пропускной способности сети. Если клиент превышает доступную пропускную способность путем перегрузки пропускной способности сети, то данные не обработаны на стороне клиента сразу же после отправки с сервера. Это может привести к превышению времени ожидания.

Отслеживать, как изменить использование пропускной способности по сравнению с использованием времени [пример `BandwidthLogger` ](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs). В некоторых окружениях с ограниченными разрешениями (например, веб-сайты Azure) этот код может не удастся выполнить.

Чтобы устранить проблему, сократить использование пропускной способности сети, или увеличьте размер виртуальной Машины, чтобы получить дополнительные пропускная способность сети клиента.

### <a name="large-requestresponse-size"></a>Большой размер запроса или ответа

Из-за большого размера запроса или ответа может истекать время ожидания. Например предположим, что значение времени ожидания на клиентском компьютере составляет 1 секунду. Приложение одновременно запрашивает два ключа (например, А и Б) в одном физическом сетевом подключении. Большинство клиентов поддерживают запроса «конвейеризации», где оба запросы «A» и «B» отправляются один за другим без ожидания ответы на них. Сервер отправляет ответы в том же порядке. Если ответ «Объект» имеет большой размер, он может занять большую периода ожидания для последующих запросов.

В следующем примере запрос «A» и «B» быстро отправляются на сервер. Запускается служба отправку ответов «A» и «B» быстро. Из-за длительного времени передачи данных ответа, которое 'B' должны ожидать за ответа «A» время ожидания, несмотря на то, что сервер быстро ответил.

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)

Запрос или ответ сложно измерить. Вы могли инструментировать код клиента для отслеживания больших запросов и ответов.

Разрешениями для ответа больших размеров, различны, но включают:

1. Оптимизируйте приложение для большое количество небольших значений, а не нескольких больших значений.
    - Поэтому рекомендуется разбить данные на небольшие связанные части.
    - См. в публикации [каков диапазон размеров оптимальное значение для redis? 100 КБ слишком велик? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) Дополнительные сведения о том, почему рекомендуется использовать меньшие значения.
1. Увеличьте размер виртуальной машины, чтобы увеличить пропускную способность
    - Больше пропускной способности на клиенте или сервере виртуальной Машины может сократить время передачи данных для больших ответов.
    - Сравнение текущего использования сети на обоих компьютерах, к ограничениям текущий размер виртуальной Машины. Больше пропускной способности только на сервере или только на стороне клиента может оказаться недостаточно.
1. Увеличьте количество объектов подключения, которые использует приложение.
    - Позволяет выполнять запросы через другое подключение объекты циклического перебора.

## <a name="server-side-troubleshooting"></a>Устранение проблем на стороне сервера

В этом разделе рассматриваются способы устранения проблем, вызванных определенным условием на сервере кэширования.

- [Нехватка памяти на сервере](#memory-pressure-on-the-server)
- [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage--server-load)
- [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a>Нехватка памяти на сервере

Нехватка памяти на сервере кэширования служит причиной всевозможных проблем с производительностью, которые вызывают задержку обработки запросов. При посещении нехватки памяти, система может страниц данных на диск. Именно _ошибки страниц_ существенно замедляют работу системы. Нехватка памяти может возникнуть по следующим причинам.

- Кэш заполняется данных рядом с максимальной емкости.
- Redis испытывает высокой степени фрагментации памяти. Фрагментация чаще всего причиной является хранение больших объектов, так как Redis оптимизирован для небольших объектов.

Redis предоставляет две stats через [INFO](https://redis.io/commands/info) команду, которая может помочь определить проблемы: «used_memory» и «used_memory_rss». Вы можете [просмотреть эти метрики](cache-how-to-monitor.md#view-metrics-with-azure-monitor) с помощью портала.

Существует несколько возможных изменения, внесенные для обеспечения работоспособности использования памяти:

- [Настройте политику памяти](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) и параметры времени завершения срока действия ключей. Эта политика может быть недостаточно, если используется фрагментация.
- [Настройте значение maxmemory-reserved](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , которого будет достаточно, чтобы компенсировать фрагментацию памяти. Дополнительные сведения см. в разделе дополнительной [рекомендации для резервирования памяти](#considerations-for-memory-reservations) ниже.
- Разбейте большие кэшированные объекты на меньшие связанные объекты.
- [Создание оповещений](cache-how-to-monitor.md#alerts) на основе метрик, например используемой памяти, чтобы получать уведомления о последствиях для заранее.
- [Масштаб](cache-how-to-scale.md) большего размера кэша с помощью дополнительной емкости памяти.

#### <a name="considerations-for-memory-reservations"></a>Рекомендации для резервирования памяти

Обновление значения резервирования памяти, зарезервированная, например, может повлиять на производительность кэша. Предположим, что у вас есть кэш размером 53 ГБ, который заполняется находится 49 ГБ данных. Изменение значение параметра резервирования на 8 ГБ удаляет максимальный объем доступной памяти системы до 45 ГБ. Если _used_memory_ или _used_memory_rss_ значения: выше, чем 45 ГБ, система может исключать данные, пока оба _used_memory_ и _used_memory_rss_ станут меньше 45 ГБ. Вытеснение может увеличить нагрузку на сервер и фрагментацию памяти.

### <a name="high-cpu-usage--server-load"></a>Высокий коэффициент загрузки ЦП и сервера

Высокий уровень нагрузки или ЦП означает, что сервер не может обрабатывать запросы своевременно. Возможно, сервер медленно отвечает на запросы и не может справиться с частоты запросов.

[Мониторинг метрик](cache-how-to-monitor.md#view-metrics-with-azure-monitor) такие как загрузка ЦП или сервера. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания.

Существует несколько изменения, внесенные для снижения нагрузки высокой нагрузки.

- Определите причину пиков использования ЦП, например запуск [ресурсоемкие команды](#expensive-commands) или завершение со сбоем из-за нехватки памяти страницы.
- [Создание оповещений](cache-how-to-monitor.md#alerts) на основе метрик, таких как ЦП или сервера нагрузки, чтобы получать уведомления о последствиях для ранних.
- [Масштаб](cache-how-to-scale.md) большего размера кэша емкость ЦП.

#### <a name="expensive-commands"></a>Ресурсоемкие команды

Не все команды Redis создаются одинаково - некоторые стоят дороже, чем другие. [Команды Redis, документация](https://redis.io/commands) показывает временная сложность каждой команды. Рекомендуется просмотреть команды, что вы используете свой кэш, чтобы понять влияние на производительность этих команд. Например [ключи](https://redis.io/commands/keys) команда часто используется не зная, что это операция O(N). КЛЮЧИ можно избежать, используя [СКАНИРОВАНИЯ](https://redis.io/commands/scan) чтобы уменьшить нагрузку на ЦП резко возрастает.

С помощью [SLOWLOG](https://redis.io/commands/slowlog) команды, можно измерить ресурсоемкие команды, выполняемой на сервере.

### <a name="server-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне сервера

Размеры разных кэша имеют другую сеть емкости пропускной способности. Если сервер превышает доступную пропускную способность, данные не отправляются клиенту в виде быстро. Запросы клиентов может времени ожидания, так как сервер не может отправлять данные клиенту достаточно быстро.

Метрики «Чтение из кэша» и «Запись в кэш» можно использовать для пропускной способности на стороне сервера используется. Вы можете [просмотреть эти метрики](cache-how-to-monitor.md#view-metrics-with-azure-monitor) на портале.

Во избежание ситуаций, где использование пропускной способности сети близок к максимальной емкости:

- Изменить поведение вызова клиента для снижения спроса сети.
- [Создание оповещений](cache-how-to-monitor.md#alerts) на основе метрик, таких как чтение из кэша или запись кэша, чтобы получать уведомления о последствиях для ранних.
- [Масштаб](cache-how-to-scale.md) большего размера кэша с дополнительные пропускная способность сети.

## <a name="data-loss-troubleshooting"></a>Устранение неполадок потери данных

В экземпляре кэша Redis для Azure не оказалось ожидаемых данных.

Дополнительные сведения о возможных причинах и способах устранения проблемы см. в статье [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) (Что произошло с моими данными в Redis?).

## <a name="stackexchangeredis-timeout-exceptions"></a>Исключения времени ожидания StackExchange.Redis

StackExchange.Redis использует параметр конфигурации `synctimeout` для синхронных операций со значением по умолчанию 1000 мс. Если синхронный вызов не завершается в течение этого времени, клиент StackExchange.Redis выводит ошибку времени ожидания, аналогичный приведенному ниже:

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)

В этом сообщении об ошибке содержатся метрики, которые помогут вам определить причину и возможное решение проблемы. В следующей таблице содержатся сведения о метриках сообщения об ошибке.

| Метрики сообщения об ошибке | Сведения |
| --- | --- |
| inst |В последний интервал времени: передано 0 команд |
| mgr |Диспетчер сокетов выполняет `socket.select`, то есть отправляет в ОС запрос на определение сокета, который имеет какое-то действие. Средство чтения не выполняет активное чтение из сети, так как он предполагает, что что-нибудь сделать |
| очередь |Указывает, что выполняется 73 операции. |
| qu |6 выполняемых операций в очереди неотправленных и еще не были записаны исходящие сетевые |
| qs |Указывает, что 67 выполняемых операций отправлено на сервер, но ответ еще не доступна. Ответ может быть таким: `Not yet sent by the server` или `sent by the server but not yet processed by the client.` |
| qc |0 или выполняемых операций отправлены ответы, но еще не были отмечены как завершенные, так как пользователь ждет окончания в цикле выполнения |
| wr |Нет байтов/activewriters активных модулей записи (то есть 6 неотправленных запросов не игнорируются) |
| больше |Указывает, что отсутствуют активные модули чтения и нет байтов для чтения для bytes/activereaders сетевой карты. |

### <a name="steps-to-investigate"></a>Действия для обнаружения проблем

1. Рекомендуется убедитесь, что для подключения при использовании клиента StackExchange.Redis используется следующий шаблон.

    ```csharp
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");

    });

    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ```

    Дополнительные сведения см. в разделе о [подключении к кэшу с использованием StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

1. Убедитесь, что серверу и клиентским приложением, в том же регионе, в Azure. Например, вы может истекать при кэш расположен в восточной части США, но клиент находится в западной части США, и запрос не завершается в течение `synctimeout` или интервал ожидания может истекать при отладке из вашей локальной машины. 

    Кэш и клиент настоятельно рекомендуется размещать в одном и том же регионе Azure. Если используются межрегиональные вызовы, необходимо увеличить значение интервала `synctimeout` по умолчанию (1000 мс), добавив в строку подключения свойство `synctimeout`. В следующем примере показано фрагмент строки подключения для StackExchange.Redis, предоставляемые Azure кэша для Redis с `synctimeout` 2000 мс.

        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
1. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
1. Если ваши запросы связаны с ограничением пропускной способности на сервере или клиенте, занимает больше времени их выполнения и могут стать причиной таймаутов. Находится ли ваш времени ожидания из-за пропускной способности сети на сервере, см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded). Находится ли ваш времени ожидания из-за пропускной способности сети клиента, см. в разделе [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded).
1. Используются ли ресурсы ЦП на сервере или клиенте?

   - Проверьте, если вы являетесь начало привязать по ЦП на клиентском компьютере. Высокой загрузки ЦП может привести к не быть обработку запроса `synctimeout` интервал и причину запроса времени ожидания. Чтобы решить эту проблему, увеличьте размер клиента или распределите загрузку.
   - Флажок, если вы получаете ЦП ограничивается на сервере мониторинга `CPU` [метрику производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals). Запросы, поступающие во время выполнения Redis ЦП могут вызывать возникновение времени ожидания. Чтобы устранить эту проблему, распределите нагрузку между несколькими сегментами в кэше (цен. категории "Премиум") либо используйте кэш большего размера или другой ценовой уровень. Дополнительные сведения см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded).
1. Занимает ли выполнение команд на сервере слишком много времени? Долго выполняющихся команд, которых требуется много времени на обработку на сервере redis может истекать время ожидания. Дополнительные сведения о долго выполняющихся команд, см. в разделе [ресурсоемкие команды](#expensive-commands). Вы можете подключиться к кэшу Azure для экземпляра Redis, с помощью клиента redis-cli или [консоль Redis](cache-configure.md#redis-console). Затем запустите [SLOWLOG](https://redis.io/commands/slowlog) команду, чтобы определить наличие запросов медленнее, чем ожидалось. Сервер Redis и StackExchange.Redis оптимизированы для обработки большого количества небольших запросов, а не нескольких больших запросов. Чтобы повысить их производительность, рекомендуется разбить данные на небольшие фрагменты.

    Сведения о подключении к конечной точке SSL кэша, с помощью redis-cli и stunnel см. в записи блога [объявление о выпуске поставщик состояний сеансов ASP.NET для предварительной версии Redis](https://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx).
1. Высокая загрузка сервера Redis может влечь истечение времени ожидания. Вы можете выполнить мониторинг значения загрузки сервера, измеряя [метрику производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Redis Server Load`. Максимальное значение загрузки (100) указывает на то, что сервер слишком загружен обработкой запросов и не простаивает. Чтобы узнать, не использует ли сервер все свои ресурсы на определенные запросы, выполните команду SlowLog, как описано в предыдущем абзаце. Дополнительные сведения см. в разделе "Высокий коэффициент загрузки ЦП и сервера".
1. Происходили ли на клиенте другие события, для которых требовалось сетевое кэширование? Общие события включают: масштабирование числа экземпляров клиента или вниз, развертывание новых версий клиента или Автомасштабирование включено. В ходе тестирования мы обнаружили, что Автомасштабирование или изменение масштабирование вверх/вниз может привести к исходящее сетевое подключение к на несколько секунд. Код StackExchange.Redis устойчив к таким событиям и подключается повторно. При восстановлении подключения, все запросы в очереди можно по времени.
1. Была ли большой запрос перед несколькими небольшими в кэш, истекло время ожидания? Параметр `qs` в ошибке, сообщение о том, сколько запросов, отправленных от клиента к серверу, но еще не обработал ответ. Это количество может увеличиваться, так как StackExchange.Redis использует одно подключение TCP, которое позволяет обрабатывать только один ответ за раз. Несмотря на то, что истекло время ожидания первой операции, все не заканчивается больше данных, отправку или с сервера. Другие запросы будут заблокированы, пока не завершит большой запрос и может привести к истечения времени ожидания. Чтобы решить эту проблему, рекомендуется снизить вероятность возникновения времени ожидания, увеличив размер кэша для рабочей нагрузки и разбив данные большого объема на небольшие фрагменты. Другое решение — использовать в клиенте пул объектов `ConnectionMultiplexer` и для отправки новых запросов применять наименее загруженный объект `ConnectionMultiplexer`. Загрузки между несколькими объектами подключения следует не вызывал единый истечения времени ожидания других запросов также истечения времени ожидания.
1. Если вы используете `RedisSessionStateProvider`, проверить время ожидания повтора настроены правильно. Значение `retryTimeoutInMilliseconds` должно быть выше, чем `operationTimeoutInMilliseconds`, иначе попытки не повторяются. В следующем примере для `retryTimeoutInMilliseconds` задано значение 3000. Дополнительные сведения см. в статьях [Поставщик состояния сеанса ASP.NET для Redis](cache-aspnet-session-state-provider.md) и [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration) (Использование параметров конфигурации поставщика состояния сеанса и поставщика кэша вывода).

    ```xml
    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />
    ```

1. Проверяйте использование памяти на сервере кэша Redis для Azure, [отслеживая](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` и `Used Memory`. Если используется политика вытеснения, Redis начнет вытеснять ключи, когда значение `Used_Memory` достигнет размера кэша. В идеале значение `Used Memory RSS` должно быть немного больше, чем значение `Used memory`. Большая разница означает, что бывает фрагментация памяти (внутренним или внешним). Если значение `Used Memory RSS` меньше значения `Used Memory`, это значит, что часть кэш-памяти используется операционной системой для подкачки. При этом могут возникать значительные задержки. Так как Redis не имеет контроля над сопоставление распределений со страниц памяти, высокая `Used Memory RSS` обычно является результатом пик в использовании памяти. Когда сервер Redis освобождает память, распределитель занимает память, но он может или может не вернуть память в системе. При этом операционная система может сообщать о расхождении между `Used Memory` и использованием памяти. Может, память используется и выпуска от Redis, но не возвращена обратно в систему. Чтобы минимизировать проблемы с памятью, можно сделать следующее:

   - Обновление кэша до большего размера, чтобы вы не работаете с ограниченным объемом памяти в системе.
   - Задайте время истечения срока действия ключей, чтобы они вытеснялись заранее.
   - Отслеживайте метрику кэша `used_memory_rss`. Это значение достигает размера кэша, вы скорее всего начать просмотр проблем с производительностью. Если вы с помощью кэша уровня "премиум", или обновление до большего размера кэша, распределите данные между несколькими сегментами.

   Дополнительные сведения см. в разделе [Нехватка памяти на сервере](#memory-pressure-on-the-server).

## <a name="additional-information"></a>Дополнительные сведения

- [Какое предложение и размер кэша Redis для Azure мне следует использовать?](cache-faq.md#what-azure-cache-for-redis-offering-and-size-should-i-use)
- [Как измерить и протестировать производительность моего кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
- [Как выполнять команды Redis?](cache-faq.md#how-can-i-run-redis-commands)
- [Как отслеживать кэш Redis для Azure?](cache-how-to-monitor.md)
