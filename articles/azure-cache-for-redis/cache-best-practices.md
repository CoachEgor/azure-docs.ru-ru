---
title: Рекомендации по использованию Кэша Azure для Redis
description: Узнайте, как эффективно использовать кэш Azure для Redis, следуя этим рекомендациям.
author: joncole
ms.service: cache
ms.topic: conceptual
ms.date: 01/06/2020
ms.author: joncole
ms.openlocfilehash: 71056fd04069b861b37a595b1a4f2a8bba4a01ef
ms.sourcegitcommit: 2f8ff235b1456ccfd527e07d55149e0c0f0647cc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75689977"
---
# <a name="best-practices-for-azure-cache-for-redis"></a>Рекомендации по использованию Кэша Azure для Redis 
Следуя этим рекомендациям, вы сможете повысить производительность и экономичное использование кэша Azure для экземпляра Redis.

## <a name="configuration-and-concepts"></a>Конфигурация и основные понятия
 * **Используйте уровень "Стандартный" или "Премиум" для рабочих систем.**  Уровень "базовый" — это система с одним узлом без репликации данных и соглашения об уровне обслуживания. Кроме того, используйте по крайней мере кэш C1.  Кэши C0 предназначены для простых сценариев разработки и тестирования, так как они имеют общее ядро ЦП, небольшое количество памяти и подвержены проблемам с помехами в связи с соседями.

 * **Помните, что Redis — это хранилище данных в памяти.**  В [этой статье](cache-troubleshoot-data-loss.md) описываются некоторые сценарии, в которых могут возникать потери данных.

 * **Разрабатывайте систему так, чтобы она могла управлять подключением нестабильной работе** [из-за исправлений и отработки отказа](cache-failover.md).

 * **Настройте [параметр MaxMemory-reserved](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , чтобы повысить скорость реагирования системы** при условиях нехватки памяти.  Достаточный параметр резервирования особенно важен для рабочих нагрузок с интенсивной записью или при хранении больших значений (100 КБ или более) в Redis. Необходимо начать с 10% от размера кэша и увеличить этот процент при наличии загрузок с интенсивной записью.

 * **Redis работает наилучшим образом с меньшими значениями**, поэтому рассмотрите возможность разбить данные большего размера на несколько ключей.  В [этом Redisм обсуждении](https://stackoverflow.com/questions/55517224/what-is-the-ideal-value-size-range-for-redis-is-100kb-too-large/)приводятся некоторые соображения, которые следует тщательно рассмотреть.  Прочитайте [эту статью](cache-troubleshoot-client.md#large-request-or-response-size) , чтобы ознакомиться с примером проблемы, вызванной большими значениями.

 * **Нахождение экземпляра кэша и приложения в одном регионе.**  Подключение к кэшу в другом регионе может увеличить задержку и значительно снизить надежность.  Хотя вы можете подключаться извне Azure, не рекомендуется, *особенно при использовании Redis в качестве кэша*.  Если вы используете Redis в качестве простого хранилища ключей и значений, то задержка может не быть основной задачей. 

 * **Повторное использование подключений.**  Создание новых подключений требует больших затрат и увеличивает задержку, поэтому используйте подключения максимально часто. Если вы решили создать новые подключения, обязательно закройте старые подключения, прежде чем выпустить их (даже в управляемых языках памяти, таких как .NET или Java).

 * **Настройте клиентскую библиотеку на использование *времени ожидания подключения* не менее 15 секунд**, чтобы системное время подключаться даже при более высоких условиях ЦП.  Значение времени ожидания небольшого соединения не гарантирует, что подключение будет установлено в течение этого времени.  Если что-то пойдет не так (высокий клиентский ЦП, высокий серверный ЦП и т. д.), то попытка подключения приведет к сбою соединения. Такое поведение часто делает серьезную ситуацию хуже.  Вместо того, чтобы сократить время ожидания, усилиться проблему, переведя систему на перезапуск процесса повторного подключения, что может привести к циклу *повторных попыток подключения > сбоя >* . Обычно рекомендуется оставлять время ожидания подключения через 15 секунд или выше. Лучше разрешить успешное выполнение попытки подключения через 15 или 20 секунд, чем при неудачном завершении попытки. Такой цикл повторных попыток может привести к тому, что время простоя будет больше, чем если бы вы позволяли системе получить более длинные первоначальные возможности.  
     > [!NOTE]
     > Это руководство относится к *попыткам подключения* и не связано с тем временем, когда вы ожидаете завершения *операции* , например Get или Set.
 
 * **Старайтесь не использовать дорогостоящие операции** . Некоторые Redis операции, такие как команды [Keys](https://redis.io/commands/keys) , являются *очень* ресурсоемкими, и их следует избегать.  Дополнительные сведения см. в разделе некоторые рекомендации по [работе с длительными командами](cache-troubleshoot-server.md#long-running-commands) .

 * **Использование шифрования TLS** . по умолчанию для кэша Azure для REDIS требуется TLS-шифрование сообщений.  В настоящее время поддерживаются версии TLS 1,0, 1,1 и 1,2.  Однако протоколы TLS 1,0 и 1,1 — это путь к устаревшей отрасли, поэтому по возможности используйте TLS 1,2.  Если клиентская библиотека или средство не поддерживает протокол TLS, то включить незашифрованные соединения можно с [помощью портал Azure](cache-configure.md#access-ports) или [API управления](https://docs.microsoft.com/rest/api/redis/redis/update).  В таких случаях, когда зашифрованные подключения невозможны, рекомендуется разместить кэш и клиентское приложение в виртуальной сети.  Дополнительные сведения о том, какие порты используются в сценарии использования кэша виртуальной сети, см. в этой [таблице](cache-how-to-premium-vnet.md#outbound-port-requirements).
 
## <a name="memory-management"></a>Управление памятью
Существует несколько моментов, связанных с использованием памяти в экземпляре сервера Redis, который может потребоваться рассмотреть.  Вот некоторые из них:

 * **Выберите [политику вытеснения](https://redis.io/topics/lru-cache) , которая подходит для вашего приложения.**  Политика по умолчанию для Azure Redis — это *volatile-LRU*, что означает, что только ключи с установленным значением TTL будут доступны для вытеснения.  Если ключи не имеют значения TTL, система не будет выключать никакие ключи.  Если вы хотите, чтобы система могла удалить любой ключ в случае нехватки памяти, можно рассмотреть политику *AllKeys-LRU* .

 * **Задайте значение срока действия ключей.**  После истечения срока действия ключи будут удалены заранее, а не ждать, пока не найдется нехватка памяти.  Если вытеснение происходит из-за нехватки памяти, это может привести к дополнительной нагрузке на сервер.  Дополнительные сведения см. в документации по командам [Expires](https://redis.io/commands/expire) и [експиреат](https://redis.io/commands/expireat) .
 
## <a name="client-library-specific-guidance"></a>Специальные рекомендации для клиентской библиотеки
 * [StackExchange. Redis (.NET)](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-stackexchange-redis-md)
 * [Java — какой клиент следует использовать?](https://gist.github.com/warrenzhu25/1beb02a09b6afd41dff2c27c53918ce7#file-azure-redis-java-best-practices-md)
 * [Салат (Java)](https://gist.github.com/warrenzhu25/181ccac7fa70411f7eb72aff23aa8a6a#file-azure-redis-lettuce-best-practices-md)
 * [Jedis (Java)](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-java-jedis-md)
 * [Node.js](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-node-js-md)
 * [PHP](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-php-md)
 * [Поставщик состояния сеанса Asp.Net](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-session-state-provider-md)


## <a name="when-is-it-safe-to-retry"></a>Когда можно попробовать повторить попытку?
Увы, простого ответа нет.  Каждое приложение должно решить, какие операции можно повторить, а какие — нет.  Каждая операция имеет разные требования и межключные зависимости.  Ниже приведены некоторые моменты, которые можно учитывать.

 * Ошибки на стороне клиента можно получить, несмотря на то, что Redis успешно выполнил команду, которая запросила ее запуск.  Пример.
     - Время ожидания является концепцией на стороне клиента.  Если операция достигла сервера, сервер выполнит команду, даже если клиент предоставит ожидание.  
     - При возникновении ошибки в подключении к сокету невозможно выяснить, реально ли выполнялась операция на сервере.  Например, ошибка подключения может произойти после того, как сервер обработал запрос, но до того, как клиент получит ответ.
 *  Как работает приложение, если случайно выполнялась та же операция дважды?  Например, что делать, если вместо одного раза увеличить целое число?  Будет ли приложение выполнять запись в один и тот же ключ из нескольких мест?  Что если логика повторных попыток перезаписывает значение, заданное какой-либо другой частью моего приложения?

Если вы хотите протестировать работу кода в условиях ошибки, рассмотрите возможность использования [функции перезагрузки](cache-administration.md#reboot). Перезагрузка позволяет увидеть, как нестабильной работе подключений влияет на приложение.

## <a name="performance-testing"></a>Тестирование производительности
 * **Начните с использования `redis-benchmark.exe`** , чтобы получить представление о возможной пропускной способности и задержке перед написанием собственных тестов производительности.  Redis. документацию по производительности можно [найти здесь](https://redis.io/topics/benchmarks).  Обратите внимание, что Redis-testing не поддерживает SSL, поэтому перед выполнением теста необходимо [включить порт без SSL на портале](cache-configure.md#access-ports) .  [Совместимую с Windows версию Redis-Benchmark. exe можно найти здесь.](https://github.com/MSOpenTech/redis/releases)
 * Клиентская виртуальная машина, используемая для тестирования, должна находиться **в том же регионе** , что и экземпляр кэша Redis.
 * **Мы рекомендуем использовать серию виртуальных машин Dv2** для клиента, так как они имеют лучшее оборудование и дают лучшие результаты.
 * Убедитесь, что используемая виртуальная машина клиента имеет **по крайней мере столько вычислений и пропускной способности* , как тестируемый кэш. 
 * **Включите VRSS** на клиентском компьютере, если вы используете Windows.  [Щелкните здесь, чтобы узнать больше](https://technet.microsoft.com/library/dn383582(v=ws.11).aspx).  Пример скрипта PowerShell:
     >PowerShell-ExecutionPolicy без ограничений Enable-Нетадаптеррсс-Name (Get-NetAdapter). Безымян 
     
 * **Рассмотрите возможность использования экземпляров Redis уровня Premium**.  Эти размеры кэша будут иметь лучшую сетевую задержку и пропускную способность, так как они работают на более эффективном оборудовании как для ЦП, так и для сети.
 
     > [!NOTE]
     > Наши наблюдаемые результаты производительности [публикуются здесь](cache-faq.md#azure-cache-for-redis-performance) для справки.   Кроме того, имейте в виду, что SSL/TLS добавляет некоторые дополнительные издержки, поэтому при использовании шифрования транспорта может возникнуть разная задержка и (или) пропускная способность.
 
### <a name="redis-benchmark-examples"></a>Redis — примеры производительности
**Настройка перед тестированием**. Подготовьте экземпляр кэша с данными, необходимыми для команд проверки задержки и пропускной способности, перечисленных ниже.
> Redis-Benchmark. exe-h yourcache.redis.cache.windows.net-a Йоуракцесскэй-t SET-n 10-d 1024 

**Проверка задержки**: проверка запросов GET с помощью полезных данных 1000.
> Redis-Benchmark. exe-h yourcache.redis.cache.windows.net-a Йоуракцесскэй-t GET-d 1024-P 50-c 4

**Проверка пропускной способности:** Конвейерные запросы GET с полезной нагрузкой 1000.
> redis-benchmark.exe -h yourcache.redis.cache.windows.net -a yourAccesskey -t  GET -n 1000000 -d 1024 -P 50  -c 50
