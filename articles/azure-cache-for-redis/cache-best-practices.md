---
title: Рекомендации по использованию Кэша Azure для Redis
description: Узнайте, как эффективно использовать кэш Azure для Redis, следуя этим рекомендациям.
author: joncole
ms.service: cache
ms.topic: conceptual
ms.date: 01/06/2020
ms.author: joncole
ms.openlocfilehash: 105a3996753a1d1c2d71846cc8bad574e4498acf
ms.sourcegitcommit: efefce53f1b75e5d90e27d3fd3719e146983a780
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2020
ms.locfileid: "80478608"
---
# <a name="best-practices-for-azure-cache-for-redis"></a>Рекомендации по использованию Кэша Azure для Redis 
Следуя этим рекомендациям, вы можете обеспечить максимальную производительность и экономичное использование кэша Azure для экземпляра Redis.

## <a name="configuration-and-concepts"></a>Конфигурация и основные понятия
 * **Используйте стандартный или премиум-уровень для производственных систем.**  Базовый уровень представляет собой единую систему узлов без репликации данных и без SLA. Кроме того, используйте по крайней мере кэш C1.  Кэши C0 предназначены для простых сценариев dev/test, так как они имеют общий процессор, мало памяти и подвержены проблемам "шумного соседа".

 * **Помните, что Redis — это хранилище данных в памяти.**  [В этой статье](cache-troubleshoot-data-loss.md) описаны некоторые сценарии, в которых может произойти потеря данных.

 * **Разработайте свою систему таким образом, что она может обрабатывать соединения blips** [из-за исправления и неудачи.](cache-failover.md)

 * **Настроите [настройки, зарезервированные на максима,](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) чтобы улучшить отзывчивость системы** в условиях давления памяти.  Достаточная настройка резервирования особенно важна для рабочих нагрузок с записью или при хранении больших значений (100 кБ или более) в Redis. Вы должны начать с 10% от размера кэша и увеличить этот процент, если у вас есть записи тяжелых нагрузок.

 * **Redis лучше всего работает с меньшими значениями,** поэтому рассмотрите возможность измельчения больших данных в несколько ключей.  В [этом обсуждении Redis](https://stackoverflow.com/questions/55517224/what-is-the-ideal-value-size-range-for-redis-is-100kb-too-large/), некоторые соображения перечислены, что вы должны рассмотреть тщательно.  Прочитайте [эту статью](cache-troubleshoot-client.md#large-request-or-response-size) , чтобы ознакомиться с примером проблемы, вызванной большими значениями.

 * **Найдите экземпляр кэша и приложение в одном регионе.**  Подключение к кэшу в другом регионе может увеличить задержку и значительно снизить надежность.  Хотя вы можете подключиться из-за пределов Azure, он не рекомендуется *особенно при использовании Redis в качестве кэша*.  Если вы используете Redis как просто магазин ключей/ценностей, задержка может не быть главной проблемой. 

 * **Повторное использование соединений.**  Создание новых соединений обходится дорого и увеличивает задержку, поэтому максимально ежеразить соединения повторно. Если вы решили создать новые соединения, не забудьте закрыть старые соединения, прежде чем выпустить их (даже в управляемых языках памяти, таких как .NET или Java).

 * **Напередите клиентскую библиотеку, чтобы использовать *время подключения* не менее 15 секунд,** что дает системе время для подключения даже при более высоких условиях процессора.  Небольшое значение тайм-аута соединения не гарантирует, что соединение установлено в этот промежуток времени.  Если что-то пойдет не так (высокий клиентский процессор, высокопроизводительный процессор и так далее), то короткое значение тайм-аута соединения приведет к сбою в работе соединения. Такое поведение часто ухудшает плохую ситуацию.  Вместо того, чтобы помочь, более короткие тайм-ауты усугубляют проблему, заставляя систему перезапустить процесс повторного подключения, что может привести к *сбою в подключении >-> цикле повторной попытки.* Обычно мы рекомендуем вам оставить время подключения на 15 секунд или выше. Лучше, чтобы ваша попытка подключения успеха после 15 или 20 секунд, чем иметь его быстро не только повторить. Такой цикл повтора может привести к сражени дольше, чем если вы позволите системе просто занять больше времени на начальном этапе.  
     > [!NOTE]
     > Это руководство специфично для *попытки подключения* и не связано со временем, когда вы готовы ждать *операции,* такой как GET или SET.
 
 * **Избегайте дорогостоящих операций** - Некоторые операции Redis, такие как команда [KEYS,](https://redis.io/commands/keys) *стоят очень* дорого и следует избегать.  Для получения дополнительной информации [long-running commands](cache-troubleshoot-server.md#long-running-commands) см.

 * **Используйте шифрование TLS** - Кэш Azure для Redis требует шифрованных сообщений TLS по умолчанию.  В настоящее время поддерживаются версии TLS 1.0, 1.1 и 1.2.  Тем не менее, TLS 1.0 и 1.1 находятся на пути к амортизации в масштабах всей отрасли, поэтому используйте TLS 1.2, если это вообще возможно.  Если ваша клиентская библиотека или инструмент не поддерживает TLS, то включение незашифрованных подключений может быть сделано [через портал Azure](cache-configure.md#access-ports) или [AI управления.](https://docs.microsoft.com/rest/api/redis/redis/update)  В таких случаях, когда зашифрованные соединения невозможны, рекомендуется поместить кэш и клиентское приложение в виртуальную сеть.  Для получения дополнительной информации о том, какие порты [table](cache-how-to-premium-vnet.md#outbound-port-requirements)используются в сценарии виртуального кэша сети, см.
 
## <a name="memory-management"></a>Управление памятью
Есть несколько вещей, связанных с использованием памяти в экземпляре сервера Redis, которые вы можете рассмотреть.  Вот некоторые из них:

 * **Выберите [политику выселения,](https://redis.io/topics/lru-cache) которая работает для вашего приложения.**  Политика по умолчанию для Azure Redis является *нестабильной,* что означает, что только ключи с набором значений TTL будут иметь право на выселение.  Если ключи не имеют значения TTL, система не будет выселять ключи.  Если вы хотите, чтобы система позволила выселить любой ключ, если под давлением памяти, то вы можете рассмотреть политику *allkeys-lru.*

 * **Установите значение истечения срока действия на ключах.**  Истечение срока действия удалит ключи упреждающе, а не будет ждать, пока не появится давление памяти.  Когда выселение делает удар из-за давления памяти, это может привести к дополнительной нагрузке на сервере.  Для получения дополнительной информации смотрите документацию для команд [EXPIRE](https://redis.io/commands/expire) и [EXPIREAT.](https://redis.io/commands/expireat)
 
## <a name="client-library-specific-guidance"></a>Конкретная рекомендация библиотеки клиента
 * [StackExchange.Redis (.NET)](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-stackexchange-redis-md)
 * [Java - Какой клиент я должен использовать?](https://gist.github.com/warrenzhu25/1beb02a09b6afd41dff2c27c53918ce7#file-azure-redis-java-best-practices-md)
 * [Салат (Ява)](https://gist.github.com/warrenzhu25/181ccac7fa70411f7eb72aff23aa8a6a#file-azure-redis-lettuce-best-practices-md)
 * [Джедаи (Ява)](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-java-jedis-md)
 * [Node.js](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-node-js-md)
 * [PHP](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-php-md)
 * [Asp.Net сессии государственный поставщик](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-session-state-provider-md)


## <a name="when-is-it-safe-to-retry"></a>Когда можно было бы повторить попытку?
К сожалению, нет простого ответа.  Каждое приложение должно решить, какие операции можно повторить, а какие нет.  Каждая операция имеет различные требования и взаимоключевые зависимости.  Вот некоторые вещи, которые вы могли бы рассмотреть:

 * Вы можете получить ошибки на стороне клиента, даже если Redis успешно запустил команду, которая вы попросили ее запустить.  Пример:
     - Тайм-ауты — это концепция клиентской стороны.  Если операция достигла сервера, сервер запустит команду, даже если клиент откажется от ожидания.  
     - При возникновении ошибки на подключении к розетке невозможно узнать, действительно ли операция выполняется на сервере.  Например, ошибка соединения может произойти после обработки запроса сервером, но до того, как клиент получит ответ.
 *  Как реагирует мое приложение, если я случайно запускаю одну и ту же операцию дважды?  Например, что, если я приравнять integer дважды, а не один раз?  Является ли мое приложение письменной форме на тот же ключ из нескольких мест?  Что делать, если моя логика повтора перезаписывает значение, установленное какой-либо другой частью моего приложения?

Если вы хотите проверить, как ваш код работает в условиях ошибки, рассмотрите возможность использования [функции Перезагрузки.](cache-administration.md#reboot) Перезагрузка позволяет увидеть, как всплески соединения влияют на ваше приложение.

## <a name="performance-testing"></a>Тестирование производительности
 * **Начните `redis-benchmark.exe` с использования,** чтобы почувствовать возможную пропускную/ задержку перед написанием собственных тестов perf.  Redis-бенчмарк документации можно [найти здесь](https://redis.io/topics/benchmarks).  Обратите внимание, что Redis-benchmark не поддерживает TLS, поэтому перед запуском теста вам придется [включить порт Non-TLS через портал.](cache-configure.md#access-ports)  [Окна совместимая версия redis-benchmark.exe можно найти здесь](https://github.com/MSOpenTech/redis/releases)
 * Клиент VM, используемый для тестирования, должен находиться **в том же регионе,** что и экземпляр кэша Redis.
 * **Мы рекомендуем использовать Dv2 VM серии** для вашего клиента, поскольку они имеют лучшее оборудование и даст лучшие результаты.
 * Убедитесь, что клиент VM, который вы используете, имеет*по крайней мере столько вычислений и пропускной способности,* как кэш тестируется. 
 * **Включите VRSS** на клиентской машине, если вы находитесь на Windows.  [Щелкните здесь, чтобы узнать больше](https://technet.microsoft.com/library/dn383582(v=ws.11).aspx).  Пример сценария powershell:
     >PowerShell -ИсполнениеПолитика Неограниченное включить-NetAdapterRSS-Имя ( Get-NetAdapter). Имя 
     
 * **Рассмотрите возможность использования экземпляров Premium tier Redis.**  Эти размеры кэша будут иметь лучшую задержку сети и пропускную вычисляемость, потому что они работают на лучшем оборудовании как для процессора, так и для сети.
 
     > [!NOTE]
     > Наши наблюдаемые результаты производительности [публикуются здесь](cache-faq.md#azure-cache-for-redis-performance) для вашей справки.   Кроме того, имейте в виду, что SSL / TLS добавляет некоторые накладные расходы, так что вы можете получить различные опоздания и / или пропускной способности, если вы используете транспортное шифрование.
 
### <a name="redis-benchmark-examples"></a>Примеры Redis-Benchmark
**Предтестовая настройка**: Подготовьте экземпляр кэша с данными, необходимыми для команд тестирования задержки и пропускной их пропускной четырбы, перечисленных ниже.
> redis-benchmark.exe -h yourcache.redis.cache.windows.net -a yourAccesskey -t SET -n 10 -d 1024 

**Для проверки задержки**: Тест-запросы GET с помощью полезной нагрузки 1k.
> redis-benchmark.exe -h yourcache.redis.cache.windows.net -a yourAccesskey -t GET -d 1024 -P 50 -c 4

**Для тестирования пропускной всей проходики:** Pipelined GET запросы с 1k полезной нагрузки.
> redis-benchmark.exe -h yourcache.redis.cache.windows.net -a yourAccesskey -t GET -n 1000000 -d 1024 -P 50 -c 50
