---
title: Рекомендации по использованию кэша Azure для Redis
description: Узнайте, как эффективно использовать кэш Azure для Redis, следуя этим рекомендациям.
author: joncole
ms.service: cache
ms.topic: conceptual
ms.date: 06/21/2019
ms.author: joncole
ms.openlocfilehash: 136c29245c63b2f2feed79a10a09fb57a379736f
ms.sourcegitcommit: 5a8c65d7420daee9667660d560be9d77fa93e9c9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2019
ms.locfileid: "74122394"
---
# <a name="best-practices-for-azure-cache-for-redis"></a>Рекомендации по использованию кэша Azure для Redis 
Следуя этим рекомендациям, вы сможете повысить производительность и экономичное использование кэша Azure для экземпляра Redis.

## <a name="configuration-and-concepts"></a>Конфигурация и основные понятия
 * **Используйте уровень "Стандартный" или "Премиум" для рабочих систем.**  Уровень "базовый" — это система с одним узлом без репликации данных и соглашения об уровне обслуживания. Кроме того, используйте по крайней мере кэш C1.  Кэши C0 предназначены для простых сценариев разработки и тестирования, так как они имеют общее ядро ЦП, небольшое количество памяти и подвержены проблемам с помехами в связи с соседями.

 * **Помните, что Redis — это хранилище данных в памяти.**  В [этой статье](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) описываются некоторые сценарии, в которых могут возникать потери данных.

 * **Разрабатывайте систему так, чтобы она могла управлять подключением нестабильной работе** [из-за исправлений и отработки отказа](https://gist.github.com/JonCole/317fe03805d5802e31cfa37e646e419d#file-azureredis-patchingexplained-md).

 * **Настройте [параметр MaxMemory-reserved](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , чтобы повысить скорость реагирования системы** при условиях нехватки памяти.  Этот параметр особенно важен для рабочих нагрузок с интенсивной записью или при хранении больших значений (100 КБ или более) в Redis. Рекомендуется начать с 10% от размера кэша, а затем увеличить процент при наличии загрузок с интенсивной записью.

 * **Redis работает наилучшим образом с меньшими значениями**, поэтому рассмотрите возможность разбить данные большего размера на несколько ключей.  В [этом Redisм обсуждении](https://stackoverflow.com/questions/55517224/what-is-the-ideal-value-size-range-for-redis-is-100kb-too-large/)приводятся некоторые соображения, которые следует тщательно рассмотреть.  Прочитайте [эту статью](cache-troubleshoot-client.md#large-request-or-response-size) , чтобы ознакомиться с примером проблемы, вызванной большими значениями.

 * **Нахождение экземпляра кэша и приложения в одном регионе.**  Подключение к кэшу в другом регионе может значительно увеличить задержку и снизить надежность.  Хотя вы можете подключаться извне Azure, не рекомендуется, *особенно при использовании Redis в качестве кэша*.  Если вы используете Redis в качестве простого хранилища ключей и значений, то задержка может не быть основной задачей. 

 * **Повторное использование подключений** . Создание новых подключений занимает много ресурсов и увеличивает задержку, поэтому повторно используйте подключения. Если вы решили создать новые подключения, обязательно закройте старые подключения, прежде чем выпустить их (даже в управляемых языках памяти, таких как .NET или Java).

 * **Настройте клиентскую библиотеку на использование *времени ожидания подключения* не менее 15 секунд**, чтобы системное время подключаться даже при более высоких условиях ЦП.  Значение времени ожидания небольшого соединения не гарантирует, что подключение будет установлено в течение этого времени.  Если что-то пойдет не так (высокий клиентский ЦП, высокий серверный ЦП и т. д.), то попытка подключения приведет к сбою соединения. Такое поведение часто делает серьезную ситуацию хуже.  Вместо того, чтобы сократить время ожидания, усилиться проблему, переведя систему на перезапуск процесса повторного подключения, что может привести к циклу *повторных попыток подключения > сбоя >* . Обычно рекомендуется оставлять время ожидания подключения через 15 секунд или выше. Лучше допустить успешную попытку подключения через 15 или 20 секунд, по сравнению с тем, что он не сможет быстро выполнить повторные попытки. Такой цикл повторных попыток может привести к тому, что время простоя будет больше, чем если бы вы позволяли системе получить более длинные первоначальные возможности.  
     > [!NOTE]
     > Это руководство относится к *попыткам подключения* и не связано с тем временем, когда вы ожидаете завершения *операции* , например Get или Set.
 
 * **Старайтесь не использовать дорогостоящие операции** . Некоторые Redis операции, такие как команды [Keys](https://redis.io/commands/keys) , являются *очень* ресурсоемкими, и их следует избегать.  Дополнительные сведения см. в разделе некоторые рекомендации по [работе с длительными командами](cache-troubleshoot-server.md#long-running-commands) .

 * **Использование шифрования TLS** . по умолчанию для кэша Azure для REDIS требуется TLS-шифрование сообщений.  В настоящее время поддерживаются версии TLS 1,0, 1,1 и 1,2.  Однако протоколы TLS 1,0 и 1,1 — это путь к устаревшей отрасли, поэтому по возможности используйте TLS 1,2.  Если клиентская библиотека или средство не поддерживает протокол TLS, то включить незашифрованные соединения можно с [помощью портал Azure](cache-configure.md#access-ports) или [API управления](https://docs.microsoft.com/rest/api/redis/redis/update).  В таких случаях, когда зашифрованные подключения невозможны, рекомендуется разместить кэш и клиентское приложение в виртуальной сети.  Дополнительные сведения о том, какие порты используются для 
 
## <a name="memory-management"></a>Управление памятью
Существует несколько моментов, связанных с использованием памяти в экземпляре сервера Redis, который может потребоваться рассмотреть.  Вот несколько:

 * **Выберите [политику вытеснения](https://redis.io/topics/lru-cache) , которая подходит для вашего приложения.**  Политика по умолчанию для Azure Redis — это *volatile-LRU*, что означает, что только ключи с установленным значением TTL будут доступны для вытеснения.  Если ключи не имеют значения TTL, система не будет выключать никакие ключи.  Если вы хотите, чтобы система могла удалить любой ключ в случае нехватки памяти, можно рассмотреть политику *AllKeys-LRU* .

 * **Задайте значение срока действия ключей.**  При этом ключи будут удалены заранее, а не ожидать, пока не найдется нехватка памяти.  Если вытеснение происходит из-за нехватки памяти, это может привести к дополнительной нагрузке на сервер.  Дополнительные сведения см. в документации по командам [Expires](https://redis.io/commands/expire) и [експиреат](https://redis.io/commands/expireat) .
 
## <a name="client-library-specific-guidance"></a>Специальные рекомендации для клиентской библиотеки
 * [StackExchange. Redis (.NET)](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-stackexchange-redis-md)
 * [Java — какой клиент следует использовать?](https://gist.github.com/warrenzhu25/1beb02a09b6afd41dff2c27c53918ce7#file-azure-redis-java-best-practices-md)
 * [Салат (Java)](https://gist.github.com/warrenzhu25/181ccac7fa70411f7eb72aff23aa8a6a#file-azure-redis-lettuce-best-practices-md)
 * [Jedis (Java)](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-java-jedis-md)
 * [Node.js](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-node-js-md)
 * [PHP](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-php-md)
 * [Поставщик состояния сеанса Asp.Net](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-session-state-provider-md)


## <a name="when-is-it-safe-to-retry"></a>Когда можно попробовать повторить попытку?
Увы, простого ответа нет.  Каждое приложение должно решить, какие операции можно повторить, а какие — нет.  Каждая операция имеет разные требования и межключные зависимости.  Ниже приведены некоторые моменты, которые можно учитывать.

 * Ошибки на стороне клиента можно получить, несмотря на то, что Redis успешно выполнил команду, которая запросила ее запуск.  Например,
     - Время ожидания является концепцией на стороне клиента.  Если операция достигла сервера, сервер выполнит команду, даже если клиент предоставит ожидание.  
     - При возникновении ошибки в подключении к сокету невозможно выяснить, реально ли выполнялась операция на сервере.  Например, ошибка соединения может произойти после обработки запроса сервером, но до получения ответа клиентом.
 *  Как работает приложение, если случайно выполнялась та же операция дважды?  Например, что делать, если увеличить целое число дважды, а не только один раз?  Будет ли приложение выполнять запись в один и тот же ключ из нескольких мест?  Что если логика повторных попыток перезаписывает значение, заданное какой-либо другой частью моего приложения?

Если вы хотите протестировать работу кода в условиях ошибки, рассмотрите возможность использования [функции перезагрузки](cache-administration.md#reboot). Это позволяет увидеть, как нестабильной работе подключений влияет на приложение.

## <a name="performance-testing"></a>Тестирование производительности
 * **Начните с использования `redis-benchmark.exe`** , чтобы получить представление о возможной пропускной способности и задержке перед написанием собственных тестов производительности.  Redis. документацию по производительности можно [найти здесь](https://redis.io/topics/benchmarks).  Обратите внимание, что Redis-testing не поддерживает SSL, поэтому перед выполнением теста необходимо [включить порт без SSL на портале](cache-configure.md#access-ports) .  [Совместимую с Windows версию Redis-Benchmark. exe можно найти здесь.](https://github.com/MSOpenTech/redis/releases)
 * Клиентская виртуальная машина, используемая для тестирования, должна находиться **в том же регионе** , что и экземпляр кэша Redis.
 * **Мы рекомендуем использовать серию виртуальных машин Dv2** для клиента, так как они имеют лучшее оборудование и дают лучшие результаты.
 * Убедитесь, что используемая виртуальная машина клиента имеет **по крайней мере столько вычислений и пропускной способности* , как тестируемый кэш. 
 * **Включите VRSS** на клиентском компьютере, если вы используете Windows.  [Щелкните здесь, чтобы узнать больше](https://technet.microsoft.com/library/dn383582(v=ws.11).aspx).  Пример скрипта PowerShell:
     >PowerShell-ExecutionPolicy без ограничений Enable-Нетадаптеррсс-Name (Get-NetAdapter). Безымян 
     
 * **Рассмотрите возможность использования экземпляров Redis уровня Premium**.  Эти размеры кэша будут иметь лучшую сетевую задержку и пропускную способность, так как они работают на более эффективном оборудовании как для ЦП, так и для сети.
 
     > [!NOTE]
     > Наши наблюдаемые результаты производительности [публикуются здесь](cache-faq.md#azure-cache-for-redis-performance) для справки.   Кроме того, имейте в виду, что SSL/TLS добавляет некоторые дополнительные издержки, поэтому при использовании шифрования транспорта может возникнуть разная задержка и (или) пропускная способность.
 
### <a name="redis-benchmark-examples"></a>Redis — примеры производительности
**Настройка перед тестированием**. при этом будет подготовлен экземпляр кэша с данными, необходимыми для команд проверки задержки и пропускной способности, перечисленных ниже.
> Redis-Benchmark. exe-h yourcache.redis.cache.windows.net-a Йоуракцесскэй-t SET-n 10-d 1024 

**Чтобы проверить задержку**, выполните проверку запросов GET с помощью полезных данных 1000.
> Redis-Benchmark. exe-h yourcache.redis.cache.windows.net-a Йоуракцесскэй-t GET-d 1024-P 50-c 4

**Проверка пропускной способности:** При этом используются конвейерные запросы GET с полезной нагрузкой 1000.
> redis-benchmark.exe -h yourcache.redis.cache.windows.net -a yourAccesskey -t  GET -n 1000000 -d 1024 -P 50  -c 50
