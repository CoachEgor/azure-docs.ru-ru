---
title: Устранение неполадок с Кэшем Azure для Redis на стороне клиента
description: Узнайте, как решить общие проблемы на стороне клиента с Azure Cache для Redis, такие как давление памяти клиента Redis, взрыв трафика, высокий процессор, ограниченная пропускная способность, большие запросы или большой размер ответа.
author: yegu-ms
ms.author: yegu
ms.service: cache
ms.topic: troubleshooting
ms.date: 10/18/2019
ms.openlocfilehash: ace953fcb278604cb64eef463753f0f2622d3d24
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2020
ms.locfileid: "79277951"
---
# <a name="troubleshoot-azure-cache-for-redis-client-side-issues"></a>Устранение неполадок с Кэшем Azure для Redis на стороне клиента

В этом разделе рассматриваются проблемы устранения неполадок, возникающие из-за состояния клиента Redis, которое использует ваше приложение.

- [Давление памяти на клиента Redis](#memory-pressure-on-redis-client)
- [Взрыв трафика](#traffic-burst)
- [Высокий коэффициент загрузки ЦП клиента](#high-client-cpu-usage)
- [Ограничение пропускной способности на стороне клиента](#client-side-bandwidth-limitation)
- [Большой размер запроса или ответа](#large-request-or-response-size)

## <a name="memory-pressure-on-redis-client"></a>Давление памяти на клиента Redis

Давление памяти на клиентскую машину приводит к всевозможным проблемам с производительностью, которые могут задержать обработку ответов из кэша. При попадании давления памяти система может переходить к диску. Именно _ошибки страниц_ существенно замедляют работу системы.

Для обнаружения давления памяти на клиента:

- Мониторинг использования памяти на машине, чтобы убедиться, что она не превышает доступную память.
- Мониторинг счетчика `Page Faults/Sec` производительности клиента. Во время нормальной работы большинство систем имеют некоторые ошибки страницы. Спайки в сбоях страницы, соответствующие тайм-аутам запроса, могут указывать на давление памяти.

Высокое давление памяти на клиента можно смягчить несколькими способами:

- Погрузитесь в шаблоны использования памяти, чтобы уменьшить потребление памяти на клиенте.
- Обновите ваш клиент VM до большего размера с большей памятью.

## <a name="traffic-burst"></a>Взрыв трафика

Увеличение трафика в сочетании с недостаточными параметрами `ThreadPool` может привести к возникновению задержек обработки данных, отправленных сервером Redis, но еще не использованных на стороне клиента.

Мониторинг того, как ваша `ThreadPool` статистика меняется с [течением времени, используя пример. `ThreadPoolLogger` ](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs) Вы можете `TimeoutException` использовать сообщения от StackExchange.Redis, как ниже, для дальнейшего расследования:

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0,
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

В предыдущем исключении есть несколько интересных вопросов:

- Обратите внимание, что в разделах `IOCP` и `WORKER` значение `Busy` больше, чем значение `Min`. Эта разница `ThreadPool` означает, что ваши настройки нуждаются в настройках.
- Кроме того, обратите внимание на `in: 64221`. Это значение указывает на то, что 64 211 байтов были получены на слое ядра клиента, но не были прочитаны приложением. Это различие обычно означает, что приложение (например, StackExchange.Redis) не считывает данные из сети так же быстро, как сервер отправляет их вам.

Можно [настроить `ThreadPool` настройки,](cache-faq.md#important-details-about-threadpool-growth) чтобы убедиться, что пул потоков быстро масштабируется в сценариях лопаев.

## <a name="high-client-cpu-usage"></a>Высокий коэффициент загрузки ЦП клиента

Высокое использование процессора клиента означает, что система не может идти в ногу с работой, которую она попросила сделать. Несмотря на то, что кэш быстро отправил ответ, клиент может не обработать ответ своевременно.

Мониторинг общесистемного использования процессора клиента с помощью метрик, доступных на портале Azure или с помощью счетчиков производительности на машине. Будьте осторожны, чтобы не контролировать *процесс* процессора, потому что один процесс может иметь низкое использование процессора, но общесистемный процессор может быть высоким. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания. Высокий процессор может `in: XXX` также вызывать `TimeoutException` высокие значения в сообщениях об ошибках, описанных в разделе ["Взрыв трафика".](#traffic-burst)

> [!NOTE]
> В StackExchange.Redis 1.1.603 и более поздней версии в сообщениях об ошибках `TimeoutException` содержится метрика `local-cpu`. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
>

Чтобы смягчить высокое использование процессора клиента:

- Исследуйте, что вызывает шипы процессора.
- Обновите клиента до большего размера VM с большей емкостью процессора.

## <a name="client-side-bandwidth-limitation"></a>Ограничение пропускной способности на стороне клиента

В зависимости от архитектуры клиентских компьютеров на них применяются разные ограничения доступности пропускной способности сети. Если клиент превышает доступную пропускную способность за счет перегрузки пропускной способности сети, то данные не обрабатываются на стороне клиента так же быстро, как сервер отправляет его. Это может привести к превышению времени ожидания.

Мониторинг того, как изменяется использование пропускной способности с течением времени [с помощью `BandwidthLogger`примера. ](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs) В некоторых окружениях с ограниченными разрешениями (например, веб-сайты Azure) этот код может не удастся выполнить.

Чтобы уменьшить, уменьшить потребление пропускной способности сети или увеличить размер клиента VM до одного с большей пропускной способностью сети.

## <a name="large-request-or-response-size"></a>Большой размер запроса или ответа

Из-за большого размера запроса или ответа может истекать время ожидания. В качестве примера предположим, что значение тайм-аута, настроенное на клиенте, составляет 1 секунду. Приложение одновременно запрашивает два ключа (например, А и Б) в одном физическом сетевом подключении. Большинство клиентов поддерживают запрос «pipelining», где оба запроса 'A' и 'B' отправляются один за другим, не дожидаясь их ответов. Сервер отправляет ответы в том же порядке. Если ответ 'A' большой, он может съесть большую часть тайм-аута для последующих запросов.

В следующем примере запросы 'A' и 'B' быстро отправляются на сервер. Сервер быстро начинает отправлять ответы 'A' и 'B'. Из-за времени передачи данных, ответ 'B' должен ждать за время ответа 'A', даже если сервер ответил быстро.

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)

Запрос или ответ сложно измерить. Можно инструментировать код клиента для отслеживания больших запросов и ответов.

Резолюции для больших размеров ответов разнообразны, но включают в себя:

1. Оптимизируйте приложение для большого количества небольших значений, а не для нескольких больших значений.
    - Поэтому рекомендуется разбить данные на небольшие связанные части.
    - Смотрите сообщение [Каков идеальный диапазон размеров значения для Redis? Является ли 100 КБ слишком большим?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) для получения подробной информации о том, почему рекомендованы меньшие значения.
1. Увеличьте размер вашего VM, чтобы получить более высокую пропускную способность
    - Большая пропускная способность вашего клиента или сервера VM может сократить время передачи данных для более широких ответов.
    - Сравните текущее использование сети на обеих машинах с пределами текущего размера VM. Больше пропускной способности только на сервере или только на клиенте может быть недостаточно.
1. Увеличьте количество объектов соединения, которые использует приложение.
    - Используйте круговой подход для запросов на различные объекты соединения.

## <a name="additional-information"></a>Дополнительные сведения

- [Устранение неполадок с Кэшем Azure для Redis на стороне сервера](cache-troubleshoot-server.md)
- [Как измерить и протестировать производительность моего кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
