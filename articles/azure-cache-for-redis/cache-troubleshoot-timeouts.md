---
title: Устранение неполадок с временем ожидания Кэша Azure для Redis
description: Узнайте, как решить общие проблемы тайм-аута с Azure Cache для Redis, такие как исправление сервера Redis и исключения тайм-аута StackExchange.Redis.
author: yegu-ms
ms.author: yegu
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.openlocfilehash: 4301a55e3f5ea5b445ef1540ee59d1b5c28ca0ed
ms.sourcegitcommit: ae3d707f1fe68ba5d7d206be1ca82958f12751e8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/10/2020
ms.locfileid: "81010823"
---
# <a name="troubleshoot-azure-cache-for-redis-timeouts"></a>Устранение неполадок с временем ожидания Кэша Azure для Redis

В этом разделе рассматриваются проблемы тайм-аута устранения неполадок, возникающие при подключении к Кэшу Azure для Redis.

- [Исправление сервера Redis](#redis-server-patching)
- [Исключения времени ожидания StackExchange.Redis](#stackexchangeredis-timeout-exceptions)

> [!NOTE]
> Шаги по устранению проблем в этой статье также включают в себя указания по выполнению команд Redis и мониторингу различных метрик производительности. Дополнительные сведения и указания см. в разделе [Дополнительные сведения](#additional-information).
>

## <a name="redis-server-patching"></a>Исправление сервера Redis

Azure Cache for Redis регулярно обновляет свое серверное программное обеспечение как часть функциональности управляемой службы, которую он предоставляет. Эта [исправления деятельности](cache-failover.md) происходит в основном за сценой. Во время сбоев при исправлении серверных узлов Redis клиенты Redis, подключенные к этим узлам, могут испытывать временные тайм-ауты, поскольку соединения переключаются между этими узлами. Узнайте, [как сбой влияет на мое клиентское приложение](cache-failover.md#how-does-a-failover-affect-my-client-application) для получения дополнительной информации о том, какие побочные эффекты исправления могут иметь на вашем приложении и как вы можете улучшить его обработку исправления событий.

## <a name="stackexchangeredis-timeout-exceptions"></a>Исключения времени ожидания StackExchange.Redis

StackExchange.Redis использует настройку `synctimeout` конфигурации, названную для синхронных операций со значением по умолчанию 1000 мс. Если синхронный вызов не выполняется в это время, клиент StackExchange.Redis бросает ошибку тайм-аута, похожую на следующий пример:

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)

В этом сообщении об ошибке содержатся метрики, которые помогут вам определить причину и возможное решение проблемы. В следующей таблице содержатся сведения о метриках сообщения об ошибке.

| Метрики сообщения об ошибке | Сведения |
| --- | --- |
| inst |Указывает, что за последний интервал времени инициировано 0 команд. |
| mgr |Менеджер розетки делает, `socket.select`что означает, что он просит ОС, чтобы указать розетку, которая что-то делать. Читатель не активно читает из сети, потому что он не думает, что есть что-то делать |
| очередь |Указывает, что выполняется 73 операции. |
| qu |6 из незавершенных операций находятся в неотправленной очереди и еще не были записаны в исходящий сеть |
| qs |67 из незавершенных операций были отправлены на сервер, но ответ еще не доступен. Ответ может быть таким: `Not yet sent by the server` или `sent by the server but not yet processed by the client.` |
| qc |0 из незавершенных операций видели ответы, но еще не были помечены как полные, потому что они ждут на цикл завершения |
| wr |Там в активном писателе (имеется в виду 6 неотправленных запросов не игнорируются) байты / активные авторы |
| in |Указывает, что отсутствуют активные модули чтения и нет байтов для чтения для bytes/activereaders сетевой карты. |

Вы можете использовать следующие шаги для изучения возможных причин.

1. В качестве наилучшей практики убедитесь, что вы используете следующий шаблон для подключения при использовании клиента StackExchange.Redis.

    ```csharp
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");

    });

    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ```

    Дополнительные сведения см. в разделе о [подключении к кэшу с использованием StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

1. Убедитесь, что ваш сервер и клиентское приложение находятся в одном регионе Azure. Например, вы можете получать тайм-ауты, когда ваш кэш находится в Восточной части США, `synctimeout` но клиент находится в Западной ЧАСТИ США, и запрос не выполняется в интервале, или вы можете получать тайм-ауты при отладке с локальной машины разработки. 

    Кэш и клиент настоятельно рекомендуется размещать в одном и том же регионе Azure. Если используются межрегиональные вызовы, необходимо увеличить значение интервала `synctimeout` по умолчанию (1000 мс), добавив в строку подключения свойство `synctimeout`. В следующем примере показан фрагмент строки соединения для StackExchange.Redis, предоставленная Azure Cache для Redis с `synctimeout` 2000 мс.

        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
1. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
1. Если ваши запросы связаны ограничениями пропускной способности сервера или клиента, их выполнение занимает больше времени, что может привести к тайм-аутам. Чтобы узнать, связано ли время из-за [Server-side bandwidth limitation](cache-troubleshoot-server.md#server-side-bandwidth-limitation)пропускной способности сети на сервере, см. Чтобы узнать, связано ли время из-за пропускной способности клиентской сети, [см.](cache-troubleshoot-client.md#client-side-bandwidth-limitation)
1. Используются ли ресурсы ЦП на сервере или клиенте?

   - Проверьте, связаны ли вы процессором на вашего клиента. Высокий процессор может привести к тому, `synctimeout` что запрос не будет обработан в интервале и привести к тайм-ауту запроса. Переход к большему размеру клиента или распределение нагрузки могут помочь в управлении этой проблемой.
   - Проверьте, связаны ли вы процессором на сервере, отслеживая [метрика кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)процессора. Запросы, поступающие в то время как Redis является CPU связаны может привести к этим запросам тайм-аут. Для устранения этого состояния можно распределить нагрузку по нескольким осколки в кэше премиум-класса или обновиться до большего размера или ценового уровня. Для получения дополнительной [Server-side bandwidth limitation](cache-troubleshoot-server.md#server-side-bandwidth-limitation)информации см.
1. Занимает ли выполнение команд на сервере слишком много времени? Долгосрочные команды, обработка на redis-сервере, может привести к тайм-аутам. Для получения дополнительной информации о [Long-running commands](cache-troubleshoot-server.md#long-running-commands)долгосрочных командах см. Вы можете подключиться к кэшу Azure для экземпляра Redis с помощью клиента Redis-cli или [консоли Redis.](cache-configure.md#redis-console) Затем запустите команду [SLOWLOG,](https://redis.io/commands/slowlog) чтобы увидеть, есть ли запросы медленнее, чем ожидалось. Сервер Redis и StackExchange.Redis оптимизированы для обработки большого количества небольших запросов, а не нескольких больших запросов. Чтобы повысить их производительность, рекомендуется разбить данные на небольшие фрагменты.

    Для получения информации о подключении к вашему кэшу TLS / SSL конечная точка с помощью redis-cli и stunnel, см [ASP.NET.](https://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx)
1. Высокая загрузка сервера Redis может влечь истечение времени ожидания. Вы можете выполнить мониторинг значения загрузки сервера, измеряя  [метрику производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)`Redis Server Load`. Максимальное значение загрузки (100) указывает на то, что сервер слишком загружен обработкой запросов и не простаивает. Чтобы узнать, не использует ли сервер все свои ресурсы на определенные запросы, выполните команду SlowLog, как описано в предыдущем абзаце. Дополнительные сведения см. в разделе "Высокий коэффициент загрузки ЦП и сервера".
1. Происходили ли на клиенте другие события, для которых требовалось сетевое кэширование? Общие события включают в себя: масштабирование числа экземпляров клиента вверх или вниз, развертывание новой версии клиента или включено автомасштабирование. В нашем тестировании мы обнаружили, что автомасштабирование или масштабирование вверх/вниз может привести к потере испускаемого подключения к сети в течение нескольких секунд. Код StackExchange.Redis устойчив к таким событиям и подключается повторно. При повторном подключении любые запросы в очереди могут отойти.
1. Был ли большой запрос, предшествующий нескольким небольшим запросам на кэш, который приурочен? Параметр `qs` в сообщении об ошибке показывает, сколько запросов было отправлено от клиента на сервер, но не обработал ответ. Это количество может увеличиваться, так как StackExchange.Redis использует одно подключение TCP, которое позволяет обрабатывать только один ответ за раз. Несмотря на то, что первая операция приурочена, она не останавливает отправку большего количества данных на сервер или с сервера. Другие запросы будут заблокированы до тех пор, пока большой запрос не будет закончен и может привести к тайм-аутам. Чтобы решить эту проблему, рекомендуется снизить вероятность возникновения времени ожидания, увеличив размер кэша для рабочей нагрузки и разбив данные большого объема на небольшие фрагменты. Другое решение — использовать в клиенте пул объектов `ConnectionMultiplexer` и для отправки новых запросов применять наименее загруженный объект `ConnectionMultiplexer`. Загрузка на несколько объектов соединения должна предотвратить один тайм-аут из-за других запросов, чтобы также тайм-аут.
1. Если вы используете, `RedisSessionStateProvider`убедитесь, что вы установили повторную попытку тайм-аут правильно. Значение `retryTimeoutInMilliseconds` должно быть выше, чем `operationTimeoutInMilliseconds`, иначе попытки не повторяются. В следующем примере для `retryTimeoutInMilliseconds` задано значение 3000. Дополнительные сведения см. в статьях [Поставщик состояния сеанса ASP.NET для Redis](cache-aspnet-session-state-provider.md) и [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration) (Использование параметров конфигурации поставщика состояния сеанса и поставщика кэша вывода).

    ```xml
    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />
    ```

1. Проверяйте использование памяти на сервере кэша Redis для Azure, [отслеживая](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` и `Used Memory`. Если используется политика вытеснения, Redis начнет вытеснять ключи, когда значение `Used_Memory` достигнет размера кэша. В идеале значение `Used Memory RSS` должно быть немного больше, чем значение `Used memory`. Большая разница означает, что есть фрагментация памяти (внутренней или внешней). Если значение `Used Memory RSS` меньше значения `Used Memory`, это значит, что часть кэш-памяти используется операционной системой для подкачки. При этом могут возникать значительные задержки. Поскольку Redis не имеет контроля над тем, как его `Used Memory RSS` распределения отображаются на страницах памяти, высокий часто является результатом всплеска использования памяти. Когда сервер Redis освобождает память, распределитель забирает память, но он может или не может вернуть память в систему. При этом операционная система может сообщать о расхождении между `Used Memory` и использованием памяти. Память, возможно, была использована и выпущена Redis, но не возвращена в систему. Чтобы уменьшить проблемы с памятью, вы можете сделать следующие шаги:

   - Обновите кэш до большего размера, чтобы вы не работали против ограничений памяти в системе.
   - Задайте время истечения срока действия ключей, чтобы они вытеснялись заранее.
   - Отслеживайте метрику кэша `used_memory_rss`. Когда это значение приближается к размеру кэша, вы, вероятно, начнете видеть проблемы с производительностью. Распределите данные по нескольким осколки, если вы используете премиум кэш, или перейти на больший размер кэша.

   Для получения дополнительной информации [см.](cache-troubleshoot-server.md#memory-pressure-on-redis-server)

## <a name="additional-information"></a>Дополнительные сведения

- [Устранение неполадок с Кэшем Azure для Redis на стороне клиента](cache-troubleshoot-client.md)
- [Устранение неполадок с Кэшем Azure для Redis на стороне сервера](cache-troubleshoot-server.md)
- [Как измерить и протестировать производительность моего кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
- [Как отслеживать кэш Redis для Azure?](cache-how-to-monitor.md)
