---
title: Failover and patching - Azure Cache for Redis (Отработка отказа и исправление в службе "Кэш Azure для Redis")
description: Узнайте о сбое, исправлении и процессе обновления для Azure Cache для Redis.
author: asasine
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 6ff33bd594181aabc4fd7d55ce33f780a0d06086
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "74122188"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>Failover и исправления для Azure Кэш для Redis

Для создания устойчивых и успешных клиентских приложений очень важно понять сбой в контексте службы Azure Cache для Redis. Сбой может быть частью запланированных операций управления или может быть вызван незапланированными сбоями оборудования или сети. Распространенное использование сбоя кэша происходит, когда служба управления патчи Azure Кэш для файлов redis. В этой статье рассказывается о том, что такое неудача, как это происходит во время исправления, и как построить устойчивое клиентское приложение.

## <a name="what-is-a-failover"></a>Что такое неудача?

Начнем с обзора сбоя для Azure Cache для Redis.

### <a name="a-quick-summary-of-cache-architecture"></a>Краткое резюме архитектуры кэша

Кэш построен из нескольких виртуальных машин с отдельными частными IP-адресами. Каждая виртуальная машина, также известная как узла, подключена к общему балансуелизатору нагрузки с одним виртуальным IP-адресом. Каждый узла запускает процесс сервера Redis и доступен с помощью имени хоста и портов Redis. Каждый узла считается либо мастером, либо узлами реплики. Когда клиентское приложение подключается к кэшу, его трафик проходит через этот баланселизатор нагрузки и автоматически направляется в основной узла.

В базовом кэше один узла всегда является мастером. В стандартном или премиум кэше есть два узла: один выбран в качестве мастера, а другой - реплика. Поскольку кэши Standard и Premium имеют несколько узлов, один узла может быть недоступен, в то время как другой продолжает обрабатывать запросы. Кластерные кэши состоят из множества осколков, каждый из которых имеет различные узлы мастера и реплики. Один осколок может быть вниз, а другие остаются доступными.

> [!NOTE]
> Базовый кэш не имеет нескольких узлов и не предлагает для его доступности соглашение на уровне обслуживания (SLA). Основные кэши рекомендуются только для целей разработки и тестирования. Для развертывания нескольких узлов используйте стандартный или премиум-кэш, чтобы повысить доступность.

### <a name="explanation-of-a-failover"></a>Объяснение неудачи

Сбой происходит, когда узла реплики способствует себе стать мастер-узла, и старый узла мастер закрывает существующие соединения. После того, как мастер-узла возвращается вверх, он замечает изменения в ролях и опускается, чтобы стать репликой. Затем он подключается к новому мастеру и синхронизирует данные. Сбой может быть спланирован или незапланирован.

*Запланированный сбой* происходит во время обновления системы, таких как исправление Redis или обновление ОС, а также операции управления, такие как масштабирование и перезагрузка. Поскольку узлы получают предварительное уведомление об обновлении, они могут совместно поменяться ролями и быстро обновлять балансисатор нагрузки изменения. Запланированный сбой обычно заканчивается менее чем за 1 секунду.

*Незапланированное сбой* может произойти из-за сбоя оборудования, сбоя сети или других неожиданных сбоев в работе основного узла. Узла реплики способствует освоению, но процесс занимает больше времени. Узел реплики должен сначала обнаружить, что его основной узел недоступен, прежде чем он может инициировать процесс сбоя. Узел реплики должен также убедиться, что этот незапланированный сбой не является временным или локальным, чтобы избежать ненужного сбоя. Эта задержка в обнаружении означает, что незапланированный сбой обычно заканчивается в течение 10-15 секунд.

## <a name="how-does-patching-occur"></a>Как происходит исправление?

Служба Azure Cache для Redis регулярно обновляет кэш с помощью новейших функций платформы и исправлений. Чтобы исправления кэша служба следует следующим шагам:

1. Служба управления выбирает один узла для исправления.
1. Если выбранный узла является мастер-узлы, соответствующий узлы реплики кооперативно продвигает себя. Эта акция считается запланированным неудачей.
1. Выбранный узлы перезагружаются, чтобы принять новые изменения и возвращается в качестве узла реплики.
1. Узла реплики подключается к главному узлау и синхронизирует данные.
1. Когда синхронизация данных завершена, процесс исправления повторяется для остальных узлов.

Поскольку исправление является запланированным сбой, узла реплики быстро способствует себе стать мастером и начинает обслуживать запросы и новые соединения. Основные кэши не имеют узла реплики и недоступны до завершения обновления. Каждый осколок кластерного кэша исправляется отдельно и не закрывает соединения с другим осколок.

> [!IMPORTANT]
> Узлы исправляются по одному, чтобы предотвратить потерю данных. Базовые кэши будут иметь потерю данных. Кластерные кэши патчи один осколок за один раз.

Несколько кэшов в одной и той же группе ресурсов и регионе также исправляются по одному за раз.  Кэши, отожобленные в различных группах ресурсов или в разных регионах, могут быть исправлены одновременно.

Поскольку полная синхронизация данных происходит до повторения процесса, потеря данных вряд ли произойдет при использовании кэша Standard или Premium. Вы можете дополнительно защититься от потери данных, [экспортируя](cache-how-to-import-export-data.md#export) данные и [обеспечивая сохранение.](cache-how-to-premium-persistence.md)

## <a name="additional-cache-load"></a>Дополнительная нагрузка кэша

Всякий раз, когда происходит сбой, кэши Standard и Premium должны реплицировать данные из одного узла в другой. Эта репликация вызывает некоторое увеличение нагрузки как в памяти сервера, так и в процессоре. Если экземпляр кэша уже сильно загружен, клиентские приложения могут испытывать повышенную задержку. В крайних случаях клиентские приложения могут получать исключения за тайм-аут. Чтобы уменьшить влияние этой дополнительной нагрузки, [настроите](cache-configure.md#memory-policies) настройку кэша. `maxmemory-reserved`

## <a name="how-does-a-failover-affect-my-client-application"></a>Как сбой влияет на мое клиентское приложение?

Количество ошибок, увиденных клиентским приложением, зависит от количества операций, ожидающих выполнения этого соединения на момент сбоя. Любое соединение, направиваемые через узлы, закрывающие его соединения, будет видеть ошибки. Многие библиотеки клиентов могут бросать различные типы ошибок при разрыве соединений, включая исключения тайм-аута, исключения соединения или исключения из розетки. Число и тип исключений зависят от того, где в пути кода находится запрос, когда кэш закрывает свои соединения. Например, операция, отправляя запрос, но не получиващий ответ при сбое, может получить исключение тайм-аута. Новые запросы на объект закрытого соединения получают исключения из подключения до тех пор, пока повторное подключение не произойдет успешно.

Большинство библиотек клиентов пытаются восстановить подключение к кэшу, если они настроены для этого. Однако непредвиденные ошибки могут иногда помещать объекты библиотеки в невосстановимое состояние. Если ошибки сохраняются дольше, чем предварительно настроенное количество времени, объект соединения должен быть воссоздан. В Microsoft.NET и других объектно-ориентированных языках, воссоздание соединения без перезапуска приложения может быть выполнено с помощью [шаблона\<Lazy T.\> ](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)

### <a name="how-do-i-make-my-application-resilient"></a>Как сделать приложение устойчивым?

Поскольку полностью избежать сбоев не удается, напишите клиенту приложения для устойчивости к перерывам соединения и невыполненным запросам. Хотя большинство библиотек клиентов автоматически подключаются к конечной точке кэша, лишь немногие из них пытаются повторить неудачные запросы. В зависимости от сценария приложения, возможно, имеет смысл использовать логику повтора с откатом.

Чтобы проверить устойчивость клиентского приложения, используйте [перезагрузку](cache-administration.md#reboot) в качестве ручного триггера для прерываний соединения. Кроме того, мы рекомендуем [запланировать обновления](cache-administration.md#schedule-updates) кэша. Сообщите службе управления, чтобы применить патчи времени выполнения Redis во время указанных еженедельных окон. Эти окна, как правило, периоды, когда трафик клиентского приложения является низким, чтобы избежать потенциальных инцидентов.

### <a name="client-network-configuration-changes"></a>Изменения конфигурации сети клиентов

Некоторые изменения конфигурации сети на стороне клиента могут вызвать ошибки «Без подключения». Такие изменения могут включать:

- Замена виртуального IP-адреса клиентского приложения между промежуточными и производственными слотами.
- Масштабирование размера или количества экземпляров приложения.

Такие изменения могут привести к проблеме подключения, которая длится менее одной минуты. Ваше клиентское приложение, вероятно, потеряет подключение к другим внешним сетевым ресурсам в дополнение к кэшу Azure для службы Redis.

## <a name="next-steps"></a>Дальнейшие действия

- [Расписание обновлений](cache-administration.md#schedule-updates) для кэша.
- Тест ируем устойчивость приложения с помощью [перезагрузки.](cache-administration.md#reboot)
- [Настройка](cache-configure.md#memory-policies) резервирования и политик и политик памяти.
