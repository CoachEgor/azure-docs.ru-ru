---
title: Преобразование присоединение в поток данных сопоставления фабрики данных Azure | Документация Майкрософт
description: Объединение данных из двух источников данных с помощью преобразования «соединение» в потоке данных сопоставления фабрики данных Azure
author: kromerm
ms.author: makromer
ms.reviewer: daperlov
ms.service: data-factory
ms.topic: conceptual
ms.date: 10/17/2019
ms.openlocfilehash: 78de9f2bedfc36add567053e1de47e8893bfaf3c
ms.sourcegitcommit: b4f201a633775fee96c7e13e176946f6e0e5dd85
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2019
ms.locfileid: "72597006"
---
# <a name="join-transformation-in-mapping-data-flow"></a>Преобразование «соединение» в потоке данных сопоставления

Используйте преобразование «соединение» для объединения данных из двух источников или потоков в потоке данных сопоставления. Выходной поток будет включать все столбцы из обоих источников, совпадающие на основе условия объединения. 

## <a name="join-types"></a>Типы соединений

Сопоставление потоков данных в настоящее время поддерживает пять разных типов объединения.

### <a name="inner-join"></a>Внутреннее соединение

Внутреннее соединение выводит только строки с совпадающими значениями обеих таблиц.

### <a name="left-outer"></a>Левое внешнее соединение

Левое внешнее соединение возвращает все строки из левого потока и совпадающие записи из правого потока. Если строка из левого потока не имеет совпадения, выходные столбцы из правого потока будут установлены в значение NULL. Выходные данные будут строками, возвращаемыми внутренним соединением, а также несовпадающими строками из левого потока.

### <a name="right-outer"></a>Правое внешнее соединение

Левое внешнее соединение возвращает все строки из правильного потока и совпадающие записи из левого потока. Если строка из правого потока не имеет совпадения, выходные столбцы из правого потока будут установлены в значение NULL. Выходными данными будут строки, возвращаемые внутренним соединением, а также несовпадающие строки из правого потока.

### <a name="full-outer"></a>Полное внешнее соединение

Полное внешнее соединение выводит все столбцы и строки из обеих сторон со значениями NULL для столбцов, не совпадающих.

### <a name="cross-join"></a>Перекрестное соединение

Перекрестное соединение выводит перекрестное произведение двух потоков на основе условия. Если вы используете условие, не определяющее равенство, укажите пользовательское выражение в качестве условия перекрестного объединения. Поток вывода будет содержать все строки, соответствующие условию JOIN. Чтобы создать декартово произведение, которое выводит каждую комбинацию строк, укажите `true()` в качестве условия объединения.

## <a name="configuration"></a>Настройка

1. Выберите поток данных, с которым выполняется соединение, в **правильном** раскрывающемся списке потока.
1. Выбор **типа присоединение**
1. Выберите ключевые столбцы, которые нужно сопоставить с условием объединения. По умолчанию поток данных ищет равенство между двумя столбцами в каждом потоке. Для сравнения с помощью вычисляемого значения наведите указатель мыши на раскрывающийся список столбцов и выберите **вычисляемый столбец**.

![Преобразование «соединение»](media/data-flow/join.png "Объединение")

## <a name="optimizing-join-performance"></a>Оптимизация производительности соединений

В отличие от объединения слиянием в таких средствах, как SSIS, преобразование «соединение» не является обязательной операцией объединения слиянием. Для ключей объединения не требуется сортировка. Операция объединения выполняется на основе оптимальной операции JOIN в Spark, широковещательной или присоединяемой на стороне схемы.

![Оптимизация преобразования «соединение»](media/data-flow/joinoptimize.png "Оптимизация присоединение")

Если один или оба потока данных помещаются в память рабочего узла, еще более Оптимизируйте производительность, включив **вещание** на вкладке Оптимизация. Вы также можете повторно секционировать данные в операции объединения, чтобы они лучше соответствовали объему памяти для каждого рабочего процесса.

## <a name="self-join"></a>Самосоединение

Для самосоединения потока данных с самим собой можно задать псевдоним для существующего потока с помощью преобразования Select. Создайте новую ветвь, щелкнув значок "плюс" рядом с преобразованием и выбрав пункт **создать ветвь**. Добавьте преобразование «выбор» для присвоения псевдонима исходному потоку. Добавьте преобразование «соединение» и выберите исходный поток в качестве **левого потока** и преобразование «выбор» в качестве **правильного потока**.

![Самостоятельная связь](media/data-flow/selfjoin.png "Самостоятельная связь")

## <a name="testing-join-conditions"></a>Проверка условий Join

При тестировании преобразований «соединение» с предварительным просмотром данных в режиме отладки используйте небольшой набор известных данных. При выборке строк из большого набора данных нельзя предсказать, какие строки и ключи будут считываться для тестирования. Результат является недетерминированным, то есть условия объединения не могут возвращать совпадения.

## <a name="data-flow-script"></a>Сценарий потока данных

### <a name="syntax"></a>Синтаксис

```
<leftStream>, <rightStream>
    join(
        <conditionalExpression>,
        joinType: { 'inner'> | 'outer' | 'left_outer' | 'right_outer' | 'cross' }
        broadcast: { 'none' | 'left' | 'right' | 'both' }
    ) ~> <joinTransformationName>
```

### <a name="inner-join-example"></a>Пример внутреннего объединения

Ниже приведен пример преобразования «соединение» с именем `JoinMatchedData`, которое принимает левый поток `TripData` и правый поток `TripFare`.  Условие Join — это `hack_license == { hack_license} && TripData@medallion == TripFare@medallion && vendor_id == { vendor_id} && pickup_datetime == { pickup_datetime}` выражения, которое возвращает значение true, если столбцы `hack_license`, `medallion`, `vendor_id` и `pickup_datetime` в каждом потоке совпадают. @No__t_0 `'inner'`. Включение вещания выполняется только в левом потоке, поэтому `broadcast` имеет значение `'left'`.

В интерфейсе фабрики данных это преобразование выглядит как на изображении ниже:

![Пример подключения](media/data-flow/join-script1.png "Пример подключения")

Сценарий потока данных для этого преобразования находится в следующем фрагменте кода:

```
TripData, TripFare
    join(
        hack_license == { hack_license}
        && TripData@medallion == TripFare@medallion
        && vendor_id == { vendor_id}
        && pickup_datetime == { pickup_datetime},
        joinType:'inner',
        broadcast: 'left'
    )~> JoinMatchedData
```

### <a name="cross-join-example"></a>Пример перекрестного объединения

Ниже приведен пример преобразования «соединение» с именем `CartesianProduct`, которое принимает левый поток `TripData` и правый поток `TripFare`. Это преобразование принимает два потока и возвращает декартово произведение их строк. Условием объединения является `true()`, так как выводится полное декартово произведение. @No__t_0 в `cross`. Включение вещания выполняется только в левом потоке, поэтому `broadcast` имеет значение `'left'`.

В интерфейсе фабрики данных это преобразование выглядит как на изображении ниже:

![Пример подключения](media/data-flow/join-script2.png "Пример подключения")

Сценарий потока данных для этого преобразования находится в следующем фрагменте кода:

```
TripData, TripFare
    join(
        true(),
        joinType:'cross',
        broadcast: 'left'
    )~> CartesianProduct
```

## <a name="next-steps"></a>Дальнейшие действия

После объединения данных создайте [производный столбец](data-flow-derived-column.md) [и присоедините данные к](data-flow-sink.md) целевому хранилищу данных.
