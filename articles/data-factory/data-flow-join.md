---
title: Преобразование «соединение» в потоке данных сопоставления
description: Объединение данных из двух источников данных с помощью преобразования «соединение» в потоке данных сопоставления фабрики данных Azure
author: kromerm
ms.author: makromer
ms.reviewer: daperlov
ms.service: data-factory
ms.topic: conceptual
ms.custom: seo-lt-2019
ms.date: 01/02/2020
ms.openlocfilehash: 9b720470ac406ed0730e6243262dcf33d2df169a
ms.sourcegitcommit: 58faa9fcbd62f3ac37ff0a65ab9357a01051a64f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2020
ms.locfileid: "82233433"
---
# <a name="join-transformation-in-mapping-data-flow"></a>Преобразование «соединение» в потоке данных сопоставления

[!INCLUDE[appliesto-adf-asa-md](includes/appliesto-adf-asa-md.md)]

Используйте преобразование «соединение» для объединения данных из двух источников или потоков в потоке данных сопоставления. Выходной поток будет включать все столбцы из обоих источников, совпадающие на основе условия объединения. 

## <a name="join-types"></a>Типы соединений

Сопоставление потоков данных в настоящее время поддерживает пять разных типов объединения.

### <a name="inner-join"></a>Внутреннее соединение

Внутреннее соединение выводит только строки, имеющие совпадающие значения в обеих таблицах.

### <a name="left-outer"></a>Левое внешнее соединение

Левое внешнее соединение возвращает все строки из левого потока и совпадающие записи из правого потока. Если строка из левого потока не имеет совпадения, выходные столбцы из правого потока будут установлены в значение NULL. Выходные данные будут строками, возвращаемыми внутренним соединением, а также несовпадающими строками из левого потока.

> [!NOTE]
> Обработчик Spark, используемый потоками данных, периодически завершается сбоем из-за возможных продуктов с декартой в условиях соединения. В этом случае можно переключиться на пользовательское перекрестное соединение и ввести условие объединения вручную. Это может привести к снижению производительности потоков данных, так как подсистеме выполнения может потребоваться вычислить все строки по обеим сторонам связи, а затем отфильтровать строки.

### <a name="right-outer"></a>Правое внешнее соединение

Правое внешнее соединение возвращает все строки из правильного потока и совпадающие записи из левого потока. Если строка из правого потока не имеет совпадения, выходные столбцы из левого потока будут установлены в значение NULL. Выходными данными будут строки, возвращаемые внутренним соединением, а также несовпадающие строки из правого потока.

### <a name="full-outer"></a>Полное внешнее соединение

Полное внешнее соединение выводит все столбцы и строки из обеих сторон со значениями NULL для несовпадающих столбцов.

### <a name="custom-cross-join"></a>Пользовательское перекрестное соединение

Перекрестное соединение выводит перекрестное произведение двух потоков на основе условия. Если вы используете условие, не определяющее равенство, укажите пользовательское выражение в качестве условия перекрестного объединения. Поток вывода будет содержать все строки, соответствующие условию JOIN.

Этот тип объединения можно использовать для неэквивалентных соединений и ```OR``` условий.

Если вы хотите явно создать полное декартово произведение, используйте преобразование «Производный столбец» в каждом из двух независимых потоков перед соединением, чтобы создать искусственный ключ для сопоставления. Например, создайте новый столбец в производном столбце в каждом вызываемом ```SyntheticKey``` потоке и установите его ```1```равным. Затем используйте ```a.SyntheticKey == b.SyntheticKey``` в качестве пользовательского выражения JOIN.

> [!NOTE]
> Не забудьте включить по крайней мере один столбец с каждой стороны левой и правой связей в пользовательском перекрестном соединении. Выполнение перекрестных соединений со статическими значениями вместо столбцов из каждой стороны приводит к полному сканированию всего набора данных, что приводит к плохому выполнению потока данных.

## <a name="configuration"></a>Параметр Configuration

1. Выберите поток данных, с которым выполняется соединение, в **правильном** раскрывающемся списке потока.
1. Выбор **типа присоединение**
1. Выберите ключевые столбцы, которые нужно сопоставить с условием объединения. По умолчанию поток данных ищет равенство между двумя столбцами в каждом потоке. Для сравнения с помощью вычисляемого значения наведите указатель мыши на раскрывающийся список столбцов и выберите **вычисляемый столбец**.

![Преобразование «соединение»](media/data-flow/join.png "Join")

## <a name="optimizing-join-performance"></a>Оптимизация производительности соединений

В отличие от объединения слиянием в таких средствах, как SSIS, преобразование «соединение» не является обязательной операцией объединения слиянием. Для ключей объединения не требуется сортировка. Операция объединения выполняется на основе оптимальной операции JOIN в Spark, широковещательной или присоединяемой на стороне схемы.

![Оптимизация преобразования «соединение»](media/data-flow/joinoptimize.png "Оптимизация присоединение")

В случае преобразования «уточняющие запросы» и «EXISTS», если один или оба потока данных помещаются в память рабочего узла, можно оптимизировать производительность, включив **вещание**. По умолчанию механизм Spark автоматически решает, следует ли транслировать одну сторону. Чтобы вручную выбрать сторону для вещания, выберите **фиксированный**.

Не рекомендуется отключать трансляцию с помощью параметра **Off** , если только не истечет ошибка времени ожидания при выполнении соединений.

## <a name="self-join"></a>Самосоединение

Для самосоединения потока данных с самим собой можно задать псевдоним для существующего потока с помощью преобразования Select. Создайте новую ветвь, щелкнув значок "плюс" рядом с преобразованием и выбрав пункт **создать ветвь**. Добавьте преобразование «выбор» для присвоения псевдонима исходному потоку. Добавьте преобразование «соединение» и выберите исходный поток в качестве **левого потока** и преобразование «выбор» в качестве **правильного потока**.

![Самостоятельная связь](media/data-flow/selfjoin.png "Самостоятельная связь")

## <a name="testing-join-conditions"></a>Проверка условий Join

При тестировании преобразований «соединение» с предварительным просмотром данных в режиме отладки используйте небольшой набор известных данных. При выборке строк из большого набора данных нельзя предсказать, какие строки и ключи будут считываться для тестирования. Результат является недетерминированным, то есть условия объединения не могут возвращать совпадения.

## <a name="data-flow-script"></a>Скрипт потока данных

### <a name="syntax"></a>Синтаксис

```
<leftStream>, <rightStream>
    join(
        <conditionalExpression>,
        joinType: { 'inner'> | 'outer' | 'left_outer' | 'right_outer' | 'cross' }
        broadcast: { 'auto' | 'left' | 'right' | 'both' | 'off' }
    ) ~> <joinTransformationName>
```

### <a name="inner-join-example"></a>Пример внутреннего объединения

Ниже приведен пример преобразования «соединение» с `JoinMatchedData` именем, которое принимает `TripData` левый поток и `TripFare`правый поток.  Условием объединения является выражение `hack_license == { hack_license} && TripData@medallion == TripFare@medallion && vendor_id == { vendor_id} && pickup_datetime == { pickup_datetime}` , возвращающее значение true `hack_license`, `medallion`если `vendor_id`столбцы, `pickup_datetime` , и в каждом потоке совпадают. Значение параметра `joinType` — `'inner'`. Мы разрешив вещание только в левом потоке, `broadcast` чтобы иметь `'left'`значение.

В интерфейсе фабрики данных это преобразование выглядит как на изображении ниже:

![Пример подключения](media/data-flow/join-script1.png "Пример подключения")

Сценарий потока данных для этого преобразования находится в следующем фрагменте кода:

```
TripData, TripFare
    join(
        hack_license == { hack_license}
        && TripData@medallion == TripFare@medallion
        && vendor_id == { vendor_id}
        && pickup_datetime == { pickup_datetime},
        joinType:'inner',
        broadcast: 'left'
    )~> JoinMatchedData
```

### <a name="custom-cross-join-example"></a>Пример пользовательского перекрестного объединения

Ниже приведен пример преобразования «соединение» с `JoiningColumns` именем, которое принимает `LeftStream` левый поток и `RightStream`правый поток. Это преобразование принимает два потока и объединяет все строки, где столбец `leftstreamcolumn` больше столбца. `rightstreamcolumn` Значение параметра `joinType` — `cross`. Параметр `'none'`широковещания не включен `broadcast` .

В интерфейсе фабрики данных это преобразование выглядит как на изображении ниже:

![Пример подключения](media/data-flow/join-script2.png "Пример подключения")

Сценарий потока данных для этого преобразования находится в следующем фрагменте кода:

```
LeftStream, RightStream
    join(
        leftstreamcolumn > rightstreamcolumn,
        joinType:'cross',
        broadcast: 'none'
    )~> JoiningColumns
```

## <a name="next-steps"></a>Следующие шаги

После объединения данных создайте [производный столбец](data-flow-derived-column.md) [и присоедините данные к](data-flow-sink.md) целевому хранилищу данных.
