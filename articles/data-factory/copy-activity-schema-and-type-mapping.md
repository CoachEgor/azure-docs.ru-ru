---
title: Сопоставление схем в действии копирования | Документация Майкрософт
description: Узнайте, как действие копирования в фабрике данных Azure сопоставляет схемы и типы исходных данных с данными приемника во время копирования данных.
services: data-factory
documentationcenter: ''
author: linda33wj
manager: craigg
ms.reviewer: craigg
ms.service: data-factory
ms.workload: data-services
ms.tgt_pltfrm: na
ms.topic: conceptual
ms.date: 04/29/2019
ms.author: jingwang
ms.openlocfilehash: 9108f83e854b51720c64c5a74a828543cc5e7688
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "64875806"
---
# <a name="schema-mapping-in-copy-activity"></a>Сопоставление схем в действии копирования

Эта статья содержит сведения о том, как действие копирования фабрики данных Azure сопоставляет схемы и типы исходных данных с данными приемника во время выполнения копирования данных.

## <a name="schema-mapping"></a>Сопоставление схем

Сопоставление столбцов применяется при копировании данных из источника в приемник. По умолчанию действие копирования **сопоставить исходные данные для приемника по именам столбцов**. Можно указать [явное сопоставление](#explicit-mapping) для настройки сопоставления столбцов, по своему усмотрению. В частности, действие копирования выполняет следующие задачи:

1. Считывает данные из источника и определяет исходную схему.
2. Использование сопоставления столбцов по умолчанию для сопоставления столбцов по имени или выполняет явное сопоставление столбцов, если указано.
3. Записывает данные в приемник.

### <a name="explicit-mapping"></a>Явное сопоставление

Можно указать столбцы, чтобы сопоставить в действии копирования "->" `translator`  ->  `mappings` свойство. В следующем примере определяется действие копирования в конвейере, чтобы копировать данные из текста с разделителями в базе данных SQL Azure.

```json
{
    "name": "CopyActivity",
    "type": "Copy",
    "inputs": [{
        "referenceName": "DelimitedTextInput",
        "type": "DatasetReference"
    }],
    "outputs": [{
        "referenceName": "AzureSqlOutput",
        "type": "DatasetReference"
    }],
    "typeProperties": {
        "source": { "type": "DelimitedTextSource" },
        "sink": { "type": "SqlSink" },
        "translator": {
            "type": "TabularTranslator",
            "mappings": [
                {
                    "source": {
                        "name": "UserId",
                        "type": "Guid"
                    },
                    "sink": {
                        "name": "MyUserId"
                    }
                }, 
                {
                    "source": {
                        "name": "Name",
                        "type": "String"
                    },
                    "sink": {
                        "name": "MyName"
                    }
                }, 
                {
                    "source": {
                        "name": "Group",
                        "type": "String"
                    },
                    "sink": {
                        "name": "MyGroup"
                    }
                }
            ]
        }
    }
}
```

Поддерживаются следующие свойства `translator`  ->  `mappings` "->" объект с `source` и `sink`:

| Свойство | ОПИСАНИЕ                                                  | Обязательно для заполнения |
| -------- | ------------------------------------------------------------ | -------- |
| name     | Имя столбца источника или приемника.                           | Yes      |
| ordinal  | Индекс столбца. Начинается с 1. <br>Применить и требуется, если с помощью с разделителями текста без строки заголовка. | Нет       |
| path     | Выражение пути JSON для каждого поля для извлечения или сопоставления. Применить иерархических данных: например MongoDB или REST.<br>Для полей в корневом объекте JSON путь должен начинаться с корня $; для полей внутри массива, выбранных по `collectionReference` свойства JSON путь начинается с элемента массива. | Нет       |
| type     | Тип промежуточных данных фабрики данных столбца источника или приемника. | Нет       |
| culture  | Язык и региональные параметры столбца источника или приемника. <br>Применить, если выбран тип `Datetime` или `Datetimeoffset`. Значение по умолчанию — `en-us`. | Нет       |
| свойства   | Строка для использования в том случае, если выбран тип формата `Datetime` или `Datetimeoffset`. Сведения о формате даты и времени см. в статье [Строки настраиваемых форматов даты и времени](https://docs.microsoft.com/dotnet/standard/base-types/custom-date-and-time-format-strings). | Нет       |

Поддерживаются следующие свойства `translator`  ->  `mappings` дополнение к объекту с `source` и `sink`:

| Свойство            | ОПИСАНИЕ                                                  | Обязательно для заполнения |
| ------------------- | ------------------------------------------------------------ | -------- |
| collectionReference | Поддерживается только в том случае, когда иерархических данных, например MongoDB или REST является источник.<br>Для итерации и извлечения данных из объектов **в поле массива** с таким же шаблоном и построчного преобразования этих данных по каждому объекту укажите путь JSON массива для перекрестного применения. | Нет       |

### <a name="alternative-column-mapping"></a>Сопоставление альтернативного столбцов

Можно указать копирования activity -> `translator`  ->  `columnMappings` сопоставления данных в табличной форме. В нашем разделе «structure» является обязательным для входных и выходных наборов данных. Функция сопоставления столбцов поддерживает сопоставление **всех или подмножества столбцов в разделе structure набора данных, используемого в качестве источника, со всеми столбцами в разделе structure набора данных, используемого в качестве приемника**. Ниже приведены неправильные условия, которые приводят к порождению исключения.

* В результате запроса исходного хранилища данных нет имени столбца, указанного в разделе structure входного набора данных.
* Приемник данных (если имеется предопределенная схема) не содержит имя столбца, указанное в разделе structure выходного набора данных.
* Меньше или больше столбцов в structure набора данных приемника, чем указано в сопоставлении.
* Повторяющееся сопоставление.

В следующем примере входной набор данных имеет структуру, и она указывает на таблицу в базе данных Oracle в локальной.

```json
{
    "name": "OracleDataset",
    "properties": {
        "structure":
         [
            { "name": "UserId"},
            { "name": "Name"},
            { "name": "Group"}
         ],
        "type": "OracleTable",
        "linkedServiceName": {
            "referenceName": "OracleLinkedService",
            "type": "LinkedServiceReference"
        },
        "typeProperties": {
            "tableName": "SourceTable"
        }
    }
}
```

В этом примере выходной набор данных имеет структуру, и она указывает на таблицу в Salesfoce.

```json
{
    "name": "SalesforceDataset",
    "properties": {
        "structure":
        [
            { "name": "MyUserId"},
            { "name": "MyName" },
            { "name": "MyGroup"}
        ],
        "type": "SalesforceObject",
        "linkedServiceName": {
            "referenceName": "SalesforceLinkedService",
            "type": "LinkedServiceReference"
        },
        "typeProperties": {
            "tableName": "SinkTable"
        }
    }
}
```

Ниже приведен фрагмент JSON, который определяет действие копирования в конвейере. Столбцы из источника сопоставляются со столбцами в приемнике с помощью **translator** -> **columnMappings** свойство.

```json
{
    "name": "CopyActivity",
    "type": "Copy",
    "inputs": [
        {
            "referenceName": "OracleDataset",
            "type": "DatasetReference"
        }
    ],
    "outputs": [
        {
            "referenceName": "SalesforceDataset",
            "type": "DatasetReference"
        }
    ],
    "typeProperties":    {
        "source": { "type": "OracleSource" },
        "sink": { "type": "SalesforceSink" },
        "translator":
        {
            "type": "TabularTranslator",
            "columnMappings":
            {
                "UserId": "MyUserId",
                "Group": "MyGroup",
                "Name": "MyName"
            }
        }
    }
}
```

Если вы используете синтаксис `"columnMappings": "UserId: MyUserId, Group: MyGroup, Name: MyName"`, чтобы указать сопоставление столбцов, оно будет поддерживаться без изменений.

### <a name="alternative-schema-mapping"></a>Альтернативные схемы сопоставления

Можно указать копирования activity -> `translator`  ->  `schemaMapping` для сопоставления данных в иерархической форме и данных в табличной форме, например скопировать из MongoDB или REST в текстовый файл и копировать из Oracle в Azure Cosmos DB API для MongoDB. В разделе `translator` действия копирования поддерживаются следующие свойства.

| Свойство | ОПИСАНИЕ | Обязательно для заполнения |
|:--- |:--- |:--- |
| type | Свойство типа преобразователя действия копирования должно иметь следующее значение. **TabularTranslator** | Yes |
| schemaMapping | Коллекция пар "ключ значение", который представляет отношения сопоставления **со стороны источника в приемник стороне**.<br/>- **Ключ:** представляет источник. Для **табличный источник**, укажите имя столбца, как определено в структуре набора данных; для **иерархических источника**, укажите выражение пути JSON для каждого поля для извлечения и сопоставления.<br>- **Значение:** представляет приемника. Для **табличных приемника**, укажите имя столбца, как определено в структуре набора данных; для **иерархических приемника**, укажите выражение пути JSON для каждого поля для извлечения и сопоставления. <br>В случае иерархические данные, для полей в корневом объекте JSON путь должен начинаться с корня $; для полей внутри массива, выбранных по `collectionReference` свойства JSON путь начинается с элемента массива.  | Yes |
| collectionReference | Для итерации и извлечения данных из объектов **в поле массива** с таким же шаблоном и построчного преобразования этих данных по каждому объекту укажите путь JSON массива для перекрестного применения. Это свойство поддерживается только при копировании иерархических данных. | Нет |

**Пример: копирование из базы данных MongoDB в Oracle:**

Например, если у вас есть документ MongoDB со следующим содержимым:

```json
{
    "id": {
        "$oid": "592e07800000000000000000"
    },
    "number": "01",
    "date": "20170122",
    "orders": [
        {
            "prod": "p1",
            "price": 23
        },
        {
            "prod": "p2",
            "price": 13
        },
        {
            "prod": "p3",
            "price": 231
        }
    ],
    "city": [ { "name": "Seattle" } ]
}
```

и вы хотите скопировать его в таблицу Azure SQL в следующем формате путем сведения данных внутри массива *(order_pd и order_price)* и перекрестного соединения с общими сведениями о корневом объекте *(number, date и city)* .

| orderNumber | orderDate | order_pd | order_price | city |
| --- | --- | --- | --- | --- |
| 01 | 20170122 | P1 | 23 | Сиэтл; |
| 01 | 20170122 | P2 | 13 | Сиэтл; |
| 01 | 20170122 | P3 | 231 | Сиэтл; |

Настройте правило сопоставления схем, как в следующем примере JSON действия копирования.

```json
{
    "name": "CopyFromMongoDBToOracle",
    "type": "Copy",
    "typeProperties": {
        "source": {
            "type": "MongoDbV2Source"
        },
        "sink": {
            "type": "OracleSink"
        },
        "translator": {
            "type": "TabularTranslator",
            "schemaMapping": {
                "orderNumber": "$.number",
                "orderDate": "$.date",
                "order_pd": "prod",
                "order_price": "price",
                "city": " $.city[0].name"
            },
            "collectionReference":  "$.orders"
        }
    }
}
```

## <a name="data-type-mapping"></a>Сопоставление типов данных

Действие копирования выполняет сопоставление типов источника с типами приемника. Такое сопоставление выполняется в два этапа.

1. Преобразование собственных типов источников в промежуточные типы данных фабрики данных Azure.
2. Преобразование промежуточных типов данных фабрики данных Azure в собственный тип приемника.

Вы можете найти сопоставление собственного типа с промежуточным типом данных в разделе "Сопоставление типов данных" каждой статьи о соединителях.

### <a name="supported-data-types"></a>Поддерживаемые типы данных.

Фабрика данных поддерживает следующие промежуточные типы форматов. При настройке информации о типе в конфигурации [структуры данных](concepts-datasets-linked-services.md#dataset-structure-or-schema) можно указать следующие значения.

* Byte[]
* Boolean
* DateTime
* Datetimeoffset
* Decimal
* Double
* Guid
* Int16
* Int32
* Int64
* Single
* Строка
* Timespan

## <a name="next-steps"></a>Дальнейшие действия
См. другие статьи о действиях копирования:

- [Действие копирования в фабрике данных Azure](copy-activity-overview.md)
