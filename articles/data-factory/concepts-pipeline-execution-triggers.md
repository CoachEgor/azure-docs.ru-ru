---
title: Выполнение конвейера и триггеры в фабрике данных Azure | Документация Майкрософт
description: В этой статье объясняется, как выполнить конвейер в фабрике данных Azure по запросу или путем создания триггера.
services: data-factory
documentationcenter: ''
author: djpmsft
ms.author: daperlov
manager: jroth
ms.reviewer: maghan
ms.service: data-factory
ms.workload: data-services
ms.topic: conceptual
ms.date: 07/05/2018
ms.openlocfilehash: 34ff075a604afdcbef67c7b10ce1ef8cbe2924e7
ms.sourcegitcommit: d200cd7f4de113291fbd57e573ada042a393e545
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/29/2019
ms.locfileid: "70137032"
---
# <a name="pipeline-execution-and-triggers-in-azure-data-factory"></a>Выполнение конвейера и триггеры в фабрике данных Azure
> [!div class="op_single_selector" title1="Выберите версию службы "Фабрика данных", которую вы используете:"]
> * [Версия 1](v1/data-factory-scheduling-and-execution.md)
> * [Текущая версия](concepts-pipeline-execution-triggers.md)

_Запуск конвейера_ в службе "Фабрика данных Azure" определяет экземпляр выполнения конвейера. Например, у вас есть конвейер, который выполняется в 8:00, 09:00 и 10:00. В этом случае выполняются три отдельных запуска конвейера. Для каждого запуска конвейера предусмотрен уникальный идентификатор. Идентификатор запуска представляет собой уникальный идентификатор GUID, который определяет запуск определенного конвейера.

Запуск конвейера обычно создается путем передачи аргументов в параметры, определенные в конвейерах. Конвейер можно выполнить двумя способами: вручную или с помощью _триггера_. Эта статья подробно описывает оба способа.

## <a name="manual-execution-on-demand"></a>Выполнение вручную (по запросу)
Выполнение конвейера вручную также называется выполнением _по требованию_.

Предположим, у вас есть базовый конвейер с именем **copyPipeline**, который вы хотите выполнить. Это конвейер с одним действием, которое копирует данные из папки источника, расположенной в хранилище BLOB-объектов Azure, в папку приемника в том же хранилище. В следующем определении JSON показан этот пример конвейера:

```json
{
    "name": "copyPipeline",
    "properties": {
        "activities": [
            {
                "type": "Copy",
                "typeProperties": {
                    "source": {
                        "type": "BlobSource"
                    },
                    "sink": {
                        "type": "BlobSink"
                    }
                },
                "name": "CopyBlobtoBlob",
                "inputs": [
                    {
                        "referenceName": "sourceBlobDataset",
                        "type": "DatasetReference"
                    }
                ],
                "outputs": [
                    {
                        "referenceName": "sinkBlobDataset",
                        "type": "DatasetReference"
                    }
                ]
            }
        ],
        "parameters": {
            "sourceBlobContainer": {
                "type": "String"
            },
            "sinkBlobContainer": {
                "type": "String"
            }
        }
    }
}
```

В определении JSON этот конвейер принимает два параметра: **sourceBlobContainer** и **sinkBlobContainer**. Значения этих параметров передаются во время выполнения.

Вы можете вручную запустить свой конвейер, используя один из методов ниже:
- Пакет SDK для .NET
- модуль Azure PowerShell;
- REST API
- Пакет SDK для Python

### <a name="rest-api"></a>REST API
В следующем примере команды показано, как запустить конвейер вручную с помощью REST API:

```
POST
https://management.azure.com/subscriptions/mySubId/resourceGroups/myResourceGroup/providers/Microsoft.DataFactory/factories/myDataFactory/pipelines/copyPipeline/createRun?api-version=2017-03-01-preview
```

Полный пример см. в статье [Создание фабрики данных Azure и конвейера с помощью REST API](quickstart-create-data-factory-rest-api.md).

### <a name="azure-powershell"></a>Azure PowerShell

[!INCLUDE [updated-for-az](../../includes/updated-for-az.md)]

В следующем примере команды показано, как запустить конвейер вручную с помощью Azure PowerShell:

```powershell
Invoke-AzDataFactoryV2Pipeline -DataFactory $df -PipelineName "Adfv2QuickStartPipeline" -ParameterFile .\PipelineParameters.json
```

Параметры передаются в тексте полезных данных запроса. В пакетах SDK для .NET, Azure PowerShell и Python можно передавать значения в словарь, который передается в качестве аргумента вызова:

```json
{
  "sourceBlobContainer": "MySourceFolder",
  "sinkBlobContainer": "MySinkFolder"
}
```

Полезные данные ответа содержат уникальный идентификатор запуска конвейера.

```json
{
  "runId": "0448d45a-a0bd-23f3-90a5-bfeea9264aed"
}
```

Полный пример см. в статье [Создание фабрики данных Azure с помощью PowerShell](quickstart-create-data-factory-powershell.md).

### <a name="net-sdk"></a>Пакет SDK для .NET
В следующем примере вызова показано, как запустить конвейер вручную с помощью .NET SDK:

```csharp
client.Pipelines.CreateRunWithHttpMessagesAsync(resourceGroup, dataFactoryName, pipelineName, parameters)
```

Полный пример см. в статье [Создание фабрики данных и конвейера с помощью пакета SDK .NET](quickstart-create-data-factory-dot-net.md).

> [!NOTE]
> Пакет SDK .NET можно использовать для вызова конвейеров фабрики данных из решения "Функции Azure", собственных веб-служб и т. д.

<h2 id="triggers">Выполнение триггера</h2>
Триггеры — это еще один способ выполнить запуск конвейера. Триггеры обозначает единицу обработки, которая определяет время запуска для выполнения конвейера. Сейчас службы "Фабрика данных" поддерживает три типа триггеров:

- Триггер планировщика. Триггер, который запускает конвейер в определенное время по расписанию.

- Триггер "переворачивающегося" окна. Триггер, который работает на основе периодических интервалов, сохраняя состояние.

- Триггер на основе событий. Триггер, который реагирует на событие.

Конвейеры и триггеры имеют связь "многие ко многим". Несколько триггеров могут запускать один конвейер, а один триггер может запускать несколько конвейеров. В следующем определении триггера свойство **конвейеры** ссылается на список конвейеров, запускаемых определенным триггером. Определение свойства содержит значения для параметров конвейера.

### <a name="basic-trigger-definition"></a>Базовое определение триггера

```json
{
    "properties": {
        "name": "MyTrigger",
        "type": "<type of trigger>",
        "typeProperties": {...},
        "pipelines": [
            {
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "<Name of your pipeline>"
                },
                "parameters": {
                    "<parameter 1 Name>": {
                        "type": "Expression",
                        "value": "<parameter 1 Value>"
                    },
                    "<parameter 2 Name>": "<parameter 2 Value>"
                }
            }
        ]
    }
}
```

## <a name="schedule-trigger"></a>Триггер планировщика
Триггер планировщика запускает конвейер в определенное время по расписанию. Этот триггер поддерживает периодичность и расширенные возможности календаря. Например, триггер поддерживает такие интервалы, как "еженедельно" или "каждую неделю, в 17:00 по понедельникам и в 21:00 по четвергам". Триггер планировщика гибкий, так как шаблон набора данных не важен, а триггер не различает данные временных рядов и данные, не относящиеся к временным рядам.

Дополнительные сведения о триггерах планировщика и примеры см. в руководстве по [созданию триггера расписания](how-to-create-schedule-trigger.md).

## <a name="schedule-trigger-definition"></a>Определение триггера планировщика
При создании триггера планировщика нужно указать расписание и повторения с помощью определения JSON.

Чтобы триггер планировщика выполнял конвейер, включите в определении триггера ссылку на нужный конвейер. Конвейеры и триггеры имеют связь "многие ко многим". Несколько триггеров могут запускать один конвейер. Один триггер может запускать несколько конвейеров.

```json
{
  "properties": {
    "type": "ScheduleTrigger",
    "typeProperties": {
      "recurrence": {
        "frequency": <<Minute, Hour, Day, Week, Year>>,
        "interval": <<int>>, // How often to fire
        "startTime": <<datetime>>,
        "endTime": <<datetime>>,
        "timeZone": "UTC",
        "schedule": { // Optional (advanced scheduling specifics)
          "hours": [<<0-24>>],
          "weekDays": [<<Monday-Sunday>>],
          "minutes": [<<0-60>>],
          "monthDays": [<<1-31>>],
          "monthlyOccurrences": [
            {
              "day": <<Monday-Sunday>>,
              "occurrence": <<1-5>>
            }
          ]
        }
      }
    },
  "pipelines": [
    {
      "pipelineReference": {
        "type": "PipelineReference",
        "referenceName": "<Name of your pipeline>"
      },
      "parameters": {
        "<parameter 1 Name>": {
          "type": "Expression",
          "value": "<parameter 1 Value>"
        },
        "<parameter 2 Name>": "<parameter 2 Value>"
      }
    }
  ]}
}
```

> [!IMPORTANT]
> Свойство **parameters** является обязательным свойством для элемента **pipelines**. Если конвейер не принимает никаких параметров, необходимо включить пустое определение JSON для свойства **parameters**.

### <a name="schema-overview"></a>Общее представление схемы
Таблица ниже содержит обзор основных элементов схемы, связанных с периодичностью выполнения и расписанием триггера:

| Свойство JSON | Описание |
|:--- |:--- |
| **startTime** | Значение даты и времени. Для базовых расписаний значение свойства **startTime** применяется к первому выполнению. В сложных расписаниях триггер не запускается раньше, чем определяется значением **startTime**. |
| **endTime** | Дата и время завершения триггера. После указанной даты и времени триггер перестает выполняться. Значение свойства не может быть в прошлом. <!-- This property is optional. --> |
| **timeZone** | Часовой пояс. В настоящее время поддерживается только часовой пояс UTC. |
| **recurrence** | Объект recurrence указывает правила повторения для триггера. Этот объект поддерживает следующие элементы: **frequency**, **interval**, **endTime**, **count** и **schedule**. Если определен объект recurrence, элемент **frequency** является обязательным. Другие элементы объекта recurrence являются необязательными. |
| **frequency** | Единица частоты, с которой выполняется триггер. Поддерживаются следующие значения: "минута", "час", "день", "неделя" и "месяц". |
| **interval** | Положительное целое число, указывающее интервал для значения **frequency**, **которое** определяет, как часто выполняется триггер. Например, если **interval** имеет значение 3, а для элемента **frequency** выбран вариант week (неделя), триггер выполняется один раз каждые три недели. |
| **schedule** | Расписание повторения для триггера. Триггер с указанным значением **частоты** выполняется по расписанию. Свойство **schedule** содержит изменения для повторения, основанного на минутах, часах, неделях, днях месяца и номере недели.

### <a name="schedule-trigger-example"></a>Пример триггера расписания

```json
{
    "properties": {
        "name": "MyTrigger",
        "type": "ScheduleTrigger",
        "typeProperties": {
            "recurrence": {
                "frequency": "Hour",
                "interval": 1,
                "startTime": "2017-11-01T09:00:00-08:00",
                "endTime": "2017-11-02T22:00:00-08:00"
            }
        },
        "pipelines": [{
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "SQLServerToBlobPipeline"
                },
                "parameters": {}
            },
            {
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "SQLServerToAzureSQLPipeline"
                },
                "parameters": {}
            }
        ]
    }
}
```

### <a name="schema-defaults-limits-and-examples"></a>Параметры схемы по умолчанию, ограничения и примеры

| Свойство JSON | Тип | Обязательное значение | Значение по умолчанию | Допустимые значения | Пример |
|:--- |:--- |:--- |:--- |:--- |:--- |
| **startTime** | строка | Да | Отсутствуют | Дата и время по спецификации ISO 8601 | `"startTime" : "2013-01-09T09:30:00-08:00"` |
| **recurrence** | объект | Да | Отсутствуют | Объект recurrence | `"recurrence" : { "frequency" : "monthly", "interval" : 1 }` |
| **interval** | номер | Нет | 1 | От 1 до 1000 | `"interval":10` |
| **endTime** | строка | Да | Отсутствуют | Значение даты и времени, представляющее время в будущем. | `"endTime" : "2013-02-09T09:30:00-08:00"` |
| **schedule** | объект | Нет | Отсутствуют | Объект schedule | `"schedule" : { "minute" : [30], "hour" : [8,17] }` |

### <a name="starttime-property"></a>Свойство startTime
В следующей таблице показано, как свойство **startTime** управляет запуском триггера:

| Значение startTime | Повторение без расписания | Повторение с расписанием |
|:--- |:--- |:--- |
| **Время начала в прошлом** | Вычисляется время первого выполнения, относящееся к будущему времени, после указанного времени начала.<br /><br />Последующие выполнения производятся с учетом времени предыдущего выполнения.<br /><br />Пример представлен после этой таблицы. | Триггер выполняется _не раньше_ указанного времени начала. Первое выполнение производится по расписанию, которое отсчитывается от времени начала.<br /><br />Последующие выполнения производятся по расписанию повторов. |
| **Время начала в будущем или в настоящем** | Выполняется первый раз в указанное время начала.<br /><br />Последующие выполнения производятся с учетом времени предыдущего выполнения. | Триггер выполняется _не раньше_ указанного времени начала. Первое выполнение производится по расписанию, которое отсчитывается от времени начала.<br /><br />Последующие выполнения производятся по расписанию повторов. |

Рассмотрим, как работает триггер, для которого время начала установлено в прошлом, указан параметр recurrence и отсутствует параметр schedule. Предположим, что текущее время — 08.04.2017 13:00, время начала — 07.04.2017 14:00, а повторение — каждые два дня. (Значение **recurrence** определяется путем указания для свойства **frequency** значения "день", а для свойства **interval** значение 2.) Обратите внимание, что значение **startTime** находится в прошлом, то есть наступает раньше текущего времени.

В этих условиях первое выполнение происходит 09.04.2017 в 14:00. От времени начала ядро планировщика отсчитывает время повторных выполнений. Выполнения, которые приходятся на прошлое, игнорируются. Ядро берет очередной случай выполнения, который приходится на будущее. В этом случае время начала — 07.04.2017 в 14:00. Следующее выполнение состоится через 2 дня от этого времени начала, то есть 09.04.2017 в 14:00.

Время первого выполнения останется тем же даже при таких значениях **startTime**: 05.04.2017 в 14:00 или 01.04.2017 в 14:00. Все последующие выполнения после первого вычисляются по расписанию (свойство schedule). Таким образом, последующие выполнения проходят 11.04.2017 в 14:00, затем 13.04.2017 в 14:00, затем 15.04.2017 в 14:00 и т. д.

Наконец, когда часы или минуты не установлены в расписании триггера, часы или минуты первого выполнения используются как значения по умолчанию.

### <a name="schedule-property"></a>Свойство schedule
С помощью параметра **schedule** можно *ограничить* число выполнений триггера. Например, если триггеру назначена ежемесячная частота и параметр schedule, который запускает триггер только на 31-й день месяца, он будет выполняться только в те месяцы, в которых есть 31 день.

Кроме того, с помощью параметра **schedule** можно *увеличить* число выполнений триггера. Например, триггер с ежемесячной частотой и параметром schedule, который запускает триггер в 1 и 2 день месяца, будет выполняться в первый и второй дни месяца, а не раз в месяц.

Если для параметра **schedule** задано несколько элементов, они применяются в порядке от большего к меньшему: номер недели, число месяца, день недели, час и минута.

В следующей таблице элементы свойства **schedule** описаны подробно.

| Элемент JSON | Описание | Допустимые значения |
|:--- |:--- |:--- |
| **minutes** | Минуты часа, в которые будет выполняться триггер. |Целое число<br />Массив целых чисел|
| **hours** | Часы дня, в которые будет выполняться триггер. |Целое число<br />Массив целых чисел|
| **weekDays** | Дни недели, в которые будет выполняться триггер. Значение можно указать только с еженедельной частотой.|<br />monday<br />tuesday<br />wednesday<br />thursday<br />friday<br />saturday<br />sunday<br />Массив значений дня (максимальный размер массива — 7)<br /><br />Значения дня можно вводить в любом регистре|
| **monthlyOccurrences** | Дни месяца, по которым выполняется триггер. Значение можно указать только с ежемесячной частотой. |Массив объектов **monthlyOccurrence**: `{ "day": day, "occurrence": occurrence }`<br />Атрибут **day** является днем недели, в который выполняется триггер. Например, свойство **monthlyOccurrences** со значением **day** равным `{Sunday}` означает каждое воскресенье месяца. Атрибут **day** является обязательным.<br />Атрибут **occurrence** является частотой появления определенного **дня** на протяжении месяца. Например, свойство **monthlyOccurrences** со значением **day** и **occurrence** со значением `{Sunday, -1}` означает последнее воскресенье месяца. Атрибут **occurrence** не является обязательным.|
| **monthDays** | Дни месяца, по которым выполняется триггер. Значение можно указать только с ежемесячной частотой. |— любое значение <= -1 и >= -31;<br />— любое значение >= 1 и <= 31.<br />Массив значений|

## <a name="tumbling-window-trigger"></a>Триггер "переворачивающегося" окна
Триггер "переворачивающегося" окна — это тип триггера, который активируется с определенным интервалом начиная с указанного времени запуска, сохраняя состояние. "Переворачивающиеся" окна — это ряд неперекрывающихся и несоприкасающихся интервалов времени фиксированного размера.

Дополнительные сведения об этом типе триггеров и примеры см. в статье, посвященной [созданию триггера "переворачивающегося" окна](how-to-create-tumbling-window-trigger.md).

## <a name="event-based-trigger"></a>Триггер на основе событий

Триггеры на основе событий запускают конвейеры в ответ на событие, например поступление файла в хранилище BLOB-объектов Azure или удаление из него.

Дополнительные сведения см. в статье о [создании триггера, который запускает конвейер в ответ на событие](how-to-create-event-trigger.md).

## <a name="examples-of-trigger-recurrence-schedules"></a>Примеры расписаний повторения триггеров
Этот раздел содержит примеры расписания повторений с применением объекта **schedule** и его элементов.

В примерах предполагается, что **interval** имеет значение равное 1, а значение **frequency** является правильным согласно определению расписания. Например, у вас не может быть значения **frequency** "день" и изменения **monthDays** в объекте **schedule**. Такие ограничения описаны в таблице в предыдущем разделе.

| Пример | Описание |
|:--- |:--- |
| `{"hours":[5]}` | Выполняется каждый день в 05:00. |
| `{"minutes":[15], "hours":[5]}` | Выполняется каждый день в 05:15. |
| `{"minutes":[15], "hours":[5,17]}` | Выполняется каждый день в 05:15 и 16:15. |
| `{"minutes":[15,45], "hours":[5,17]}` | Выполняется каждый день в 05:15, 05:45, 16:15 и 16:45. |
| `{"minutes":[0,15,30,45]}` | Выполнение каждые 15 минут. |
| `{hours":[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}` | Выполнение каждый час.<br /><br />Этот триггер запускается каждый час. Минуты зависят от значения **startTime**, если оно указано. Если значение не указано, управление минутами осуществляется в соответствии с временем создания. Например, если триггер запущен или создан (в зависимости от ситуации) в 12:25, он будет запускаться в 00:25, 01:25, 02:25 и т. д. и 23:25.<br /><br />Это расписание работает так же, как триггер со значением **frequency** равным "hour", значением 1 для параметра **interval** и без параметра **schedule**. Это расписание можно использовать с различными значениями **частоты** и **интервала** для создания других триггеров. Например, если значение **frequency** — "month", расписание выполняется один раз в месяц, а не каждый день, когда **frequency** имеет значение "day". |
| `{"minutes":[0]}` | Задание выполняется с наступлением каждого часа.<br /><br />Этот триггер выполняется с наступлением каждого часа, начиная с 12:00, 13:00, 14:00 и т. д.<br /><br />Это расписание является эквивалентом триггера со значением **frequency** равным "hour" и значением **startTime** без минут или без объекта **schedule**, но со значением **frequency** "day". Если значение **frequency** равно "week" или "month", расписание выполняется только один раз в неделю или один раз в месяц соответственно. |
| `{"minutes":[15]}` | Задание выполняется через 15 минут после наступления каждого часа.<br /><br />Этот триггер выполняется через 15 минут после наступления каждого часа, начиная с 00:15, 01:15, 02:15 и т. д. и заканчивая в 23:15. |
| `{"hours":[17], "weekDays":["saturday"]}` | Задание выполняется в 17:00 каждую субботу. |
| `{"hours":[17], "weekDays":["monday", "wednesday", "friday"]}` | Задание выполняется в 17:00 в каждые понедельник, среду и пятницу. |
| `{"minutes":[15,45], "hours":[17], "weekDays":["monday", "wednesday", "friday"]}` | Задание выполняется в 17:15 и 17:45 в каждые понедельник, среду и пятницу. |
| `{"minutes":[0,15,30,45], "weekDays":["monday", "tuesday", "wednesday", "thursday", "friday"]}` | Задание выполняется каждые 15 минут в каждый рабочий день. |
| `{"minutes":[0,15,30,45], "hours": [9, 10, 11, 12, 13, 14, 15, 16] "weekDays":["monday", "tuesday", "wednesday", "thursday", "friday"]}` | Задание выполняется каждые 15 минут в период с 09:00 до 16:45 в каждый рабочий день. |
| `{"weekDays":["tuesday", "thursday"]}` | Задание выполняется по вторникам и четвергам в указанное время начала. |
| `{"minutes":[0], "hours":[6], "monthDays":[28]}` | Задание выполняется в 6:00 28-го числа каждого месяца (при условии, что значение **frequency** — "month"). |
| `{"minutes":[0], "hours":[6], "monthDays":[-1]}` | Задание выполняется в 06:00 в последний день месяца.<br /><br />Чтобы триггер запускался в последний день месяца, используйте "-1" вместо значения 28, 29, 30 или 31. |
| `{"minutes":[0], "hours":[6], "monthDays":[1,-1]}` | Задание выполняется в 06:00 в первый и последний день каждого месяца. |
| `{monthDays":[1,14]}` | Выполняется в первый и 14-й день каждого месяца в указанное время начала. |
| `{"minutes":[0], "hours":[5], "monthlyOccurrences":[{"day":"friday", "occurrence":1}]}` | Задание выполняется в первую пятницу каждого месяца в 05:00. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":1}]}` | Задание выполняется в первую пятницу каждого месяца в указанное время начала. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":-3}]}` | Задание выполняется в третью пятницу с конца каждого месяца в указанное время начала. |
| `{"minutes":[15], "hours":[5], "monthlyOccurrences":[{"day":"friday", "occurrence":1},{"day":"friday", "occurrence":-1}]}` | Задание выполняется в первую и последнюю пятницу каждого месяца в 05:15. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":1},{"day":"friday", "occurrence":-1}]}` | Задание выполняется в первую и последнюю пятницу каждого месяца в указанное время начала. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":5}]}` | Задание выполняется в пятую пятницу каждого месяца в указанное время начала.<br /><br />Оно не выполняется, если пятой пятницы в месяце нет. Чтобы триггер выполнялся в последнюю пятницу месяца, используйте вместо значения **повторения** 5 значение –1. |
| `{"minutes":[0,15,30,45], "monthlyOccurrences":[{"day":"friday", "occurrence":-1}]}` | Задание выполняется каждые 15 минут в последнюю пятницу месяца. |
| `{"minutes":[15,45], "hours":[5,17], "monthlyOccurrences":[{"day":"wednesday", "occurrence":3}]}` | Задание выполняется в 5:15, 5:45, 17:15, 17:45 в третью среду каждого месяца. |

## <a name="trigger-type-comparison"></a>Сравнение типов триггеров
Триггер "переворачивающегося" окна и триггер расписания работают с одинаковыми интервалами времени. Чем они отличаются?

В следующей таблице представлено сравнение триггера "переворачивающегося" окна и триггера расписания:

|  | Триггер "переворачивающегося" окна | Триггер планировщика |
|:--- |:--- |:--- |
| **Сценарии с задним числом** | Поддерживается. Выполнения конвейера можно запланировать для окон в прошлом. | Не поддерживается. Конвейер можно выполнить только в периоды времени в настоящем и будущем. |
| **Надежность** | 100 % надежность. Запуск конвейеров можно запланировать для всех окон с заданной датой начала без пробелов. | Меньшая надежность. |
| **Повторные попытки** | Поддерживается. При сбое запуска конвейера по умолчанию политика повторного запуска настроена на 0 повторных попыток. Или пользователь может указать количество повторных попыток в определении триггера. Автоматически выполняет повтор при сбое конвейера из-за ограничений параллелизма, сервера и регулирования (т. е. коды состояния "400: ошибка пользователя", "429: слишком много запросов" и "500: внутренняя ошибка сервера"). | Не поддерживается. |
| **Параллелизм** | Поддерживается. Пользователи могут явно задавать ограничения параллелизма для триггера. Триггер может параллельно запустить от 1 до 50 конвейеров. | Не поддерживается. |
| **Системные переменные** | Поддерживают использование системных переменных **WindowStart** и **WindowEnd**. Пользователи могут получить доступ к `triggerOutputs().windowStartTime` и `triggerOutputs().windowEndTime` как к системным переменным триггера в определении триггера. Значения используются как время начала и окончания окна соответственно. Например, для триггера "переворачивающегося" окна, выполняющегося каждый час, в окне от 1:00 до 2:00 определением является `triggerOutputs().WindowStartTime = 2017-09-01T01:00:00Z` и `triggerOutputs().WindowEndTime = 2017-09-01T02:00:00Z`. | Не поддерживается. |
| **Связь конвейера и триггера** | Поддерживает связь "один к одному". Вы можете активировать только один конвейер. | Поддерживает связи "многие ко многим" Несколько триггеров могут запускать один конвейер. Один триггер может запускать несколько конвейеров. |

## <a name="next-steps"></a>Следующие шаги
Ознакомьтесь со следующими руководствами:

- [Краткое руководство. Создание фабрики данных и конвейера с помощью пакета SDK .NET](quickstart-create-data-factory-dot-net.md)
- [Create a trigger that runs a pipeline on a schedule](how-to-create-schedule-trigger.md) (Создание триггера, запускающего конвейер по расписанию)
- [Create a trigger that runs a pipeline on a tumbling window](how-to-create-tumbling-window-trigger.md) (Создание триггера, который запускает конвейер в "переворачивающемся" окне)
