---
title: Функции выражений в функции потока данных сопоставления в фабрике данных Azure
description: Сведения о функциях выражений в сопоставлении потока данных.
author: kromerm
ms.author: makromer
ms.reviewer: daperlov
ms.service: data-factory
ms.topic: conceptual
ms.date: 02/15/2019
ms.openlocfilehash: c062a75516a1b865c1ff6c35f00d4fbf7c4881c6
ms.sourcegitcommit: 11265f4ff9f8e727a0cbf2af20a8057f5923ccda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/08/2019
ms.locfileid: "72029370"
---
# <a name="data-transformation-expressions-in-mapping-data-flow"></a>Выражения преобразования данных в потоке данных сопоставления 



## <a name="expression-functions"></a>Функции выражений

В фабрике данных используйте язык выражений функции потока данных сопоставления для настройки преобразований данных.

___
### <code>abs</code>
<code><b>abs(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Абсолютное значение числа.
* ``abs(-20) -> 20``
* ``abs(10) -> 10``
___
### <code>acos</code>
<code><b>acos(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Вычисляет значение арккосинус обратно * ``acos(1) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Добавляет пару строк или чисел. Добавляет дату к числу дней. Добавляет длительность в отметку времени. Добавляет один массив аналогичного типа к другому. То же, что и оператор + * ``add(10, 20) -> 30`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6 @ no__t-7 @ no__t-8 @ no__t-9<br/><br/>
Добавляет дни к дате или метке времени. Аналогичен оператору + для Date * ``addDays(toDate('2016-08-08'), 1) -> toDate('2016-08-09')`` @ no__t-1 @ no__t-2<br/><br/>
Добавление месяцев к дате или метке времени. При необходимости можно передать часовой пояс * ``addMonths(toDate('2016-08-31'), 1) -> toDate('2016-09-30')`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Логический оператор AND. То же, что & & * ``and(true, false) -> false`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Вычисляет обратное значение синуса * ``asin(0) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет обратное значение тангенса * ``atan(0) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает угол в радианах между положительной осью x плоскости и точкой, заданной координатами * ``atan2(0, 0) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает среднее значение столбца * ``avg(sales)`` @ no__t-1 @ no__t-2<br/><br/>
На основе критерия Возвращает среднее значение столбца * ``avgIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Выбирает значение столбца по имени в потоке. В качестве второго аргумента можно передать необязательное имя потока. При наличии нескольких совпадений возвращается первое совпадение. Если совпадений нет, возвращается значение NULL. Возвращаемое значение должно быть типом, преобразованным одной из функций преобразования типа (TO_DATE, TO_STRING...).  Имена столбцов, известные во время разработки, должны быть адресованы только по имени. Вычисленные входные данные не поддерживаются, но можно использовать подстановки параметров * ``toString(byName('parent'))`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6 @ no__t-7<br/><br/>
Выбирает значение столбца по относительному положению (1 на основе) в потоке. Если расположение выходит за пределы допустимого диапазона, возвращается значение NULL. Возвращаемое значение должно быть типом, преобразованным одной из функций преобразования типа (TO_DATE, TO_STRING...). Вычисленные входные данные не поддерживаются, но можно использовать подстановки параметров * ``toString(byPosition(1))`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6<br/><br/>
На основе чередующихся условий применяется одно или другое значение. Если число входов четное, другое значение по умолчанию равно NULL для последнего условия * ``case(10 + 20 == 30, 'dumbo', 'gumbo') -> 'dumbo'`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Вычисление корня Куба числа * ``cbrt(8) -> 2.0`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает наименьшее целое число, не меньшее числа * ``ceil(-0.1) -> 0`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает первое значение, не равное NULL, из набора входных данных. Все входные данные должны иметь один и тот же тип * ``coalesce(10, 20) -> 10`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Сравнивает два значения одного типа. Возвращает отрицательное целое число, если значение1 < value2, 0, если значение1 = = значение2, положительное значение, если значение1 > значение2 * ``(compare(12, 24) < 1) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Объединяет переменное количество строк. Аналогично оператору + со строками. * ``concat('dataflow', 'is', 'awesome') -> 'dataflowisawesome'``
* ``'dataflow' + 'is' + 'awesome' -> 'dataflowisawesome'``
* ``isNull('sql' + null) -> true``
___
### <code>concatWS</code>
<code><b>concatWS(<i>&lt;separator&gt;</i> : string, <i>&lt;this&gt;</i> : string, <i>&lt;that&gt;</i> : string, ...) => string</b></code><br/><br/>
Объединяет переменное количество строк с использованием разделителя. Первый параметр — Разделитель * ``concatWS(' ', 'dataflow', 'is', 'awesome') -> 'dataflow is awesome'`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Возвращает значение true, если любой элемент в предоставленном массиве принимает значение true в указанном предикате. Contains принимает ссылку на один элемент в функции предиката как #item * ``contains([1, 2, 3, 4], #item == 3) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Вычисляет значение косинуса * ``cos(10) -> -0.8390715290764524`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет гиперболический косинус значения * ``cosh(0) -> 1.0`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает совокупное количество значений. Если указаны необязательные столбцы, он игнорирует значения NULL в счетчике * ``count(custId)`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Возвращает совокупное число различных значений набора столбцов * ``countDistinct(custId, custName)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает совокупное количество значений на основе критериев. Если указан необязательный столбец, значения NULL игнорируются в счетчике * ``countIf(state == 'CA' && commission < 10000, name)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает ковариацию Генеральной совокупности между двумя столбцами * ``covariancePopulation(sales, profit)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия получает ковариацию Генеральной совокупности двух столбцов * ``covariancePopulationIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Получает Пример ковариации двух столбцов * ``covarianceSample(sales, profit)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия получает выборку ковариации двух столбцов * ``covarianceSampleIf(region == 'West', sales, profit)`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет хэш-код CRC32 набора столбцов различных примитивных типов данных с заданной разрядностью, которая может иметь только значения 0(256), 224, 256, 384, 512. Его можно использовать для вычисления отпечатка по строке * ``crc32(256, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> 3630253689L`` @ no__t-1 @ no__t-2<br/><br/>
Функция CumeDist вычисляет позицию значения относительно всех значений в разделе. Результатом является количество строк, предшествующих или равных текущей строке в упорядоченном наборе раздела, деленное на общее количество строк в разделе окна. Все привязку значений в упорядочении будут иметь ту же самую точку.
* ``cumeDist()``
___
### <code>currentDate</code>
<code><b>currentDate([<i>&lt;value1&gt;</i> : string]) => date</b></code><br/><br/>
Возвращает текущую дату начала выполнения этого задания. Вы можете передать дополнительный часовой пояс в формате GMT, PST, UTC, "Острова Кайман". По умолчанию используется локальный часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``currentDate() == toDate('2250-12-31') -> false``
* ``currentDate('PST')  == toDate('2250-12-31') -> false``
* ``currentDate('America/New_York')  == toDate('2250-12-31') -> false``
___
### <code>currentTimestamp</code>
<code><b>currentTimestamp() => timestamp</b></code><br/><br/>
Возвращает текущую метку времени, когда задание начинает выполняться с местным часовым поясом * ``currentTimestamp() == toTimestamp('2250-12-31 12:12:12') -> false`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает текущую метку времени в формате UTC. Если вы хотите, чтобы текущее время было интерпретировано на другом часовом поясе, отличном от часового пояса кластера, можно передать дополнительный часовой пояс в формате "GMT", "PST", "UTC", "America/Кайман". По умолчанию используется текущий часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.htmlTo. Преобразуйте время в формате UTC в другой часовой пояс, используйте Фромутк () * ``currentUTC() == toTimestamp('2050-12-12 19:18:12') -> false`` @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Возвращает день месяца с учетом даты * ``dayOfMonth(toDate('2018-06-08')) -> 8`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает день недели для заданной даты. 1 – воскресенье, 2-понедельник..., 7-Суббота * ``dayOfWeek(toDate('2018-06-08')) -> 6`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает день года, заданный в качестве даты * ``dayOfYear(toDate('2016-04-09')) -> 100`` @ no__t-1 @ no__t-2<br/><br/>
Длительность в миллисекундах для числа дней * ``days(2) -> 172800000L`` @ no__t-1 @ no__t-2<br/><br/>
Преобразует радианы в градусы * ``degrees(3.141592653589793) -> 180`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет ранг значения в группе значений. Результатом является единица плюс количество строк, предшествующих или равных текущей строке в упорядоченном наборе раздела. Значения не будут создавать промежутки в последовательности. Сжатый ранг работает даже в том случае, если данные не отсортированы и выполняется поиск изменений в значениях * ``denseRank(salesQtr, salesAmt)`` @ no__t-1 @ no__t-2<br/><br/>
Делит пару чисел. То же, что и оператор/* ``divide(20, 10) -> 2`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, заканчивается ли строка указанной строкой * ``endsWith('dumbo', 'mbo') -> true`` @ no__t-1 @ no__t-2<br/><br/>
Оператор сравнения на равенство. Аналогичен оператору = = * ``equals(12, 24) -> false`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6<br/><br/>
Оператор сравнения на равенство без учета регистра. То же, что < = > operator * ``'abc'<=>'Abc' -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Вычисление факториала числа * ``factorial(5) -> 120`` @ no__t-1 @ no__t-2<br/><br/>
Всегда возвращает значение false. Используйте синтаксис функции (false ()), если имеется столбец с именем "false" * ``(10 + 20 > 30) -> false`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Фильтрует элементы из массива, который не соответствует указанному предикату. Фильтр принимает ссылку на один элемент в функции предиката как #item * ``filter([1, 2, 3, 4], #item > 2) -> [3, 4]`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает первое значение группы столбцов. Если второй параметр Игноренуллс опущен, он принимает значение false * ``first(sales)`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает максимальное целое число, не большее числа * ``floor(-0.1) -> -1`` @ no__t-1 @ no__t-2<br/><br/>
Преобразует в отметку времени из времени в формате UTC. При необходимости можно передать часовой пояс в формате "GMT", "PST", "UTC", "America/Кайман". По умолчанию используется текущий Симпледатеформат Java Тимезонерефер для доступных форматов. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``fromUTC(currentTimeStamp()) == toTimestamp('2050-12-12 19:18:12') -> false``
* ``fromUTC(currentTimeStamp(), 'Asia/Seoul') != toTimestamp('2050-12-12 19:18:12') -> true``
___
### <code>greater</code>
<code><b>greater(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Оператор сравнения "больше". То же, что > оператор * ``greater(12, 24) -> false`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Оператор сравнения "больше чем или равно". То же, что и > = operator * ``greaterOrEqual(12, 12) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает наибольшее значение из списка значений, в котором пропускаются значения NULL. Возвращает значение null, если все входные данные имеют значение NULL * ``greatest(10, 30, 15, 20) -> 30`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Проверяет значение столбца по имени в потоке. В качестве второго аргумента можно передать необязательное имя потока.  Имена столбцов, известные во время разработки, должны быть адресованы только по имени. Вычисленные входные данные не поддерживаются, но можно использовать подстановки параметров * ``hasColumn('parent')`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает значение часа метки времени. Вы можете передать дополнительный часовой пояс в формате GMT, PST, UTC, "Острова Кайман". По умолчанию используется локальный часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``hour(toTimestamp('2009-07-30 12:58:59')) -> 12``
* ``hour(toTimestamp('2009-07-30 12:58:59'), 'PST') -> 12``
___
### <code>hours</code>
<code><b>hours(<i>&lt;value1&gt;</i> : integer) => long</b></code><br/><br/>
Продолжительность в миллисекундах для числа часов * ``hours(2) -> 7200000L`` @ no__t-1 @ no__t-2<br/><br/>
Сопоставляет каждый элемент массива с новым элементом, используя предоставленное выражение. Функция map принимает ссылку на один элемент в функции выражения как #item и ссылку на индекс элемента как #index * ``iMap([1, 2, 3, 4], #item + 2 + #index) -> [4, 6, 8, 10]`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от условия применяется одно или другое значение. Если другое значение не указано, оно считается нулевым. Оба значения должны быть совместимыми (numeric, String...) * ``iif(10 + 20 == 30, 'dumbo', 'gumbo') -> 'dumbo'`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Проверяет, что значение не равно NULL, и возвращает его, иначе возвращает альтернативный. Он проверяет все входные данные до тех пор, пока не найдет первое значение, отличное от NULL, * ``iifNull(10, 20) -> 10`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Проверяет, находится ли элемент в массиве * ``in([10, 20, 30], 10) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Преобразует первую букву каждого слова в верхний регистр. Слова обозначаются символами пробела * ``initCap('cool iceCREAM') -> 'Cool Icecream'`` @ no__t-1 @ no__t-2<br/><br/>
Находит позицию (на основе 1) подстроки в строке. 0 возвращается, если не найден * ``instr('dumbo', 'mbo') -> 3`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Проверяет, помечена ли строка для удаления. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isDelete()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, помечена ли строка как ошибка. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isError()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, помечена ли строка для игнорирования. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isIgnore()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, помечена ли строка для вставки. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isInsert()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет соответствие строки при поиске. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isMatch()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, имеет ли значение NULL * ``isNull(NULL()) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, помечена ли строка для обновления. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isUpdate()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, помечена ли строка для вставки. Для преобразований, использующих более одного входного потока, можно передать индекс потока (с 1). Значение по умолчанию для индекса потока — 1 * ``isUpsert()`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает эксцесс столбца * ``kurtosis(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия получает эксцесс столбца * ``kurtosisIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает значение первого параметра, вычислившего n строк перед текущей строкой. Второй параметр — число строк, которые необходимо просмотреть, а значение по умолчанию — 1. Если число строк не превышает допустимого значения, возвращается значение null, если не указано значение по умолчанию * ``lag(amount, 2)`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Возвращает последнее значение группы столбцов. Если второй параметр Игноренуллс опущен, он принимает значение false * ``last(sales)`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает последнюю дату месяца с учетом даты * ``lastDayOfMonth(toDate('2009-01-12')) -> toDate('2009-01-31')`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает значение первого параметра, вычислившего n строк после текущей строки. Вторым параметром является число строк, которые нужно найти вперед, а значение по умолчанию — 1. Если число строк не превышает допустимого значения, возвращается значение null, если не указано значение по умолчанию * ``lead(amount, 2)`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Оператор сравнения "меньше чем или равно". То же, что и < = operator * ``least(10, 30, 15, 20) -> 10`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Извлекает подстроку, начиная с индекса 1, с необходимым количеством знаков. То же, что и substring (STR, 1, n) * ``left('bojjus', 2) -> 'bo'`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает длину строки * ``length('dumbo') -> 5`` @ no__t-1 @ no__t-2<br/><br/>
Оператор сравнения "меньше". То же, что < оператор * ``lesser(12, 24) -> true`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Оператор сравнения "меньше чем или равно". То же, что и < = operator * ``lesserOrEqual(12, 12) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает Левенштейна расстояние между двумя строками * ``levenshtein('boys', 'girls') -> 4`` @ no__t-1 @ no__t-2<br/><br/>
Шаблон — это строка, которая сопоставляется буквально. Исключения являются следующими специальными символами: _ соответствует любому символу во входных данных (аналогично. в регулярных выражениях posix), % соответствует нулю или большему количеству знаков во входной строке (аналогично * в регулярных выражениях posix).
Escape-символом является ''. Если escape-символ предшествует специальному символу или другому escape-символу, следующий знак сопоставляется буквально. Недопустимо экранировать любые другие знаки.
* ``like('icecream', 'ice%') -> true``
___
### <code>locate</code>
<code><b>locate(<i>&lt;substring to find&gt;</i> : string, <i>&lt;string&gt;</i> : string, [<i>&lt;from index - 1-based&gt;</i> : integral]) => integer</b></code><br/><br/>
Находит позицию (на основе 1) подстроки в строке, начиная определение с определенной позиции. Если позиция опущена, то она отсчитывается с начала строки. 0 возвращается, если не найден * ``locate('mbo', 'dumbo') -> 3`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Вычисляет значение логарифма. При использовании * ``log(100, 10) -> 2`` @ no__t-1 @ no__t-2 можно указать необязательный базовый номер.<br/><br/>
Вычисляет значение журнала на основе 10 базовых * ``log10(100) -> 2`` @ no__t-1 @ no__t-2<br/><br/>
Строчные буквы строки * ``lower('GunChus') -> 'gunchus'`` @ no__t-1 @ no__t-2<br/><br/>
Слева дополняет строку прилагаемым отступом определенной длины. Если строка больше или равна длине, то она усекается до длины * ``lpad('dumbo', 10, '-') -> '-----dumbo'`` @ no__t-1 @ no__t-2 ' ' лпад (' Думбо ', 8, ' < > ')-> ' < > <dumbo'``
___
### <code>ltrim @ no__t-4 @ no__t-5<br/><br/>
Обрезает строку начальных знаков слева. Если второй параметр не указан, удаляются пробелы. В противном случае все символы, указанные во втором параметре, обрезаются * ``ltrim('  dumbo  ') -> 'dumbo  '`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Сопоставляет каждый элемент массива с новым элементом, используя предоставленное выражение. Функция map принимает ссылку на один элемент в функции выражения #item * ``map([1, 2, 3, 4], #item + 2) -> [3, 4, 5, 6]`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Возвращает максимальное значение столбца * ``max(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия получает максимальное значение столбца * ``maxIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет хэш-код MD5 набора столбцов с различными типами данных и возвращает шестнадцатеричную строку из 32 знаков. Его можно использовать для вычисления отпечатка по строке * ``md5(5, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> '4ce8a880bd621a1ffad0bca905e1bc5a'`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает среднее значение столбца. То же, что AVG * ``mean(sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает среднее значение столбца на основе критериев. То же, что и Авгиф * ``meanIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает значение миллисекунды для даты. Вы можете передать дополнительный часовой пояс в формате GMT, PST, UTC, "Острова Кайман". По умолчанию используется локальный часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``millisecond(toTimestamp('2009-07-30 12:58:59.871', 'yyyy-MM-dd HH:mm:ss.SSS')) -> 871``
___
### <code>milliseconds</code>
<code><b>milliseconds(<i>&lt;value1&gt;</i> : integer) => long</b></code><br/><br/>
Продолжительность в миллисекундах для числа миллисекунд * ``seconds(2) -> 2L`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает минимальное значение столбца. * ``min(sales)``
___
### <code>minIf</code>
<code><b>minIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
В зависимости от критерия получает минимальное значение столбца * ``minIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Вычитает числа. Вычитает количество дней из даты. Вычитание длительность из метки времени. Вычитание две метки времени, чтобы получить разницу в миллисекундах. То же, что и operator * ``minus(20, 10) -> 10`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6 @ no__t-7<br/><br/>
Возвращает значение минуты метки времени. Вы можете передать дополнительный часовой пояс в формате GMT, PST, UTC, "Острова Кайман". По умолчанию используется локальный часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``minute(toTimestamp('2009-07-30 12:58:59')) -> 58``
* ``minute(toTimestamp('2009-07-30 12:58:59'), 'PST') -> 58``
___
### <code>minutes</code>
<code><b>minutes(<i>&lt;value1&gt;</i> : integer) => long</b></code><br/><br/>
Длительность в миллисекундах для числа минут * ``minutes(2) -> 120000L`` @ no__t-1 @ no__t-2<br/><br/>
Модуль пары чисел. То же, что оператор% * ``mod(20, 8) -> 4`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает значение месяца для даты или метки времени * ``month(toDate('2012-8-8')) -> 8`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает число месяцев между двумя датами. Вычисление можно округлить. Можно передать дополнительный часовой пояс в формате "GMT", "PST", "UTC", "America/Кайман". По умолчанию используется локальный часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``monthsBetween(toTimestamp('1997-02-28 10:30:00'), toDate('1996-10-30')) -> 3.94959677``
___
### <code>multiply</code>
<code><b>multiply(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Умножает пару чисел. То же, что и оператор * * ``multiply(20, 10) -> 200`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Функция NTile делит строки для каждого раздела окна на `n` сегментов от 1 до `n`. Значения сегментов будут отличаться максимум на 1. Если количество строк в разделе не делится поровну на количество сегментов, то остальные значения распределяются по одному на сегмент, начиная с первого. Функция NTile полезна для вычисления тертилес, квартилей, децили и других общих сводных статистических данных. Функция вычисляет две переменные во время инициализации: Размер обычного контейнера будет добавлен к одной дополнительной строке. Обе переменные основаны на размере текущей секции. В процессе вычисления функция отслеживает текущее число строк, номер текущего сегмента и номер строки, на которой изменяется сегмент (bucketThreshold). Когда текущий номер строки достигает порога сегмента, значение сегмента увеличивается на единицу, а порог увеличивается на размер сегмента (плюс единица, если текущий сегмент заполняется).
* ``nTile()``
* ``nTile(numOfBuckets)``
___
### <code>negate</code>
<code><b>negate(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Инвертирует число. Превращает положительные числа в отрицательные и наоборот * ``negate(13) -> -13`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает следующую уникальную последовательность. Это число является последовательным только в пределах секции и имеет префикс partitionId * ``nextSequence() == 12313112 -> false`` @ no__t-1 @ no__t-2<br/><br/>
Нормализация строкового значения для разделения символов Юникода с диакритическими знаками * ``regexReplace(normalize('bo²s'), `\p{M}`, '') -> 'boys'`` @ no__t-1 @ no__t-2<br/><br/>
Оператор логического отрицания * ``not(true) -> false`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Оператор сравнения на неравенство. То же, что и! = оператор * ``12 != 24 -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает значение NULL. Используйте функцию syntax(null()), если есть столбец с именем null. Любая операция, которая использует, приведет к значению NULL * ``isNull('dumbo' + null) -> true`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6<br/><br/>
Логический оператор OR. То же, что и | | * ``or(true, false) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Положительный модуль пары чисел.
* ``pmod(-20, 8) -> 4``
___
### <code>partitionId</code>
<code><b>partitionId() => integer</b></code><br/><br/>
Возвращает идентификатор текущей секции, в которой находится входная строка * ``partitionId()`` @ no__t-1 @ no__t-2<br/><br/>
Порождает одно число в степень другого * ``power(10, 2) -> 100`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет ранг значения в группе значений. Результатом является единица плюс количество строк, предшествующих или равных текущей строке в упорядоченном наборе раздела. Значения будут создавать промежутки в последовательности. Ранжирование работает даже в том случае, если данные не отсортированы и выполняется поиск изменений в значениях * ``rank(salesQtr, salesAmt)`` @ no__t-1 @ no__t-2<br/><br/>
Накапливает элементы в массиве. Функция Reduce ждет ссылку на агрегат и один элемент в первой функции выражения как #acc и #item, и он ждет, что результирующее значение #resultся для использования во второй функции выражения * ``reduce([1, 2, 3, 4], 0, #acc + #item, #result) -> 10`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Извлекает соответствующую подстроку для данного шаблона регулярного выражения. Последний параметр идентифицирует группу для сопоставления и, если не указан, по умолчанию равен 1. Используйте "<regex>" (Обратная кавычка) для сопоставления строки без экранирования * ``regexExtract('Cost is between 600 and 800 dollars', '(\\d+) and (\\d+)', 2) -> '800'`` @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Проверяет, соответствует ли строка заданному шаблону регулярного выражения. Используйте "<regex>" (Обратная кавычка) для сопоставления строки без экранирования * ``regexMatch('200.50', '(\\d+).(\\d+)') -> true`` @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Заменить все вхождения шаблона регулярного выражения другой подстрокой в заданной строке использовать "<regex>" (Обратная кавычка) для сопоставления строки без экранирования * ``regexReplace('100 and 200', '(\\d+)', 'bojjus') -> 'bojjus and bojjus'`` @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Разделяет строку на основе разделителя на основе регулярного выражения и возвращает массив строк * ``regexSplit('bojjusAgunchusBdumbo', `[CAB]`) -> ['bojjus', 'gunchus', 'dumbo']`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Замена всех вхождений подстроки другой подстрокой в заданной строке. Если последний параметр пропущен, по умолчанию используется пустая строка * ``replace('doggie dog', 'dog', 'cat') -> 'catgie cat'`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Обращает строку * ``reverse('gunchus') -> 'suhcnug'`` @ no__t-1 @ no__t-2<br/><br/>
Извлекает подстроку с количеством знаков справа. То же, что и substring (STR, LENGTH (STR)-n, n) * ``right('bojjus', 2) -> 'us'`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Проверяет, соответствует ли строка заданному шаблону регулярного выражения * ``rlike('200.50', `(\d+).(\d+)`) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Округляет число, заданное необязательным масштабом, и необязательным режимом округления. Если масштаб не указан, по умолчанию используется значение 0.  Если этот режим опущен, по умолчанию используется значение ROUND_HALF_UP (5). Округление значений: 1-ROUND_UP 2-ROUND_DOWN 3-ROUND_CEILING 4-ROUND_FLOOR 5-ROUND_HALF_UP 6-ROUND_HALF_DOWN 7-ROUND_HALF_EVEN 8-ROUND_UNNECESSARY * ``round(100.123) -> 100.0`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Назначает последовательную нумерацию строк для строк в окне, начиная с 1 * ``rowNumber()`` @ no__t-1 @ no__t-2<br/><br/>
Дополняет строку прилагаемым отступом справа до достижения определенной длины. Если строка больше или равна длине, то она усекается до длины * ``rpad('dumbo', 10, '-') -> 'dumbo-----'`` @ no__t-1 @ no__t-2 @ no__t-3rtrim @ no__t-4 @ no__t-5<br/><br/>
Обрезает строку начальных знаков справа. Если второй параметр не указан, удаляются пробелы. В противном случае все символы, указанные во втором параметре, обрезаются * ``rtrim('  dumbo  ') -> '  dumbo'`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Возвращает второе значение даты. Вы можете передать дополнительный часовой пояс в формате GMT, PST, UTC, "Острова Кайман". По умолчанию используется локальный часовой пояс. Сведения о доступных форматах см. в разделе Симпледатеформат Java. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``second(toTimestamp('2009-07-30 12:58:59')) -> 59``
___
### <code>seconds</code>
<code><b>seconds(<i>&lt;value1&gt;</i> : integer) => long</b></code><br/><br/>
Длительность в миллисекундах для числа секунд * ``seconds(2) -> 2000L`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет хэш-код SHA-1 набора столбцов с различными типами данных и возвращает шестнадцатеричную строку из 40 знаков. Его можно использовать для вычисления отпечатка по строке * ``sha1(5, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> '46d3b478e8ec4e1f3b453ac3d8e59d5854e282bb'`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет дайджест SHA-2 для набора столбцов различных примитивных типов данных с битовой длиной, которая может иметь только значения 0 (256), 224, 256, 384, 512. Его можно использовать для вычисления отпечатка по строке * ``sha2(256, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> 'afe8a553b1761c67d76f8c31ceef7f71b66a1ee6f4e6d3b5478bf68b47d06bd3'`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет значение синуса * ``sin(2) -> 0.9092974268256817`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет гиперболический синус значения * ``sinh(0) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает асимметрию столбца * ``skewness(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия получает асимметрию столбца * ``skewnessIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Извлекает подмножество массива из позиции. Позиция отсчитывается от единицы. Если длина опущена, по умолчанию используется конец строки * ``slice([10, 20, 30, 40], 1, 2) -> [10, 20]`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6 @ no__t-7<br/><br/>
Сортирует массив с помощью предоставленной функции предиката. Функция Sort принимает ссылку на два последовательных элемента в функции выражения как #item1 и #item2 * ``sort([4, 8, 2, 3], compare(#item1, #item2)) -> [2, 3, 4, 8]`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает код SOUNDEX для строки * ``soundex('genius') -> 'G520'`` @ no__t-1 @ no__t-2<br/><br/>
Разделяет строку на основе разделителя и возвращает массив строк * ``split('bojjus,guchus,dumbo', ',') -> ['bojjus', 'guchus', 'dumbo']`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6 @ no__t-7 @ no__t-8.<br/><br/>
Вычисляет квадратный корень числа * ``sqrt(9) -> 3`` @ no__t-1 @ no__t-2<br/><br/>
Проверяет, начинается ли строка с указанной строки * ``startsWith('dumbo', 'du') -> true`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает стандартное отклонение столбца * ``stdDev(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия возвращает стандартное отклонение столбца * ``stddevIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает среднеквадратичное отклонение совокупности для столбца * ``stddevPopulation(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия возвращает стандартное отклонение совокупности для столбца * ``stddevPopulationIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает стандартное отклонение выборки для столбца * ``stddevSample(sales)`` @ no__t-1 @ no__t-2<br/><br/>
На основе критерия возвращает стандартное отклонение выборки для столбца * ``stddevSampleIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Вычтите месяцы из даты или метки времени. То же, что оператор-operator для Date * ``subDays(toDate('2016-08-08'), 1) -> toDate('2016-08-07')`` @ no__t-1 @ no__t-2<br/><br/>
Вычесть месяцы из даты или метки времени * ``subMonths(toDate('2016-09-30'), 1) -> toDate('2016-08-31')`` @ no__t-1 @ no__t-2<br/><br/>
Извлекает подстроку определенной длины из заданной позиции. Позиция отсчитывается от единицы. Если длина опущена, по умолчанию используется конец строки * ``substring('Cat in the hat', 5, 2) -> 'in'`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Возвращает статистическую сумму числового столбца * ``sum(col)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает статистическую сумму различных значений числового столбца * ``sumDistinct(col)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает общую сумму числового столбца на основе критериев. Условие может быть основано на любом столбце * ``sumDistinctIf(state == 'CA' && commission < 10000, sales)`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Возвращает общую сумму числового столбца на основе критериев. Условие может быть основано на любом столбце * ``sumIf(state == 'CA' && commission < 10000, sales)`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Вычисляет значение тангенса * ``tan(0) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Вычисляет гиперболический тангенс значения * ``tanh(0) -> 0.0`` @ no__t-1 @ no__t-2<br/><br/>
Преобразует все числовые значения типа Date, timestamp и String в двоичное представление * ``toBinary(3) -> [0x11]`` @ no__t-1 @ no__t-2<br/><br/>
Преобразует значения ('t ', ' true ', ' y ', ' YES ', ' 1 ') в true и (' f ', ' false ', ' n ', ' No ', ' 0 ') в значение false и NULL для любого другого значения * ``toBoolean('true') -> true`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Преобразует входную строку даты в дату, используя необязательный входной формат даты. Сведения о доступных форматах см. в разделе Симпледатеформат Java. Если входной формат даты опущен, по умолчанию используется формат YYYY-[M] M-[d] d. Допустимые форматы: [гггг, гггг-[M] M, гггг-[M] M-[d] d, гггг-[M] M-[d] dT *] * ``toDate('2012-8-18') -> toDate('2012-08-18')`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Преобразует любое числовое значение или строку в десятичное значение. Если точность и масштаб не указаны, по умолчанию используется значение (10,2). Для преобразования можно использовать необязательный десятичный формат Java. Необязательный формат языкового стандарта в формате BCP47, например en-US, de, zh-CN * ``toDecimal(123.45) -> 123.45`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Преобразует любое числовое значение или строку в двойное значение. Для преобразования может использоваться дополнительный десятичный формат Java. Необязательный формат языкового стандарта в формате BCP47, например en-US, de, zh-CN * ``toDouble(123.45) -> 123.45`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5<br/><br/>
Преобразует любое числовое или строковое значение в плавающее. Для преобразования может использоваться дополнительный десятичный формат Java. Усекает любой двойной * ``toFloat(123.45) -> 123.45f`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Преобразует любое числовое или строковое значение в целое число. Для преобразования может использоваться дополнительный десятичный формат Java. Усекает все длинные, float, Double * ``toInteger(123) -> 123`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Преобразует любое числовое или строковое значение в длинное. Для преобразования может использоваться дополнительный десятичный формат Java. Усекает любой тип float, Double * ``toLong(123) -> 123`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Преобразует любое числовое или строковое значение в короткое. Для преобразования может использоваться дополнительный десятичный формат Java. Усекает любое целое число, Long, float, Double * ``toShort(123) -> 123`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Преобразует примитивный тип данных в строку. Для чисел и даты можно указать формат. Если формат не задан, выбирается значение по умолчанию. Для чисел используется десятичный формат Java, Все возможные форматы даты см. в разделе Java Симпледатеформат. Формат по умолчанию: гггг-мм-дд * ``toString(10) -> '10'`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6 @ no__t-7 @ no__t-8 @ no__t-9<br/><br/>
Преобразует строку в метку времени по указанному необязательному формату метки времени. Для всех возможных форматов используйте Java Симпледатеформат. Если метка времени пропущена, используется шаблон по умолчанию. гггг-[M] M-[d] d чч: мм: СС [. f...]. Можно передать дополнительный часовой пояс в формате "GMT", "PST", "UTC", "America/Кайман". Метка времени поддерживает точность в миллисекундах со значением 999Refer Java Симпледатеформат для доступных форматов. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``toTimestamp('2016-12-31 00:12:00') -> toTimestamp('2016-12-31 00:12:00')`` @ no__t-2 @ no__t-3 @ no__t-4 @ no__t-5 @ no__t-6<br/><br/>
Преобразует метку времени в формат UTC. Вы можете передать дополнительный часовой пояс в формате GMT, PST, UTC, "Острова Кайман". По умолчанию используется текущий Симпледатеформат Java Тимезонерефер для доступных форматов. https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html * ``toUTC(currentTimeStamp()) == toTimestamp('2050-12-12 19:18:12') -> false``
* ``toUTC(currentTimeStamp(), 'Asia/Seoul') != toTimestamp('2050-12-12 19:18:12') -> true``
___
### <code>translate</code>
<code><b>translate(<i>&lt;string to translate&gt;</i> : string, <i>&lt;lookup characters&gt;</i> : string, <i>&lt;replace characters&gt;</i> : string) => string</b></code><br/><br/>
Заменяет один набор знаков другим набором знаков в строке. Символы имеют от 1 до 1 замены * ``translate('(bojjus)', '()', '[]') -> '[bojjus]'`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Обрезает строку начальных и конечных знаков. Если второй параметр не указан, удаляются пробелы. В противном случае все символы, указанные во втором параметре, обрезаются * ``trim('  dumbo  ') -> 'dumbo'`` @ no__t-1 @ no__t-2 @ no__t-3.<br/><br/>
Всегда возвращает истинное значение. Используйте синтаксис функции (true ()), если имеется столбец с именем "true" * ``(10 + 20 == 30) -> true`` @ no__t-1 @ no__t-2 @ no__t-3<br/><br/>
Сопоставляет тип столбца. Может использоваться только в выражениях шаблонов. число соответствует Short, Integer, Long, Double, float или Decimal, целочисленные совпадения Short, Integer, Long, дробные совпадения с типом данных Double, float, Decimal и DateTime соответствуют типу Date или timestamp * ``typeMatch(type, 'number')`` @ no__t-1 @ no__t-2 @ no__ t-3<br/><br/>
Строка в верхнем регистре * ``upper('bojjus') -> 'BOJJUS'`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает созданный UUID * ``uuid()`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает дисперсию столбца * ``variance(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия Получает дисперсию столбца * ``varianceIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает дисперсию генеральной совокупности для столбца * ``variancePopulation(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия Получает дисперсию генеральной совокупности столбца * ``variancePopulationIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает несмещенную дисперсию столбца * ``varianceSample(sales)`` @ no__t-1 @ no__t-2<br/><br/>
В зависимости от критерия получает несмещенную дисперсию столбца * ``varianceSampleIf(region == 'West', sales)`` @ no__t-1 @ no__t-2<br/><br/>
Возвращает неделю года с заданными датой * ``weekOfYear(toDate('2008-02-20')) -> 8`` @ no__t-1 @ no__t-2<br/><br/>
Длительность в миллисекундах для числа недель * ``weeks(2) -> 1209600000L`` @ no__t-1 @ no__t-2<br/><br/>
Логический оператор XOR. Аналогичен оператору ^ * ``xor(true, false) -> true`` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4<br/><br/>
Возвращает значение года для даты * ``year(toDate('2012-8-8')) -> 2012``

## <a name="next-steps"></a>Следующие шаги

[Узнайте, как использовать построитель выражений](concepts-data-flow-expression-builder.md).
