---
title: Балансировка нагрузки секций между несколькими экземплярами в концентраторах событий Azure | Документация Майкрософт
description: Описывает, как сбалансировать нагрузку секций между несколькими экземплярами приложения с помощью обработчика событий и пакета SDK концентраторов событий Azure.
services: event-hubs
documentationcenter: .net
author: ShubhaVijayasarathy
editor: ''
ms.service: event-hubs
ms.devlang: na
ms.topic: conceptual
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 01/16/2020
ms.author: shvija
ms.openlocfilehash: 1244fe64d0c23782fdae7a0f92415bada4bef55a
ms.sourcegitcommit: 67e9f4cc16f2cc6d8de99239b56cb87f3e9bff41
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/31/2020
ms.locfileid: "76907660"
---
# <a name="balance-partition-load-across-multiple-instances-of-your-application"></a>Балансировка нагрузки секций между несколькими экземплярами приложения
Чтобы масштабировать приложение обработки событий, можно запустить несколько экземпляров приложения и распределить нагрузку между ними. В более ранних версиях [EventProcessorHost](event-hubs-event-processor-host.md) позволили сбалансировать нагрузку между несколькими экземплярами программы и событиями контрольной точки при получении. В более новых версиях (5,0 и выше) **евентпроцессорклиент** (.NET и Java) или **евенсубконсумерклиент** (Python и JavaScript) позволяют делать то же самое. Модель разработки упрощается с помощью событий. Подпишитесь на интересующие вас события, зарегистрировав обработчик событий.

В этой статье описывается пример сценария использования нескольких экземпляров для чтения событий из концентратора событий, а затем предоставляются сведения о функциях клиента обработчика событий, что позволяет одновременно получить события из нескольких секций и распределить нагрузку между ними. потребители, использующие один и тот же концентратор событий и группу потребителей.

> [!NOTE]
> Масштабирование в Центрах событий базируется на идее секционированных потребителей. В отличие от шаблона [конкурирующих потребителей](https://msdn.microsoft.com/library/dn568101.aspx), секционированный потребительский шаблон обеспечивает высокий уровень масштабирования путем удаления конфликтного узкого места и упрощения сквозного параллелизма.

## <a name="example-scenario"></a>Пример сценария

В качестве примера рассмотрим компанию по обеспечению безопасности дома, которая отслеживает 100 000 домов. Каждую минуту она получает данные из различных датчиков, таких как детектор движения, Открытый датчик открытия дверцы или окна, детектор прозрачного стекла и т. д., установленный в каждом домашнем компьютере. Компания предоставляет веб-сайт для жителей, чтобы наблюдать за деятельностью своего дома почти в реальном времени.

Каждый датчик отправляет данные в концентратор событий. Концентратор событий настроен на 16 секций. В конечном итоге нужен механизм, который может считывать эти события, консолидировать их (фильтровать, агрегировать и т. д.) и выгружать статистическое выражение в хранилище BLOB-объектов, которое затем проецируется на удобную для пользователя страницу.

## <a name="write-the-consumer-application"></a>Написание приложения-потребителя

При создании потребителя в распределенной среде сценарий должен удовлетворять следующие требования:

1. **Масштаб.** Создайте несколько потребителей и каждый потребитель возьмет на себя ответственность за чтение нескольких секций Центров событий.
2. **Балансировка нагрузки.** Изменяйте количество потребителей динамически. Например, при добавлении нового типа датчика в каждый дом (например, детектора угарного газа) увеличивается число событий. В этом случае оператор (человек) увеличивает число экземпляров потребителя. Затем пул потребителей может перебалансировать количество секций, которыми они владеют, для распределения нагрузки на вновь добавленных потребителей.
3. **Простое возобновление при сбоях:** Если потребитель (**потребитель a**) завершается сбоем (например, виртуальная машина, на которой размещается потребитель, неожиданно завершает работу), другие потребители могут выбрать секции, принадлежащие **потребителю a** , и продолжить. Кроме того, точка продолжения, называемая *контрольной точкой* или *смещением*, должна находиться в точке пересечения, в которой произошел сбой **потребителя А**, или немного раньше этого.
4. **Использовать события:** Хотя предыдущие три точки связаны с управлением потребителем, необходим код для использования событий и выполнения каких-либо полезных действий с ним. Например, вычислить его и передать в хранилище BLOB-объектов.

## <a name="event-processor-or-consumer-client"></a>Обработчик событий или клиент-потребитель

Вам не нужно создавать собственное решение для удовлетворения этих требований. Эти функции предоставляются пакетами SDK концентраторов событий Azure. В пакетах SDK для .NET или Java используется клиент обработчика событий (Евентпроцессорклиент), а в комплектах SDK для Python и Java — Евенсубконсумерклиент. В старой версии пакета SDK использовался узел обработчика событий (EventProcessorHost), который поддерживал эти функции.

В большинстве рабочих сценариев рекомендуется использовать клиент обработчика событий для чтения и обработки событий. Клиент процессора предназначен для обеспечения надежной работы при обработке событий во всех секциях концентратора событий в работоспособном и отказоустойчивом режиме, предоставляя средства для создания контрольной точки хода выполнения. Клиенты обработчика событий также способны работать совместно в контексте группы потребителей для данного концентратора событий. Клиенты будут автоматически управлять распределением и балансировкой работы по мере того, как экземпляры становятся доступными или недоступными для группы.

## <a name="partition-ownership-tracking"></a>Отслеживание владения секциями

Экземпляр обработчика событий обычно владеет и обрабатывает события из одной или нескольких секций. Владение секциями равномерно распределяется среди всех активных экземпляров обработчика событий, связанных с сочетанием концентратора событий и группы потребителей. 

Каждому обработчику событий присваивается уникальный идентификатор и право владения секциями путем добавления или обновления записи в хранилище контрольных точек. Все экземпляры обработчиков событий периодически взаимодействуют с этим хранилищем для обновления своего состояния обработки, а также для получения сведений о других активных экземплярах. Эти данные затем используются для балансировки нагрузки между активными процессорами. Новые экземпляры могут присоединиться к пулу обработки для увеличения масштаба. При отказе экземпляров из-за сбоев или уменьшения уровня владения Секция надлежащим образом передается другим активным процессорам.

Записи владения секциями в хранилище контрольных точек отслеживают пространство имен концентраторов событий, имя концентратора событий, группу потребителей, идентификатор обработчика событий (также известный как владелец), идентификатор секции и время последнего изменения.



| пространство имен Центров событий;               | имя концентратора событий; | **Группа потребителей** | Владелец                                | Partition ID | Время последнего изменения  |
| ---------------------------------- | -------------- | :----------------- | :----------------------------------- | :----------- | :------------------ |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | 3be3f9d3-9d9e-4c50-9491-85ece8334ff6 | 0            | 2020-01-15T01:22:15 |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | f5cc5176-ce96-4bb4-bbaa-a0e3a9054ecf | 1            | 2020-01-15T01:22:17 |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | 72b980e9-2efc-4ca7-ab1b-ffd7bece8472 | 2            | 2020-01-15T01:22:10 |
|                                    |                | :                  |                                      |              |                     |
|                                    |                | :                  |                                      |              |                     |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | 844bd8fb-1f3a-4580-984d-6324f9e208af | 15           | 2020-01-15T01:22:00 |

Каждый экземпляр обработчика событий получает владение секцией и начинает обработку секции из последней известной [контрольной точки](# Checkpointing). Если произошел сбой процессора (виртуальная машина завершает работу), другие экземпляры обнаруживают это, просмотрев время последнего изменения. Другие экземпляры пытаются стать владельцем секций, которые ранее принадлежали неактивному экземпляру, а хранилище контрольных точек гарантирует, что только один из экземпляров будет выполнен в результате запроса на владение секцией. Таким образом, в любой момент времени существует не более одного процессора, получающего события из секции.

## <a name="receive-messages"></a>Получение сообщений

При создании обработчика событий указываются функции, которые будут обрабатывать события и ошибки. Каждый вызов функции, обрабатывающей события, доставляет одно событие из определенной секции. Вы отвечаете за обработку этого события. Если вы хотите убедиться, что потребитель обрабатывает каждое сообщение по крайней мере один раз, необходимо написать собственный код с помощью логики повторных попыток. Но учитывайте при этом возможность получения поврежденных сообщений.

Рекомендуется выполнять задачи относительно быстро. То есть, как можно меньше обработки. Если вам нужно писать в хранилище и выполнить некоторую маршрутизацию, лучше использовать две группы потребителей и два обработчика событий.

## <a name="checkpointing"></a>Контрольные точки

*Контрольные точки* — это процесс, с помощью которого обработчик событий помечает или фиксирует расположение последней успешной обработки события в секции. Пометка контрольной точки обычно выполняется внутри функции, которая обрабатывает события и выполняется для каждого раздела в группе потребителей. 

Если обработчик событий отключается от секции, другой экземпляр может возобновить обработку секции на контрольной точке, которая ранее была зафиксирована последним процессором этого раздела в этой группе потребителей. При подключении процессора передает смещение концентратору событий, чтобы указать расположение, с которого начинается чтение. Таким образом можно использовать контрольные точки для пометки событий как "завершенных" подчиненными приложениями и обеспечения устойчивости при отключении обработчика событий. Вы можете вернуться к предыдущим данным, указав более низкое значение смещения по отношению к этому процессу создания контрольных точек. 

Когда выполняется контрольная точка для пометки события как обработанного, запись в хранилище контрольных точек добавляется или обновляется с использованием смещения и порядкового номера события. Пользователи должны выбрать частоту обновления контрольной точки. Обновление после каждого успешно обработанного события может повлиять на производительность и затраты, так как оно запускает операцию записи в базовое хранилище контрольных точек. Кроме того, контрольные точки для каждого отдельного события свидетельствуют о шаблоне обмена сообщениями в очереди, для которого очередь служебной шины может быть лучшим вариантом, чем концентратор событий. Идея Центров событий заключается в том, что вы получаете доставку по принципу "хотя бы раз" в масштабе. Благодаря тому, что ваши идемпотентные нисходящие системы легко восстанавливаются после сбоев или перезапуска, это приводит к тому, что одни и те же события принимаются несколько раз.

## <a name="thread-safety-and-processor-instances"></a>Потокобезопасность и экземпляры процессора

По умолчанию обработчик событий или потребитель является потокобезопасным и ведет себя синхронно. При получении события для секции вызывается функция, которая обрабатывает события. Последующие сообщения и вызовы этой функции помещаются в очередь в фоновом режиме, так как конвейер сообщений по мере продолжения выполняется в фоне других потоков. Потокобезопасность устраняет потребность в потокобезопасной коллекции и значительно повышает производительность.

## <a name="next-steps"></a>Дальнейшие действия
См. следующие краткие руководства.

- [.NET Core](get-started-dotnet-standard-send-v2.md)
- [Java](event-hubs-java-get-started-send.md)
- [Python](get-started-python-send-v2.md)
- [JavaScript](get-started-node-send-v2.md)
