---
title: OAuth 2.0 неявного потока грантов - платформа идентификации Microsoft (ru) Azure
description: Безопасные одностраничные приложения с использованием неявного потока идентификационных данных платформы Майкрософт.
services: active-directory
documentationcenter: ''
author: rwike77
manager: CelesteDG
editor: ''
ms.assetid: 3605931f-dc24-4910-bb50-5375defec6a8
ms.service: active-directory
ms.subservice: develop
ms.workload: identity
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: conceptual
ms.date: 11/19/2019
ms.author: ryanwi
ms.reviewer: hirsin
ms.custom: aaddev
ms.openlocfilehash: 53d498f4aed8ec86cc57c35824a9fb8aa471dc1d
ms.sourcegitcommit: 7581df526837b1484de136cf6ae1560c21bf7e73
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/31/2020
ms.locfileid: "80419683"
---
# <a name="microsoft-identity-platform-and-implicit-grant-flow"></a>Платформа идентификации Майкрософт и неявный поток грантов

С помощью конечной точки платформы Майкрософт вы можете подписать пользователей в приложения с одной страницей как с личными, так и рабочими или школьными учетными записями от корпорации Майкрософт. Во время проверки подлинности одностраничные и другие приложения JavaScript, которые запускаются в основном в браузере, сталкиваются с некоторыми проблемами.

* Характеристики безопасности этих приложений значительно отличаются от традиционных серверных веб-приложений.
* Многие серверы авторизации и поставщики удостоверений не поддерживают запросы CORS.
* Полностраничный браузер перенаправляет пользователя из приложения, взаимодействие с которым становится особенно агрессивным.

Для этих приложений (Angular, Ember.js, React.js и так далее) платформа microsoft identity поддерживает поток неявного гранта OAuth 2.0. Подробное описание неявного потока данных см. в [спецификации OAuth 2.0](https://tools.ietf.org/html/rfc6749#section-4.2). Его основное преимущество заключается в том, что он позволяет приложению получать токены с платформы идентификации Microsoft без выполнения обмена учетными данными сервера бэкэнда. Так, приложение может авторизовать пользователей, поддерживать сеансы и получать маркеры для других веб-API — и все это из клиентского кода JavaScript. Во время использования неявного потока данных необходимо обращать внимание на некоторые важные вопросы безопасности, касающиеся [клиента](https://tools.ietf.org/html/rfc6749#section-10.3) и [маскировки под другого пользователя](https://tools.ietf.org/html/rfc6749#section-10.3).

В этой статье описывается, как запрограммировать непосредственно против протокола в приложении.  Когда это возможно, мы рекомендуем вам использовать поддерживаемые библиотеки подлинности Майкрософт (MSAL) вместо того, чтобы [приобретать токены и вызывать защищенные web-aIS.](authentication-flows-app-scenarios.md#scenarios-and-supported-authentication-flows)  Также взгляните на [образец приложений, которые используют MSAL](sample-v2-code.md).

Но в одностраничном приложении можно обойтись без использования библиотеки. Отправлять сообщения протокола в таком случае нужно самостоятельно. Для этого выполните следующие шаги.

> [!NOTE]
> Не все сценарии и функции Azure Active Directory (Azure AD) поддерживаются конечными точками платформы идентификации Майкрософт. Чтобы определить, следует ли использовать конечную точку платформы идентификации Майкрософт, прочитайте об [ограничениях платформы идентификации Майкрософт.](active-directory-v2-limitations.md)

## <a name="suitable-scenarios-for-the-oauth2-implicit-grant"></a>Подходящие сценарии для неявного предоставления OAuth2

В спецификации OAuth2 указано, что неявное предоставление разработано для поддержки приложений агента пользователя, то есть выполняемых в браузере приложений JavaScript. Определяющей характеристикой таких приложений является использование кода JavaScript для доступа к ресурсам сервера (обычно к веб-API) и для обновления пользовательского интерфейса приложения. Рассмотрим такие приложения, как Gmail или Outlook Web Access. При выборе входящего сообщения, чтобы отобразить новое выделение, изменяется только область визуализации, в то время как остальная часть страницы остается неизменной. В этом заключается их отличие от традиционных веб-приложений на основе перенаправления, в которых при каждом действии пользователя выполняется обратная передача всей страницы и полная отрисовка нового ответа сервера.

Приложения, в которых концепция JavaScript используется наиболее полно, называются одностраничными. Такие приложения передают только начальную HTML-страницу и связанный с ней объект JavaScript, а все последующие операции выполняются в виде вызовов веб-API через JavaScript. Но нередко используются и гибридные методы, когда приложение в основном выполняет обратную передачу, а иногда — отдельные вызовы через JavaScript. Информация об использовании неявного потока применима и для таких приложений.

Приложения на основе перенаправления традиционно защищают свои запросы с помощью файлов cookie, но этот метод не очень хорошо подходит для приложений JavaScript. Файлы cookie действуют только для того домена, в котором они были созданы, тогда как вызовы JavaScript могут направляться и в другие домены. И такая ситуация возникает довольно часто, например, для любых приложений, которые вызывают API-интерфейсы Microsoft Graph, Office или Azure. Все эти службы интерфейсов расположены за пределами домена, из которого получено приложение. Все чаще в приложениях JavaScript не бывает серверной части, а для реализации ее бизнес-функций полностью используются сторонние веб-API.

В настоящее время для защиты вызовов к веб-API рекомендуется использовать токены носителя OAuth2, которые прилагаются к каждому вызову интерфейса. Веб-API проверяет входящий маркер доступа и предоставляет доступ к запрошенной операции, если соблюдены все необходимые условия. Неявный поток предоставляет приложениям JavaScript удобный механизм получения маркеров доступа для веб-API, а также множество преимуществ по сравнению с использованием файлов cookie.

* Маркеры можно получать безопасно, не выполняя междоменные вызовы. Обязательная регистрация URI перенаправления, на который возвращаются маркеры, гарантирует, что они не будут направлены в неправильное расположение.
* Приложения JavaScript могут получать любое необходимое количество маркеров доступа для обращения к любому количеству веб-API без ограничений по доменам.
* Возможности HTML5, например управления сеансом или локальным хранилищем, предоставляют полный контроль над кэшированием и управлением временем существования маркеров, тогда как управление файлами cookie является непрозрачным для приложения.
* Токены доступа не подвержены атакам кросс-сайта запроса (CSRF)

Неявный поток предоставления не выдает маркеры обновления, преимущественно в целях безопасности. Токен обновления не так узко масштабируется, как маркеры доступа, предоставляя гораздо больше энергии, следовательно, нанося гораздо больший ущерб в случае утечки. В неявном потоке токены поставляются в URL, следовательно, риск перехвата выше, чем в гранте кода авторизации.

Тем не менее приложения JavaScript используют другой механизм обновления маркеров доступа, который не предусматривает многократное запрашивание учетных данных пользователя. Для выполнения новых запросов маркеров к конечной точке авторизации Azure AD приложение может использовать скрытый элемент iframe. Пока в браузере открыт сеанс в домене Azure AD (т. е. сохраняется файл cookie сеанса), при запросе проверки подлинности не нужно взаимодействие с пользователем.

Эта модель дает приложению JavaScript возможность независимо обновлять маркеры доступа и даже получать новые для новых API (при условии, что пользователь ранее согласился на это). Это избавляет от накладных расходов на получение, обслуживание и защиту такого ценного артефакта, как маркер обновления. Управление файлом cookie сеанса Azure AD, т. е. артефактом, который позволяет выполнять автоматическое обновление маркера доступа, происходит вне приложения. У этого подхода есть и другое преимущество: пользователь может выйти из Azure AD, используя любое из приложений, с помощью которого был выполнен вход в Azure AD, запущенного в любой из вкладок браузера. При этом удаляется файл cookie сеанса Azure AD, и приложение JavaScript автоматически теряет возможность обновлять маркеры для пользователя, выполнившего выход.

## <a name="is-the-implicit-grant-suitable-for-my-app"></a>Совместимость неявного предоставления с приложением

Неявное предоставление сопряжено с большими рисками, чем другие типы предоставления. Сферы, требующие особого внимания, хорошо задокументированы (например, [неправильное использование маркера доступа для олицетворения владельца ресурса в неявном потоке][OAuth2-Spec-Implicit-Misuse] и [модели угроз и рекомендации по безопасности в OAuth 2.0][OAuth2-Threat-Model-And-Security-Implications]). Но высокий риск связан преимущественно с тем, что предоставление позволяет использовать приложения с активным кодом, который отправляется из удаленного ресурса в браузер. Если у вас нет серверных компонентов приложения, если вы намерены использовать архитектуру безопасной проверки пароля или вызывать веб-API через JavaScript, мы рекомендуем использовать неявный поток получения маркеров.

Если ваше приложение является родным клиентом, неявный поток не подходит. Отсутствие файла cookie для сеанса Azure AD в контексте собственного клиента не позволит вашему приложению поддерживать длительные сеансы. Это означает, что приложение будет регулярно запрашивать разрешение пользователя при получении маркеров доступа для новых ресурсов.

При разработке веб-приложения с серверной частью, которая будет использовать API из серверного кода, также не рекомендуется использовать неявный поток. Другие варианты предоставления маркера дают намного больше возможностей. Например, предоставление учетных данных клиента OAuth2 позволяет получать маркеры с указанием разрешений для конкретного приложения, а не для пользователя. Это означает, что клиент сможет программно поддерживать доступ к ресурсам, даже когда пользователь не участвует в сеансе, и т. д. Кроме того, такое предоставление обеспечивает более высокий уровень безопасности. Например, токены доступа никогда не проходят через браузер пользователя, они не рискуют быть сохраненными в истории браузера и так далее. Клиентское приложение может выполнять при запросе маркера строгую проверку подлинности.

[OAuth2-Spec-Implicit-Misuse]: https://tools.ietf.org/html/rfc6749#section-10.16
[OAuth2-Threat-Model-And-Security-Implications]: https://tools.ietf.org/html/rfc6819

## <a name="protocol-diagram"></a>Схема протокола

На следующей схеме показано, как выглядит весь неявный входной поток. В последующих разделах каждый шаг описывается более подробно.

![Диаграмма, показывающая неявный поток входной системы](./media/v2-oauth2-implicit-grant-flow/convergence-scenarios-implicit.svg)

## <a name="send-the-sign-in-request"></a>Отправка запроса на вход

Чтобы первоначально войти пользователя в ваше приложение, вы можете отправить запрос `id_token` на аутентификацию [OpenID Connect](v2-protocols-oidc.md) и получить его из конечных точек платформы Майкрософт.

> [!IMPORTANT]
> Чтобы успешно запросить токен ID и/или токен доступа, регистрация приложения на [портале Azure - страница регистрации приложений](https://go.microsoft.com/fwlink/?linkid=2083908) должна иметь соответствующий неявный поток грантов, выбрав **токены и.или** доступ к **токенам** в разделе **Неявного гранта.** Если он не включен, `unsupported_response` ошибка будет возвращена: **для этого клиента не допускается предоставленное значение для входиного параметра "response_type". Ожидаемое значение 'код'**

```
// Line breaks for legibility only

https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize?
client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&response_type=id_token
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F
&scope=openid
&response_mode=fragment
&state=12345
&nonce=678910
```

> [!TIP]
> Чтобы протестировать подписание при использовании неявного потока, нажмите <a href="https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=6731de76-14a6-49ae-97bc-6eba6914391e&response_type=id_token&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F&scope=openid&response_mode=fragment&state=12345&nonce=678910" target="_blank"> https://login.microsoftonline.com/common/oauth2/v2.0/authorize..кнопку .</a> После входе в систему `https://localhost/myapp/` ваш браузер `id_token` должен быть перенаправлен в адресную строку.
>

| Параметр |  | Описание |
| --- | --- | --- |
| `tenant` | обязательно |Значение `{tenant}` в пути запроса можно использовать для того, чтобы контролировать, кто может входить в приложение. Допустимые значения: `common`, `organizations`, `consumers`, а также идентификаторы клиента. Дополнительные сведения см. в [описании протоколов](active-directory-v2-protocols.md#endpoints). |
| `client_id` | обязательно | Идентификатор приложения (клиента), который имеет [сявок портала Azure -](https://go.microsoft.com/fwlink/?linkid=2083908) страница регистраций приложений, назначенная вашему приложению. |
| `response_type` | обязательно |Должен включать `id_token` для входа в OpenID Connect. Этот параметр также может содержать значение `token` параметра response_type (тип ответа). Использование `token` здесь позволяет приложению получать токен доступа непосредственно от конечной точки авторизации, при этом отправлять новый запрос на вход в эту конечную точку не требуется. Если вы `token` используете `scope` response_type, параметр должен содержать область, указывающую на то, для какого ресурса выдать токен (например, user.read on Microsoft Graph).  |
| `redirect_uri` | рекомендуется |URI перенаправления приложения, на который можно отправлять ответы проверки подлинности для их получения приложением. Он должен в точности соответствовать одному из URI перенаправления, зарегистрированных на портале, но иметь форму закодированного URL-адреса. |
| `scope` | обязательно |Разделенный пространством список [областей.](v2-permissions-and-consent.md) Для OpenID Connect (id_tokens) он `openid`должен включать область действия, которая переводится как разрешение "Подписать вас" в uI-разъеме согласия. Возможно, вы также захотите `email` `profile` включить и области для получения доступа к дополнительным данным пользователей. Вы также можете включить другие области в этот запрос для запроса согласия на различные ресурсы, если запрашивается токен доступа. |
| `response_mode` | необязательный |Указывает метод, с помощью которого результирующий маркер будет отправлен приложению. По умолчанию запрашивает только токен доступа, но фрагментирует, если запрос включает id_token. |
| `state` | рекомендуется |Значение, включенное в запрос, которое также возвращается в ответе маркера. Это может быть строка любого контента. Случайно сгенерированное уникальное значение обычно используется для [предотвращения атак подделки запросов на кросс-сайт.](https://tools.ietf.org/html/rfc6749#section-10.12) Параметр "state" также используется для кодирования информации о состоянии пользователя в приложении перед созданием запроса на проверку подлинности, например информации об открытой на тот момент странице или представлении. |
| `nonce` | обязательно |Значение, включенное в запрос и созданное приложением, которое войдет в состав полученного токена "id_token" в качестве утверждения. Приложение может проверить это значение во избежание атак с использованием воспроизведения токена. Это значение обычно представляет собой случайную уникальную строку, которую можно использовать для определения источника запроса. Требуется только при запросе id_token. |
| `prompt` | необязательный |Указывает требуемый тип взаимодействия с пользователем. На текущий момент единственные допустимые значения — login, none, select_account и consent. При значении `prompt=login` пользователю придется вводить учетные данные по запросу. Единый вход не сработает. `prompt=none`наоборот - это будет гарантировать, что пользователь не представлен с какой-либо интерактивный запрос бы то ни было. Если запрос не может быть выполнен в режиме бесшумно с помощью одного знака, конечная точка платформы Майкрософт вернет ошибку. `prompt=select_account` отправляет пользователя в средство выбора учетных записей, где будут отображаться все учетные записи, запомненные в сеансе. Если установить значение `prompt=consent`, то после входа пользователь увидит диалоговое окно согласия OAuth с запросом на предоставление разрешений приложению. |
| `login_hint`  |необязательный |Можно применять для предварительного заполнения поля имени пользователя или электронного адреса на странице входа пользователя (если имя пользователя известно заранее). Зачастую этот параметр используется в приложениях при повторной проверке подлинности. При этом имя пользователя извлекается во время предыдущего входа с помощью утверждения `preferred_username`.|
| `domain_hint` | необязательный |Если он будет включен, он пропустит процесс обнаружения на основе электронной почты, который пользователь проходит на знак е-странице, что приведет к немного более обтекаемой пользовательской работы. Это обычно используется для бизнес-приложений Line of Business, которые работают в одном арендаторе, где они предоставят доменное имя в пределах данного арендатора.  Это будет направлено пользователю поставщику федерации для этого арендатора.  Обратите внимание, что это не позволит гостям войти в это приложение.  |

На текущем этапе пользователю придется ввести учетные данные и завершить проверку подлинности. Конечная точка платформы идентификации Майкрософт также гарантирует, что пользователь `scope` дал согласие на разрешения, указанные в параметре запроса. Если пользователь **не предоставил** какие-либо из этих разрешений, конечная точка запросит их у пользователя. Дополнительные сведения см. в статье [Разрешения и предоставление согласия в конечной точке Azure Active Directory версии 2.0](v2-permissions-and-consent.md).

Как только пользователь удостоверяет подлинность и предоставляет согласие, конечная точка платформы Майкрософт возвращает ответ вашему приложению в указанном, `redirect_uri`используя метод, указанный в параметре. `response_mode`

#### <a name="successful-response"></a>Успешный ответ

Успешный ответ с использованием `response_mode=fragment` и `response_type=id_token+token` выглядит следующим образом (разрывы строк — для удобства чтения):

```
GET https://localhost/myapp/#
&token_type=Bearer
&expires_in=3599
&id_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...
&state=12345
```

| Параметр | Описание |
| --- | --- |
| `access_token` |Указывается, если параметр `response_type` содержит значение `token`. Маркер доступа, запрошенный приложением. Токен доступа не должен быть расшифрован или иным образом проверен, он должен рассматриваться как непрозрачная строка. |
| `token_type` |Указывается, если параметр `response_type` содержит значение `token`. Всегда будет использоваться значение `Bearer`. |
| `expires_in`|Указывается, если параметр `response_type` содержит значение `token`. Указывает количество секунд, в течение которых маркер остается допустимым (для кэширования). |
| `scope` |Указывается, если параметр `response_type` содержит значение `token`. Указывает области, для которых будет допустимым access_token. Может не включать все запрошенные области, если они не применимы к пользователю (в случае запроса только областей Azure AD при входе в систему учетная запись). |
| `id_token` | Подписанный JSON Web Token (JWT). Приложение может декодировать сегменты этого токена, чтобы запрашивать сведения о пользователе, выполнившем вход. Приложение может кэшировать значения и отображать их, но оно не должно полагаться на них для каких-либо разрешений или границ безопасности. Для получения дополнительной информации [`id_token reference`](id-tokens.md)о id_tokens, см. <br> **Примечание.** Предоставляется, только если подан запрос на область `openid`. |
| `state` |Если запрос содержит параметр "state", в ответе должно отображаться то же значение. Приложение должно проверить, совпадают ли значения параметра "state" в запросе и ответе. |

#### <a name="error-response"></a>Сообщение об ошибке

Сообщения об ошибках также можно отправлять на `redirect_uri` , чтобы приложение обрабатывало их должным образом:

```
GET https://localhost/myapp/#
error=access_denied
&error_description=the+user+canceled+the+authentication
```

| Параметр | Описание |
| --- | --- |
| `error` |Строка кода ошибки, которую можно использовать для классификации типов возникающих ошибок и реагирования на них. |
| `error_description` |Конкретное сообщение об ошибке, с помощью которого разработчик может определить причину возникновения ошибки проверки подлинности. |

## <a name="getting-access-tokens-silently-in-the-background"></a>Получение токенов доступа молча в фоновом режиме

Теперь, когда вы зарегистрировали пользователя в одностраничное приложение, вы можете бесшумно получить токены доступа для вызова web-aIS, защищенных платформой идентификации Майкрософт, например [Microsoft Graph.](https://developer.microsoft.com/graph) Даже если вы уже получили токен с использованием параметра response_type со значением `token`, этот метод можно использовать для получения токенов к дополнительным ресурсам. При наличии этих токенов пользователям не нужно повторно выполнять вход.

В обычном потоке OpenID Connect/OAuth вы сделаете это, `/token` сделав запрос в конечную точку платформы Майкрософт. Тем не менее, конечная точка платформы идентификации Майкрософт не поддерживает запросы CORS, поэтому о том, чтобы AJAX было не оспорить вызовы для получения и обновления токенов, не может быть и речи. Вместо этого для получения новых маркеров для других веб-API можно использовать неявный поток данных в скрытом iframe.

```
// Line breaks for legibility only

https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize?
client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&response_type=token
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F
&scope=https%3A%2F%2Fgraph.microsoft.com%2Fuser.read
&response_mode=fragment
&state=12345
&nonce=678910
&prompt=none
&login_hint=myuser@mycompany.com
```

Дополнительные сведения о параметрах запроса в URL-адресе см. в разделе [Отправка запроса на вход](#send-the-sign-in-request).

> [!TIP]
> Попробуйте скопировать и вставить запрос, показанный ниже, на вкладку браузера. (Не забудьте заменить значения `login_hint` на правильное значение для вашего пользователя.)
>
>`https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=6731de76-14a6-49ae-97bc-6eba6914391e&response_type=token&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F&scope=https%3A%2F%2Fgraph.microsoft.com%2Fuser.read&response_mode=fragment&state=12345&nonce=678910&prompt=none&login_hint={your-username}`
>

Благодаря параметру `prompt=none` этот запрос успешно выполнится или немедленно завершится с ошибкой, и вы вернетесь к своему приложению. Успешный ответ будет отправлен в ваше приложение на указанный `redirect_uri` с помощью метода, заданного в параметре `response_mode`.

#### <a name="successful-response"></a>Успешный ответ

Успешный ответ с использованием метода `response_mode=fragment` выглядит следующим образом:

```
GET https://localhost/myapp/#
access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...
&state=12345
&token_type=Bearer
&expires_in=3599
&scope=https%3A%2F%2Fgraph.microsoft.com%2Fdirectory.read
```

| Параметр | Описание |
| --- | --- |
| `access_token` |Указывается, если параметр `response_type` содержит значение `token`. Это маркер доступа, запрошенный приложением. В данном случае для Microsoft Graph. Токен доступа не должен быть расшифрован или иным образом проверен, он должен рассматриваться как непрозрачная строка. |
| `token_type` | Всегда будет использоваться значение `Bearer`. |
| `expires_in` | Указывает количество секунд, в течение которых маркер остается допустимым (для кэширования). |
| `scope` | Указывает области, для которых будет допустимым access_token. Может не включать все запрошенные области, если они не применимы к пользователю (в случае запроса только областей Azure AD при входе в систему учетная запись). |
| `id_token` | Подписанный JSON Web Token (JWT). Указывается, если параметр `response_type` содержит значение `id_token`. Приложение может декодировать сегменты этого токена, чтобы запрашивать сведения о пользователе, выполнившем вход. Приложение может кэшировать значения и отображать их, но оно не должно полагаться на них для каких-либо разрешений или границ безопасности. Для получения дополнительной информации [ `id_token` ](id-tokens.md)о id_tokens, см. <br> **Примечание.** Предоставляется, только если подан запрос на область `openid`. |
| `state` |Если запрос содержит параметр "state", в ответе должно отображаться то же значение. Приложение должно проверить, совпадают ли значения параметра "state" в запросе и ответе. |

#### <a name="error-response"></a>Сообщение об ошибке

Сообщения об ошибках также можно отправлять на `redirect_uri` , чтобы приложение правильно обрабатывало их. Если вы используете `prompt=none`, отобразится следующая ошибка.

```
GET https://localhost/myapp/#
error=user_authentication_required
&error_description=the+request+could+not+be+completed+silently
```

| Параметр | Описание |
| --- | --- |
| `error` |Строка кода ошибки, которую можно использовать для классификации типов возникающих ошибок и реагирования на них. |
| `error_description` |Конкретное сообщение об ошибке, с помощью которого разработчик может определить причину возникновения ошибки проверки подлинности. |

После появления этой ошибки в запросе iframe пользователю необходимо войти еще раз в интерактивном режиме для получения нового маркера. Этот случай можно обрабатывать любым способом, который лучше всего подходит для вашего приложения.

## <a name="refreshing-tokens"></a>Обновление маркеров

Неявное предоставление не обеспечивает маркеры обновления. Срок действия маркеров `id_token` и `access_token` очень короткий, поэтому приложение должно быть готово периодически обновлять их. Чтобы обновить любой тип маркера, можно выполнить тот же `prompt=none` скрытый запрос iframe сверху, используя параметр для управления поведением платформы идентификации. Если вы хотите получить `id_token`новый, `id_token` не `response_type` забудьте использовать в и, `scope=openid`а также `nonce` параметр.

## <a name="send-a-sign-out-request"></a>Отправка запроса на выход

OpenID Connect `end_session_endpoint` позволяет приложению отправлять запрос в конечную точку платформы Майкрософт, чтобы закончить сеанс пользователя, и очистить файлы cookie, установленные конечными точками платформы Microsoft. Чтобы пользователь полностью вышел из веб-приложения, приложение должно завершить свой сеанс пользователя (обычно с помощью очистки кэша маркеров или файлов cookie), а затем перенаправить браузер на:

```
https://login.microsoftonline.com/{tenant}/oauth2/v2.0/logout?post_logout_redirect_uri=https://localhost/myapp/
```

| Параметр |  | Описание |
| --- | --- | --- |
| `tenant` |обязательно |Значение `{tenant}` в пути запроса можно использовать для того, чтобы контролировать, кто может входить в приложение. Допустимые значения: `common`, `organizations`, `consumers`, а также идентификаторы клиента. Дополнительные сведения см. в [описании протоколов](active-directory-v2-protocols.md#endpoints). |
| `post_logout_redirect_uri` | рекомендуется | URL-адрес, на который следует возвратить пользователя после выхода. Это значение должно соответствовать одному из универсальных кодов ресурсов (URI) перенаправления, зарегистрированных для приложения. Если пользователь не включен, он будет показан общий текст сообщения конечным пунктом платформы идентификации Майкрософт. |

## <a name="next-steps"></a>Следующие шаги

* Перейдите на страницу [примеров MSAL JS](sample-v2-code.md), чтобы приступить к созданию кода.
