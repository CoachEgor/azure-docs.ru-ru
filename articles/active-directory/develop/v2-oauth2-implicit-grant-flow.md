---
title: Неявный поток предоставления OAuth 2,0 — платформа Microsoft Identity | Службы
description: Защита одностраничных приложений с помощью неявного потока платформы идентификации Майкрософт.
services: active-directory
author: hpsin
manager: CelesteDG
ms.service: active-directory
ms.subservice: develop
ms.workload: identity
ms.topic: conceptual
ms.date: 11/19/2019
ms.author: hirsin
ms.reviewer: hirsin
ms.custom: aaddev
ms.openlocfilehash: fbe74b62352babf7a1fdd93bf19a6e1475e3f032
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2020
ms.locfileid: "85553578"
---
# <a name="microsoft-identity-platform-and-implicit-grant-flow"></a>Платформа удостоверений Майкрософт и неявный поток предоставления

Конечная точка платформы идентификации Майкрософт позволяет подписывать пользователей в одностраничных приложениях с помощью личных и рабочих учетных записей Майкрософт. Во время проверки подлинности одностраничные и другие приложения JavaScript, которые запускаются в основном в браузере, сталкиваются с некоторыми проблемами.

* Характеристики безопасности этих приложений значительно отличаются от традиционных серверных веб-приложений.
* Многие серверы авторизации и поставщики удостоверений не поддерживают запросы CORS.
* Полностраничный браузер перенаправляет пользователя из приложения, взаимодействие с которым становится особенно агрессивным.

Для этих приложений (угловой, Ember.js, React.js и т. д.) платформа Microsoft Identity поддерживает неявный поток предоставления OAuth 2,0. Подробное описание неявного потока данных см. в [спецификации OAuth 2.0](https://tools.ietf.org/html/rfc6749#section-4.2). Его основное преимущество заключается в том, что оно позволяет приложению получать маркеры от платформы Microsoft Identity, не выполняя обмен учетными данными внутреннего сервера. Это позволяет приложениям выполнять вход пользователя, поддерживать сеансы и получать маркеры для доступа к другим веб-API прямо из кода JavaScript в клиенте. Во время использования неявного потока данных необходимо обращать внимание на некоторые важные вопросы безопасности, касающиеся [клиента](https://tools.ietf.org/html/rfc6749#section-10.3) и [маскировки под другого пользователя](https://tools.ietf.org/html/rfc6749#section-10.3).

В этой статье описывается, как программировать непосредственно в протокол в приложении.  По возможности рекомендуется использовать поддерживаемые библиотеки проверки подлинности Майкрософт (MSAL) вместо [получения маркеров и вызова защищенных веб-API](authentication-flows-app-scenarios.md#scenarios-and-supported-authentication-flows).  Также ознакомьтесь с [примерами приложений, которые используют MSAL](sample-v2-code.md).

Но в одностраничном приложении можно обойтись без использования библиотеки. Отправлять сообщения протокола в таком случае нужно самостоятельно. Для этого выполните следующие шаги.

## <a name="suitable-scenarios-for-the-oauth2-implicit-grant"></a>Подходящие сценарии для неявного предоставления OAuth2

В спецификации OAuth2 указано, что неявное предоставление разработано для поддержки приложений агента пользователя, то есть выполняемых в браузере приложений JavaScript. Определение характеристик таких приложений заключается в том, что код JavaScript используется для доступа к ресурсам сервера (обычно веб-API) и для обновления пользовательского интерфейса приложения соответствующим образом. Рассмотрим такие приложения, как Gmail или Outlook Web Access. При выборе входящего сообщения, чтобы отобразить новое выделение, изменяется только область визуализации, в то время как остальная часть страницы остается неизменной. В этом заключается их отличие от традиционных веб-приложений на основе перенаправления, в которых при каждом действии пользователя выполняется обратная передача всей страницы и полная отрисовка нового ответа сервера.

Приложения, в которых концепция JavaScript используется наиболее полно, называются одностраничными. Идея состоит в том, что эти приложения обслуживают только начальную HTML-страницу и связанный с ними код JavaScript, при этом все последующие взаимодействия управляются через вызовы веб-API, выполняемые через JavaScript. Но нередко используются и гибридные методы, когда приложение в основном выполняет обратную передачу, а иногда — отдельные вызовы через JavaScript. Информация об использовании неявного потока применима и для таких приложений.

Приложения на основе перенаправления традиционно защищают свои запросы с помощью файлов cookie, но этот метод не очень хорошо подходит для приложений JavaScript. Файлы cookie действуют только для того домена, в котором они были созданы, тогда как вызовы JavaScript могут направляться и в другие домены. И такая ситуация возникает довольно часто, например, для любых приложений, которые вызывают API-интерфейсы Microsoft Graph, Office или Azure. Все эти службы интерфейсов расположены за пределами домена, из которого получено приложение. Растущий тренд для приложений JavaScript заключается в отсутствии серверной части, которая полагается на 100% на веб-API сторонних производителей, чтобы реализовать свои деловые функции.

В настоящее время предпочтительным методом защиты вызовов к веб-API является использование токена носителя OAuth2, где каждый вызов сопровождается маркером доступа OAuth2. Веб-API проверяет входящий маркер доступа и, если он находит необходимые области, предоставляет доступ к запрошенной операции. Неявный поток предоставляет удобный механизм для приложений JavaScript, позволяющий получать маркеры доступа для веб-API, предлагая многочисленные преимущества в отношении файлов cookie:

* Маркеры можно получать безопасно, не выполняя междоменные вызовы. Обязательная регистрация URI перенаправления, на который возвращаются маркеры, гарантирует, что они не будут направлены в неправильное расположение.
* Приложения JavaScript могут получить столько маркеров доступа, сколько требуется, для любого числа веб-API, для которых они предназначены, без ограничений на домены.
* Возможности HTML5, например управления сеансом или локальным хранилищем, предоставляют полный контроль над кэшированием и управлением временем существования маркеров, тогда как управление файлами cookie является непрозрачным для приложения.
* Маркеры доступа не подвержены атакам подделки запросов между сайтами (CSRF)

Неявный поток предоставления не выдает маркеры обновления, преимущественно в целях безопасности. Маркер обновления не настолько ограничен, как маркеры доступа, что дает гораздо больше электроэнергии, поэтому инфликтинг гораздо больше повреждений в случае утечки. В неявном потоке маркеры доставляются в URL-адресе, поэтому риск перехвата выше, чем в предоставлении кода авторизации.

Тем не менее приложения JavaScript используют другой механизм обновления маркеров доступа, который не предусматривает многократное запрашивание учетных данных пользователя. Для выполнения новых запросов маркеров к конечной точке авторизации Azure AD приложение может использовать скрытый элемент iframe. Пока в браузере открыт сеанс в домене Azure AD (т. е. сохраняется файл cookie сеанса), при запросе проверки подлинности не нужно взаимодействие с пользователем.

Эта модель дает приложению JavaScript возможность независимо обновлять маркеры доступа и даже получать новые для новых API (при условии, что пользователь ранее согласился на это). Это избавляет от накладных расходов на получение, обслуживание и защиту такого ценного артефакта, как маркер обновления. Управление файлом cookie сеанса Azure AD, т. е. артефактом, который позволяет выполнять автоматическое обновление маркера доступа, происходит вне приложения. У этого подхода есть и другое преимущество: пользователь может выйти из Azure AD, используя любое из приложений, с помощью которого был выполнен вход в Azure AD, запущенного в любой из вкладок браузера. При этом удаляется файл cookie сеанса Azure AD, и приложение JavaScript автоматически теряет возможность обновлять маркеры для пользователя, выполнившего выход.

## <a name="is-the-implicit-grant-suitable-for-my-app"></a>Совместимость неявного предоставления с приложением

Неявное предоставление сопряжено с большими рисками, чем другие типы предоставления. Сферы, требующие особого внимания, хорошо задокументированы (например, [неправильное использование маркера доступа для олицетворения владельца ресурса в неявном потоке][OAuth2-Spec-Implicit-Misuse] и [модели угроз и рекомендации по безопасности в OAuth 2.0][OAuth2-Threat-Model-And-Security-Implications]). Но высокий риск связан преимущественно с тем, что предоставление позволяет использовать приложения с активным кодом, который отправляется из удаленного ресурса в браузер. Если вы планируете архитектуру SPA, не имеете серверных компонентов или планируете вызывать веб-API через JavaScript, рекомендуется использовать неявный поток для получения маркера.

Если приложение является собственным клиентом, неявный поток не подходит. Отсутствие файла cookie для сеанса Azure AD в контексте собственного клиента не позволит вашему приложению поддерживать длительные сеансы. Это означает, что приложение будет регулярно запрашивать разрешение пользователя при получении маркеров доступа для новых ресурсов.

При разработке веб-приложения с серверной частью, которая будет использовать API из серверного кода, также не рекомендуется использовать неявный поток. Другие варианты предоставления маркера дают намного больше возможностей. Например, предоставление учетных данных клиента OAuth2 позволяет получать маркеры с указанием разрешений для конкретного приложения, а не для пользователя. Это означает, что клиент сможет программно поддерживать доступ к ресурсам, даже когда пользователь не участвует в сеансе, и т. д. Кроме того, такое предоставление обеспечивает более высокий уровень безопасности. Например, маркеры доступа никогда не передаются через пользовательский браузер, они не могут быть сохранены в журнале браузера и т. д. Клиентское приложение может выполнять при запросе маркера строгую проверку подлинности.

[OAuth2-Spec-Implicit-Misuse]: https://tools.ietf.org/html/rfc6749#section-10.16
[OAuth2-Threat-Model-And-Security-Implications]: https://tools.ietf.org/html/rfc6819

## <a name="protocol-diagram"></a>Схема протокола

На следующей схеме представлен весь неявный поток входа, а каждый его шаг подробно описан в следующих разделах.

![Схема, показывающая неявный поток входа](./media/v2-oauth2-implicit-grant-flow/convergence-scenarios-implicit.svg)

## <a name="send-the-sign-in-request"></a>Отправка запроса на вход

Чтобы изначально подписать пользователя в приложении, можно отправить запрос на проверку подлинности [OpenID Connect Connect](v2-protocols-oidc.md) и получить `id_token` из конечной точки платформы идентификации Майкрософт.

> [!IMPORTANT]
> Для успешного запроса маркера идентификации и (или) маркера доступа регистрация приложения на странице [портал Azure-регистрация приложений](https://go.microsoft.com/fwlink/?linkid=2083908) должна иметь соответствующий неявный поток предоставления разрешения, выбрав **токены идентификации** и или **маркеры доступа** в разделе **неявного предоставления** . Если он не включен, `unsupported_response` будет возвращена ошибка: **указанное значение входного параметра "response_type" не разрешено для этого клиента. Ожидаемое значение — "Code"**

```
// Line breaks for legibility only

https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize?
client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&response_type=id_token
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F
&scope=openid
&response_mode=fragment
&state=12345
&nonce=678910
```

> [!TIP]
> Чтобы проверить вход с помощью неявного потока, нажмите кнопку <a href="https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=6731de76-14a6-49ae-97bc-6eba6914391e&response_type=id_token&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F&scope=openid&response_mode=fragment&state=12345&nonce=678910" target="_blank"> https://login.microsoftonline.com/common/oauth2/v2.0/authorize.. .</a> После входа в систему браузер должен быть перенаправлен `https://localhost/myapp/` с помощью `id_token` в адресной строке.
>

| Параметр | Тип | Описание |
| --- | --- | --- |
| `tenant` | обязательно |Значение `{tenant}` в пути запроса можно использовать для того, чтобы контролировать, кто может входить в приложение. Допустимые значения: `common`, `organizations`, `consumers`, а также идентификаторы клиента. Дополнительные сведения см. в [описании протоколов](active-directory-v2-protocols.md#endpoints). |
| `client_id` | обязательно | Идентификатор приложения (клиента), назначенный вашему приложению на странице [регистрации приложений на портале Azure](https://go.microsoft.com/fwlink/?linkid=2083908). |
| `response_type` | обязательно |Должен включать `id_token` для входа в OpenID Connect. Этот параметр также может содержать значение `token` параметра response_type (тип ответа). Использование `token` здесь позволяет приложению получать токен доступа непосредственно от конечной точки авторизации, при этом отправлять новый запрос на вход в эту конечную точку не требуется. При использовании `token` response_type `scope` параметр должен содержать область, указывающую, для какого ресурса выдается маркер (например, пользователь. read on Microsoft Graph).  |
| `redirect_uri` | рекомендуется |URI перенаправления приложения, на который можно отправлять ответы проверки подлинности для их получения приложением. Он должен в точности соответствовать одному из URI перенаправления, зарегистрированных на портале, но иметь форму закодированного URL-адреса. |
| `scope` | обязательно |Список [областей](v2-permissions-and-consent.md)с разделителями-пробелами. Для OpenID Connect Connect (id_tokens) он должен включать область `openid` , которая преобразуется в разрешение "вход" в пользовательском интерфейсе согласия. При необходимости также можно включить `email` `profile` области и для получения доступа к дополнительным данным пользователя. Вы также можете включить в этот запрос другие области для запроса согласия на различные ресурсы, если запрошен маркер доступа. |
| `response_mode` | необязательно |Определяет метод, который следует использовать для отправки созданного маркера запрашивающему приложению. По умолчанию запрашивает только маркер доступа, но фрагмент, если запрос содержит id_token. |
| `state` | рекомендуется |Значение, включенное в запрос, которое также возвращается в ответе маркера. Это может быть строка любого контента. Как правило, для [предотвращения подделки межсайтовых запросов](https://tools.ietf.org/html/rfc6749#section-10.12)используется генерируемое случайным образом уникальное значение. Состояние также используется для кодирования сведений о состоянии пользователя в приложении перед выполнением запроса проверки подлинности, например о просматриваемой странице или представлении. |
| `nonce` | обязательные |Значение, включаемое в создаваемый приложением запрос, которое будет использоваться как утверждение в получаемом значении id_token. Приложение может проверять это значение, чтобы устранить атаки с воспроизведением маркеров. Значение обычно представляет собой случайным образом полученную уникальную строку, которую можно использовать для идентификации источника запроса. Требуется только при запросе id_token. |
| `prompt` | необязательный |Указывает требуемый тип взаимодействия с пользователем. На текущий момент единственные допустимые значения — login, none, select_account и consent. При значении `prompt=login` пользователю придется вводить учетные данные по запросу. Единый вход не сработает. Значение `prompt=none` является противоположным — оно гарантирует, что интерактивные запросы не будут выводиться ни при каких обстоятельствах. Если запрос не может быть выполнен автоматически с помощью единого входа, конечная точка платформы Microsoft Identity возвратит ошибку. `prompt=select_account` отправляет пользователя в средство выбора учетных записей, где будут отображаться все учетные записи, запомненные в сеансе. Если установить значение `prompt=consent`, то после входа пользователь увидит диалоговое окно согласия OAuth с запросом на предоставление разрешений приложению. |
| `login_hint`  |необязательно |Может использоваться для предварительного заполнения полей имени пользователя или адреса электронной почты на отображаемой пользователю странице входа, если имя пользователя уже известно. Зачастую этот параметр используется в приложениях при повторной проверке подлинности. При этом имя пользователя извлекается во время предыдущего входа с помощью утверждения `preferred_username`.|
| `domain_hint` | необязательный |Если этот параметр включен, процесс обнаружения на основе электронной почты будет пропускаться на странице входа, что упрощает работу пользователя. Обычно это используется для бизнес-приложений, которые работают в одном клиенте, где они будут предоставлять доменное имя в пределах заданного клиента.  Это приведет к пересылке пользователя поставщику Федерации для этого клиента.  Обратите внимание, что это предотвратит вход гостей в приложение.  |

На текущем этапе пользователю придется ввести учетные данные и завершить проверку подлинности. Конечная точка платформы удостоверений Майкрософт также проверяет, согласился ли пользователь предоставить разрешения, указанные в параметре запроса `scope`. Если пользователь **не предоставил** какие-либо из этих разрешений, конечная точка запросит их у пользователя. Дополнительные сведения см. в статье [Разрешения и предоставление согласия в конечной точке Azure Active Directory версии 2.0](v2-permissions-and-consent.md).

После того как пользователь пройдет проверку подлинности и предоставит разрешения, конечная точка платформы удостоверений Майкрософт вернет приложению ответ на указанный `redirect_uri` с помощью метода, указанного в параметре `response_mode`.

#### <a name="successful-response"></a>Успешный ответ

Успешный ответ с использованием `response_mode=fragment` и `response_type=id_token+token` выглядит следующим образом (разрывы строк — для удобства чтения):

```HTTP
GET https://localhost/myapp/#
&token_type=Bearer
&expires_in=3599
&id_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...
&state=12345
```

| Параметр | Описание |
| --- | --- |
| `access_token` |Указывается, если параметр `response_type` содержит значение `token`. Маркер доступа, запрошенный приложением. Маркер доступа не должен декодироваться или проверяться иным образом, он должен рассматриваться как непрозрачная строка. |
| `token_type` |Указывается, если параметр `response_type` содержит значение `token`. Всегда будет использоваться значение `Bearer`. |
| `expires_in`|Указывается, если параметр `response_type` содержит значение `token`. Обозначает количество секунд, в течение которых маркер является допустимым. Используется для кэширования. |
| `scope` |Указывается, если параметр `response_type` содержит значение `token`. Позволяет указать одну или несколько областей, для которых access_token будет допустимым. Может не включать все запрошенные области, если они не были применимы к пользователю (в случае запроса областей только Azure AD, когда для входа используется личная учетная запись). |
| `id_token` | Подписанный JSON Web Token (JWT) Приложение может декодировать сегменты этого токена, чтобы запрашивать сведения о пользователе, выполнившем вход. Приложение может кэшировать значения и отображать их, но не зависит от ограничений авторизации или безопасности. См. дополнительные сведения о маркерах id_token: [`id_token reference`](id-tokens.md). <br> **Примечание.** Предоставляется, только если подан запрос на область `openid`. |
| `state` |Если запрос содержит параметр "state", в ответе должно отображаться то же значение. Приложение должно проверить, совпадают ли значения параметра "state" в запросе и ответе. |

#### <a name="error-response"></a>Сообщение об ошибке

Сообщения об ошибках также можно отправлять на `redirect_uri` , чтобы приложение обрабатывало их должным образом:

```HTTP
GET https://localhost/myapp/#
error=access_denied
&error_description=the+user+canceled+the+authentication
```

| Параметр | Описание |
| --- | --- |
| `error` |Строка кода ошибки, которую можно использовать для классификации типов возникающих ошибок и реагирования на них. |
| `error_description` |Конкретное сообщение об ошибке, с помощью которого разработчик может определить причину возникновения ошибки проверки подлинности. |

## <a name="getting-access-tokens-silently-in-the-background"></a>Автоматическое получение маркеров доступа в фоновом режиме

Теперь, когда пользователь подписан в одностраничном приложении, можно получать маркеры доступа для вызова веб-API, защищенных платформой Microsoft Identity, например [Microsoft Graph](https://developer.microsoft.com/graph). Даже если вы уже получили токен с использованием параметра response_type со значением `token`, этот метод можно использовать для получения токенов к дополнительным ресурсам. При наличии этих токенов пользователям не нужно повторно выполнять вход.

В обычном потоке OpenID Connect Connect/OAuth это можно сделать, выполнив запрос к конечной точке платформы идентификации Майкрософт `/token` . Однако конечная точка платформы Microsoft Identity не поддерживает запросы CORS, поэтому выполнение вызовов AJAX для получения и обновления маркеров не является вопросом. Вместо этого для получения новых маркеров для других веб-API можно использовать неявный поток данных в скрытом iframe.

```
// Line breaks for legibility only

https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize?
client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&response_type=token
&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F
&scope=https%3A%2F%2Fgraph.microsoft.com%2Fuser.read
&response_mode=fragment
&state=12345
&nonce=678910
&prompt=none
&login_hint=myuser@mycompany.com
```

Дополнительные сведения о параметрах запроса в URL-адресе см. в разделе [Отправка запроса на вход](#send-the-sign-in-request).

> [!TIP]
> Попробуйте скопировать и вставить запрос, показанный ниже, на вкладку браузера. (Не забудьте заменить значения `login_hint` на правильное значение для вашего пользователя.)
>
>`https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=6731de76-14a6-49ae-97bc-6eba6914391e&response_type=token&redirect_uri=http%3A%2F%2Flocalhost%2Fmyapp%2F&scope=https%3A%2F%2Fgraph.microsoft.com%2Fuser.read&response_mode=fragment&state=12345&nonce=678910&prompt=none&login_hint={your-username}`
>

Благодаря параметру `prompt=none` этот запрос успешно выполнится или немедленно завершится с ошибкой, и вы вернетесь к своему приложению. Успешный ответ будет отправлен в ваше приложение на указанный `redirect_uri` с помощью метода, заданного в параметре `response_mode`.

#### <a name="successful-response"></a>Успешный ответ

Успешный ответ с использованием метода `response_mode=fragment` выглядит следующим образом:

```HTTP
GET https://localhost/myapp/#
access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...
&state=12345
&token_type=Bearer
&expires_in=3599
&scope=https%3A%2F%2Fgraph.microsoft.com%2Fdirectory.read
```

| Параметр | Описание |
| --- | --- |
| `access_token` |Указывается, если параметр `response_type` содержит значение `token`. Это маркер доступа, запрошенный приложением. В данном случае для Microsoft Graph. Маркер доступа не должен декодироваться или проверяться иным образом, он должен рассматриваться как непрозрачная строка. |
| `token_type` | Всегда будет использоваться значение `Bearer`. |
| `expires_in` | Обозначает количество секунд, в течение которых маркер является допустимым. Используется для кэширования. |
| `scope` | Позволяет указать одну или несколько областей, для которых access_token будет допустимым. Может не включать все запрошенные области, если они не были применимы к пользователю (в случае запроса областей только Azure AD, когда для входа используется личная учетная запись). |
| `id_token` | Подписанный JSON Web Token (JWT) Указывается, если параметр `response_type` содержит значение `id_token`. Приложение может декодировать сегменты этого токена, чтобы запрашивать сведения о пользователе, выполнившем вход. Приложение может кэшировать значения и отображать их, но не зависит от ограничений авторизации или безопасности. Дополнительные сведения о id_tokens см. в [ `id_token` справочнике](id-tokens.md). <br> **Примечание.** Предоставляется, только если подан запрос на область `openid`. |
| `state` |Если запрос содержит параметр "state", в ответе должно отображаться то же значение. Приложение должно проверить, совпадают ли значения параметра "state" в запросе и ответе. |

#### <a name="error-response"></a>Сообщение об ошибке

Сообщения об ошибках также можно отправлять на `redirect_uri` , чтобы приложение правильно обрабатывало их. Если вы используете `prompt=none`, отобразится следующая ошибка.

```HTTP
GET https://localhost/myapp/#
error=user_authentication_required
&error_description=the+request+could+not+be+completed+silently
```

| Параметр | Описание |
| --- | --- |
| `error` |Строка кода ошибки, которую можно использовать для классификации типов возникающих ошибок и реагирования на них. |
| `error_description` |Конкретное сообщение об ошибке, с помощью которого разработчик может определить причину возникновения ошибки проверки подлинности. |

После появления этой ошибки в запросе iframe пользователю необходимо войти еще раз в интерактивном режиме для получения нового маркера. Этот случай можно обрабатывать любым способом, который лучше всего подходит для вашего приложения.

## <a name="refreshing-tokens"></a>Обновление маркеров

Неявное предоставление не использует маркеры обновления. Срок действия маркеров `id_token` и `access_token` очень короткий, поэтому приложение должно быть готово периодически обновлять их. Чтобы обновить токен любого типа, можно выполнить тот же скрытый запрос IFRAME, приведенный выше, с помощью `prompt=none` параметра, чтобы управлять поведением платформы удостоверений. Если вы хотите получить новый объект `id_token` , обязательно используйте `id_token` в и, а также `response_type` в `scope=openid` качестве `nonce` параметра.

## <a name="send-a-sign-out-request"></a>Отправка запроса на выход

OpenID Connect Connect `end_session_endpoint` позволяет приложению отправить запрос к конечной точке платформы Microsoft Identity, чтобы завершить сеанс пользователя и очистить файлы cookie, заданные конечной точкой платформы Microsoft Identity. Чтобы пользователь полностью вышел из веб-приложения, приложение должно завершить свой сеанс пользователя (обычно с помощью очистки кэша маркеров или файлов cookie), а затем перенаправить браузер на:

```
https://login.microsoftonline.com/{tenant}/oauth2/v2.0/logout?post_logout_redirect_uri=https://localhost/myapp/
```

| Параметр | Тип | Описание: |
| --- | --- | --- |
| `tenant` |обязательно |Значение `{tenant}` в пути запроса можно использовать для того, чтобы контролировать, кто может входить в приложение. Допустимые значения: `common`, `organizations`, `consumers`, а также идентификаторы клиента. Дополнительные сведения см. в [описании протоколов](active-directory-v2-protocols.md#endpoints). |
| `post_logout_redirect_uri` | рекомендуется | URL-адрес, на который следует возвратить пользователя после выхода. Это значение должно соответствовать одному из универсальных кодов ресурсов (URI) перенаправления, зарегистрированных для приложения. Если этот параметр не указан, пользователь будет отображать общее сообщение в конечной точке платформы идентификации Майкрософт. |

## <a name="next-steps"></a>Дальнейшие шаги

* Перейдите на страницу [примеров MSAL JS](sample-v2-code.md), чтобы приступить к созданию кода.

[OAuth2-Spec-Implicit-Misuse]: https://tools.ietf.org/html/rfc6749#section-10.16
[OAuth2-Threat-Model-And-Security-Implications]: https://tools.ietf.org/html/rfc6819
