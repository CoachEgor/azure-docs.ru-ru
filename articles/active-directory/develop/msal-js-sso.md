---
title: Единый вход (библиотека проверки подлинности Майкрософт для JavaScript) | Azure
description: Дополнительные сведения о создания возможностей, с помощью библиотеки проверки подлинности Майкрософт для JavaScript (MSAL.js).
services: active-directory
documentationcenter: dev-center-name
author: navyasric
manager: CelesteDG
editor: ''
ms.service: active-directory
ms.subservice: develop
ms.devlang: na
ms.topic: conceptual
ms.tgt_pltfrm: na
ms.workload: identity
ms.date: 04/24/2019
ms.author: nacanuma
ms.reviewer: saeeda
ms.custom: aaddev
ms.collection: M365-identity-device-management
ms.openlocfilehash: 9f1f102307256852ac92616c7fb707e0e2739e5d
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/13/2019
ms.locfileid: "65544154"
---
# <a name="single-sign-on-with-msaljs"></a>Единый вход с помощью MSAL.js

Single Sign-On (SSO) позволяет пользователям вводить свои учетные данные один раз выполнить вход и установить сеанс, который можно использовать в нескольких приложениях без необходимости снова пройти проверку подлинности. Это обеспечивает удобную работу пользователя и снижает повторные запросы учетных данных.

Azure AD обеспечивает возможности единого входа для приложений, установка файла cookie сеанса, когда пользователь проходит проверку подлинности в первый раз. Библиотека MSAL.js позволяет приложениям использовать это несколькими способами.

## <a name="sso-between-browser-tabs"></a>Единый вход между вкладках браузера

Когда приложение открыто на нескольких вкладках и первом входе пользователя на одной вкладке, пользователь также выполнил вход на других вкладках без запроса. MSAL.js кэширует маркера Идентификации для пользователя в браузере `localStorage` и входа пользователя в приложение на другие открытые вкладки.

По умолчанию использует MSAL.js `sessionStorage` не разрешающее сеанса совместно между вкладками. Чтобы единый вход между вкладками, не забудьте задать `cacheLocation` в MSAL.js для `localStorage` как показано ниже.

```javascript
const config = {
    auth: {
        clientId: “abcd-ef12-gh34-ikkl-ashdjhlhsdg”
    },
    cache: {
        cacheLocation: 'localStorage'
    }
}

const myMSALObj = new UserAgentApplication(config);
```

## <a name="sso-between-apps"></a>Единый вход между приложениями

Когда пользователь проходит проверку подлинности, файл cookie сеанса имеет значение в домене Azure AD в браузере. MSAL.js использует этот сеансовый cookie для предоставления единого входа для пользователя между различными приложениями. MSAL.js также кэширует маркеры Идентификации и маркеры доступа пользователя в хранилище браузера каждого домена приложения. Таким образом поведение единого входа различается для разных случаев:  

### <a name="applications-on-the-same-domain"></a>Приложения на том же домене

Если приложения размещены в одном домене, пользователь может войти в приложение один раз и затем выполняется проверка подлинности в другие приложения без запроса. MSAL.js использует маркеры, кэшируются для пользователя в домене для предоставления единого входа.

### <a name="applications-on-different-domain"></a>Приложения на другой домен

Если приложения размещены в разных доменах, токены кэшироваться в домене A может быть недоступна для MSAL.js в домене б.

Это означает, что когда пользователи входят в систему в домене И переходит к приложению в домене Б, они будут перенаправлены или запрос со страницей в Azure AD. Так как Azure AD по-прежнему имеет файл cookie сеанса пользователя, он будет вход пользователя и не будет повторно ввести учетные данные. Если пользователь имеет несколько учетных записей пользователей в сеансе с помощью Azure AD, пользователю будет предложено выбрать соответствующую учетную запись для входа в систему.

### <a name="automatically-select-account-on-azure-ad"></a>Автоматический выбор учетной записи в Azure AD

В некоторых случаях приложение имеет доступ к контекст проверки подлинности пользователя и хочет избежать запроса выбора учетной записи Azure AD, если вошли в систему несколько учетных записей.  Это можно сделать несколькими разными способами:

**С помощью идентификатора сеанса (SID)**

Идентификатор сеанса является [необязательного утверждения](active-directory-optional-claims.md) , можно настроить в маркерах Идентификации. Это утверждение позволяет приложению для идентификации пользователя Azure AD сеанса, независимо от имени учетной записи пользователя или имя пользователя. Идентификатор безопасности можно передать в параметры запроса для `acquireTokenSilent` вызова. Это позволит Azure AD для обхода Выбор учетной записи. Идентификатор безопасности привязан к этому файлу cookie сеанса и не будет проходить через браузер контекстов.

```javascript
var request = {
    scopes: ["user.read"],
    sid: sid
}

userAgentApplication.acquireTokenSilent(request).then(function(response) {
        const token = response.accessToken
    }
).catch(function (error) {  
        //handle error
});
```

> [!Note]
> ИД безопасности можно использовать только с автоматическую проверку подлинности запросов, выполняемых `acquireTokenSilent` вызов в MSAL.js.
Можно найти действия, чтобы настроить необязательные утверждения в манифесте приложения [здесь](active-directory-optional-claims.md).

**С помощью указания имени входа**

Если у вас SID утверждений, настройки или требуется обойти запрос выбора учетной записи в вызовах интерактивной проверки подлинности, это можно сделать, предоставляя `login_hint` в параметры запроса и при необходимости `domain_hint` как `extraQueryParameters` в MSAL.js интерактивные методы (`loginPopup`, `loginRedirect`, `acquireTokenPopup` и `acquireTokenRedirect`). Пример:

```javascript
var request = {
    scopes: ["user.read"],
    loginHint: preferred_username,
    extraQueryParameters: {domain_hint: 'organizations'}
}

userAgentApplication.loginRedirect(request);
```

Можно получить значения для login_hint и domain_hint считывая утверждения, возвращаемые в маркере Идентификации для пользователя.

* **loginHint** должно быть присвоено `preferred_username` утверждения в маркере идентификатора.

* **domain_hint** требуется только для передачи при использовании "/ Common" центра. Указание домена определяется ID(tid) клиента.  Если `tid` утверждения в маркере Идентификации `9188040d-6c67-4c5b-b112-36a304b66dad` это потребителей. В противном случае это организаций.

Чтение [здесь](v2-oauth2-implicit-grant-flow.md) Дополнительные сведения о значениях для указания имени входа и указание домена.

> [!Note]
> В то же время нельзя передавать идентификатор безопасности и login_hint. Это приведет к в ответ на ошибку.

## <a name="sso-without-msaljs-login"></a>Единый вход без имени входа MSAL.js

По своей структуре MSAL.js предполагается, что метод входа вызывается для установления контекста пользователя перед получением токенов для API-интерфейсов. Поскольку методы входа являются интерактивными, пользователь увидит запрос.

Существует несколько случаев, в которых приложения имеют доступ к контексту пользователя, прошедшего проверку подлинности, или маркер идентификатора через проверку подлинности инициируется в другое приложение и хотите использовать единый вход для получения маркеров без первого входа в систему через MSAL.js.

Примером этого является: Пользователь входит в родительский веб-приложение, в котором размещена другого приложения JavaScript, работающего как надстройка или подключаемый модуль.

ЕДИНЫЙ вход в этом сценарии можно сделать следующим образом:

Передайте `sid` при наличии (или `login_hint` и при необходимости `domain_hint`) как запросить параметры, чтобы MSAL.js `acquireTokenSilent` вызвать следующим образом:

```javascript
var request = {
    scopes: ["user.read"],
    loginHint: preferred_username,
    extraQueryParameters: {domain_hint: 'organizations'}
}

userAgentApplication.acquireTokenSilent(request).then(function(response) {
        const token = response.accessToken
    }
).catch(function (error) {  
        //handle error
});
```

## <a name="sso-in-adaljs-to-msaljs-update"></a>Единый вход в ADAL.js MSAL.js обновления

MSAL.js предоставляет те же функции, ADAL.js для сценариев проверки подлинности Azure AD. Чтобы упростить миграцию из ADAL.js для MSAL.js и самостоятельно пользователей выполнить вход еще раз, библиотека считывает идентификатор токен, представляющий сеанс пользователя в кэше ADAL.js и легко выполняет вход пользователя в MSAL.js.  

Чтобы воспользоваться преимуществами единого входа (SSO) поведение при обновлении с ADAL.js, необходимо гарантировать использование библиотеки `localStorage` для кэширования маркеров. Задайте `cacheLocation` для `localStorage` в ADAL.js и MSAL.js конфигурации при инициализации следующим образом:


```javascript
// In ADAL.js
window.config = {
   clientId: 'g075edef-0efa-453b-997b-de1337c29185',
   cacheLocation: 'localStorage'
};

var authContext = new AuthenticationContext(config);


// In latest MSAL.js version
const config = {
    auth: {
        clientId: “abcd-ef12-gh34-ikkl-ashdjhlhsdg”
    },
    cache: {
        cacheLocation: 'localStorage'
    }
}

const myMSALObj = new UserAgentApplication(config);
```

После завершения настройки, MSAL.js будут иметь возможность чтения кэшированное состояние пользователя, прошедшего проверку подлинности в ADAL.js и использовать его для предоставления единого входа в MSAL.js.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о [единого входа в сеанс и время существования маркера](active-directory-configurable-token-lifetimes.md) значения в Azure AD.
