---
author: linda33wj
ms.service: data-factory
ms.topic: include
ms.date: 11/09/2018
ms.author: jingwang
ms.openlocfilehash: 24bb7a1fcb1569922fb34034fb3c0d003cdd7061
ms.sourcegitcommit: 3e98da33c41a7bbd724f644ce7dedee169eb5028
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/18/2019
ms.locfileid: "67185754"
---
## <a name="repeatability-during-copy"></a>Повторяемость во время копирования
При копировании данных в SQL Azure или SQL Server из других хранилищ данных необходимо помнить о повторяемости, чтобы избежать незапланированных последствий. 

Копирование данных в базу данных SQL Azure или SQL Server по умолчанию предполагает их добавление в таблицу-приемник. Например, если данные копируются из CSV-файла (со значениями данных, разделенными запятой), содержащего две записи, в базу данных SQL Azure или SQL Server, таблица будет выглядеть приведенным ниже образом.

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    2            2015-05-01 00:00:00
```

Предположим, в исходном файле обнаружили ошибки и значение параметра Down Tube в нем было обновлено с 2 до 4. Если повторно выполнить срез данных за соответствующий период, к базе данных SQL Azure или SQL Server будут присоединены две новых записи. Ниже предполагается, что ни один из столбцов таблицы не содержит ограничения первичного ключа.

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    2            2015-05-01 00:00:00
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    4            2015-05-01 00:00:00
```

Чтобы избежать такого результата, необходимо указать семантику UPSERT, воспользовавшись одним из двух описанных ниже механизмов.

> [!NOTE]
> В фабрике данных Azure можно настроить повторное выполнение среза согласно указанной политике повтора.
> 
> 

### <a name="mechanism-1"></a>Механизм 1
С помощью свойства **sqlWriterCleanupScript** вы можете сначала выполнить действие очистки при запуске среза. 

```json
"sink":  
{ 
  "type": "SqlSink", 
  "sqlWriterCleanupScript": "$$Text.Format('DELETE FROM table WHERE ModifiedDate >= \\'{0:yyyy-MM-dd HH:mm}\\' AND ModifiedDate < \\'{1:yyyy-MM-dd HH:mm}\\'', WindowStart, WindowEnd)"
}
```

Скрипт очистки будет выполнен сначала в ходе копирования для заданного среза. При этом будут удалены данные из таблицы SQL, соответствующей этому срезу. Впоследствии данные будут вставлены в таблицу SQL. 

Если теперь повторно выполнить срез, нужное количество будет обновлено, как и требовалось.

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    4            2015-05-01 00:00:00
```

Предположим, что запись Flat Washer удалена из исходного CSV-файла. В таком случае при повторном выполнении среза будет получен приведенный ниже результат. 

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
7     Down Tube    4            2015-05-01 00:00:00
```
Ничего нового делать не пришлось. Действие копирования выполнило скрипт очистки, удалив соответствующие данные среза. Затем произошло считывание входных данных из CSV-файла (который на тот момент содержал всего 1 запись) и их вставка в таблицу. 

### <a name="mechanism-2"></a>Механизм 2
> [!IMPORTANT]
> В настоящее время sliceIdentifierColumnName не поддерживается для хранилища данных Azure SQL. 

Второй способ достижения повторяемости — выделение отдельного столбца (**sliceIdentifierColumnName**) в целевой таблице. Этот столбец будет использовать фабрика данных Azure, чтобы синхронизировать источник и назначение. Такой подход работает при наличии гибкости в изменении или определении целевой схемы таблицы SQL. 

Этот столбец фабрика данных Azure будет использовать в целях повторяемости. При этом фабрика данных не будет вносить никаких изменений схемы в таблицу. Способ применения этого подхода:

1. Определите столбец двоичного типа (32) в целевой таблице SQL. Для этого столбца не должно быть никаких ограничений. Давайте в данном примере назовем столбец ColumnForADFuseOnly.
2. Он будет использоваться в действии копирования следующим образом.
   
    ```json
    "sink":  
    { 
   
        "type": "SqlSink", 
        "sliceIdentifierColumnName": "ColumnForADFuseOnly"
    }
    ```

Фабрика данных Azure будет заполнять этот столбец тогда, когда будет возникать необходимость синхронизировать источник и назначение. Значения столбца пользователю не следует использовать за пределами данного контекста. 

Подобно механизму 1, действие копирования сначала автоматически очистит данные для заданного среза из целевой таблицы SQL. Затем действие копирования будет выполнено обычным образом для вставки данных из источника в место назначения для соответствующего среза. 

